From c97c81b5f7b9effe729b34c014b8bffdf40df05e Mon Sep 17 00:00:00 2001
From: Fedor <fedor@mail.ru>
Date: Mon, 7 May 2018 22:09:43 +0300
Subject: [PATCH] tele

---
 docshell/base/nsDocShell.cpp                       |  96 ---
 docshell/base/nsIDocShell.idl                      |   7 -
 dom/base/Element.cpp                               |   1 -
 dom/base/FragmentOrElement.cpp                     |   3 -
 dom/base/Navigator.cpp                             |   3 -
 dom/base/nsDOMClassInfo.cpp                        |   3 -
 dom/base/nsDocument.cpp                            |  32 -
 dom/base/nsGlobalWindow.cpp                        |  23 -
 dom/base/nsINode.cpp                               |   1 -
 dom/base/nsJSEnvironment.cpp                       |  15 -
 dom/base/nsObjectLoadingContent.cpp                |   2 -
 dom/base/nsRange.cpp                               |   4 -
 dom/base/nsXMLHttpRequest.cpp                      |   4 -
 dom/canvas/CanvasRenderingContext2D.cpp            |   1 -
 dom/canvas/WebGL1Context.cpp                       |   3 -
 dom/canvas/WebGL2Context.cpp                       |   1 -
 dom/canvas/WebGLContext.cpp                        |   1 -
 dom/crypto/WebCryptoTask.cpp                       | 105 ---
 dom/geolocation/nsGeolocation.cpp                  |   4 -
 dom/geolocation/nsGeolocationSettings.cpp          |   1 -
 dom/html/HTMLCanvasElement.cpp                     |   4 -
 dom/html/HTMLFormElement.cpp                       |  12 +-
 dom/html/HTMLInputElement.cpp                      |   7 -
 dom/html/HTMLMediaElement.cpp                      |  78 --
 dom/html/HTMLMediaElement.h                        |  47 --
 dom/ipc/ContentParent.cpp                          |   3 -
 dom/media/AudioStream.cpp                          |   3 -
 dom/media/PeerConnection.js                        |   3 -
 dom/media/VideoUtils.cpp                           |  19 -
 dom/media/fmp4/MP4Reader.cpp                       |  47 --
 dom/media/fmp4/MP4Reader.h                         |   3 -
 dom/plugins/base/nsPluginHost.cpp                  |  11 +-
 dom/plugins/ipc/PluginAsyncSurrogate.cpp           |   3 -
 dom/plugins/ipc/PluginHangUIParent.cpp             |  42 +-
 dom/plugins/ipc/PluginInstanceParent.cpp           |   6 -
 dom/plugins/ipc/PluginModuleParent.cpp             |  11 -
 dom/plugins/ipc/PluginProcessParent.cpp            |   1 -
 dom/storage/DOMStorage.cpp                         |   7 -
 dom/storage/DOMStorageCache.cpp                    |  53 +-
 dom/storage/DOMStorageCache.h                      |   6 +-
 dom/storage/DOMStorageDBThread.cpp                 |   4 -
 dom/system/mac/CoreLocationLocationProvider.mm     |   3 -
 dom/workers/ServiceWorkerRegistrar.cpp             |   6 -
 dom/workers/ServiceWorkerRegistrar.h               |   1 -
 dom/xul/nsXULPrototypeCache.cpp                    |   6 -
 extensions/auth/nsAuthGSSAPI.cpp                   |  11 -
 extensions/auth/nsAuthSSPI.cpp                     |  11 -
 extensions/auth/nsAuthSambaNTLM.cpp                |  11 -
 intl/uconv/ucvja/nsJapaneseToUnicode.h             |   3 -
 intl/uconv/ucvlatin/nsCP866ToUnicode.cpp           |   3 -
 intl/uconv/ucvlatin/nsISO88595ToUnicode.cpp        |   3 -
 intl/uconv/ucvlatin/nsKOI8RToUnicode.cpp           |   3 -
 intl/uconv/ucvlatin/nsKOI8UToUnicode.cpp           |   3 -
 intl/uconv/ucvlatin/nsMacArabicToUnicode.cpp       |   3 -
 intl/uconv/ucvlatin/nsMacCEToUnicode.cpp           |   3 -
 intl/uconv/ucvlatin/nsMacCroatianToUnicode.cpp     |   3 -
 intl/uconv/ucvlatin/nsMacCyrillicToUnicode.cpp     |   3 -
 intl/uconv/ucvlatin/nsMacDevanagariToUnicode.cpp   |   3 -
 intl/uconv/ucvlatin/nsMacFarsiToUnicode.cpp        |   3 -
 intl/uconv/ucvlatin/nsMacGreekToUnicode.cpp        |   3 -
 intl/uconv/ucvlatin/nsMacGurmukhiToUnicode.cpp     |   3 -
 intl/uconv/ucvlatin/nsMacHebrewToUnicode.cpp       |   3 -
 intl/uconv/ucvlatin/nsMacIcelandicToUnicode.cpp    |   3 -
 intl/uconv/ucvlatin/nsMacRomanianToUnicode.cpp     |   3 -
 intl/uconv/ucvlatin/nsMacTurkishToUnicode.cpp      |   3 -
 js/public/GCAPI.h                                  |   8 -
 js/src/frontend/Parser.cpp                         |  15 -
 js/src/frontend/Parser.h                           |   2 -
 js/src/gc/Statistics.cpp                           |  23 -
 js/src/jscompartment.cpp                           |  30 -
 js/src/jscompartment.h                             |   9 -
 js/src/jsexn.cpp                                   |   7 -
 js/src/jsfriendapi.cpp                             |   6 -
 js/src/jsfriendapi.h                               |  26 -
 js/src/vm/Interpreter.cpp                          |   5 -
 js/src/vm/Runtime.cpp                              |  14 -
 js/src/vm/Runtime.h                                |   8 -
 js/xpconnect/idl/xpccomponents.idl                 |   3 -
 js/xpconnect/src/XPCComponents.cpp                 |  23 -
 js/xpconnect/src/XPCJSRuntime.cpp                  |  65 --
 js/xpconnect/src/XPCShellImpl.cpp                  |   6 -
 layout/base/nsCSSRendering.cpp                     |   6 -
 layout/base/nsDocumentViewer.cpp                   |   5 -
 layout/base/nsLayoutUtils.cpp                      |   6 -
 layout/base/nsPresShell.cpp                        |  30 -
 layout/base/nsRefreshDriver.cpp                    |  11 -
 layout/tools/reftest/remotereftest.py              |   3 -
 layout/tools/reftest/runreftest.py                 |   3 -
 mobile/android/chrome/content/browser.js           |  15 -
 netwerk/base/BackgroundFileSaver.cpp               |  17 -
 netwerk/base/BackgroundFileSaver.h                 |   9 -
 netwerk/base/Predictor.cpp                         |  34 -
 netwerk/base/nsIAuthModule.idl                     |  14 -
 netwerk/base/nsIOService.cpp                       |  27 -
 netwerk/base/nsIOService.h                         |   1 -
 netwerk/base/nsLoadGroup.cpp                       | 227 -----
 netwerk/base/nsLoadGroup.h                         |   7 -
 netwerk/base/nsUDPSocket.cpp                       |  21 -
 netwerk/cache/nsCacheEntryDescriptor.cpp           |  83 +-
 netwerk/cache/nsCacheService.cpp                   |  81 +-
 netwerk/cache/nsCacheService.h                     |  11 +-
 netwerk/cache/nsDeleteDir.cpp                      |   4 -
 netwerk/cache/nsDiskCacheBinding.cpp               |   2 +-
 netwerk/cache/nsDiskCacheDevice.cpp                |  15 +-
 netwerk/cache/nsDiskCacheDeviceSQL.cpp             |   3 -
 netwerk/cache/nsDiskCacheMap.cpp                   |  35 +-
 netwerk/cache/nsDiskCacheMap.h                     |   6 +-
 netwerk/cache/nsDiskCacheStreams.cpp               |  12 +-
 netwerk/cache/nsMemoryCacheDevice.cpp              |   2 -
 netwerk/cache2/CacheEntry.cpp                      |  23 -
 netwerk/cache2/CacheFile.cpp                       |  34 -
 netwerk/cache2/CacheFileIOManager.cpp              |   5 -
 netwerk/cache2/CacheFileMetadata.cpp               |   1 -
 netwerk/cache2/CacheStorageService.cpp             | 111 ---
 netwerk/cache2/CacheStorageService.h               |  11 -
 netwerk/cache2/OldWrappers.cpp                     |  19 -
 netwerk/cookie/nsCookieService.cpp                 |   6 -
 netwerk/dns/nsHostResolver.cpp                     |  53 --
 netwerk/protocol/http/ASpdySession.cpp             |   9 -
 netwerk/protocol/http/ASpdySession.h               |   1 -
 netwerk/protocol/http/Http2Session.cpp             |  11 -
 netwerk/protocol/http/Http2Session.h               |   3 -
 netwerk/protocol/http/Http2Stream.cpp              |  11 -
 netwerk/protocol/http/SpdySession31.cpp            |  29 -
 netwerk/protocol/http/SpdySession31.h              |   3 -
 netwerk/protocol/http/SpdyStream31.cpp             |  11 -
 netwerk/protocol/http/nsHttpChannel.cpp            |  84 --
 netwerk/protocol/http/nsHttpConnection.cpp         |  16 +-
 netwerk/protocol/http/nsHttpConnectionMgr.cpp      |  60 --
 netwerk/protocol/http/nsHttpConnectionMgr.h        |   1 -
 netwerk/protocol/http/nsHttpHandler.cpp            |  65 --
 netwerk/protocol/http/nsHttpHandler.h              |   8 -
 .../protocol/rtsp/controller/RtspController.cpp    |   1 -
 netwerk/protocol/websocket/WebSocketChannel.cpp    |  33 -
 netwerk/protocol/websocket/WebSocketChannel.h      |   1 -
 security/manager/boot/public/moz.build             |   1 -
 .../manager/boot/public/nsISecurityUITelemetry.idl | 146 ----
 security/manager/boot/src/DataStorage.cpp          |   3 -
 .../manager/boot/src/PublicKeyPinningService.cpp   |   2 -
 .../boot/src/RootCertificateTelemetryUtils.cpp     |  99 ---
 .../boot/src/RootCertificateTelemetryUtils.h       |  21 -
 security/manager/boot/src/RootHashes.inc           | 924 ---------------------
 security/manager/boot/src/moz.build                |   1 -
 .../pki/resources/content/exceptionDialog.js       |  19 -
 .../manager/ssl/src/SSLServerCertVerification.cpp  | 381 +--------
 security/manager/ssl/src/nsCertOverrideService.cpp |  13 -
 security/manager/ssl/src/nsCertOverrideService.h   |   2 -
 security/manager/ssl/src/nsNSSCallbacks.cpp        | 215 +----
 security/manager/ssl/src/nsNSSComponent.cpp        |   8 -
 security/manager/ssl/src/nsNSSIOLayer.cpp          | 108 ---
 security/manager/ssl/src/nsNTLMAuthModule.cpp      |  11 -
 .../manager/ssl/tests/unit/test_cert_overrides.js  |  38 -
 .../manager/ssl/tests/unit/test_ocsp_stapling.js   |  17 -
 .../ssl/tests/unit/test_ocsp_stapling_expired.js   |  13 -
 security/manager/ssl/tests/unit/test_pinning.js    |  32 -
 toolkit/components/telemetry/Histograms.json       |   2 +-
 toolkit/content/browser-child.js                   |   1 -
 toolkit/content/widgets/browser.xml                |   1 -
 toolkit/mozapps/extensions/amWebInstallListener.js |   4 -
 .../mozapps/extensions/content/xpinstallConfirm.js |   4 -
 toolkit/mozapps/update/content/updates.js          |  12 -
 xpcom/base/nsCycleCollector.cpp                    |  21 +-
 xpcom/base/nsMemoryReporterManager.cpp             |   2 -
 xpcom/build/LateWriteChecks.cpp                    |   6 +-
 xpcom/build/PoisonIOInterposerMac.cpp              |   1 -
 xpcom/build/XPCOMInit.cpp                          |   3 -
 xpcom/build/nsXULAppAPI.h                          |   3 -
 xpcom/threads/HangMonitor.cpp                      | 312 -------
 168 files changed, 118 insertions(+), 4638 deletions(-)
 delete mode 100644 security/manager/boot/public/nsISecurityUITelemetry.idl
 delete mode 100644 security/manager/boot/src/RootCertificateTelemetryUtils.cpp
 delete mode 100644 security/manager/boot/src/RootCertificateTelemetryUtils.h
 delete mode 100644 security/manager/boot/src/RootHashes.inc

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
index d105d68..4ead113 100644
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -21,7 +21,6 @@
 #include "mozilla/Preferences.h"
 #include "mozilla/Services.h"
 #include "mozilla/StartupTimeline.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/unused.h"
 #include "mozilla/VisualEventTracer.h"
 #include "URIUtils.h"
@@ -173,7 +172,6 @@
 #include "nsSandboxFlags.h"
 #include "nsXULAppAPI.h"
 #include "nsDOMNavigationTiming.h"
-#include "nsISecurityUITelemetry.h"
 #include "nsIAppsService.h"
 #include "nsDSURIContentListener.h"
 #include "nsDocShellLoadTypes.h"
@@ -2093,77 +2091,6 @@ nsDocShell::GetCharset(nsACString& aCharset)
 }
 
 NS_IMETHODIMP
-nsDocShell::GatherCharsetMenuTelemetry()
-{
-  nsCOMPtr<nsIContentViewer> viewer;
-  GetContentViewer(getter_AddRefs(viewer));
-  if (!viewer) {
-    return NS_OK;
-  }
-
-  nsIDocument* doc = viewer->GetDocument();
-  if (!doc || doc->WillIgnoreCharsetOverride()) {
-    return NS_OK;
-  }
-
-  Telemetry::Accumulate(Telemetry::CHARSET_OVERRIDE_USED, true);
-
-  bool isFileURL = false;
-  nsIURI* url = doc->GetOriginalURI();
-  if (url) {
-    url->SchemeIs("file", &isFileURL);
-  }
-
-  int32_t charsetSource = doc->GetDocumentCharacterSetSource();
-  switch (charsetSource) {
-    case kCharsetFromTopLevelDomain:
-      // Unlabeled doc on a domain that we map to a fallback encoding
-      Telemetry::Accumulate(Telemetry::CHARSET_OVERRIDE_SITUATION, 7);
-      break;
-    case kCharsetFromFallback:
-    case kCharsetFromDocTypeDefault:
-    case kCharsetFromCache:
-    case kCharsetFromParentFrame:
-    case kCharsetFromHintPrevDoc:
-      // Changing charset on an unlabeled doc.
-      if (isFileURL) {
-        Telemetry::Accumulate(Telemetry::CHARSET_OVERRIDE_SITUATION, 0);
-      } else {
-        Telemetry::Accumulate(Telemetry::CHARSET_OVERRIDE_SITUATION, 1);
-      }
-      break;
-    case kCharsetFromAutoDetection:
-      // Changing charset on unlabeled doc where chardet fired
-      if (isFileURL) {
-        Telemetry::Accumulate(Telemetry::CHARSET_OVERRIDE_SITUATION, 2);
-      } else {
-        Telemetry::Accumulate(Telemetry::CHARSET_OVERRIDE_SITUATION, 3);
-      }
-      break;
-    case kCharsetFromMetaPrescan:
-    case kCharsetFromMetaTag:
-    case kCharsetFromChannel:
-      // Changing charset on a doc that had a charset label.
-      Telemetry::Accumulate(Telemetry::CHARSET_OVERRIDE_SITUATION, 4);
-      break;
-    case kCharsetFromParentForced:
-    case kCharsetFromUserForced:
-      // Changing charset on a document that already had an override.
-      Telemetry::Accumulate(Telemetry::CHARSET_OVERRIDE_SITUATION, 5);
-      break;
-    case kCharsetFromIrreversibleAutoDetection:
-    case kCharsetFromOtherComponent:
-    case kCharsetFromByteOrderMark:
-    case kCharsetUninitialized:
-    default:
-      // Bug. This isn't supposed to happen.
-      Telemetry::Accumulate(Telemetry::CHARSET_OVERRIDE_SITUATION, 6);
-      break;
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP
 nsDocShell::SetCharset(const nsACString& aCharset)
 {
   // set the charset override
@@ -5071,15 +4998,6 @@ nsDocShell::DisplayLoadError(nsresult aError, nsIURI* aURI,
           cssClass.AssignLiteral("badStsCert");
         }
 
-        uint32_t bucketId;
-        if (isStsHost) {
-          // measuring STS separately allows us to measure click through
-          // rates easily
-          bucketId = nsISecurityUITelemetry::WARNING_BAD_CERT_TOP_STS;
-        } else {
-          bucketId = nsISecurityUITelemetry::WARNING_BAD_CERT_TOP;
-        }
-
         // See if an alternate cert error page is registered
         nsAdoptingCString alternateErrorPage =
           Preferences::GetCString("security.alternate_certificate_error_page");
@@ -5087,10 +5005,6 @@ nsDocShell::DisplayLoadError(nsresult aError, nsIURI* aURI,
           errorPage.Assign(alternateErrorPage);
         }
 
-        if (!IsFrame() && errorPage.EqualsIgnoreCase("certerror")) {
-          Telemetry::Accumulate(mozilla::Telemetry::SECURITY_UI, bucketId);
-        }
-
       } else {
         error.AssignLiteral("nssFailure2");
       }
@@ -5110,20 +5024,12 @@ nsDocShell::DisplayLoadError(nsresult aError, nsIURI* aURI,
       errorPage.Assign(alternateErrorPage);
     }
 
-    uint32_t bucketId;
     if (NS_ERROR_PHISHING_URI == aError) {
       error.AssignLiteral("phishingBlocked");
-      bucketId = IsFrame() ? nsISecurityUITelemetry::WARNING_PHISHING_PAGE_FRAME
-                           : nsISecurityUITelemetry::WARNING_PHISHING_PAGE_TOP;
     } else {
       error.AssignLiteral("malwareBlocked");
-      bucketId = IsFrame() ? nsISecurityUITelemetry::WARNING_MALWARE_PAGE_FRAME
-                           : nsISecurityUITelemetry::WARNING_MALWARE_PAGE_TOP;
     }
 
-    if (errorPage.EqualsIgnoreCase("blocked"))
-      Telemetry::Accumulate(Telemetry::SECURITY_UI, bucketId);
-
     cssClass.AssignLiteral("blacklist");
   } else if (NS_ERROR_CONTENT_CRASHED == aError) {
     errorPage.AssignLiteral("tabcrashed");
@@ -7546,8 +7452,6 @@ nsDocShell::EndPageLoad(nsIWebProgress* aProgress,
     TimeStamp channelCreationTime;
     rv = timingChannel->GetChannelCreation(&channelCreationTime);
     if (NS_SUCCEEDED(rv) && !channelCreationTime.IsNull()) {
-      Telemetry::AccumulateTimeDelta(Telemetry::TOTAL_CONTENT_PAGE_LOAD_TIME,
-                                     channelCreationTime);
       nsCOMPtr<nsPILoadGroupInternal> internalLoadGroup =
         do_QueryInterface(mLoadGroup);
       if (internalLoadGroup) {
diff --git a/docshell/base/nsIDocShell.idl b/docshell/base/nsIDocShell.idl
index 8af4a3b..5d46cc5 100644
--- a/docshell/base/nsIDocShell.idl
+++ b/docshell/base/nsIDocShell.idl
@@ -653,13 +653,6 @@ interface nsIDocShell : nsIDocShellTreeItem
   attribute ACString charset;
 
   /**
-   * Called when the user chose an encoding override from the character
-   * encoding menu. Separate from the setter for the charset property to avoid
-   * extensions adding noise to the data.
-   */
-  void gatherCharsetMenuTelemetry();
-
-  /**
    * The charset forced by the user.
    */
   attribute ACString forcedCharset;
diff --git a/dom/base/Element.cpp b/dom/base/Element.cpp
index 9d819ab..bf19ff9 100644
--- a/dom/base/Element.cpp
+++ b/dom/base/Element.cpp
@@ -123,7 +123,6 @@
 #include "nsWrapperCacheInlines.h"
 #include "xpcpublic.h"
 #include "nsIScriptError.h"
-#include "mozilla/Telemetry.h"
 
 #include "mozilla/CORSMode.h"
 #include "mozilla/dom/ShadowRoot.h"
diff --git a/dom/base/FragmentOrElement.cpp b/dom/base/FragmentOrElement.cpp
index 560b442..cd02b40 100644
--- a/dom/base/FragmentOrElement.cpp
+++ b/dom/base/FragmentOrElement.cpp
@@ -117,7 +117,6 @@
 #include "nsCycleCollector.h"
 #include "xpcpublic.h"
 #include "nsIScriptError.h"
-#include "mozilla/Telemetry.h"
 
 #include "mozilla/CORSMode.h"
 
@@ -1274,8 +1273,6 @@ public:
         UnbindSubtree(mSubtreeRoots[i]);
       }
       mSubtreeRoots.Clear();
-      Telemetry::Accumulate(Telemetry::CYCLE_COLLECTOR_CONTENT_UNBIND,
-                            uint32_t(PR_Now() - start) / PR_USEC_PER_MSEC);
     }
     nsCycleCollector_dispatchDeferredDeletion();
     if (this == sContentUnbinder) {
diff --git a/dom/base/Navigator.cpp b/dom/base/Navigator.cpp
index 9decf68..f3003e9 100644
--- a/dom/base/Navigator.cpp
+++ b/dom/base/Navigator.cpp
@@ -30,7 +30,6 @@
 #include "nsContentUtils.h"
 #include "nsUnicharUtils.h"
 #include "mozilla/Preferences.h"
-#include "mozilla/Telemetry.h"
 #include "BatteryManager.h"
 #include "mozilla/dom/PowerManager.h"
 #include "mozilla/dom/WakeLock.h"
@@ -579,8 +578,6 @@ Navigator::GetDoNotTrack(nsAString &aResult)
 bool
 Navigator::JavaEnabled(ErrorResult& aRv)
 {
-  Telemetry::AutoTimer<Telemetry::CHECK_JAVA_ENABLED> telemetryTimer;
-
   // Return true if we have a handler for the java mime
   nsAdoptingString javaMIME = Preferences::GetString("plugin.java.mime");
   NS_ENSURE_TRUE(!javaMIME.IsEmpty(), false);
diff --git a/dom/base/nsDOMClassInfo.cpp b/dom/base/nsDOMClassInfo.cpp
index ccb913e..e174f91 100644
--- a/dom/base/nsDOMClassInfo.cpp
+++ b/dom/base/nsDOMClassInfo.cpp
@@ -46,7 +46,6 @@
 #include "nsContentUtils.h"
 #include "nsIDOMGlobalPropertyInitializer.h"
 #include "mozilla/Attributes.h"
-#include "mozilla/Telemetry.h"
 
 // Window scriptable helper includes
 #include "nsScriptNameSpaceManager.h"
@@ -2329,8 +2328,6 @@ LookupComponentsShim(JSContext *cx, JS::Handle<JSObject*> global,
                      nsPIDOMWindow *win,
                      JS::MutableHandle<JSPropertyDescriptor> desc)
 {
-  // Keep track of how often this happens.
-  Telemetry::Accumulate(Telemetry::COMPONENTS_SHIM_ACCESSED_BY_CONTENT, true);
 
   // Warn once.
   nsCOMPtr<nsIDocument> doc = win->GetExtantDoc();
diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
index 5d344b7..2324028 100644
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -22,7 +22,6 @@
 #include "plstr.h"
 #include "prprf.h"
 
-#include "mozilla/Telemetry.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsILoadContext.h"
@@ -1648,37 +1647,6 @@ nsDocument::~nsDocument()
       uri->SchemeIs("about", &isAboutScheme);
     }
 
-    if (!isAboutScheme) {
-      // Record the page load
-      uint32_t pageLoaded = 1;
-      Accumulate(Telemetry::MIXED_CONTENT_UNBLOCK_COUNTER, pageLoaded);
-      // Record the mixed content status of the docshell in Telemetry
-      enum {
-        NO_MIXED_CONTENT = 0, // There is no Mixed Content on the page
-        MIXED_DISPLAY_CONTENT = 1, // The page attempted to load Mixed Display Content
-        MIXED_ACTIVE_CONTENT = 2, // The page attempted to load Mixed Active Content
-        MIXED_DISPLAY_AND_ACTIVE_CONTENT = 3 // The page attempted to load Mixed Display & Mixed Active Content
-      };
-
-      bool mixedActiveLoaded = GetHasMixedActiveContentLoaded();
-      bool mixedActiveBlocked = GetHasMixedActiveContentBlocked();
-
-      bool mixedDisplayLoaded = GetHasMixedDisplayContentLoaded();
-      bool mixedDisplayBlocked = GetHasMixedDisplayContentBlocked();
-
-      bool hasMixedDisplay = (mixedDisplayBlocked || mixedDisplayLoaded);
-      bool hasMixedActive = (mixedActiveBlocked || mixedActiveLoaded);
-
-      uint32_t mixedContentLevel = NO_MIXED_CONTENT;
-      if (hasMixedDisplay && hasMixedActive) {
-        mixedContentLevel = MIXED_DISPLAY_AND_ACTIVE_CONTENT;
-      } else if (hasMixedActive){
-        mixedContentLevel = MIXED_ACTIVE_CONTENT;
-      } else if (hasMixedDisplay) {
-        mixedContentLevel = MIXED_DISPLAY_CONTENT;
-      }
-      Accumulate(Telemetry::MIXED_CONTENT_PAGE_LOAD, mixedContentLevel);
-    }
   }
 
   mInDestructor = true;
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
index 77ecab6..c13eeff 100644
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -196,7 +196,6 @@
 
 #include "mozilla/AddonPathService.h"
 #include "mozilla/Services.h"
-#include "mozilla/Telemetry.h"
 #include "nsLocation.h"
 #include "nsHTMLDocument.h"
 #include "nsWrapperCacheInlines.h"
@@ -1322,8 +1321,6 @@ nsGlobalWindow::~nsGlobalWindow()
 
     DropOuterWindowDocs();
   } else {
-    Telemetry::Accumulate(Telemetry::INNERWINDOWS_WITH_MUTATION_LISTENERS,
-                          mMutationBits ? 1 : 0);
 
     if (mListenerManager) {
       mListenerManager->Disconnect();
@@ -2206,7 +2203,6 @@ TreatAsRemoteXUL(nsIPrincipal* aPrincipal)
 static bool
 EnablePrivilege(JSContext* cx, unsigned argc, JS::Value* vp)
 {
-  Telemetry::Accumulate(Telemetry::ENABLE_PRIVILEGE_EVER_CALLED, true);
   return xpc::EnableUniversalXPConnect(cx);
 }
 
@@ -2828,9 +2824,6 @@ nsGlobalWindow::InnerSetNewDocument(JSContext* aCx, nsIDocument* aDocument)
   mLastOpenedURI = aDocument->GetDocumentURI();
 #endif
 
-  Telemetry::Accumulate(Telemetry::INNERWINDOWS_WITH_MUTATION_LISTENERS,
-                        mMutationBits ? 1 : 0);
-
   // Clear our mutation bitfield.
   mMutationBits = 0;
 }
@@ -9325,8 +9318,6 @@ nsGlobalWindow::ShowModalDialog(const nsAString& aUrl, nsIVariant* aArgument,
     return nullptr;
   }
 
-  Telemetry::Accumulate(Telemetry::DOM_WINDOW_SHOWMODALDIALOG_USED, true);
-
   nsRefPtr<DialogValueHolder> argHolder =
     new DialogValueHolder(nsContentUtils::SubjectPrincipal(), aArgument);
 
@@ -11154,7 +11145,6 @@ nsGlobalWindow::ShowSlowScriptDialog()
 
   // Reached only on non-e10s - once per slow script dialog.
   // On e10s - we probe once at ProcessHangsMonitor.jsm
-  Telemetry::Accumulate(Telemetry::SLOW_SCRIPT_NOTICE_COUNT, 1);
 
   // Get the nsIPrompt interface from the docshell
   nsCOMPtr<nsIDocShell> ds = GetDocShell();
@@ -12578,16 +12568,6 @@ nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
     return;
   }
 
-  // Record telemetry information about timers set recently.
-  TimeDuration recordingInterval = TimeDuration::FromMilliseconds(STATISTICS_INTERVAL);
-  if (gLastRecordedRecentTimeouts.IsNull() ||
-      now - gLastRecordedRecentTimeouts > recordingInterval) {
-    uint32_t count = gTimeoutsRecentlySet;
-    gTimeoutsRecentlySet = 0;
-    Telemetry::Accumulate(Telemetry::DOM_TIMERS_RECENTLY_SET, count);
-    gLastRecordedRecentTimeouts = now;
-  }
-
   // Insert a dummy timeout into the list of timeouts between the
   // portion of the list that we are about to process now and those
   // timeouts that will be processed in a future call to
@@ -12604,8 +12584,6 @@ nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
   // the logic in ResetTimersForNonBackgroundWindow will need to change.
   mTimeoutInsertionPoint = dummy_timeout;
 
-  Telemetry::AutoCounter<Telemetry::DOM_TIMERS_FIRED_PER_NATIVE_TIMEOUT> timeoutsRan;
-
   for (nsTimeout *timeout = mTimeouts.getFirst();
        timeout != dummy_timeout && !IsFrozen();
        timeout = nextTimeout) {
@@ -12639,7 +12617,6 @@ nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
     }
 
     // This timeout is good to run
-    ++timeoutsRan;
     bool timeout_was_cleared = RunTimeoutHandler(timeout, scx);
 
     if (timeout_was_cleared) {
diff --git a/dom/base/nsINode.cpp b/dom/base/nsINode.cpp
index d6859c4..4aa9adb 100644
--- a/dom/base/nsINode.cpp
+++ b/dom/base/nsINode.cpp
@@ -20,7 +20,6 @@
 #include "mozilla/InternalMutationEvent.h"
 #include "mozilla/Likely.h"
 #include "mozilla/MemoryReporting.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/TimeStamp.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/Event.h"
diff --git a/dom/base/nsJSEnvironment.cpp b/dom/base/nsJSEnvironment.cpp
index 5acc9ed..4dba8c0 100644
--- a/dom/base/nsJSEnvironment.cpp
+++ b/dom/base/nsJSEnvironment.cpp
@@ -78,7 +78,6 @@
 #include "prthread.h"
 
 #include "mozilla/Preferences.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
@@ -1648,22 +1647,8 @@ nsJSContext::EndCycleCollectionCallback(CycleCollectorResults &aResults)
     endCCTime = PR_Now();
   }
 
-  // Log information about the CC via telemetry, JSON and the console.
-  Telemetry::Accumulate(Telemetry::CYCLE_COLLECTOR_FINISH_IGC, gCCStats.mAnyLockedOut);
-  Telemetry::Accumulate(Telemetry::CYCLE_COLLECTOR_SYNC_SKIPPABLE, gCCStats.mRanSyncForgetSkippable);
-  Telemetry::Accumulate(Telemetry::CYCLE_COLLECTOR_FULL, ccNowDuration);
-  Telemetry::Accumulate(Telemetry::CYCLE_COLLECTOR_MAX_PAUSE, gCCStats.mMaxSliceTime);
-
-  if (!sLastCCEndTime.IsNull()) {
-    // TimeBetween returns milliseconds, but we want to report seconds.
-    uint32_t timeBetween = TimeBetween(sLastCCEndTime, gCCStats.mBeginTime) / 1000;
-    Telemetry::Accumulate(Telemetry::CYCLE_COLLECTOR_TIME_BETWEEN, timeBetween);
-  }
   sLastCCEndTime = endCCTimeStamp;
 
-  Telemetry::Accumulate(Telemetry::FORGET_SKIPPABLE_MAX,
-                        sMaxForgetSkippableTime / PR_USEC_PER_MSEC);
-
   PRTime delta = GetCollectionTimeDelta();
 
   uint32_t cleanups = sForgetSkippableBeforeCC ? sForgetSkippableBeforeCC : 1;
diff --git a/dom/base/nsObjectLoadingContent.cpp b/dom/base/nsObjectLoadingContent.cpp
index f3dba17..df1d4fd 100644
--- a/dom/base/nsObjectLoadingContent.cpp
+++ b/dom/base/nsObjectLoadingContent.cpp
@@ -82,7 +82,6 @@
 #include "mozilla/dom/PluginCrashedEvent.h"
 #include "mozilla/EventDispatcher.h"
 #include "mozilla/EventStates.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/dom/HTMLObjectElementBinding.h"
 
 #ifdef XP_WIN
@@ -3550,7 +3549,6 @@ nsObjectLoadingContent::LegacyCall(JSContext* aCx,
     return;
   }
 
-  Telemetry::Accumulate(Telemetry::PLUGIN_CALLED_DIRECTLY, true);
 }
 
 void
diff --git a/dom/base/nsRange.cpp b/dom/base/nsRange.cpp
index 76f8f3e..9c10f32 100644
--- a/dom/base/nsRange.cpp
+++ b/dom/base/nsRange.cpp
@@ -31,7 +31,6 @@
 #include "mozilla/dom/DOMRect.h"
 #include "mozilla/dom/ShadowRoot.h"
 #include "mozilla/dom/Selection.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/Likely.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsStyleStruct.h"
@@ -209,9 +208,6 @@ nsRange::~nsRange()
 {
   NS_ASSERTION(!IsInSelection(), "deleting nsRange that is in use");
 
-  // Maybe we can remove Detach() -- bug 702948.
-  Telemetry::Accumulate(Telemetry::DOM_RANGE_DETACHED, mIsDetached);
-
   // we want the side effects (releases and list removals)
   DoSetRange(nullptr, 0, nullptr, 0, nullptr);
 }
diff --git a/dom/base/nsXMLHttpRequest.cpp b/dom/base/nsXMLHttpRequest.cpp
index 2cd4760..7291266 100644
--- a/dom/base/nsXMLHttpRequest.cpp
+++ b/dom/base/nsXMLHttpRequest.cpp
@@ -58,7 +58,6 @@
 #include "nsAsyncRedirectVerifyHelper.h"
 #include "nsStringBuffer.h"
 #include "nsIFileChannel.h"
-#include "mozilla/Telemetry.h"
 #include "jsfriendapi.h"
 #include "GoannaProfiler.h"
 #include "mozilla/dom/EncodingUtils.h"
@@ -1621,9 +1620,6 @@ nsXMLHttpRequest::Open(const nsACString& inMethod, const nsACString& url,
     GetOwner()->GetExtantDoc()->WarnOnceAbout(nsIDocument::eSyncXMLHttpRequest);
   }
 
-  Telemetry::Accumulate(Telemetry::XMLHTTPREQUEST_ASYNC_OR_SYNC,
-                        async ? 0 : 1);
-
   NS_ENSURE_TRUE(mPrincipal, NS_ERROR_NOT_INITIALIZED);
 
   // Disallow HTTP/1.1 TRACE method (see bug 302489)
diff --git a/dom/canvas/CanvasRenderingContext2D.cpp b/dom/canvas/CanvasRenderingContext2D.cpp
index 1b44c82..7ce29e6 100644
--- a/dom/canvas/CanvasRenderingContext2D.cpp
+++ b/dom/canvas/CanvasRenderingContext2D.cpp
@@ -91,7 +91,6 @@
 #include "mozilla/ipc/PDocumentRendererParent.h"
 #include "mozilla/MathAlgorithms.h"
 #include "mozilla/Preferences.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/TimeStamp.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/unused.h"
diff --git a/dom/canvas/WebGL1Context.cpp b/dom/canvas/WebGL1Context.cpp
index 87b3bce..c8413cf 100644
--- a/dom/canvas/WebGL1Context.cpp
+++ b/dom/canvas/WebGL1Context.cpp
@@ -6,7 +6,6 @@
 #include "WebGL1Context.h"
 
 #include "mozilla/dom/WebGLRenderingContextBinding.h"
-#include "mozilla/Telemetry.h"
 
 namespace mozilla {
 
@@ -36,8 +35,6 @@ WebGL1Context::WrapObject(JSContext* cx)
 nsresult
 NS_NewCanvasRenderingContextWebGL(nsIDOMWebGLRenderingContext** out_result)
 {
-    mozilla::Telemetry::Accumulate(mozilla::Telemetry::CANVAS_WEBGL_USED, 1);
-
     nsIDOMWebGLRenderingContext* ctx = mozilla::WebGL1Context::Create();
 
     NS_ADDREF(*out_result = ctx);
diff --git a/dom/canvas/WebGL2Context.cpp b/dom/canvas/WebGL2Context.cpp
index 259dd4e..d25bfd3 100644
--- a/dom/canvas/WebGL2Context.cpp
+++ b/dom/canvas/WebGL2Context.cpp
@@ -11,7 +11,6 @@
 #include "mozilla/dom/WebGL2RenderingContextBinding.h"
 #include "mozilla/ArrayUtils.h"
 #include "mozilla/Preferences.h"
-#include "mozilla/Telemetry.h"
 
 namespace mozilla {
 
diff --git a/dom/canvas/WebGLContext.cpp b/dom/canvas/WebGLContext.cpp
index 770ebf6..33309f8 100644
--- a/dom/canvas/WebGLContext.cpp
+++ b/dom/canvas/WebGLContext.cpp
@@ -26,7 +26,6 @@
 #include "mozilla/Preferences.h"
 #include "mozilla/ProcessPriorityManager.h"
 #include "mozilla/Services.h"
-#include "mozilla/Telemetry.h"
 #include "nsContentUtils.h"
 #include "nsDisplayList.h"
 #include "nsError.h"
diff --git a/dom/crypto/WebCryptoTask.cpp b/dom/crypto/WebCryptoTask.cpp
index c8cc088..6cc0f46 100644
--- a/dom/crypto/WebCryptoTask.cpp
+++ b/dom/crypto/WebCryptoTask.cpp
@@ -10,7 +10,6 @@
 #include "ScopedNSSTypes.h"
 
 #include "jsapi.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/dom/CryptoBuffer.h"
 #include "mozilla/dom/CryptoKey.h"
 #include "mozilla/dom/KeyAlgorithmProxy.h"
@@ -21,55 +20,6 @@
 namespace mozilla {
 namespace dom {
 
-// Pre-defined identifiers for telemetry histograms
-
-enum TelemetryMethod {
-  TM_ENCRYPT      = 0,
-  TM_DECRYPT      = 1,
-  TM_SIGN         = 2,
-  TM_VERIFY       = 3,
-  TM_DIGEST       = 4,
-  TM_GENERATEKEY  = 5,
-  TM_DERIVEKEY    = 6,
-  TM_DERIVEBITS   = 7,
-  TM_IMPORTKEY    = 8,
-  TM_EXPORTKEY    = 9,
-  TM_WRAPKEY      = 10,
-  TM_UNWRAPKEY    = 11
-};
-
-enum TelemetryAlgorithm {
-  // Please make additions at the end of the list,
-  // to preserve comparability of histograms over time
-  TA_UNKNOWN         = 0,
-  // encrypt / decrypt
-  TA_AES_CBC         = 1,
-  TA_AES_CFB         = 2,
-  TA_AES_CTR         = 3,
-  TA_AES_GCM         = 4,
-  TA_RSAES_PKCS1     = 5, // NB: This algorithm has been removed
-  TA_RSA_OAEP        = 6,
-  // sign/verify
-  TA_RSASSA_PKCS1    = 7,
-  TA_RSA_PSS         = 8,
-  TA_HMAC_SHA_1      = 9,
-  TA_HMAC_SHA_224    = 10,
-  TA_HMAC_SHA_256    = 11,
-  TA_HMAC_SHA_384    = 12,
-  TA_HMAC_SHA_512    = 13,
-  // digest
-  TA_SHA_1           = 14,
-  TA_SHA_224         = 15,
-  TA_SHA_256         = 16,
-  TA_SHA_384         = 17,
-  TA_SHA_512         = 18,
-  // Later additions
-  TA_AES_KW          = 19,
-  TA_ECDH            = 20,
-  TA_PBKDF2          = 21,
-  TA_ECDSA           = 22,
-};
-
 // Convenience functions for extracting / converting information
 
 // OOM-safe CryptoBuffer initialization, suitable for constructors
@@ -289,7 +239,6 @@ void
 WebCryptoTask::FailWithError(nsresult aRv)
 {
   MOZ_ASSERT(NS_IsMainThread());
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_RESOLVED, false);
 
   // Blindly convert nsresult to DOMException
   // Individual tasks must ensure they pass the right values
@@ -331,7 +280,6 @@ WebCryptoTask::CallCallback(nsresult rv)
   }
 
   Resolve();
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_RESOLVED, true);
 
   // Manually release mResultPromise while we're on the main thread
   mResultPromise = nullptr;
@@ -420,12 +368,10 @@ public:
     }
 
     // Cache parameters depending on the specific algorithm
-    TelemetryAlgorithm telemetryAlg;
     if (algName.EqualsLiteral(WEBCRYPTO_ALG_AES_CBC)) {
       CHECK_KEY_ALGORITHM(aKey.Algorithm(), WEBCRYPTO_ALG_AES_CBC);
 
       mMechanism = CKM_AES_CBC_PAD;
-      telemetryAlg = TA_AES_CBC;
       AesCbcParams params;
       nsresult rv = Coerce(aCx, params, aAlgorithm);
       if (NS_FAILED(rv)) {
@@ -442,7 +388,6 @@ public:
       CHECK_KEY_ALGORITHM(aKey.Algorithm(), WEBCRYPTO_ALG_AES_CTR);
 
       mMechanism = CKM_AES_CTR;
-      telemetryAlg = TA_AES_CTR;
       AesCtrParams params;
       nsresult rv = Coerce(aCx, params, aAlgorithm);
       if (NS_FAILED(rv)) {
@@ -461,7 +406,6 @@ public:
       CHECK_KEY_ALGORITHM(aKey.Algorithm(), WEBCRYPTO_ALG_AES_GCM);
 
       mMechanism = CKM_AES_GCM;
-      telemetryAlg = TA_AES_GCM;
       AesGcmParams params;
       nsresult rv = Coerce(aCx, params, aAlgorithm);
       if (NS_FAILED(rv)) {
@@ -490,7 +434,6 @@ public:
       mEarlyRv = NS_ERROR_DOM_NOT_SUPPORTED_ERR;
       return;
     }
-    Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, telemetryAlg);
   }
 
 private:
@@ -632,7 +575,6 @@ public:
       return;
     }
 
-    Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, TA_AES_KW);
   }
 
 private:
@@ -746,7 +688,6 @@ public:
   void Init(JSContext* aCx, const ObjectOrString& aAlgorithm,
             CryptoKey& aKey, bool aEncrypt)
   {
-    Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, TA_RSA_OAEP);
 
     CHECK_KEY_ALGORITHM(aKey.Algorithm(), WEBCRYPTO_ALG_RSA_OAEP);
 
@@ -887,16 +828,6 @@ public:
       return;
     }
 
-    TelemetryAlgorithm telemetryAlg;
-    switch (mMechanism) {
-      case CKM_SHA_1_HMAC:  telemetryAlg = TA_HMAC_SHA_1; break;
-      case CKM_SHA224_HMAC: telemetryAlg = TA_HMAC_SHA_224; break;
-      case CKM_SHA256_HMAC: telemetryAlg = TA_HMAC_SHA_256; break;
-      case CKM_SHA384_HMAC: telemetryAlg = TA_HMAC_SHA_384; break;
-      case CKM_SHA512_HMAC: telemetryAlg = TA_HMAC_SHA_512; break;
-      default:              telemetryAlg = TA_UNKNOWN;
-    }
-    Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, telemetryAlg);
   }
 
 private:
@@ -1002,7 +933,6 @@ public:
     // Look up the SECOidTag
     if (algName.EqualsLiteral(WEBCRYPTO_ALG_RSASSA_PKCS1)) {
       mEcdsa = false;
-      Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, TA_RSASSA_PKCS1);
       CHECK_KEY_ALGORITHM(aKey.Algorithm(), WEBCRYPTO_ALG_RSASSA_PKCS1);
 
       // For RSA, the hash name comes from the key algorithm
@@ -1022,7 +952,6 @@ public:
       }
     } else if (algName.EqualsLiteral(WEBCRYPTO_ALG_ECDSA)) {
       mEcdsa = true;
-      Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, TA_ECDSA);
       CHECK_KEY_ALGORITHM(aKey.Algorithm(), WEBCRYPTO_ALG_ECDSA);
 
       // For ECDSA, the hash name comes from the algorithm parameter
@@ -1164,24 +1093,18 @@ public:
       return;
     }
 
-    TelemetryAlgorithm telemetryAlg;
     if (algName.EqualsLiteral(WEBCRYPTO_ALG_SHA1))   {
       mOidTag = SEC_OID_SHA1;
-      telemetryAlg = TA_SHA_1;
     } else if (algName.EqualsLiteral(WEBCRYPTO_ALG_SHA256)) {
       mOidTag = SEC_OID_SHA256;
-      telemetryAlg = TA_SHA_224;
     } else if (algName.EqualsLiteral(WEBCRYPTO_ALG_SHA384)) {
       mOidTag = SEC_OID_SHA384;
-      telemetryAlg = TA_SHA_256;
     } else if (algName.EqualsLiteral(WEBCRYPTO_ALG_SHA512)) {
       mOidTag = SEC_OID_SHA512;
-      telemetryAlg = TA_SHA_384;
     } else {
       mEarlyRv = NS_ERROR_DOM_SYNTAX_ERR;
       return;
     }
-    Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, telemetryAlg);
   }
 
 private:
@@ -2368,7 +2291,6 @@ public:
   void Init(JSContext* aCx, const ObjectOrString& aAlgorithm, CryptoKey& aKey,
             uint32_t aLength)
   {
-    Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, TA_PBKDF2);
     CHECK_KEY_ALGORITHM(aKey.Algorithm(), WEBCRYPTO_ALG_PBKDF2);
 
     // Check that we got a symmetric key
@@ -2531,7 +2453,6 @@ public:
 
   void Init(JSContext* aCx, const ObjectOrString& aAlgorithm, CryptoKey& aKey)
   {
-    Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, TA_ECDH);
     CHECK_KEY_ALGORITHM(aKey.Algorithm(), WEBCRYPTO_ALG_ECDH);
 
     // Check that we have a private key.
@@ -2825,10 +2746,6 @@ WebCryptoTask::CreateEncryptDecryptTask(JSContext* aCx,
                                         const CryptoOperationData& aData,
                                         bool aEncrypt)
 {
-  TelemetryMethod method = (aEncrypt)? TM_ENCRYPT : TM_DECRYPT;
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_METHOD, method);
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_EXTRACTABLE_ENC, aKey.Extractable());
-
   // Ensure key is usable for this operation
   if ((aEncrypt  && !aKey.HasUsage(CryptoKey::ENCRYPT)) ||
       (!aEncrypt && !aKey.HasUsage(CryptoKey::DECRYPT))) {
@@ -2860,10 +2777,6 @@ WebCryptoTask::CreateSignVerifyTask(JSContext* aCx,
                                     const CryptoOperationData& aData,
                                     bool aSign)
 {
-  TelemetryMethod method = (aSign)? TM_SIGN : TM_VERIFY;
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_METHOD, method);
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_EXTRACTABLE_SIG, aKey.Extractable());
-
   // Ensure key is usable for this operation
   if ((aSign  && !aKey.HasUsage(CryptoKey::SIGN)) ||
       (!aSign && !aKey.HasUsage(CryptoKey::VERIFY))) {
@@ -2892,8 +2805,6 @@ WebCryptoTask::CreateDigestTask(JSContext* aCx,
                                 const ObjectOrString& aAlgorithm,
                                 const CryptoOperationData& aData)
 {
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_METHOD, TM_DIGEST);
-
   nsString algName;
   nsresult rv = GetAlgorithmName(aCx, aAlgorithm, algName);
   if (NS_FAILED(rv)) {
@@ -2918,9 +2829,6 @@ WebCryptoTask::CreateImportKeyTask(JSContext* aCx,
                                    bool aExtractable,
                                    const Sequence<nsString>& aKeyUsages)
 {
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_METHOD, TM_IMPORTKEY);
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_EXTRACTABLE_IMPORT, aExtractable);
-
   // Verify that the format is recognized
   if (!aFormat.EqualsLiteral(WEBCRYPTO_KEY_FORMAT_RAW) &&
       !aFormat.EqualsLiteral(WEBCRYPTO_KEY_FORMAT_SPKI) &&
@@ -2970,8 +2878,6 @@ WebCryptoTask*
 WebCryptoTask::CreateExportKeyTask(const nsAString& aFormat,
                                    CryptoKey& aKey)
 {
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_METHOD, TM_EXPORTKEY);
-
   // Verify that the format is recognized
   if (!aFormat.EqualsLiteral(WEBCRYPTO_KEY_FORMAT_RAW) &&
       !aFormat.EqualsLiteral(WEBCRYPTO_KEY_FORMAT_SPKI) &&
@@ -3012,9 +2918,6 @@ WebCryptoTask::CreateGenerateKeyTask(JSContext* aCx,
                                      bool aExtractable,
                                      const Sequence<nsString>& aKeyUsages)
 {
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_METHOD, TM_GENERATEKEY);
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_EXTRACTABLE_GENERATE, aExtractable);
-
   // Verify that aKeyUsages does not contain an unrecognized value
   // SPEC-BUG: Spec says that this should be InvalidAccessError, but that
   // is inconsistent with other analogous points in the spec
@@ -3053,8 +2956,6 @@ WebCryptoTask::CreateDeriveKeyTask(JSContext* aCx,
                                    bool aExtractable,
                                    const Sequence<nsString>& aKeyUsages)
 {
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_METHOD, TM_DERIVEKEY);
-
   // Ensure baseKey is usable for this operation
   if (!aBaseKey.HasUsage(CryptoKey::DERIVEKEY)) {
     return new FailureTask(NS_ERROR_DOM_INVALID_ACCESS_ERR);
@@ -3092,8 +2993,6 @@ WebCryptoTask::CreateDeriveBitsTask(JSContext* aCx,
                                     CryptoKey& aKey,
                                     uint32_t aLength)
 {
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_METHOD, TM_DERIVEBITS);
-
   // Ensure baseKey is usable for this operation
   if (!aKey.HasUsage(CryptoKey::DERIVEBITS)) {
     return new FailureTask(NS_ERROR_DOM_INVALID_ACCESS_ERR);
@@ -3127,8 +3026,6 @@ WebCryptoTask::CreateWrapKeyTask(JSContext* aCx,
                                  CryptoKey& aWrappingKey,
                                  const ObjectOrString& aWrapAlgorithm)
 {
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_METHOD, TM_WRAPKEY);
-
   // Verify that the format is recognized
   if (!aFormat.EqualsLiteral(WEBCRYPTO_KEY_FORMAT_RAW) &&
       !aFormat.EqualsLiteral(WEBCRYPTO_KEY_FORMAT_SPKI) &&
@@ -3179,8 +3076,6 @@ WebCryptoTask::CreateUnwrapKeyTask(JSContext* aCx,
                                    bool aExtractable,
                                    const Sequence<nsString>& aKeyUsages)
 {
-  Telemetry::Accumulate(Telemetry::WEBCRYPTO_METHOD, TM_UNWRAPKEY);
-
   // Ensure key is usable for this operation
   if (!aUnwrappingKey.HasUsage(CryptoKey::UNWRAPKEY)) {
     return new FailureTask(NS_ERROR_DOM_INVALID_ACCESS_ERR);
diff --git a/dom/geolocation/nsGeolocation.cpp b/dom/geolocation/nsGeolocation.cpp
index eb9cd5c..cdb63a2 100644
--- a/dom/geolocation/nsGeolocation.cpp
+++ b/dom/geolocation/nsGeolocation.cpp
@@ -5,7 +5,6 @@
 #include "nsXULAppAPI.h"
 
 #include "mozilla/dom/ContentChild.h"
-#include "mozilla/Telemetry.h"
 
 #include "nsISettingsService.h"
 
@@ -1268,7 +1267,6 @@ Geolocation::Update(nsIDOMGeoPosition *aSomewhere)
     if (coords) {
       double accuracy = -1;
       coords->GetAccuracy(&accuracy);
-      mozilla::Telemetry::Accumulate(mozilla::Telemetry::GEOLOCATION_ACCURACY_EXPONENTIAL, accuracy);
     }
   }
 
@@ -1304,8 +1302,6 @@ Geolocation::NotifyError(uint16_t aErrorCode)
     return NS_OK;
   }
 
-  mozilla::Telemetry::Accumulate(mozilla::Telemetry::GEOLOCATION_ERROR, true);
-
   for (uint32_t i = mPendingCallbacks.Length(); i > 0; i--) {
     mPendingCallbacks[i-1]->NotifyErrorAndShutdown(aErrorCode);
     //NotifyErrorAndShutdown() removes the request from the array
diff --git a/dom/geolocation/nsGeolocationSettings.cpp b/dom/geolocation/nsGeolocationSettings.cpp
index c186c3e..19c152c 100644
--- a/dom/geolocation/nsGeolocationSettings.cpp
+++ b/dom/geolocation/nsGeolocationSettings.cpp
@@ -6,7 +6,6 @@
 #include "nsXULAppAPI.h"
 
 #include "mozilla/dom/ContentChild.h"
-#include "mozilla/Telemetry.h"
 
 #include "nsISettingsService.h"
 
diff --git a/dom/html/HTMLCanvasElement.cpp b/dom/html/HTMLCanvasElement.cpp
index 68649f5..3a0f46c 100644
--- a/dom/html/HTMLCanvasElement.cpp
+++ b/dom/html/HTMLCanvasElement.cpp
@@ -20,7 +20,6 @@
 #include "mozilla/gfx/Rect.h"
 #include "mozilla/MouseEvents.h"
 #include "mozilla/Preferences.h"
-#include "mozilla/Telemetry.h"
 #include "nsAttrValueInlines.h"
 #include "nsContentUtils.h"
 #include "nsDisplayList.h"
@@ -696,12 +695,10 @@ CreateContextForCanvas(CanvasContextType contextType, HTMLCanvasElement* canvas)
 
   switch (contextType) {
   case CanvasContextType::Canvas2D:
-    Telemetry::Accumulate(Telemetry::CANVAS_2D_USED, 1);
     ret = new CanvasRenderingContext2D();
     break;
 
   case CanvasContextType::WebGL1:
-    Telemetry::Accumulate(Telemetry::CANVAS_WEBGL_USED, 1);
 
     ret = WebGL1Context::Create();
     if (!ret)
@@ -709,7 +706,6 @@ CreateContextForCanvas(CanvasContextType contextType, HTMLCanvasElement* canvas)
     break;
 
   case CanvasContextType::WebGL2:
-    Telemetry::Accumulate(Telemetry::CANVAS_WEBGL_USED, 1);
 
     ret = WebGL2Context::Create();
     if (!ret)
diff --git a/dom/html/HTMLFormElement.cpp b/dom/html/HTMLFormElement.cpp
index 50f04b7..98ecfb9 100644
--- a/dom/html/HTMLFormElement.cpp
+++ b/dom/html/HTMLFormElement.cpp
@@ -32,7 +32,6 @@
 #include "mozilla/BinarySearch.h"
 
 // form submission
-#include "mozilla/Telemetry.h"
 #include "nsIFormSubmitObserver.h"
 #include "nsIObserverService.h"
 #include "nsICategoryManager.h"
@@ -46,7 +45,6 @@
 #include "nsFormData.h"
 #include "nsFormSubmissionConstants.h"
 #include "nsIPromptService.h"
-#include "nsISecurityUITelemetry.h"
 #include "nsIStringBundle.h"
 
 // radio buttons
@@ -953,15 +951,7 @@ HTMLFormElement::DoSecureToInsecureSubmitCheck(nsIURI* aActionURL,
     return rv;
   }
   *aCancelSubmit = (buttonPressed == 1);
-  uint32_t telemetryBucket =
-    nsISecurityUITelemetry::WARNING_CONFIRM_POST_TO_INSECURE_FROM_SECURE;
-  mozilla::Telemetry::Accumulate(mozilla::Telemetry::SECURITY_UI,
-                                 telemetryBucket);
-  if (!*aCancelSubmit) {
-    // The user opted to continue, so note that in the next telemetry bucket.
-    mozilla::Telemetry::Accumulate(mozilla::Telemetry::SECURITY_UI,
-                                   telemetryBucket + 1);
-  }
+
   return NS_OK;
 }
 
diff --git a/dom/html/HTMLInputElement.cpp b/dom/html/HTMLInputElement.cpp
index 2d9b281..08acf3b 100644
--- a/dom/html/HTMLInputElement.cpp
+++ b/dom/html/HTMLInputElement.cpp
@@ -17,7 +17,6 @@
 #include "nsIRadioVisitor.h"
 #include "nsIPhonetic.h"
 
-#include "mozilla/Telemetry.h"
 #include "nsIControllers.h"
 #include "nsIStringBundle.h"
 #include "nsFocusManager.h"
@@ -4478,12 +4477,6 @@ HTMLInputElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
   // And now make sure our state is up to date
   UpdateState(false);
 
-#ifdef EARLY_BETA_OR_EARLIER
-  if (mType == NS_FORM_INPUT_PASSWORD) {
-    Telemetry::Accumulate(Telemetry::PWMGR_PASSWORD_INPUT_IN_FORM, !!mForm);
-  }
-#endif
-
   return rv;
 }
 
diff --git a/dom/html/HTMLMediaElement.cpp b/dom/html/HTMLMediaElement.cpp
index d3b5408..6a6e48c 100644
--- a/dom/html/HTMLMediaElement.cpp
+++ b/dom/html/HTMLMediaElement.cpp
@@ -84,7 +84,6 @@
 #include "mozilla/dom/VideoTrackList.h"
 #include "mozilla/dom/TextTrack.h"
 #include "nsIContentPolicy.h"
-#include "mozilla/Telemetry.h"
 
 #include "ImageContainer.h"
 #include "nsRange.h"
@@ -1229,9 +1228,6 @@ nsresult HTMLMediaElement::LoadResource()
     mMediaSource = source.forget();
     nsRefPtr<MediaResource> resource =
       MediaSourceDecoder::CreateResource(mMediaSource->GetPrincipal());
-    if (IsAutoplayEnabled()) {
-      mJoinLatency.Start();
-    }
     return FinishDecoderSetup(decoder, resource, nullptr, nullptr);
   }
 
@@ -2589,66 +2585,6 @@ nsresult HTMLMediaElement::BindToTree(nsIDocument* aDocument, nsIContent* aParen
   return rv;
 }
 
-void
-HTMLMediaElement::ReportMSETelemetry()
-{
-  // Report telemetry for videos when a page is unloaded. We
-  // want to know data on what state the video is at when
-  // the user has exited.
-  enum UnloadedState {
-    ENDED = 0,
-    PAUSED = 1,
-    STALLED = 2,
-    SEEKING = 3,
-    OTHER = 4
-  };
-
-  UnloadedState state = OTHER;
-  if (Seeking()) {
-    state = SEEKING;
-  }
-  else if (Ended()) {
-    state = ENDED;
-  }
-  else if (Paused()) {
-    state = PAUSED;
-  }
-  else {
-    // For buffering we check if the current playback position is at the end
-    // of a buffered range, within a margin of error. We also consider to be
-    // buffering if the last frame status was buffering and the ready state is
-    // HAVE_CURRENT_DATA to account for times where we are in a buffering state
-    // regardless of what actual data we have buffered.
-    bool stalled = false;
-    nsRefPtr<TimeRanges> ranges = Buffered();
-    const double errorMargin = 0.05;
-    double t = CurrentTime();
-    TimeRanges::index_type index = ranges->Find(t, errorMargin);
-    ErrorResult ignore;
-    stalled = index != TimeRanges::NoIndex &&
-              (ranges->End(index, ignore) - t) < errorMargin;
-    stalled |= mDecoder && NextFrameStatus() == MediaDecoderOwner::NEXT_FRAME_UNAVAILABLE_BUFFERING &&
-               mReadyState == HTMLMediaElement::HAVE_CURRENT_DATA;
-    if (stalled) {
-      state = STALLED;
-    }
-  }
-
-  Telemetry::Accumulate(Telemetry::VIDEO_MSE_UNLOAD_STATE, state);
-  LOG(PR_LOG_DEBUG, ("%p VIDEO_MSE_UNLOAD_STATE = %d", this, state));
-
-  Telemetry::Accumulate(Telemetry::VIDEO_MSE_PLAY_TIME_MS, SECONDS_TO_MS(mPlayTime.Total()));
-  LOG(PR_LOG_DEBUG, ("%p VIDEO_MSE_PLAY_TIME_MS = %f", this, mPlayTime.Total()));
-
-  Telemetry::Accumulate(Telemetry::VIDEO_MSE_BUFFERING_COUNT, mRebufferTime.Count());
-  LOG(PR_LOG_DEBUG, ("%p VIDEO_MSE_BUFFERING_COUNT = %d", this, mRebufferTime.Count()));
-
-  double latency = mJoinLatency.Count() ? mJoinLatency.Total() / mJoinLatency.Count() : 0.0;
-  Telemetry::Accumulate(Telemetry::VIDEO_MSE_JOIN_LATENCY_MS, SECONDS_TO_MS(latency));
-  LOG(PR_LOG_DEBUG, ("%p VIDEO_MSE_JOIN_LATENCY = %f (%d ms) count=%d\n",
-                     this, latency, SECONDS_TO_MS(latency), mJoinLatency.Count()));
-}
-
 void HTMLMediaElement::UnbindFromTree(bool aDeep,
                                       bool aNullParent)
 {
@@ -3843,17 +3779,6 @@ nsresult HTMLMediaElement::DispatchAsyncEvent(const nsAString& aName)
     return NS_OK;
   }
 
-  if ((aName.EqualsLiteral("play") || aName.EqualsLiteral("playing"))) {
-    mPlayTime.Start();
-    mRebufferTime.Pause();
-    mJoinLatency.Pause();
-  } else if (aName.EqualsLiteral("waiting")) {
-    mPlayTime.Pause();
-    mRebufferTime.Start();
-  } else if (aName.EqualsLiteral("pause")) {
-    mPlayTime.Pause();
-  }
-
   return NS_OK;
 }
 
@@ -3943,9 +3868,6 @@ void HTMLMediaElement::SuspendOrResumeElement(bool aPauseElement, bool aSuspendE
   if (aPauseElement != mPausedForInactiveDocumentOrChannel) {
     mPausedForInactiveDocumentOrChannel = aPauseElement;
     if (aPauseElement) {
-      if (mMediaSource) {
-        ReportMSETelemetry();
-      }
 
       if (mDecoder) {
         mDecoder->Pause();
diff --git a/dom/html/HTMLMediaElement.h b/dom/html/HTMLMediaElement.h
index e86b585..32940a2 100644
--- a/dom/html/HTMLMediaElement.h
+++ b/dom/html/HTMLMediaElement.h
@@ -966,8 +966,6 @@ protected:
     return isPaused;
   }
 
-  void ReportMSETelemetry();
-
   // Check the permissions for audiochannel.
   bool CheckAudioChannelPermissions(const nsAString& aType);
 
@@ -1354,51 +1352,6 @@ protected:
   // initially be set to zero seconds. This time is used to allow the element to
   // be seeked even before the media is loaded.
   double mDefaultPlaybackStartPosition;
-public:
-  // Helper class to measure times for MSE telemetry stats
-  class TimeDurationAccumulator {
-  public:
-    TimeDurationAccumulator()
-      : mCount(0)
-    {
-    }
-    void Start() {
-      if (IsStarted()) {
-        return;
-      }
-      mStartTime = TimeStamp::Now();
-    }
-    void Pause() {
-      if (!IsStarted()) {
-        return;
-      }
-      mSum += (TimeStamp::Now() - mStartTime);
-      mCount++;
-      mStartTime = TimeStamp();
-    }
-    bool IsStarted() const {
-      return !mStartTime.IsNull();
-    }
-    double Total() const {
-      return mSum.ToSeconds();
-    }
-    uint32_t Count() const {
-      return mCount;
-    }
-  private:
-    TimeStamp mStartTime;
-    TimeDuration mSum;
-    uint32_t mCount;
-  };
-private:
-  // Total time an MSE video has spent playing
-  TimeDurationAccumulator mPlayTime;
-
-  // Time spent buffering in an MSE video
-  TimeDurationAccumulator mRebufferTime;
-
-  // Time spent between video load and video playback.
-  TimeDurationAccumulator mJoinLatency;
 };
 
 } // namespace dom
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
index 99ef275..4c013c8 100644
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -70,7 +70,6 @@
 #include "mozilla/ProcessHangMonitorIPC.h"
 #include "mozilla/Services.h"
 #include "mozilla/StaticPtr.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/unused.h"
 #include "nsAnonymousTemporaryFile.h"
 #include "nsAppRunner.h"
@@ -1817,8 +1816,6 @@ ContentParent::ActorDestroy(ActorDestroyReason why)
         props->SetPropertyAsUint64(NS_LITERAL_STRING("childID"), mChildID);
 
         if (AbnormalShutdown == why) {
-            Telemetry::Accumulate(Telemetry::SUBPROCESS_ABNORMAL_ABORT,
-                                  NS_LITERAL_CSTRING("content"), 1);
 
             props->SetPropertyAsBool(NS_LITERAL_STRING("abnormal"), true);
 
diff --git a/dom/media/AudioStream.cpp b/dom/media/AudioStream.cpp
index 7ddf933..c6a3fa4 100644
--- a/dom/media/AudioStream.cpp
+++ b/dom/media/AudioStream.cpp
@@ -13,7 +13,6 @@
 #include "mozilla/Monitor.h"
 #include "mozilla/Mutex.h"
 #include <algorithm>
-#include "mozilla/Telemetry.h"
 #include "soundtouch/SoundTouch.h"
 #include "Latency.h"
 #include "CubebUtils.h"
@@ -519,8 +518,6 @@ AudioStream::OpenCubeb(cubeb_stream_params &aParams,
     TimeDuration timeDelta = TimeStamp::Now() - mStartTime;
     LOG(("AudioStream creation time %sfirst: %u ms", mIsFirst ? "" : "not ",
           (uint32_t) timeDelta.ToMilliseconds()));
-    Telemetry::Accumulate(mIsFirst ? Telemetry::AUDIOSTREAM_FIRST_OPEN_MS :
-        Telemetry::AUDIOSTREAM_LATER_OPEN_MS, timeDelta.ToMilliseconds());
   }
 
   return NS_OK;
diff --git a/dom/media/PeerConnection.js b/dom/media/PeerConnection.js
index d52c702..ef4ce79 100644
--- a/dom/media/PeerConnection.js
+++ b/dom/media/PeerConnection.js
@@ -1148,16 +1148,13 @@ PeerConnectionObserver.prototype = {
   //                 STUN requests.
 
   handleIceConnectionStateChange: function(iceConnectionState) {
-    var histogram = Services.telemetry.getHistogramById("WEBRTC_ICE_SUCCESS_RATE");
 
     if (iceConnectionState === 'failed') {
-      histogram.add(false);
       this._dompc.logError("ICE failed, see about:webrtc for more details", null, 0);
     }
     if (this._dompc.iceConnectionState === 'checking' &&
         (iceConnectionState === 'completed' ||
          iceConnectionState === 'connected')) {
-          histogram.add(true);
     }
     this._dompc.changeIceConnectionState(iceConnectionState);
   },
diff --git a/dom/media/VideoUtils.cpp b/dom/media/VideoUtils.cpp
index c1181fa..b2d9b5f 100644
--- a/dom/media/VideoUtils.cpp
+++ b/dom/media/VideoUtils.cpp
@@ -12,7 +12,6 @@
 #include "SharedThreadPool.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/Base64.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/Function.h"
 #include "nsIRandomGenerator.h"
 #include "nsIServiceManager.h"
@@ -276,24 +275,6 @@ ExtractH264CodecDetails(const nsAString& aCodec,
     aLevel *= 10;
   }
 
-  // Capture the constraint_set flag value for the purpose of Telemetry.
-  // We don't NS_ENSURE_SUCCESS here because ExtractH264CodecDetails doesn't
-  // care about this, but we make sure constraints is above 4 (constraint_set5_flag)
-  // otherwise collect 0 for unknown.
-  uint8_t constraints = PromiseFlatString(Substring(aCodec, 7, 2)).ToInteger(&rv, 16);
-  Telemetry::Accumulate(Telemetry::VIDEO_CANPLAYTYPE_H264_CONSTRAINT_SET_FLAG,
-                        constraints >= 4 ? constraints : 0);
-
-  // 244 is the highest meaningful profile value (High 4:4:4 Intra Profile)
-  // that can be represented as single hex byte, otherwise collect 0 for unknown.
-  Telemetry::Accumulate(Telemetry::VIDEO_CANPLAYTYPE_H264_PROFILE,
-                        aProfile <= 244 ? aProfile : 0);
-
-  // Make sure aLevel represents a value between levels 1 and 5.2,
-  // otherwise collect 0 for unknown.
-  Telemetry::Accumulate(Telemetry::VIDEO_CANPLAYTYPE_H264_LEVEL,
-                        (aLevel >= 10 && aLevel <= 52) ? aLevel : 0);
-
   return true;
 }
 
diff --git a/dom/media/fmp4/MP4Reader.cpp b/dom/media/fmp4/MP4Reader.cpp
index 4cb43f2..ec7067e 100644
--- a/dom/media/fmp4/MP4Reader.cpp
+++ b/dom/media/fmp4/MP4Reader.cpp
@@ -17,7 +17,6 @@
 #include "Layers.h"
 #include "SharedThreadPool.h"
 #include "mozilla/Preferences.h"
-#include "mozilla/Telemetry.h"
 #include "mp4_demuxer/AnnexB.h"
 #include "mp4_demuxer/H264.h"
 #include "SharedDecoderManager.h"
@@ -68,41 +67,6 @@ TrackTypeToStr(TrackInfo::TrackType aTrack)
 }
 #endif
 
-bool
-AccumulateSPSTelemetry(const MediaByteBuffer* aExtradata)
-{
-  SPSData spsdata;
-  if (H264::DecodeSPSFromExtraData(aExtradata, spsdata)) {
-   uint8_t constraints = (spsdata.constraint_set0_flag ? (1 << 0) : 0) |
-                         (spsdata.constraint_set1_flag ? (1 << 1) : 0) |
-                         (spsdata.constraint_set2_flag ? (1 << 2) : 0) |
-                         (spsdata.constraint_set3_flag ? (1 << 3) : 0) |
-                         (spsdata.constraint_set4_flag ? (1 << 4) : 0) |
-                         (spsdata.constraint_set5_flag ? (1 << 5) : 0);
-    Telemetry::Accumulate(Telemetry::VIDEO_DECODED_H264_SPS_CONSTRAINT_SET_FLAG,
-                          constraints);
-
-    // Collect profile_idc values up to 244, otherwise 0 for unknown.
-    Telemetry::Accumulate(Telemetry::VIDEO_DECODED_H264_SPS_PROFILE,
-                          spsdata.profile_idc <= 244 ? spsdata.profile_idc : 0);
-
-    // Make sure level_idc represents a value between levels 1 and 5.2,
-    // otherwise collect 0 for unknown level.
-    Telemetry::Accumulate(Telemetry::VIDEO_DECODED_H264_SPS_LEVEL,
-                          (spsdata.level_idc >= 10 && spsdata.level_idc <= 52) ?
-                          spsdata.level_idc : 0);
-
-    // max_num_ref_frames should be between 0 and 16, anything larger will
-    // be treated as invalid.
-    Telemetry::Accumulate(Telemetry::VIDEO_H264_SPS_MAX_NUM_REF_FRAMES,
-                          std::min(spsdata.max_num_ref_frames, 17u));
-
-    return true;
-  }
-
-  return false;
-}
-
 // MP4Demuxer wants to do various blocking reads, which cause deadlocks while
 // mDemuxerMonitor is held. This stuff should really be redesigned, but we don't
 // have time for that right now. So in order to get proper synchronization while
@@ -153,7 +117,6 @@ MP4Reader::MP4Reader(AbstractMediaDecoder* aDecoder)
   , mLastReportedNumDecodedFrames(0)
   , mLayersBackendType(layers::LayersBackend::LAYERS_NONE)
   , mDemuxerInitialized(false)
-  , mFoundSPSForTelemetry(false)
   , mIsEncrypted(false)
   , mIndexReady(false)
   , mLastSeenEnd(-1)
@@ -355,10 +318,6 @@ MP4Reader::ReadMetadata(MediaInfo* aInfo,
     mInfo.mVideo = mDemuxer->VideoConfig();
     mVideo.mCallback = new DecoderCallback(this, TrackInfo::kVideoTrack);
 
-    // Collect telemetry from h264 AVCC SPS.
-    if (!mFoundSPSForTelemetry) {
-      mFoundSPSForTelemetry = AccumulateSPSTelemetry(mInfo.mVideo.mExtraData);
-    }
   }
 
   if (mCrypto.valid) {
@@ -702,12 +661,6 @@ MP4Reader::Update(TrackType aTrack)
   if (needInput) {
     nsRefPtr<MediaRawData> sample(PopSample(aTrack));
 
-    // Collect telemetry from h264 Annex B SPS.
-    if (!mFoundSPSForTelemetry && sample && AnnexB::HasSPS(sample)) {
-      nsRefPtr<MediaByteBuffer> extradata = AnnexB::ExtractExtraData(sample);
-      mFoundSPSForTelemetry = AccumulateSPSTelemetry(extradata);
-    }
-
     if (sample) {
       decoder.mDecoder->Input(sample);
       if (aTrack == TrackInfo::kVideoTrack) {
diff --git a/dom/media/fmp4/MP4Reader.h b/dom/media/fmp4/MP4Reader.h
index 413f24d..ae032bb 100644
--- a/dom/media/fmp4/MP4Reader.h
+++ b/dom/media/fmp4/MP4Reader.h
@@ -266,9 +266,6 @@ private:
   // True if we've read the streams' metadata.
   bool mDemuxerInitialized;
 
-  // True if we've gathered telemetry from an SPS.
-  bool mFoundSPSForTelemetry;
-
   // Synchronized by decoder monitor.
   bool mIsEncrypted;
 
diff --git a/dom/plugins/base/nsPluginHost.cpp b/dom/plugins/base/nsPluginHost.cpp
index 03b8b33..2782fd9 100644
--- a/dom/plugins/base/nsPluginHost.cpp
+++ b/dom/plugins/base/nsPluginHost.cpp
@@ -87,7 +87,6 @@
 #include "nsIContentPolicy.h"
 #include "nsContentPolicyUtils.h"
 #include "mozilla/TimeStamp.h"
-#include "mozilla/Telemetry.h"
 #include "nsIImageLoadingContent.h"
 #include "mozilla/Preferences.h"
 #include "nsVersionComparator.h"
@@ -1967,11 +1966,8 @@ nsresult nsPluginHost::ScanPluginsDirectory(nsIFile *pluginsDir,
       nsPluginInfo info;
       memset(&info, 0, sizeof(info));
       nsresult res;
-      // Opening a block for the telemetry AutoTimer
-      {
-        Telemetry::AutoTimer<Telemetry::PLUGIN_LOAD_METADATA> telemetry;
-        res = pluginFile.GetPluginInfo(info, &library);
-      }
+      res = pluginFile.GetPluginInfo(info, &library);
+
       // if we don't have mime type don't proceed, this is not a plugin
       if (NS_FAILED(res) || !info.fMimeTypeArray) {
         nsRefPtr<nsInvalidPluginTag> invalidTag = new nsInvalidPluginTag(filePath.get(),
@@ -2230,8 +2226,6 @@ nsPluginHost::FindPluginsInContent(bool aCreatePluginList, bool* aPluginsChanged
 // This is needed in ReloadPlugins to prevent possible recursive reloads
 nsresult nsPluginHost::FindPlugins(bool aCreatePluginList, bool * aPluginsChanged)
 {
-  Telemetry::AutoTimer<Telemetry::FIND_PLUGINS> telemetry;
-
   NS_ENSURE_ARG_POINTER(aPluginsChanged);
 
   *aPluginsChanged = false;
@@ -3336,7 +3330,6 @@ nsPluginHost::StopPluginInstance(nsNPAPIPluginInstance* aInstance)
     return NS_OK;
   }
 
-  Telemetry::AutoTimer<Telemetry::PLUGIN_SHUTDOWN_MS> timer;
   aInstance->Stop();
 
   // if the instance does not want to be 'cached' just remove it
diff --git a/dom/plugins/ipc/PluginAsyncSurrogate.cpp b/dom/plugins/ipc/PluginAsyncSurrogate.cpp
index 71ff12d..5401e1a 100644
--- a/dom/plugins/ipc/PluginAsyncSurrogate.cpp
+++ b/dom/plugins/ipc/PluginAsyncSurrogate.cpp
@@ -12,7 +12,6 @@
 #include "mozilla/plugins/PluginInstanceParent.h"
 #include "mozilla/plugins/PluginModuleParent.h"
 #include "mozilla/plugins/PluginScriptableObjectParent.h"
-#include "mozilla/Telemetry.h"
 #include "nsJSNPRuntime.h"
 #include "nsNPAPIPlugin.h"
 #include "nsNPAPIPluginInstance.h"
@@ -471,8 +470,6 @@ PluginAsyncSurrogate::WaitForInit()
   if (mAcceptCalls) {
     return true;
   }
-  Telemetry::AutoTimer<Telemetry::BLOCKED_ON_PLUGINASYNCSURROGATE_WAITFORINIT_MS>
-    timer(mParent->GetHistogramKey());
   bool result = false;
   MOZ_ASSERT(mParent);
   if (mParent->IsChrome()) {
diff --git a/dom/plugins/ipc/PluginHangUIParent.cpp b/dom/plugins/ipc/PluginHangUIParent.cpp
index 5376e71..1f3b22e 100644
--- a/dom/plugins/ipc/PluginHangUIParent.cpp
+++ b/dom/plugins/ipc/PluginHangUIParent.cpp
@@ -8,7 +8,6 @@
 
 #include "PluginHangUIParent.h"
 
-#include "mozilla/Telemetry.h"
 #include "mozilla/plugins/PluginModuleParent.h"
 
 #include "nsContentUtils.h"
@@ -31,41 +30,6 @@ using mozilla::widget::WidgetUtils;
 using std::string;
 using std::vector;
 
-namespace {
-class nsPluginHangUITelemetry : public nsRunnable
-{
-public:
-  nsPluginHangUITelemetry(int aResponseCode, int aDontAskCode,
-                          uint32_t aResponseTimeMs, uint32_t aTimeoutMs)
-    : mResponseCode(aResponseCode),
-      mDontAskCode(aDontAskCode),
-      mResponseTimeMs(aResponseTimeMs),
-      mTimeoutMs(aTimeoutMs)
-  {
-  }
-
-  NS_IMETHOD
-  Run()
-  {
-    mozilla::Telemetry::Accumulate(
-              mozilla::Telemetry::PLUGIN_HANG_UI_USER_RESPONSE, mResponseCode);
-    mozilla::Telemetry::Accumulate(
-              mozilla::Telemetry::PLUGIN_HANG_UI_DONT_ASK, mDontAskCode);
-    mozilla::Telemetry::Accumulate(
-              mozilla::Telemetry::PLUGIN_HANG_UI_RESPONSE_TIME, mResponseTimeMs);
-    mozilla::Telemetry::Accumulate(
-              mozilla::Telemetry::PLUGIN_HANG_TIME, mTimeoutMs + mResponseTimeMs);
-    return NS_OK;
-  }
-
-private:
-  int mResponseCode;
-  int mDontAskCode;
-  uint32_t mResponseTimeMs;
-  uint32_t mTimeoutMs;
-};
-} // anonymous namespace
-
 namespace mozilla {
 namespace plugins {
 
@@ -364,11 +328,7 @@ PluginHangUIParent::RecvUserResponse(const unsigned int& aResponse)
     responseCode = 3;
   }
   int dontAskCode = (aResponse & HANGUI_USER_RESPONSE_DONT_SHOW_AGAIN) ? 1 : 0;
-  nsCOMPtr<nsIRunnable> workItem = new nsPluginHangUITelemetry(responseCode,
-                                                               dontAskCode,
-                                                               LastShowDurationMs(),
-                                                               mTimeoutPrefMs);
-  NS_DispatchToMainThread(workItem);
+
   return true;
 }
 
diff --git a/dom/plugins/ipc/PluginInstanceParent.cpp b/dom/plugins/ipc/PluginInstanceParent.cpp
index abe68b2..37e9988 100644
--- a/dom/plugins/ipc/PluginInstanceParent.cpp
+++ b/dom/plugins/ipc/PluginInstanceParent.cpp
@@ -7,7 +7,6 @@
 #include "mozilla/DebugOnly.h"
 #include <stdint.h> // for intptr_t
 
-#include "mozilla/Telemetry.h"
 #include "PluginInstanceParent.h"
 #include "BrowserStreamParent.h"
 #include "PluginAsyncSurrogate.h"
@@ -178,8 +177,6 @@ PluginInstanceParent::Destroy()
 {
     NPError retval;
     {   // Scope for timer
-        Telemetry::AutoTimer<Telemetry::BLOCKED_ON_PLUGIN_INSTANCE_DESTROY_MS>
-            timer(Module()->GetHistogramKey());
         if (!CallNPP_Destroy(&retval)) {
             retval = NPERR_GENERIC_ERROR;
         }
@@ -1351,9 +1348,6 @@ PluginInstanceParent::NPP_NewStream(NPMIMEType type, NPStream* stream,
         return NPERR_GENERIC_ERROR;
     }
 
-    Telemetry::AutoTimer<Telemetry::BLOCKED_ON_PLUGIN_STREAM_INIT_MS>
-        timer(Module()->GetHistogramKey());
-
     NPError err = NPERR_NO_ERROR;
     if (mParent->IsStartingAsync()) {
         MOZ_ASSERT(mSurrogate);
diff --git a/dom/plugins/ipc/PluginModuleParent.cpp b/dom/plugins/ipc/PluginModuleParent.cpp
index ade7bf6..5637730 100644
--- a/dom/plugins/ipc/PluginModuleParent.cpp
+++ b/dom/plugins/ipc/PluginModuleParent.cpp
@@ -22,7 +22,6 @@
 #include "mozilla/Preferences.h"
 #include "mozilla/ProcessHangMonitor.h"
 #include "mozilla/Services.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/unused.h"
 #include "nsAutoPtr.h"
 #include "nsCRT.h"
@@ -990,11 +989,6 @@ PluginModuleParent::ActorDestroy(ActorDestroyReason why)
 void
 PluginModuleChromeParent::ActorDestroy(ActorDestroyReason why)
 {
-    if (why == AbnormalShutdown) {
-        Telemetry::Accumulate(Telemetry::SUBPROCESS_ABNORMAL_ABORT,
-                              NS_LITERAL_CSTRING("plugin"), 1);
-    }
-
     // We can't broadcast settings changes anymore.
     UnregisterSettingsCallbacks();
 
@@ -1886,9 +1880,6 @@ PluginModuleParent::NPP_New(NPMIMEType pluginType, NPP instance,
          *  We don't accumulate its value until here because the plugin info
          *  is not available until *after* NP_Initialize.
          */
-        Telemetry::Accumulate(Telemetry::BLOCKED_ON_PLUGIN_MODULE_INIT_MS,
-                              GetHistogramKey(),
-                              static_cast<uint32_t>(mTimeBlocked.ToMilliseconds()));
         mTimeBlocked = TimeDuration();
     }
 
@@ -1941,8 +1932,6 @@ PluginModuleParent::NPP_NewInternal(NPMIMEType pluginType, NPP instance,
     }
 
     {   // Scope for timer
-        Telemetry::AutoTimer<Telemetry::BLOCKED_ON_PLUGIN_INSTANCE_INIT_MS>
-            timer(GetHistogramKey());
         if (mIsStartingAsync) {
             MOZ_ASSERT(surrogate);
             surrogate->AsyncCallDeparting();
diff --git a/dom/plugins/ipc/PluginProcessParent.cpp b/dom/plugins/ipc/PluginProcessParent.cpp
index b111130..f33c754 100644
--- a/dom/plugins/ipc/PluginProcessParent.cpp
+++ b/dom/plugins/ipc/PluginProcessParent.cpp
@@ -11,7 +11,6 @@
 
 #include "mozilla/ipc/BrowserProcessSubThread.h"
 #include "mozilla/plugins/PluginMessageUtils.h"
-#include "mozilla/Telemetry.h"
 #include "nsThreadUtils.h"
 
 #if defined(XP_WIN) && defined(MOZ_SANDBOX)
diff --git a/dom/storage/DOMStorage.cpp b/dom/storage/DOMStorage.cpp
index b1e99be..3a6e54f 100644
--- a/dom/storage/DOMStorage.cpp
+++ b/dom/storage/DOMStorage.cpp
@@ -111,13 +111,6 @@ DOMStorage::SetItem(const nsAString& aKey, const nsAString& aData,
     return;
   }
 
-  Telemetry::Accumulate(GetType() == LocalStorage
-      ? Telemetry::LOCALDOMSTORAGE_KEY_SIZE_BYTES
-      : Telemetry::SESSIONDOMSTORAGE_KEY_SIZE_BYTES, aKey.Length());
-  Telemetry::Accumulate(GetType() == LocalStorage
-      ? Telemetry::LOCALDOMSTORAGE_VALUE_SIZE_BYTES
-      : Telemetry::SESSIONDOMSTORAGE_VALUE_SIZE_BYTES, aData.Length());
-
   nsString data;
   bool ok = data.Assign(aData, fallible);
   if (!ok) {
diff --git a/dom/storage/DOMStorageCache.cpp b/dom/storage/DOMStorageCache.cpp
index 67d92d7..024aaff 100644
--- a/dom/storage/DOMStorageCache.cpp
+++ b/dom/storage/DOMStorageCache.cpp
@@ -83,7 +83,6 @@ DOMStorageCache::DOMStorageCache(const nsACString* aScope)
 , mInitialized(false)
 , mPersistent(false)
 , mSessionOnlyDataSetActive(false)
-, mPreloadTelemetryRecorded(false)
 {
   MOZ_COUNT_CTOR(DOMStorageCache);
 }
@@ -172,7 +171,7 @@ DOMStorageCache::DataSet(const DOMStorage* aStorage)
     // Session only data set is demanded but not filled with
     // current data set, copy to session only set now.
 
-    WaitForPreload(Telemetry::LOCALDOMSTORAGE_SESSIONONLY_PRELOAD_BLOCKING_MS);
+    WaitForPreload();
 
     Data& defaultSet = mData[kDefaultSet];
     Data& sessionSet = mData[kSessionSet];
@@ -293,27 +292,8 @@ DOMStorageCache::KeepAlive()
   mKeepAliveTimer.swap(timer);
 }
 
-namespace { // anon
-
-// The AutoTimer provided by telemetry headers is only using static,
-// i.e. compile time known ID, but here we know the ID only at run time.
-// Hence a new class.
-class TelemetryAutoTimer
-{
-public:
-  explicit TelemetryAutoTimer(Telemetry::ID aId)
-    : id(aId), start(TimeStamp::Now()) {}
-  ~TelemetryAutoTimer()
-    { Telemetry::AccumulateDelta_impl<Telemetry::Millisecond>::compute(id, start); }
-private:
-  Telemetry::ID id;
-  const TimeStamp start;
-};
-
-} // anon
-
 void
-DOMStorageCache::WaitForPreload(Telemetry::ID aTelemetryID)
+DOMStorageCache::WaitForPreload()
 {
   if (!mPersistent) {
     return;
@@ -321,21 +301,10 @@ DOMStorageCache::WaitForPreload(Telemetry::ID aTelemetryID)
 
   bool loaded = mLoaded;
 
-  // Telemetry of rates of pending preloads
-  if (!mPreloadTelemetryRecorded) {
-    mPreloadTelemetryRecorded = true;
-    Telemetry::Accumulate(
-      Telemetry::LOCALDOMSTORAGE_PRELOAD_PENDING_ON_FIRST_ACCESS,
-      !loaded);
-  }
-
   if (loaded) {
     return;
   }
 
-  // Measure which operation blocks and for how long
-  TelemetryAutoTimer timer(aTelemetryID);
-
   // If preload already started (i.e. we got some first data, but not all)
   // SyncPreload will just wait for it to finish rather then synchronously
   // read from the database.  It seems to me more optimal.
@@ -352,7 +321,7 @@ nsresult
 DOMStorageCache::GetLength(const DOMStorage* aStorage, uint32_t* aRetval)
 {
   if (Persist(aStorage)) {
-    WaitForPreload(Telemetry::LOCALDOMSTORAGE_GETLENGTH_BLOCKING_MS);
+    WaitForPreload();
     if (NS_FAILED(mLoadResult)) {
       return mLoadResult;
     }
@@ -400,7 +369,7 @@ DOMStorageCache::GetKey(const DOMStorage* aStorage, uint32_t aIndex, nsAString&
   // maybe we need to have a lazily populated key array here or
   // something?
   if (Persist(aStorage)) {
-    WaitForPreload(Telemetry::LOCALDOMSTORAGE_GETKEY_BLOCKING_MS);
+    WaitForPreload();
     if (NS_FAILED(mLoadResult)) {
       return mLoadResult;
     }
@@ -428,7 +397,7 @@ void
 DOMStorageCache::GetKeys(const DOMStorage* aStorage, nsTArray<nsString>& aKeys)
 {
   if (Persist(aStorage)) {
-    WaitForPreload(Telemetry::LOCALDOMSTORAGE_GETALLKEYS_BLOCKING_MS);
+    WaitForPreload();
   }
 
   if (NS_FAILED(mLoadResult)) {
@@ -443,7 +412,7 @@ DOMStorageCache::GetItem(const DOMStorage* aStorage, const nsAString& aKey,
                          nsAString& aRetval)
 {
   if (Persist(aStorage)) {
-    WaitForPreload(Telemetry::LOCALDOMSTORAGE_GETVALUE_BLOCKING_MS);
+    WaitForPreload();
     if (NS_FAILED(mLoadResult)) {
       return mLoadResult;
     }
@@ -465,7 +434,7 @@ DOMStorageCache::SetItem(const DOMStorage* aStorage, const nsAString& aKey,
                          const nsString& aValue, nsString& aOld)
 {
   if (Persist(aStorage)) {
-    WaitForPreload(Telemetry::LOCALDOMSTORAGE_SETVALUE_BLOCKING_MS);
+    WaitForPreload();
     if (NS_FAILED(mLoadResult)) {
       return mLoadResult;
     }
@@ -511,7 +480,7 @@ DOMStorageCache::RemoveItem(const DOMStorage* aStorage, const nsAString& aKey,
                             nsString& aOld)
 {
   if (Persist(aStorage)) {
-    WaitForPreload(Telemetry::LOCALDOMSTORAGE_REMOVEKEY_BLOCKING_MS);
+    WaitForPreload();
     if (NS_FAILED(mLoadResult)) {
       return mLoadResult;
     }
@@ -551,7 +520,7 @@ DOMStorageCache::Clear(const DOMStorage* aStorage)
     // XXX as in case of unload, this is not technically needed now, but
     // after super-scope quota introduction we have to do this.  Get telemetry
     // right now.
-    WaitForPreload(Telemetry::LOCALDOMSTORAGE_CLEAR_BLOCKING_MS);
+    WaitForPreload();
     if (NS_FAILED(mLoadResult)) {
       // When we failed to load data from the database, force delete of the
       // scope data and make use of the storage possible again.
@@ -614,7 +583,7 @@ DOMStorageCache::UnloadItems(uint32_t aUnloadFlags)
     // per-origin isolated quota handling, but when we introduce super-
     // -scope quotas, we have to do this.  Better to start getting
     // telemetry right now.
-    WaitForPreload(Telemetry::LOCALDOMSTORAGE_UNLOAD_BLOCKING_MS);
+    WaitForPreload();
 
     mData[kDefaultSet].mKeys.Clear();
     ProcessUsageDelta(kDefaultSet, -mData[kDefaultSet].mOriginQuotaUsage);
@@ -633,7 +602,7 @@ DOMStorageCache::UnloadItems(uint32_t aUnloadFlags)
 
 #ifdef DOM_STORAGE_TESTS
   if (aUnloadFlags & kTestReload) {
-    WaitForPreload(Telemetry::LOCALDOMSTORAGE_UNLOAD_BLOCKING_MS);
+    WaitForPreload();
 
     mData[kDefaultSet].mKeys.Clear();
     mLoaded = false; // This is only used in testing code
diff --git a/dom/storage/DOMStorageCache.h b/dom/storage/DOMStorageCache.h
index ed072ab..f53d5d5 100644
--- a/dom/storage/DOMStorageCache.h
+++ b/dom/storage/DOMStorageCache.h
@@ -13,7 +13,6 @@
 #include "nsDataHashtable.h"
 #include "nsHashKeys.h"
 #include "mozilla/Monitor.h"
-#include "mozilla/Telemetry.h"
 #include "nsAutoPtr.h"
 
 namespace mozilla {
@@ -154,7 +153,7 @@ private:
 
 private:
   // Synchronously blocks until the cache is fully loaded from the database
-  void WaitForPreload(mozilla::Telemetry::ID aTelemetryID);
+  void WaitForPreload();
 
   // Helper to get one of the 3 data sets (regular, private, session)
   Data& DataSet(const DOMStorage* aStorage);
@@ -222,9 +221,6 @@ private:
   // Drops back to false when session-only data are cleared from chrome.
   bool mSessionOnlyDataSetActive : 1;
 
-  // Whether we have already captured state of the cache preload on our first access.
-  bool mPreloadTelemetryRecorded : 1;
-
   // DOMStorageDBThread on the parent or single process,
   // DOMStorageDBChild on the child process.
   static DOMStorageDBBridge* sDatabase;
diff --git a/dom/storage/DOMStorageDBThread.cpp b/dom/storage/DOMStorageDBThread.cpp
index e5fc7d7..75602b8 100644
--- a/dom/storage/DOMStorageDBThread.cpp
+++ b/dom/storage/DOMStorageDBThread.cpp
@@ -95,8 +95,6 @@ DOMStorageDBThread::Shutdown()
     return NS_ERROR_NOT_INITIALIZED;
   }
 
-  Telemetry::AutoTimer<Telemetry::LOCALDOMSTORAGE_SHUTDOWN_DATABASE_MS> timer;
-
   {
     MonitorAutoLock monitor(mThreadObserver->GetMonitor());
 
@@ -456,8 +454,6 @@ DOMStorageDBThread::OpenDatabaseConnection()
 nsresult
 DOMStorageDBThread::InitDatabase()
 {
-  Telemetry::AutoTimer<Telemetry::LOCALDOMSTORAGE_INIT_DATABASE_MS> timer;
-
   nsresult rv;
 
   // Here we are on the worker thread. This opens the worker connection.
diff --git a/dom/system/mac/CoreLocationLocationProvider.mm b/dom/system/mac/CoreLocationLocationProvider.mm
index 78ebea5..6e52f02 100644
--- a/dom/system/mac/CoreLocationLocationProvider.mm
+++ b/dom/system/mac/CoreLocationLocationProvider.mm
@@ -12,7 +12,6 @@
 #include "CoreLocationLocationProvider.h"
 #include "nsCocoaFeatures.h"
 #include "prtime.h"
-#include "mozilla/Telemetry.h"
 
 #include <CoreLocation/CLError.h>
 #include <CoreLocation/CLLocation.h>
@@ -126,7 +125,6 @@ static const CLLocationAccuracy kDEFAULT_ACCURACY = kCLLocationAccuracyNearestTe
                       PR_Now());
 
   mProvider->Update(geoPosition);
-  Telemetry::Accumulate(Telemetry::GEOLOCATION_OSX_SOURCE_IS_MLS, false);
 }
 @end
 
@@ -147,7 +145,6 @@ CoreLocationLocationProvider::MLSUpdate::Update(nsIDOMGeoPosition *position)
   }
 
   mParentLocationProvider.Update(position);
-  Telemetry::Accumulate(Telemetry::GEOLOCATION_OSX_SOURCE_IS_MLS, true);
   return NS_OK;
 }
 
diff --git a/dom/workers/ServiceWorkerRegistrar.cpp b/dom/workers/ServiceWorkerRegistrar.cpp
index f0a9f77..01b428e 100644
--- a/dom/workers/ServiceWorkerRegistrar.cpp
+++ b/dom/workers/ServiceWorkerRegistrar.cpp
@@ -124,12 +124,6 @@ ServiceWorkerRegistrar::GetRegistrations(
     aValues.AppendElements(mData);
   }
 
-  if (firstTime) {
-    firstTime = false;
-    Telemetry::AccumulateTimeDelta(
-      Telemetry::SERVICE_WORKER_REGISTRATION_LOADING,
-      startTime);
-  }
 }
 
 void
diff --git a/dom/workers/ServiceWorkerRegistrar.h b/dom/workers/ServiceWorkerRegistrar.h
index 5c99d3a..75f4869 100644
--- a/dom/workers/ServiceWorkerRegistrar.h
+++ b/dom/workers/ServiceWorkerRegistrar.h
@@ -6,7 +6,6 @@
 #define mozilla_dom_workers_ServiceWorkerRegistrar_h
 
 #include "mozilla/Monitor.h"
-#include "mozilla/Telemetry.h"
 #include "nsClassHashtable.h"
 #include "nsIObserver.h"
 #include "nsCOMPtr.h"
diff --git a/dom/xul/nsXULPrototypeCache.cpp b/dom/xul/nsXULPrototypeCache.cpp
index ea0558c..0a26c93 100644
--- a/dom/xul/nsXULPrototypeCache.cpp
+++ b/dom/xul/nsXULPrototypeCache.cpp
@@ -27,7 +27,6 @@
 #include "mozilla/Preferences.h"
 #include "mozilla/scache/StartupCache.h"
 #include "mozilla/scache/StartupCacheUtils.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 using namespace mozilla::scache;
@@ -46,11 +45,6 @@ UpdategDisableXULCache()
     gDisableXULCache =
         Preferences::GetBool(kDisableXULCachePref, gDisableXULCache);
 
-    // Sets the flag if the XUL cache is disabled
-    if (gDisableXULCache) {
-        Telemetry::Accumulate(Telemetry::XUL_CACHE_DISABLED, true);
-    }
-    
 }
 
 static void
diff --git a/extensions/auth/nsAuthGSSAPI.cpp b/extensions/auth/nsAuthGSSAPI.cpp
index 29c5548..20df685 100644
--- a/extensions/auth/nsAuthGSSAPI.cpp
+++ b/extensions/auth/nsAuthGSSAPI.cpp
@@ -22,7 +22,6 @@
 #include "nsIPrefBranch.h"
 #include "nsIServiceManager.h"
 #include "nsNativeCharsetUtils.h"
-#include "mozilla/Telemetry.h"
 
 #include "nsAuthGSSAPI.h"
 
@@ -381,16 +380,6 @@ nsAuthGSSAPI::Init(const char *serviceName,
     mServiceName = serviceName;
     mServiceFlags = serviceFlags;
 
-    static bool sTelemetrySent = false;
-    if (!sTelemetrySent) {
-        mozilla::Telemetry::Accumulate(
-            mozilla::Telemetry::NTLM_MODULE_USED_2,
-            serviceFlags & nsIAuthModule::REQ_PROXY_AUTH
-                ? NTLM_MODULE_KERBEROS_PROXY
-                : NTLM_MODULE_KERBEROS_DIRECT);
-        sTelemetrySent = true;
-    }
-
     return NS_OK;
 }
 
diff --git a/extensions/auth/nsAuthSSPI.cpp b/extensions/auth/nsAuthSSPI.cpp
index 27b6815..3078c10 100644
--- a/extensions/auth/nsAuthSSPI.cpp
+++ b/extensions/auth/nsAuthSSPI.cpp
@@ -20,7 +20,6 @@
 #include "nsNetCID.h"
 #include "nsCOMPtr.h"
 #include "nsICryptoHash.h"
-#include "mozilla/Telemetry.h"
 
 #include <windows.h>
 
@@ -275,16 +274,6 @@ nsAuthSSPI::Init(const char *serviceName,
     if (rc != SEC_E_OK)
         return NS_ERROR_UNEXPECTED;
 
-    static bool sTelemetrySent = false;
-    if (!sTelemetrySent) {
-        mozilla::Telemetry::Accumulate(
-            mozilla::Telemetry::NTLM_MODULE_USED_2,
-            serviceFlags & nsIAuthModule::REQ_PROXY_AUTH
-                ? NTLM_MODULE_WIN_API_PROXY
-                : NTLM_MODULE_WIN_API_DIRECT);
-        sTelemetrySent = true;
-    }
-
     LOG(("AcquireCredentialsHandle() succeeded.\n"));
     return NS_OK;
 }
diff --git a/extensions/auth/nsAuthSambaNTLM.cpp b/extensions/auth/nsAuthSambaNTLM.cpp
index 7cbf128..f97640b 100644
--- a/extensions/auth/nsAuthSambaNTLM.cpp
+++ b/extensions/auth/nsAuthSambaNTLM.cpp
@@ -8,7 +8,6 @@
 #include "prenv.h"
 #include "plbase64.h"
 #include "prerror.h"
-#include "mozilla/Telemetry.h"
 
 #include <stdlib.h>
 
@@ -212,16 +211,6 @@ nsAuthSambaNTLM::Init(const char *serviceName,
 {
     NS_ASSERTION(!username && !domain && !password, "unexpected credentials");
 
-    static bool sTelemetrySent = false;
-    if (!sTelemetrySent) {
-        mozilla::Telemetry::Accumulate(
-            mozilla::Telemetry::NTLM_MODULE_USED_2,
-            serviceFlags & nsIAuthModule::REQ_PROXY_AUTH
-                ? NTLM_MODULE_SAMBA_AUTH_PROXY
-                : NTLM_MODULE_SAMBA_AUTH_DIRECT);
-        sTelemetrySent = true;
-    }
-
     return NS_OK;
 }
 
diff --git a/intl/uconv/ucvja/nsJapaneseToUnicode.h b/intl/uconv/ucvja/nsJapaneseToUnicode.h
index 8e3f207..f6dbdf1 100644
--- a/intl/uconv/ucvja/nsJapaneseToUnicode.h
+++ b/intl/uconv/ucvja/nsJapaneseToUnicode.h
@@ -5,7 +5,6 @@
 #ifndef nsShiftJISToUnicode_h__
 #define nsShiftJISToUnicode_h__
 #include "nsUCSupport.h"
-#include "mozilla/Telemetry.h"
 
 class nsShiftJISToUnicode : public nsBasicDecoderSupport
 {
@@ -83,8 +82,6 @@ public:
         mGB2312Decoder = nullptr;
         mEUCKRDecoder = nullptr;
         mISO88597Decoder = nullptr;
-        mozilla::Telemetry::Accumulate(
-          mozilla::Telemetry::DECODER_INSTANTIATED_ISO2022JP, true);
      }
  virtual ~nsISO2022JPToUnicodeV2()
      {
diff --git a/intl/uconv/ucvlatin/nsCP866ToUnicode.cpp b/intl/uconv/ucvlatin/nsCP866ToUnicode.cpp
index 4d4b899..4c2fbf2 100644
--- a/intl/uconv/ucvlatin/nsCP866ToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsCP866ToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsCP866ToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsCP866ToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
   static const uint16_t g_utMappingTable[] = {
 #include "cp866.ut"
   };
-
-  Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_IBM866, true);
   return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                               aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsISO88595ToUnicode.cpp b/intl/uconv/ucvlatin/nsISO88595ToUnicode.cpp
index 23395aa..dad691e 100644
--- a/intl/uconv/ucvlatin/nsISO88595ToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsISO88595ToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsISO88595ToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsISO88595ToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
   static const uint16_t g_utMappingTable[] = {
 #include "8859-5.ut"
   };
-
-  Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_ISO_8859_5, true);
   return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                               aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsKOI8RToUnicode.cpp b/intl/uconv/ucvlatin/nsKOI8RToUnicode.cpp
index 35f77ba..e85e895 100644
--- a/intl/uconv/ucvlatin/nsKOI8RToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsKOI8RToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsKOI8RToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsKOI8RToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
   static const uint16_t g_utMappingTable[] = {
 #include "koi8r.ut"
   };
-
-  Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_KOI8R, true);
   return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                               aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsKOI8UToUnicode.cpp b/intl/uconv/ucvlatin/nsKOI8UToUnicode.cpp
index c5d588a..74911d9 100644
--- a/intl/uconv/ucvlatin/nsKOI8UToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsKOI8UToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsKOI8UToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsKOI8UToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
   static const uint16_t g_utMappingTable[] = {
 #include "koi8u.ut"
   };
-
-  Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_KOI8U, true);
   return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                               aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsMacArabicToUnicode.cpp b/intl/uconv/ucvlatin/nsMacArabicToUnicode.cpp
index 1a9950d..198a36b 100644
--- a/intl/uconv/ucvlatin/nsMacArabicToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsMacArabicToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsMacArabicToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsMacArabicToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
    static const uint16_t g_utMappingTable[] = {
 #include "macarabic.ut"
    };
-
-   Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_MACARABIC, true);
    return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                                aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsMacCEToUnicode.cpp b/intl/uconv/ucvlatin/nsMacCEToUnicode.cpp
index 458d0f5..a286758 100644
--- a/intl/uconv/ucvlatin/nsMacCEToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsMacCEToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsMacCEToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsMacCEToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
   static const uint16_t g_MacCEMappingTable[] = {
 #include "macce.ut"
   };
-
-  Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_MACCE, true);
   return CreateOneByteDecoder((uMappingTable*) &g_MacCEMappingTable,
                             aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsMacCroatianToUnicode.cpp b/intl/uconv/ucvlatin/nsMacCroatianToUnicode.cpp
index 9799ac9..4941be5 100644
--- a/intl/uconv/ucvlatin/nsMacCroatianToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsMacCroatianToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsMacCroatianToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsMacCroatianToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
   static const uint16_t g_utMappingTable[] = {
 #include "maccroat.ut"
   };
-
-  Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_MACCROATIAN, true);
   return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                               aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsMacCyrillicToUnicode.cpp b/intl/uconv/ucvlatin/nsMacCyrillicToUnicode.cpp
index edbf604..bbc914e 100644
--- a/intl/uconv/ucvlatin/nsMacCyrillicToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsMacCyrillicToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsMacCyrillicToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsMacCyrillicToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
   static const uint16_t g_utMappingTable[] = {
 #include "maccyril.ut"
   };
-
-  Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_MACCYRILLIC, true);
   return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                               aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsMacDevanagariToUnicode.cpp b/intl/uconv/ucvlatin/nsMacDevanagariToUnicode.cpp
index 3c1cae7..b185008 100644
--- a/intl/uconv/ucvlatin/nsMacDevanagariToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsMacDevanagariToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsMacDevanagariToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsMacDevanagariToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
    static const uint16_t g_utMappingTable[] = {
 #include "macdevanaga.ut"
    };
-
-   Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_MACDEVANAGARI, true);
    return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                                aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsMacFarsiToUnicode.cpp b/intl/uconv/ucvlatin/nsMacFarsiToUnicode.cpp
index 1e7e291..000240e 100644
--- a/intl/uconv/ucvlatin/nsMacFarsiToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsMacFarsiToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsMacFarsiToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsMacFarsiToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
    static const uint16_t g_utMappingTable[] = {
 #include "macfarsi.ut"
    };
-
-   Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_MACFARSI, true);
    return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                                aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsMacGreekToUnicode.cpp b/intl/uconv/ucvlatin/nsMacGreekToUnicode.cpp
index 3f90811..3c84d13 100644
--- a/intl/uconv/ucvlatin/nsMacGreekToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsMacGreekToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsMacGreekToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsMacGreekToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
   static const uint16_t g_MacGreekMappingTable[] = {
 #include "macgreek.ut"
   };
-
-  Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_MACGREEK, true);
   return CreateOneByteDecoder((uMappingTable*) &g_MacGreekMappingTable,
                             aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsMacGurmukhiToUnicode.cpp b/intl/uconv/ucvlatin/nsMacGurmukhiToUnicode.cpp
index d6b3a88..49dd152 100644
--- a/intl/uconv/ucvlatin/nsMacGurmukhiToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsMacGurmukhiToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsMacGurmukhiToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsMacGurmukhiToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
    static const uint16_t g_utMappingTable[] = {
 #include "macgurmukhi.ut"
    };
-
-   Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_MACGURMUKHI, true);
    return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                                aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsMacHebrewToUnicode.cpp b/intl/uconv/ucvlatin/nsMacHebrewToUnicode.cpp
index f19d82c..99b4b5e 100644
--- a/intl/uconv/ucvlatin/nsMacHebrewToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsMacHebrewToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsMacHebrewToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsMacHebrewToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
    static const uint16_t g_utMappingTable[] = {
 #include "machebrew.ut"
    };
-
-   Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_MACHEBREW, true);
    return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                                aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsMacIcelandicToUnicode.cpp b/intl/uconv/ucvlatin/nsMacIcelandicToUnicode.cpp
index 00cff75..94ba59b 100644
--- a/intl/uconv/ucvlatin/nsMacIcelandicToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsMacIcelandicToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsMacIcelandicToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsMacIcelandicToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
   static const uint16_t g_utMappingTable[] = {
 #include "macicela.ut"
   };
-
-  Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_MACICELANDIC, true);
   return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                               aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsMacRomanianToUnicode.cpp b/intl/uconv/ucvlatin/nsMacRomanianToUnicode.cpp
index 96c24de..d1e41fc 100644
--- a/intl/uconv/ucvlatin/nsMacRomanianToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsMacRomanianToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsMacRomanianToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsMacRomanianToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
   static const uint16_t g_utMappingTable[] = {
 #include "macro.ut"
   };
-
-  Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_MACROMANIAN, true);
   return CreateOneByteDecoder((uMappingTable*) &g_utMappingTable,
                               aOuter, aIID, aResult);
 }
diff --git a/intl/uconv/ucvlatin/nsMacTurkishToUnicode.cpp b/intl/uconv/ucvlatin/nsMacTurkishToUnicode.cpp
index 86d2d1a..11278a8 100644
--- a/intl/uconv/ucvlatin/nsMacTurkishToUnicode.cpp
+++ b/intl/uconv/ucvlatin/nsMacTurkishToUnicode.cpp
@@ -5,7 +5,6 @@
 
 #include "nsUCConstructors.h"
 #include "nsMacTurkishToUnicode.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 
@@ -19,8 +18,6 @@ nsMacTurkishToUnicodeConstructor(nsISupports *aOuter, REFNSIID aIID,
   static const uint16_t g_MacTurkishMappingTable[] = {
 #include "macturki.ut"
   };
-
-  Telemetry::Accumulate(Telemetry::DECODER_INSTANTIATED_MACTURKISH, true);
   return CreateOneByteDecoder((uMappingTable*) &g_MacTurkishMappingTable,
                             aOuter, aIID, aResult);
 }
diff --git a/js/public/GCAPI.h b/js/public/GCAPI.h
index d3ae457..2721d67 100644
--- a/js/public/GCAPI.h
+++ b/js/public/GCAPI.h
@@ -110,14 +110,6 @@ enum Reason {
 #undef MAKE_REASON
     NO_REASON,
     NUM_REASONS,
-
-    /*
-     * For telemetry, we want to keep a fixed max bucket size over time so we
-     * don't have to switch histograms. 100 is conservative; as of this writing
-     * there are 52. But the cost of extra buckets seems to be low while the
-     * cost of switching histograms is high.
-     */
-    NUM_TELEMETRY_REASONS = 100
 };
 
 } /* namespace gcreason */
diff --git a/js/src/frontend/Parser.cpp b/js/src/frontend/Parser.cpp
index d6cdea9..0719d9c 100644
--- a/js/src/frontend/Parser.cpp
+++ b/js/src/frontend/Parser.cpp
@@ -2513,7 +2513,6 @@ Parser<ParseHandler>::functionArgsAndBodyGeneric(Node pn, HandleFunction fun, Fu
 
         if (kind != Arrow) {
 #if JS_HAS_EXPR_CLOSURES
-            addTelemetry(JSCompartment::DeprecatedExpressionClosure);
 #else
             report(ParseError, false, null(), JSMSG_CURLY_BEFORE_BODY);
             return false;
@@ -4436,7 +4435,6 @@ Parser<FullParseHandler>::forStatement()
         if (matched) {
             iflags = JSITER_FOREACH;
             isForEach = true;
-            addTelemetry(JSCompartment::DeprecatedForEach);
             if (versionNumber() < JSVERSION_LATEST) {
                 if (!report(ParseWarning, pc->sc->strict, null(), JSMSG_DEPRECATED_FOR_EACH))
                     return null();
@@ -4703,7 +4701,6 @@ Parser<FullParseHandler>::forStatement()
                  */
                 if (!isForEach && headKind == PNK_FORIN) {
                     iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
-                    addTelemetry(JSCompartment::DeprecatedDestructuringForIn);
                 }
             }
             break;
@@ -5291,7 +5288,6 @@ Parser<ParseHandler>::yieldExpression()
         }
 
         pc->sc->asFunctionBox()->setGeneratorKind(LegacyGenerator);
-        addTelemetry(JSCompartment::DeprecatedLegacyGenerator);
 
         if (pc->funHasReturnExpr) {
             /* As in Python (see PEP-255), disallow return v; in generators. */
@@ -6693,7 +6689,6 @@ Parser<FullParseHandler>::legacyComprehensionTail(ParseNode* bodyExpr, unsigned
                 return null();
             if (matched) {
                 pn2->pn_iflags |= JSITER_FOREACH;
-                addTelemetry(JSCompartment::DeprecatedForEach);
                 if (versionNumber() < JSVERSION_LATEST) {
                     if (!report(ParseWarning, pc->sc->strict, pn2, JSMSG_DEPRECATED_FOR_EACH))
                         return null();
@@ -8258,16 +8253,6 @@ Parser<ParseHandler>::exprInParens()
     return pn;
 }
 
-template <typename ParseHandler>
-void
-Parser<ParseHandler>::addTelemetry(JSCompartment::DeprecatedLanguageExtension e)
-{
-    JSContext* cx = context->maybeJSContext();
-    if (!cx)
-        return;
-    cx->compartment()->addTelemetry(getFilename(), e);
-}
-
 template class Parser<FullParseHandler>;
 template class Parser<SyntaxParseHandler>;
 
diff --git a/js/src/frontend/Parser.h b/js/src/frontend/Parser.h
index 825fdc7..842e6f3 100644
--- a/js/src/frontend/Parser.h
+++ b/js/src/frontend/Parser.h
@@ -693,8 +693,6 @@ class Parser : private JS::AutoGCRooter, public StrictModeGetter
 
     bool asmJS(Node list);
 
-    void addTelemetry(JSCompartment::DeprecatedLanguageExtension e);
-
     friend class LegacyCompExprTransplanter;
     friend struct BindData<ParseHandler>;
 };
diff --git a/js/src/gc/Statistics.cpp b/js/src/gc/Statistics.cpp
index 89ed439..f013ebc 100644
--- a/js/src/gc/Statistics.cpp
+++ b/js/src/gc/Statistics.cpp
@@ -236,13 +236,6 @@ class gcstats::StatisticsSerializer
     }
 };
 
-/*
- * If this fails, then you can either delete this assertion and allow all
- * larger-numbered reasons to pile up in the last telemetry bucket, or switch
- * to GC_REASON_3 and bump the max value.
- */
-JS_STATIC_ASSERT(JS::gcreason::NUM_TELEMETRY_REASONS >= JS::gcreason::NUM_REASONS);
-
 const char*
 js::gcstats::ExplainInvocationKind(JSGCInvocationKind gckind)
 {
@@ -959,23 +952,11 @@ Statistics::endGC()
     int64_t sccTotal, sccLongest;
     sccDurations(&sccTotal, &sccLongest);
 
-    runtime->addTelemetry(JS_TELEMETRY_GC_IS_COMPARTMENTAL, !zoneStats.isCollectingAllZones());
-    runtime->addTelemetry(JS_TELEMETRY_GC_MS, t(total));
-    runtime->addTelemetry(JS_TELEMETRY_GC_MAX_PAUSE_MS, t(longest));
     int64_t markTotal = SumPhase(PHASE_MARK, phaseTimes);
     int64_t markRootsTotal = SumPhase(PHASE_MARK_ROOTS, phaseTimes);
-    runtime->addTelemetry(JS_TELEMETRY_GC_MARK_MS, t(markTotal));
-    runtime->addTelemetry(JS_TELEMETRY_GC_SWEEP_MS, t(phaseTimes[PHASE_DAG_NONE][PHASE_SWEEP]));
-    runtime->addTelemetry(JS_TELEMETRY_GC_MARK_ROOTS_MS, t(markRootsTotal));
-    runtime->addTelemetry(JS_TELEMETRY_GC_MARK_GRAY_MS, t(phaseTimes[PHASE_DAG_NONE][PHASE_SWEEP_MARK_GRAY]));
-    runtime->addTelemetry(JS_TELEMETRY_GC_NON_INCREMENTAL, !!nonincrementalReason);
-    runtime->addTelemetry(JS_TELEMETRY_GC_INCREMENTAL_DISABLED, !runtime->gc.isIncrementalGCAllowed());
-    runtime->addTelemetry(JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS, t(sccTotal));
-    runtime->addTelemetry(JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS, t(sccLongest));
 
     if (!aborted) {
         double mmu50 = computeMMU(50 * PRMJ_USEC_PER_MSEC);
-        runtime->addTelemetry(JS_TELEMETRY_GC_MMU_50, mmu50 * 100);
     }
 
     if (fp)
@@ -1007,8 +988,6 @@ Statistics::beginSlice(const ZoneGCStats& zoneStats, JSGCInvocationKind gckind,
         return;
     }
 
-    runtime->addTelemetry(JS_TELEMETRY_GC_REASON, reason);
-
     // Slice callbacks should only fire for the outermost level
     if (++gcDepth == 1) {
         bool wasFullGC = zoneStats.isCollectingAllZones();
@@ -1025,8 +1004,6 @@ Statistics::endSlice()
         slices.back().end = PRMJ_Now();
         slices.back().endFaults = GetPageFaultCount();
 
-        runtime->addTelemetry(JS_TELEMETRY_GC_SLICE_MS, t(slices.back().end - slices.back().start));
-        runtime->addTelemetry(JS_TELEMETRY_GC_RESET, !!slices.back().resetReason);
     }
 
     bool last = !runtime->gc.isIncrementalGCInProgress();
diff --git a/js/src/jscompartment.cpp b/js/src/jscompartment.cpp
index 832af00..3fb40bf 100644
--- a/js/src/jscompartment.cpp
+++ b/js/src/jscompartment.cpp
@@ -75,15 +75,12 @@ JSCompartment::JSCompartment(Zone* zone, const JS::CompartmentOptions& options =
     maybeAlive(true),
     jitCompartment_(nullptr)
 {
-    PodArrayZero(sawDeprecatedLanguageExtension);
     runtime_->numCompartments++;
     MOZ_ASSERT_IF(options.mergeable(), options.invisibleToDebugger());
 }
 
 JSCompartment::~JSCompartment()
 {
-    reportTelemetry();
-
     js_delete(jitCompartment_);
     js_delete(watchpointMap);
     js_delete(scriptCountsMap);
@@ -857,30 +854,3 @@ JSCompartment::addSizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf,
     *regexpCompartment += regExps.sizeOfExcludingThis(mallocSizeOf);
     *savedStacksSet += savedStacks_.sizeOfExcludingThis(mallocSizeOf);
 }
-
-void
-JSCompartment::reportTelemetry()
-{
-    // Only report telemetry for web content, not add-ons or chrome JS.
-    if (addonId || isSystem)
-        return;
-
-    // Hazard analysis can't tell that the telemetry callbacks don't GC.
-    JS::AutoSuppressGCAnalysis nogc;
-
-    // Call back into Firefox's Telemetry reporter.
-    for (size_t i = 0; i < DeprecatedLanguageExtensionCount; i++) {
-        if (sawDeprecatedLanguageExtension[i])
-            runtime_->addTelemetry(JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT, i);
-    }
-}
-
-void
-JSCompartment::addTelemetry(const char* filename, DeprecatedLanguageExtension e)
-{
-    // Only report telemetry for web content, not add-ons or chrome JS.
-    if (addonId || isSystem || !filename || strncmp(filename, "http", 4) != 0)
-        return;
-
-    sawDeprecatedLanguageExtension[e] = true;
-}
diff --git a/js/src/jscompartment.h b/js/src/jscompartment.h
index dcf26c8..797cadc 100644
--- a/js/src/jscompartment.h
+++ b/js/src/jscompartment.h
@@ -550,15 +550,6 @@ struct JSCompartment
         DeprecatedNoSuchMethod = 6,         // JS 1.7+
         DeprecatedLanguageExtensionCount
     };
-
-  private:
-    // Used for collecting telemetry on SpiderMonkey's deprecated language extensions.
-    bool sawDeprecatedLanguageExtension[DeprecatedLanguageExtensionCount];
-
-    void reportTelemetry();
-
-  public:
-    void addTelemetry(const char* filename, DeprecatedLanguageExtension e);
 };
 
 inline bool
diff --git a/js/src/jsexn.cpp b/js/src/jsexn.cpp
index 06b2004..7e76171 100644
--- a/js/src/jsexn.cpp
+++ b/js/src/jsexn.cpp
@@ -733,13 +733,6 @@ ErrorReport::init(JSContext* cx, HandleValue exn)
             if (!filename) {
                 filename = "FILE_NOT_FOUND";
             }
-            char histogramKey[64];
-            JS_snprintf(histogramKey, sizeof(histogramKey),
-                        "%s %s %u",
-                        addonIdChars.get(),
-                        filename,
-                        (reportp ? reportp->lineno : 0) );
-            cx->runtime()->addTelemetry(JS_TELEMETRY_ADDON_EXCEPTIONS, 1, histogramKey);
         }
     }
     // Be careful not to invoke ToString if we've already successfully extracted
diff --git a/js/src/jsfriendapi.cpp b/js/src/jsfriendapi.cpp
index bdf39f1..f9e773b 100644
--- a/js/src/jsfriendapi.cpp
+++ b/js/src/jsfriendapi.cpp
@@ -605,12 +605,6 @@ js::StringToLinearStringSlow(JSContext* cx, JSString* str)
     return str->ensureLinear(cx);
 }
 
-JS_FRIEND_API(void)
-JS_SetAccumulateTelemetryCallback(JSRuntime* rt, JSAccumulateTelemetryDataCallback callback)
-{
-    rt->setTelemetryCallback(rt, callback);
-}
-
 JS_FRIEND_API(JSObject*)
 JS_CloneObject(JSContext* cx, HandleObject obj, HandleObject protoArg, HandleObject parent)
 {
diff --git a/js/src/jsfriendapi.h b/js/src/jsfriendapi.h
index 3081cd1..c06d0db 100644
--- a/js/src/jsfriendapi.h
+++ b/js/src/jsfriendapi.h
@@ -93,32 +93,6 @@ JS_IsDeadWrapper(JSObject* obj);
 extern JS_FRIEND_API(void)
 JS_TraceShapeCycleCollectorChildren(JSTracer* trc, JS::GCCellPtr shape);
 
-enum {
-    JS_TELEMETRY_GC_REASON,
-    JS_TELEMETRY_GC_IS_COMPARTMENTAL,
-    JS_TELEMETRY_GC_MS,
-    JS_TELEMETRY_GC_MAX_PAUSE_MS,
-    JS_TELEMETRY_GC_MARK_MS,
-    JS_TELEMETRY_GC_SWEEP_MS,
-    JS_TELEMETRY_GC_MARK_ROOTS_MS,
-    JS_TELEMETRY_GC_MARK_GRAY_MS,
-    JS_TELEMETRY_GC_SLICE_MS,
-    JS_TELEMETRY_GC_MMU_50,
-    JS_TELEMETRY_GC_RESET,
-    JS_TELEMETRY_GC_INCREMENTAL_DISABLED,
-    JS_TELEMETRY_GC_NON_INCREMENTAL,
-    JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS,
-    JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS,
-    JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT,
-    JS_TELEMETRY_ADDON_EXCEPTIONS
-};
-
-typedef void
-(*JSAccumulateTelemetryDataCallback)(int id, uint32_t sample, const char* key);
-
-extern JS_FRIEND_API(void)
-JS_SetAccumulateTelemetryCallback(JSRuntime* rt, JSAccumulateTelemetryDataCallback callback);
-
 extern JS_FRIEND_API(JSPrincipals*)
 JS_GetCompartmentPrincipals(JSCompartment* compartment);
 
diff --git a/js/src/vm/Interpreter.cpp b/js/src/vm/Interpreter.cpp
index 690b381..f4eb86a 100644
--- a/js/src/vm/Interpreter.cpp
+++ b/js/src/vm/Interpreter.cpp
@@ -200,11 +200,6 @@ NoSuchMethod(JSContext* cx, unsigned argc, Value* vp)
     bool ok = Invoke(cx, args);
     vp[0] = args.rval();
 
-    if (JSScript* script = cx->currentScript()) {
-        const char* filename = script->filename();
-        cx->compartment()->addTelemetry(filename, JSCompartment::DeprecatedNoSuchMethod);
-    }
-
     return ok;
 }
 
diff --git a/js/src/vm/Runtime.cpp b/js/src/vm/Runtime.cpp
index 840f12f..003a703 100644
--- a/js/src/vm/Runtime.cpp
+++ b/js/src/vm/Runtime.cpp
@@ -124,7 +124,6 @@ JSRuntime::JSRuntime(JSRuntime* parentRuntime)
     asmJSActivationStack_(nullptr),
     parentRuntime(parentRuntime),
     interrupt_(false),
-    telemetryCallback(nullptr),
     handlingSignal(false),
     interruptCallback(nullptr),
     exclusiveAccessLock(nullptr),
@@ -447,19 +446,6 @@ JSRuntime::~JSRuntime()
 }
 
 void
-JSRuntime::addTelemetry(int id, uint32_t sample, const char* key)
-{
-    if (telemetryCallback)
-        (*telemetryCallback)(id, sample, key);
-}
-
-void
-JSRuntime::setTelemetryCallback(JSRuntime* rt, JSAccumulateTelemetryDataCallback callback)
-{
-    rt->telemetryCallback = callback;
-}
-
-void
 NewObjectCache::clearNurseryObjects(JSRuntime* rt)
 {
     for (unsigned i = 0; i < mozilla::ArrayLength(entries); ++i) {
diff --git a/js/src/vm/Runtime.h b/js/src/vm/Runtime.h
index 2e2a545..479c77d 100644
--- a/js/src/vm/Runtime.h
+++ b/js/src/vm/Runtime.h
@@ -688,15 +688,7 @@ struct JSRuntime : public JS::shadow::Runtime,
   private:
     mozilla::Atomic<uint32_t, mozilla::Relaxed> interrupt_;
 
-    /* Call this to accumulate telemetry data. */
-    JSAccumulateTelemetryDataCallback telemetryCallback;
   public:
-    // Accumulates data for Firefox telemetry. |id| is the ID of a JS_TELEMETRY_*
-    // histogram. |key| provides an additional key to identify the histogram.
-    // |sample| is the data to add to the histogram.
-    void addTelemetry(int id, uint32_t sample, const char* key = nullptr);
-
-    void setTelemetryCallback(JSRuntime* rt, JSAccumulateTelemetryDataCallback callback);
 
     enum InterruptMode {
         RequestInterruptUrgent,
diff --git a/js/xpconnect/idl/xpccomponents.idl b/js/xpconnect/idl/xpccomponents.idl
index 26c34c4..79cc671 100644
--- a/js/xpconnect/idl/xpccomponents.idl
+++ b/js/xpconnect/idl/xpccomponents.idl
@@ -620,9 +620,6 @@ interface nsIXPCComponents_Utils : nsISupports
       */
     PRTime getWatchdogTimestamp(in AString aCategory);
 
-    [implicit_jscontext]
-    jsval getJSEngineTelemetryValue();
-
     /*
      * Clone an object into a scope.
      * The 3rd argument is an optional options object:
diff --git a/js/xpconnect/src/XPCComponents.cpp b/js/xpconnect/src/XPCComponents.cpp
index 8b635a0..a8abfda 100644
--- a/js/xpconnect/src/XPCComponents.cpp
+++ b/js/xpconnect/src/XPCComponents.cpp
@@ -3405,29 +3405,6 @@ nsXPCComponents_Utils::GetWatchdogTimestamp(const nsAString& aCategory, PRTime*
     return NS_OK;
 }
 
-NS_IMETHODIMP
-nsXPCComponents_Utils::GetJSEngineTelemetryValue(JSContext* cx, MutableHandleValue rval)
-{
-    RootedObject obj(cx, JS_NewPlainObject(cx));
-    if (!obj)
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    unsigned attrs = JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT;
-
-    size_t i = JS_SetProtoCalled(cx);
-    RootedValue v(cx, DoubleValue(i));
-    if (!JS_DefineProperty(cx, obj, "setProto", v, attrs))
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    i = JS_GetCustomIteratorCount(cx);
-    v.setDouble(i);
-    if (!JS_DefineProperty(cx, obj, "customIter", v, attrs))
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    rval.setObject(*obj);
-    return NS_OK;
-}
-
 bool
 xpc::CloneInto(JSContext* aCx, HandleValue aValue, HandleValue aScope,
                HandleValue aOptions, MutableHandleValue aCloned)
diff --git a/js/xpconnect/src/XPCJSRuntime.cpp b/js/xpconnect/src/XPCJSRuntime.cpp
index 070d6f3..75df53c 100644
--- a/js/xpconnect/src/XPCJSRuntime.cpp
+++ b/js/xpconnect/src/XPCJSRuntime.cpp
@@ -24,7 +24,6 @@
 #include "nsPIDOMWindow.h"
 #include "nsPrintfCString.h"
 #include "mozilla/Preferences.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/Services.h"
 
 #include "nsContentUtils.h"
@@ -219,10 +218,7 @@ class AsyncFreeSnowWhite : public nsRunnable
 public:
   NS_IMETHOD Run()
   {
-      TimeStamp start = TimeStamp::Now();
       bool hadSnowWhiteObjects = nsCycleCollector_doDeferredDeletion();
-      Telemetry::Accumulate(Telemetry::CYCLE_COLLECTOR_ASYNC_SNOW_WHITE_FREEING,
-                            uint32_t((TimeStamp::Now() - start).ToMilliseconds()));
       if (hadSnowWhiteObjects && !mContinuation) {
           mContinuation = true;
           if (NS_FAILED(NS_DispatchToCurrentThread(this))) {
@@ -3058,66 +3054,6 @@ JSSizeOfTab(JSObject* objArg, size_t* jsObjectsSize, size_t* jsStringsSize,
 } // namespace xpc
 
 static void
-AccumulateTelemetryCallback(int id, uint32_t sample, const char* key)
-{
-    switch (id) {
-      case JS_TELEMETRY_GC_REASON:
-        Telemetry::Accumulate(Telemetry::GC_REASON_2, sample);
-        break;
-      case JS_TELEMETRY_GC_IS_COMPARTMENTAL:
-        Telemetry::Accumulate(Telemetry::GC_IS_COMPARTMENTAL, sample);
-        break;
-      case JS_TELEMETRY_GC_MS:
-        Telemetry::Accumulate(Telemetry::GC_MS, sample);
-        break;
-      case JS_TELEMETRY_GC_MAX_PAUSE_MS:
-        Telemetry::Accumulate(Telemetry::GC_MAX_PAUSE_MS, sample);
-        break;
-      case JS_TELEMETRY_GC_MARK_MS:
-        Telemetry::Accumulate(Telemetry::GC_MARK_MS, sample);
-        break;
-      case JS_TELEMETRY_GC_SWEEP_MS:
-        Telemetry::Accumulate(Telemetry::GC_SWEEP_MS, sample);
-        break;
-      case JS_TELEMETRY_GC_MARK_ROOTS_MS:
-        Telemetry::Accumulate(Telemetry::GC_MARK_ROOTS_MS, sample);
-        break;
-      case JS_TELEMETRY_GC_MARK_GRAY_MS:
-        Telemetry::Accumulate(Telemetry::GC_MARK_GRAY_MS, sample);
-        break;
-      case JS_TELEMETRY_GC_SLICE_MS:
-        Telemetry::Accumulate(Telemetry::GC_SLICE_MS, sample);
-        break;
-      case JS_TELEMETRY_GC_MMU_50:
-        Telemetry::Accumulate(Telemetry::GC_MMU_50, sample);
-        break;
-      case JS_TELEMETRY_GC_RESET:
-        Telemetry::Accumulate(Telemetry::GC_RESET, sample);
-        break;
-      case JS_TELEMETRY_GC_INCREMENTAL_DISABLED:
-        Telemetry::Accumulate(Telemetry::GC_INCREMENTAL_DISABLED, sample);
-        break;
-      case JS_TELEMETRY_GC_NON_INCREMENTAL:
-        Telemetry::Accumulate(Telemetry::GC_NON_INCREMENTAL, sample);
-        break;
-      case JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS:
-        Telemetry::Accumulate(Telemetry::GC_SCC_SWEEP_TOTAL_MS, sample);
-        break;
-      case JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS:
-        Telemetry::Accumulate(Telemetry::GC_SCC_SWEEP_MAX_PAUSE_MS, sample);
-        break;
-      case JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT:
-        Telemetry::Accumulate(Telemetry::JS_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT, sample);
-        break;
-      case JS_TELEMETRY_ADDON_EXCEPTIONS:
-        Telemetry::Accumulate(Telemetry::JS_TELEMETRY_ADDON_EXCEPTIONS, nsDependentCString(key), sample);
-        break;
-      default:
-        MOZ_ASSERT_UNREACHABLE("Unexpected JS_TELEMETRY id");
-    }
-}
-
-static void
 CompartmentNameCallback(JSRuntime* rt, JSCompartment* comp,
                         char* buf, size_t bufsize)
 {
@@ -3382,7 +3318,6 @@ XPCJSRuntime::XPCJSRuntime(nsXPConnect* aXPConnect)
     JS_AddWeakPointerCallback(runtime, WeakPointerCallback, this);
     JS_SetWrapObjectCallbacks(runtime, &WrapObjectCallbacks);
     js::SetPreserveWrapperCallback(runtime, PreserveWrapper);
-    JS_SetAccumulateTelemetryCallback(runtime, AccumulateTelemetryCallback);
     js::SetDefaultJSContextCallback(runtime, DefaultJSContextCallback);
     js::SetActivityCallback(runtime, ActivityCallback, this);
     js::SetCTypesActivityCallback(runtime, CTypesActivityCallback);
diff --git a/js/xpconnect/src/XPCShellImpl.cpp b/js/xpconnect/src/XPCShellImpl.cpp
index 816cb90..c0a6cd6 100644
--- a/js/xpconnect/src/XPCShellImpl.cpp
+++ b/js/xpconnect/src/XPCShellImpl.cpp
@@ -1239,11 +1239,6 @@ XRE_XPCShellMain(int argc, char** argv, char** envp)
 
     NS_LogInit();
 
-    // A initializer to initialize histogram collection
-    // used by telemetry.
-    UniquePtr<base::StatisticsRecorder> telStats =
-       MakeUnique<base::StatisticsRecorder>();
-
     nsCOMPtr<nsIFile> appFile;
     rv = XRE_GetBinaryPath(argv[0], getter_AddRefs(appFile));
     if (NS_FAILED(rv)) {
@@ -1522,7 +1517,6 @@ XRE_XPCShellMain(int argc, char** argv, char** envp)
     bogus = nullptr;
 #endif
 
-    telStats = nullptr;
     appDir = nullptr;
     appFile = nullptr;
     dirprovider.ClearGREDirs();
diff --git a/layout/base/nsCSSRendering.cpp b/layout/base/nsCSSRendering.cpp
index c8ff2a6..34dd859 100644
--- a/layout/base/nsCSSRendering.cpp
+++ b/layout/base/nsCSSRendering.cpp
@@ -52,7 +52,6 @@
 #include "nsCSSRenderingBorders.h"
 #include "mozilla/css/ImageLoader.h"
 #include "ImageContainer.h"
-#include "mozilla/Telemetry.h"
 #include "gfxUtils.h"
 #include "gfxColor.h"
 #include "gfxGradientCache.h"
@@ -2365,11 +2364,6 @@ nsCSSRendering::PaintGradient(nsPresContext* aPresContext,
   PROFILER_LABEL("nsCSSRendering", "PaintGradient",
     js::ProfileEntry::Category::GRAPHICS);
 
-  Telemetry::AutoTimer<Telemetry::GRADIENT_DURATION, Telemetry::Microsecond> gradientTimer;
-  if (aDest.IsEmpty() || aFillArea.IsEmpty()) {
-    return;
-  }
-
   gfxContext *ctx = aRenderingContext.ThebesContext();
   nscoord appUnitsPerDevPixel = aPresContext->AppUnitsPerDevPixel();
   gfxSize srcSize = gfxSize(gfxFloat(aIntrinsicSize.width)/appUnitsPerDevPixel,
diff --git a/layout/base/nsDocumentViewer.cpp b/layout/base/nsDocumentViewer.cpp
index 157db20..5c61d96 100644
--- a/layout/base/nsDocumentViewer.cpp
+++ b/layout/base/nsDocumentViewer.cpp
@@ -121,7 +121,6 @@ static const char sPrintOptionsContractID[] =
 #include <stdio.h>
 
 #include "mozilla/dom/Element.h"
-#include "mozilla/Telemetry.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
@@ -1239,7 +1238,6 @@ nsDocumentViewer::PermitUnloadInternal(bool aCallerClosesWindow,
 
       nsAutoSyncOperation sync(mDocument);
       mInPermitUnloadPrompt = true;
-      mozilla::Telemetry::Accumulate(mozilla::Telemetry::ONBEFOREUNLOAD_PROMPT_COUNT, 1);
       rv = prompt->ConfirmEx(title, message, buttonFlags,
                              leaveLabel, stayLabel, nullptr, nullptr,
                              &dummy, &buttonPressed);
@@ -1254,15 +1252,12 @@ nsDocumentViewer::PermitUnloadInternal(bool aCallerClosesWindow,
       // XXX: Are there other cases where prompts can abort? Is it ok to
       //      prevent unloading the page in those cases?
       if (NS_FAILED(rv)) {
-        mozilla::Telemetry::Accumulate(mozilla::Telemetry::ONBEFOREUNLOAD_PROMPT_ACTION, 2);
         *aPermitUnload = false;
         return NS_OK;
       }
 
       // Button 0 == leave, button 1 == stay
       *aPermitUnload = (buttonPressed == 0);
-      mozilla::Telemetry::Accumulate(mozilla::Telemetry::ONBEFOREUNLOAD_PROMPT_ACTION,
-        (*aPermitUnload ? 1 : 0));
       // If the user decided to go ahead, make sure not to prompt the user again
       // by toggling the internal prompting bool to false:
       if (*aPermitUnload) {
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
index 88f3eb3..57866b0 100644
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -94,7 +94,6 @@
 #include "nsFrameSelection.h"
 #include "FrameLayerBuilder.h"
 #include "mozilla/layers/APZCTreeManager.h"
-#include "mozilla/Telemetry.h"
 
 #ifdef MOZ_XUL
 #include "nsXULPopupManager.h"
@@ -3114,8 +3113,6 @@ nsLayoutUtils::PaintFrame(nsRenderingContext* aRenderingContext, nsIFrame* aFram
   }
 
   builder.LeavePresShell(aFrame);
-  Telemetry::AccumulateTimeDelta(Telemetry::PAINT_BUILD_DISPLAYLIST_TIME,
-                                 startBuildDisplayList);
 
   if (builder.GetHadToIgnorePaintSuppression()) {
     willFlushRetainedLayers = true;
@@ -3193,11 +3190,8 @@ nsLayoutUtils::PaintFrame(nsRenderingContext* aRenderingContext, nsIFrame* aFram
     flags |= nsDisplayList::PAINT_COMPRESSED;
   }
 
-  TimeStamp paintStart = TimeStamp::Now();
   nsRefPtr<LayerManager> layerManager =
     list.PaintRoot(&builder, aRenderingContext, flags);
-  Telemetry::AccumulateTimeDelta(Telemetry::PAINT_RASTERIZE_TIME,
-                                 paintStart);
 
   if (consoleNeedsDisplayList || profilerNeedsDisplayList) {
 #ifdef MOZ_DUMP_PAINTING
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
index abbc7d2..c8fafe7 100644
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -163,7 +163,6 @@
 #include "LayerTreeInvalidation.h"
 #include "mozilla/css/ImageLoader.h"
 #include "mozilla/Preferences.h"
-#include "mozilla/Telemetry.h"
 #include "nsCanvasFrame.h"
 #include "nsIImageLoadingContent.h"
 #include "nsIScreen.h"
@@ -1990,11 +1989,6 @@ PresShell::Initialize(nscoord aWidth, nscoord aHeight)
     }
   }
 
-  if (root && root->IsXUL()) {
-    mozilla::Telemetry::AccumulateTimeDelta(Telemetry::XUL_INITIAL_FRAME_CONSTRUCTION,
-                                            timerStart);
-  }
-
   return NS_OK; //XXX this needs to be real. MMP
 }
 
@@ -9533,9 +9527,6 @@ PresShell::DoVerifyReflow()
 }
 #endif
 
-// used with Telemetry metrics
-#define NS_LONG_REFLOW_TIME_MS    5000
-
 bool
 PresShell::ProcessReflowCommands(bool aInterruptible)
 {
@@ -9627,27 +9618,6 @@ PresShell::ProcessReflowCommands(bool aInterruptible)
     UnsuppressAndInvalidate();
   }
 
-  if (mDocument->GetRootElement()) {
-    TimeDuration elapsed = TimeStamp::Now() - timerStart;
-    int32_t intElapsed = int32_t(elapsed.ToMilliseconds());
-
-    Telemetry::ID id;
-    if (mDocument->GetRootElement()->IsXUL()) {
-      id = mIsActive
-        ? Telemetry::XUL_FOREGROUND_REFLOW_MS
-        : Telemetry::XUL_BACKGROUND_REFLOW_MS;
-    } else {
-      id = mIsActive
-        ? Telemetry::HTML_FOREGROUND_REFLOW_MS_2
-        : Telemetry::HTML_BACKGROUND_REFLOW_MS_2;
-    }
-    Telemetry::Accumulate(id, intElapsed);
-    if (intElapsed > NS_LONG_REFLOW_TIME_MS) {
-      Telemetry::Accumulate(Telemetry::LONG_REFLOW_INTERRUPTIBLE,
-                            aInterruptible ? 1 : 0);
-    }
-  }
-
   return !interrupted;
 }
 
diff --git a/layout/base/nsRefreshDriver.cpp b/layout/base/nsRefreshDriver.cpp
index 2a751b5..f389ce7 100644
--- a/layout/base/nsRefreshDriver.cpp
+++ b/layout/base/nsRefreshDriver.cpp
@@ -53,7 +53,6 @@
 #include "nsDocShell.h"
 #include "nsISimpleEnumerator.h"
 #include "nsJSEnvironment.h"
-#include "mozilla/Telemetry.h"
 #include "gfxPrefs.h"
 #include "BackgroundChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
@@ -510,9 +509,6 @@ protected:
         this,
         (aNowTime - mTargetTime).ToMilliseconds(),
         delay);
-#ifndef ANDROID  /* bug 1142079 */
-    Telemetry::Accumulate(Telemetry::FX_REFRESH_DRIVER_FRAME_DELAY_MS, (aNowTime - mTargetTime).ToMilliseconds());
-#endif
 
     // then schedule the timer
     LOG("[%p] scheduling callback for %d ms (2)", this, delay);
@@ -627,9 +623,6 @@ protected:
         this,
         (aNowTime - mTargetTime).ToMilliseconds(),
         delay);
-#ifndef ANDROID  /* bug 1142079 */
-    Telemetry::Accumulate(Telemetry::FX_REFRESH_DRIVER_FRAME_DELAY_MS, (aNowTime - mTargetTime).ToMilliseconds());
-#endif
 
     // then schedule the timer
     LOG("[%p] scheduling callback for %d ms (2)", this, delay);
@@ -1727,10 +1720,6 @@ nsRefreshDriver::Tick(int64_t aNowEpoch, TimeStamp aNowTime)
     }
   }
 
-#ifndef ANDROID  /* bug 1142079 */
-  mozilla::Telemetry::AccumulateTimeDelta(mozilla::Telemetry::REFRESH_DRIVER_TICK, mTickStart);
-#endif
-
   for (uint32_t i = 0; i < mPostRefreshObservers.Length(); ++i) {
     mPostRefreshObservers[i]->DidRefresh();
   }
diff --git a/layout/tools/reftest/remotereftest.py b/layout/tools/reftest/remotereftest.py
index 4b23750..097aea1 100644
--- a/layout/tools/reftest/remotereftest.py
+++ b/layout/tools/reftest/remotereftest.py
@@ -351,9 +351,6 @@ class RemoteReftest(RefTest):
         prefs["font.size.inflation.emPerLine"] = 0
         prefs["font.size.inflation.minTwips"] = 0
         prefs["reftest.remote"] = True
-        # Set a future policy version to avoid the telemetry prompt.
-        prefs["toolkit.telemetry.prompted"] = 999
-        prefs["toolkit.telemetry.notifiedOptOut"] = 999
         prefs["reftest.uri"] = "%s" % reftestlist
         prefs["datareporting.policy.dataSubmissionPolicyBypassAcceptance"] = True
 
diff --git a/layout/tools/reftest/runreftest.py b/layout/tools/reftest/runreftest.py
index 18daa57..22f8b70 100644
--- a/layout/tools/reftest/runreftest.py
+++ b/layout/tools/reftest/runreftest.py
@@ -202,9 +202,6 @@ class RefTest(object):
       prefs['reftest.shuffle'] = True
     prefs['reftest.focusFilterMode'] = options.focusFilterMode
 
-    # Ensure that telemetry is disabled, so we don't connect to the telemetry
-    # server in the middle of the tests.
-    prefs['toolkit.telemetry.enabled'] = False
     # Likewise for safebrowsing.
     prefs['browser.safebrowsing.enabled'] = False
     prefs['browser.safebrowsing.malware.enabled'] = False
diff --git a/mobile/android/chrome/content/browser.js b/mobile/android/chrome/content/browser.js
index e100611..37fb5c6 100644
--- a/mobile/android/chrome/content/browser.js
+++ b/mobile/android/chrome/content/browser.js
@@ -5458,20 +5458,13 @@ var ErrorPageEventHandler = {
           // First check whether it's malware or phishing, so that we can
           // use the right strings/links
           let isMalware = errorDoc.documentURI.includes("e=malwareBlocked");
-          let bucketName = isMalware ? "WARNING_MALWARE_PAGE_" : "WARNING_PHISHING_PAGE_";
-          let nsISecTel = Ci.nsISecurityUITelemetry;
           let isIframe = (errorDoc.defaultView.parent === errorDoc.defaultView);
-          bucketName += isIframe ? "TOP_" : "FRAME_";
 
           let formatter = Cc["@mozilla.org/toolkit/URLFormatterService;1"].getService(Ci.nsIURLFormatter);
 
           if (target == errorDoc.getElementById("getMeOutButton")) {
-            Telemetry.addData("SECURITY_UI", nsISecTel[bucketName + "GET_ME_OUT_OF_HERE"]);
             errorDoc.location = "about:home";
           } else if (target == errorDoc.getElementById("reportButton")) {
-            // We log even if malware/phishing info URL couldn't be found:
-            // the measurement is for how many users clicked the WHY BLOCKED button
-            Telemetry.addData("SECURITY_UI", nsISecTel[bucketName + "WHY_BLOCKED"]);
 
             // This is the "Why is this site blocked" button.  For malware,
             // we can fetch a site-specific report, for phishing, we redirect
@@ -5491,8 +5484,6 @@ var ErrorPageEventHandler = {
               BrowserApp.selectedBrowser.loadURI(url + "phishing-malware");
             }
           } else if (target == errorDoc.getElementById("ignoreWarningButton")) {
-            Telemetry.addData("SECURITY_UI", nsISecTel[bucketName + "IGNORE_WARNING"]);
-
             // Allow users to override and continue through to the site,
             let webNav = BrowserApp.selectedBrowser.docShell.QueryInterface(Ci.nsIWebNavigation);
             let location = BrowserApp.selectedBrowser.contentWindow.location;
@@ -6693,7 +6684,6 @@ var CharacterEncoding = {
 
   setEncoding: function setEncoding(aEncoding) {
     let browser = BrowserApp.selectedBrowser;
-    browser.docShell.gatherCharsetMenuTelemetry();
     browser.docShell.charset = aEncoding;
     browser.reload(Ci.nsIWebNavigation.LOAD_FLAGS_CHARSET_CHANGE);
   }
@@ -7399,11 +7389,6 @@ var RemoteDebugger = {
   }
 };
 
-var Telemetry = {
-  addData: function addData(aHistogramId, aValue) {
-    let histogram = Services.telemetry.getHistogramById(aHistogramId);
-    histogram.add(aValue);
-  },
 };
 
 var ExternalApps = {
diff --git a/netwerk/base/BackgroundFileSaver.cpp b/netwerk/base/BackgroundFileSaver.cpp
index a398599..1e28e27 100644
--- a/netwerk/base/BackgroundFileSaver.cpp
+++ b/netwerk/base/BackgroundFileSaver.cpp
@@ -21,7 +21,6 @@
 #include "nsThreadUtils.h"
 
 #include "BackgroundFileSaver.h"
-#include "mozilla/Telemetry.h"
 
 #ifdef XP_WIN
 #include <windows.h>
@@ -90,7 +89,6 @@ private:
 //// BackgroundFileSaver
 
 uint32_t BackgroundFileSaver::sThreadCount = 0;
-uint32_t BackgroundFileSaver::sTelemetryMaxThreadCount = 0;
 
 BackgroundFileSaver::BackgroundFileSaver()
 : mControlThread(nullptr)
@@ -167,11 +165,6 @@ BackgroundFileSaver::Init()
   rv = NS_NewThread(getter_AddRefs(mWorkerThread));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  sThreadCount++;
-  if (sThreadCount > sTelemetryMaxThreadCount) {
-    sTelemetryMaxThreadCount = sThreadCount;
-  }
-
   return NS_OK;
 }
 
@@ -806,16 +799,6 @@ BackgroundFileSaver::NotifySaveComplete()
 
   sThreadCount--;
 
-  // When there are no more active downloads, we consider the download session
-  // finished. We record the maximum number of concurrent downloads reached
-  // during the session in a telemetry histogram, and we reset the maximum
-  // thread counter for the next download session
-  if (sThreadCount == 0) {
-    Telemetry::Accumulate(Telemetry::BACKGROUNDFILESAVER_THREAD_COUNT,
-                          sTelemetryMaxThreadCount);
-    sTelemetryMaxThreadCount = 0;
-  }
-
   return NS_OK;
 }
 
diff --git a/netwerk/base/BackgroundFileSaver.h b/netwerk/base/BackgroundFileSaver.h
index 412e738..0e236e1 100644
--- a/netwerk/base/BackgroundFileSaver.h
+++ b/netwerk/base/BackgroundFileSaver.h
@@ -61,15 +61,6 @@ public:
    */
   static uint32_t sThreadCount;
 
-  /**
-   * Maximum number of worker threads reached during the current download session,
-   * used for telemetry.
-   *
-   * When there are no more worker threads running, we consider the download
-   * session finished, and this counter is reset.
-   */
-  static uint32_t sTelemetryMaxThreadCount;
-
 
 protected:
   virtual ~BackgroundFileSaver();
diff --git a/netwerk/base/Predictor.cpp b/netwerk/base/Predictor.cpp
index a5d4de8..1b0dd4d 100644
--- a/netwerk/base/Predictor.cpp
+++ b/netwerk/base/Predictor.cpp
@@ -35,7 +35,6 @@
 #include "prlog.h"
 
 #include "mozilla/Preferences.h"
-#include "mozilla/Telemetry.h"
 
 #include "mozilla/net/NeckoCommon.h"
 
@@ -263,26 +262,13 @@ Predictor::Action::OnCacheEntryAvailable(nsICacheEntry *entry, bool isNew,
                    "Aborting.", this));
     return NS_OK;
   }
-  Telemetry::AccumulateTimeDelta(Telemetry::PREDICTOR_WAIT_TIME,
-                                 mStartTime);
   if (mPredict) {
     bool predicted = mPredictor->PredictInternal(mPredictReason, entry, isNew,
                                                  mFullUri, mTargetURI,
                                                  mVerifier, mStackCount);
-    Telemetry::AccumulateTimeDelta(
-      Telemetry::PREDICTOR_PREDICT_WORK_TIME, mStartTime);
-    if (predicted) {
-      Telemetry::AccumulateTimeDelta(
-        Telemetry::PREDICTOR_PREDICT_TIME_TO_ACTION, mStartTime);
-    } else {
-      Telemetry::AccumulateTimeDelta(
-        Telemetry::PREDICTOR_PREDICT_TIME_TO_INACTION, mStartTime);
-    }
   } else {
     mPredictor->LearnInternal(mLearnReason, entry, isNew, mFullUri, mTargetURI,
                               mSourceURI);
-    Telemetry::AccumulateTimeDelta(
-      Telemetry::PREDICTOR_LEARN_WORK_TIME, mStartTime);
   }
 
   return NS_OK;
@@ -1010,8 +996,6 @@ Predictor::CalculateGlobalDegradation(uint32_t lastLoad)
     globalDegradation = mPageDegradationMax;
   }
 
-  Telemetry::Accumulate(Telemetry::PREDICTOR_GLOBAL_DEGRADATION,
-                        globalDegradation);
   return globalDegradation;
 }
 
@@ -1034,9 +1018,6 @@ Predictor::CalculateConfidence(uint32_t hitCount, uint32_t hitsPossible,
 {
   MOZ_ASSERT(NS_IsMainThread());
 
-  Telemetry::AutoCounter<Telemetry::PREDICTOR_PREDICTIONS_CALCULATED> predictionsCalculated;
-  ++predictionsCalculated;
-
   if (!hitsPossible) {
     return 0;
   }
@@ -1076,10 +1057,6 @@ Predictor::CalculateConfidence(uint32_t hitCount, uint32_t hitsPossible,
   confidence = std::max(confidence, 0);
   confidence = std::min(confidence, maxConfidence);
 
-  Telemetry::Accumulate(Telemetry::PREDICTOR_BASE_CONFIDENCE, baseConfidence);
-  Telemetry::Accumulate(Telemetry::PREDICTOR_SUBRESOURCE_DEGRADATION,
-                        confidenceDegradation);
-  Telemetry::Accumulate(Telemetry::PREDICTOR_CONFIDENCE, confidence);
   return confidence;
 }
 
@@ -1142,15 +1119,9 @@ Predictor::RunPredictions(nsINetworkPredictorVerifier *verifier)
   preconnects.SwapElements(mPreconnects);
   preresolves.SwapElements(mPreresolves);
 
-  Telemetry::AutoCounter<Telemetry::PREDICTOR_TOTAL_PREDICTIONS> totalPredictions;
-  Telemetry::AutoCounter<Telemetry::PREDICTOR_TOTAL_PRECONNECTS> totalPreconnects;
-  Telemetry::AutoCounter<Telemetry::PREDICTOR_TOTAL_PRERESOLVES> totalPreresolves;
-
   len = preconnects.Length();
   for (i = 0; i < len; ++i) {
     nsCOMPtr<nsIURI> uri = preconnects[i];
-    ++totalPredictions;
-    ++totalPreconnects;
     mSpeculativeService->SpeculativeConnect(uri, this);
     predicted = true;
     if (verifier) {
@@ -1162,8 +1133,6 @@ Predictor::RunPredictions(nsINetworkPredictorVerifier *verifier)
   nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
   for (i = 0; i < len; ++i) {
     nsCOMPtr<nsIURI> uri = preresolves[i];
-    ++totalPredictions;
-    ++totalPreresolves;
     nsAutoCString hostname;
     uri->GetAsciiHost(hostname);
     nsCOMPtr<nsICancelable> tmpCancelable;
@@ -1265,9 +1234,6 @@ Predictor::Learn(nsIURI *targetURI, nsIURI *sourceURI,
     return NS_ERROR_INVALID_ARG;
   }
 
-  Telemetry::AutoCounter<Telemetry::PREDICTOR_LEARN_ATTEMPTS> learnAttempts;
-  ++learnAttempts;
-
   Predictor::Reason argReason;
   argReason.mLearn = reason;
 
diff --git a/netwerk/base/nsIAuthModule.idl b/netwerk/base/nsIAuthModule.idl
index e073674..2d252f7 100644
--- a/netwerk/base/nsIAuthModule.idl
+++ b/netwerk/base/nsIAuthModule.idl
@@ -30,20 +30,6 @@ interface nsIAuthModule : nsISupports
     const unsigned long REQ_PROXY_AUTH = (1 << 2);
 
     /**
-     * Flags used for telemetry.
-     */
-    const unsigned long NTLM_MODULE_SAMBA_AUTH_PROXY = 0;
-    const unsigned long NTLM_MODULE_SAMBA_AUTH_DIRECT = 1;
-    const unsigned long NTLM_MODULE_WIN_API_PROXY = 2;
-    const unsigned long NTLM_MODULE_WIN_API_DIRECT = 3;
-    const unsigned long NTLM_MODULE_GENERIC_PROXY = 4;
-    const unsigned long NTLM_MODULE_GENERIC_DIRECT = 5;
-    const unsigned long NTLM_MODULE_KERBEROS_PROXY = 6;
-    const unsigned long NTLM_MODULE_KERBEROS_DIRECT = 7;
-
-    /** Other flags may be defined in the future */
-
-    /**
      * Called to initialize an auth module.  The other methods cannot be called
      * unless this method succeeds.
      *
diff --git a/netwerk/base/nsIOService.cpp b/netwerk/base/nsIOService.cpp
index 4789771..fd1a1dc 100644
--- a/netwerk/base/nsIOService.cpp
+++ b/netwerk/base/nsIOService.cpp
@@ -42,7 +42,6 @@
 #include "nsThreadUtils.h"
 #include "mozilla/LoadInfo.h"
 #include "mozilla/net/NeckoCommon.h"
-#include "mozilla/Telemetry.h"
 
 #ifdef MOZ_WIDGET_GONK
 #include "nsINetworkManager.h"
@@ -149,8 +148,6 @@ static const char kNetworkActiveChanged[] = "network-active-changed";
 uint32_t   nsIOService::gDefaultSegmentSize = 4096;
 uint32_t   nsIOService::gDefaultSegmentCount = 24;
 
-bool nsIOService::sTelemetryEnabled = false;
-
 NS_IMPL_ISUPPORTS(nsAppOfflineInfo, nsIAppOfflineInfo)
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -225,8 +222,6 @@ nsIOService::Init()
     else
         NS_WARNING("failed to get observer service");
 
-    Preferences::AddBoolVarCache(&sTelemetryEnabled, "toolkit.telemetry.enabled", false);
-
     gIOService = this;
 
     InitializeNetworkLinkService();
@@ -613,28 +608,6 @@ nsIOService::NewChannelFromURIWithProxyFlagsInternal(nsIURI* aURI,
     if (NS_FAILED(rv))
         return rv;
 
-    if (sTelemetryEnabled) {
-        nsAutoCString path;
-        aURI->GetPath(path);
-
-        bool endsInExcl = StringEndsWith(path, NS_LITERAL_CSTRING("!"));
-        int32_t bangSlashPos = path.Find("!/");
-
-        bool hasBangSlash = bangSlashPos != kNotFound;
-        bool hasBangDoubleSlash = false;
-
-        if (bangSlashPos != kNotFound) {
-            nsDependentCSubstring substr(path, bangSlashPos);
-            hasBangDoubleSlash = StringBeginsWith(substr, NS_LITERAL_CSTRING("!//"));
-        }
-
-        Telemetry::Accumulate(Telemetry::URL_PATH_ENDS_IN_EXCLAMATION, endsInExcl);
-        Telemetry::Accumulate(Telemetry::URL_PATH_CONTAINS_EXCLAMATION_SLASH,
-                              hasBangSlash);
-        Telemetry::Accumulate(Telemetry::URL_PATH_CONTAINS_EXCLAMATION_DOUBLE_SLASH,
-                              hasBangDoubleSlash);
-    }
-
     nsCOMPtr<nsIProtocolHandler> handler;
     rv = GetProtocolHandler(scheme.get(), getter_AddRefs(handler));
     if (NS_FAILED(rv))
diff --git a/netwerk/base/nsIOService.h b/netwerk/base/nsIOService.h
index b125709..493621a 100644
--- a/netwerk/base/nsIOService.h
+++ b/netwerk/base/nsIOService.h
@@ -158,7 +158,6 @@ private:
     // that is used especially in IsAppOffline
     nsDataHashtable<nsUint32HashKey, int32_t> mAppsOfflineStatus;
 
-    static bool                          sTelemetryEnabled;
 public:
     // Used for all default buffer sizes that necko allocates.
     static uint32_t   gDefaultSegmentSize;
diff --git a/netwerk/base/nsLoadGroup.cpp b/netwerk/base/nsLoadGroup.cpp
index 8047f64..4636fdb 100644
--- a/netwerk/base/nsLoadGroup.cpp
+++ b/netwerk/base/nsLoadGroup.cpp
@@ -15,7 +15,6 @@
 #include "nsString.h"
 #include "nsTArray.h"
 #include "mozilla/Atomics.h"
-#include "mozilla/Telemetry.h"
 #include "nsAutoPtr.h"
 #include "mozilla/net/PSpdyPush.h"
 #include "nsITimedChannel.h"
@@ -117,8 +116,6 @@ nsLoadGroup::nsLoadGroup(nsISupports* outer)
     , mPriority(PRIORITY_NORMAL)
     , mIsCanceling(false)
     , mDefaultLoadIsTimed(false)
-    , mTimedRequests(0)
-    , mCachedRequests(0)
     , mTimedNonCachedRequestsUntilOnEndPageLoad(0)
 {
     NS_INIT_AGGREGATED(outer);
@@ -604,44 +601,6 @@ nsLoadGroup::RemoveRequest(nsIRequest *request, nsISupports* ctxt,
 
     PL_DHashTableRawRemove(&mRequests, entry);
 
-    // Collect telemetry stats only when default request is a timed channel.
-    // Don't include failed requests in the timing statistics.
-    if (mDefaultLoadIsTimed && NS_SUCCEEDED(aStatus)) {
-        nsCOMPtr<nsITimedChannel> timedChannel = do_QueryInterface(request);
-        if (timedChannel) {
-            // Figure out if this request was served from the cache
-            ++mTimedRequests;
-            TimeStamp timeStamp;
-            rv = timedChannel->GetCacheReadStart(&timeStamp);
-            if (NS_SUCCEEDED(rv) && !timeStamp.IsNull()) {
-                ++mCachedRequests;
-            }
-            else {
-                mTimedNonCachedRequestsUntilOnEndPageLoad++;
-            }
-
-            rv = timedChannel->GetAsyncOpen(&timeStamp);
-            if (NS_SUCCEEDED(rv) && !timeStamp.IsNull()) {
-                Telemetry::AccumulateTimeDelta(
-                    Telemetry::HTTP_SUBITEM_OPEN_LATENCY_TIME,
-                    mDefaultRequestCreationTime, timeStamp);
-            }
-
-            rv = timedChannel->GetResponseStart(&timeStamp);
-            if (NS_SUCCEEDED(rv) && !timeStamp.IsNull()) {
-                Telemetry::AccumulateTimeDelta(
-                    Telemetry::HTTP_SUBITEM_FIRST_BYTE_LATENCY_TIME,
-                    mDefaultRequestCreationTime, timeStamp);
-            }
-
-            TelemetryReportChannel(timedChannel, false);
-        }
-    }
-
-    if (mRequests.EntryCount() == 0) {
-        TelemetryReport();
-    }
-
     // Undo any group priority delta...
     if (mPriority != 0)
         RescheduleRequest(request, -mPriority);
@@ -852,192 +811,6 @@ nsLoadGroup::SetDefaultLoadFlags(uint32_t aFlags)
 
 ////////////////////////////////////////////////////////////////////////////////
 
-void 
-nsLoadGroup::TelemetryReport()
-{
-    if (mDefaultLoadIsTimed) {
-        Telemetry::Accumulate(Telemetry::HTTP_REQUEST_PER_PAGE, mTimedRequests);
-        if (mTimedRequests) {
-            Telemetry::Accumulate(Telemetry::HTTP_REQUEST_PER_PAGE_FROM_CACHE,
-                                  mCachedRequests * 100 / mTimedRequests);
-        }
-
-        nsCOMPtr<nsITimedChannel> timedChannel =
-            do_QueryInterface(mDefaultLoadRequest);
-        if (timedChannel)
-            TelemetryReportChannel(timedChannel, true);
-    }
-
-    mTimedRequests = 0;
-    mCachedRequests = 0;
-    mDefaultLoadIsTimed = false;
-}
-
-void
-nsLoadGroup::TelemetryReportChannel(nsITimedChannel *aTimedChannel,
-                                    bool aDefaultRequest)
-{
-    nsresult rv;
-    bool timingEnabled;
-    rv = aTimedChannel->GetTimingEnabled(&timingEnabled);
-    if (NS_FAILED(rv) || !timingEnabled)
-        return;
-
-    TimeStamp asyncOpen;
-    rv = aTimedChannel->GetAsyncOpen(&asyncOpen);
-    // We do not check !asyncOpen.IsNull() bellow, prevent ASSERTIONs this way
-    if (NS_FAILED(rv) || asyncOpen.IsNull())
-        return;
-
-    TimeStamp cacheReadStart;
-    rv = aTimedChannel->GetCacheReadStart(&cacheReadStart);
-    if (NS_FAILED(rv))
-        return;
-
-    TimeStamp cacheReadEnd;
-    rv = aTimedChannel->GetCacheReadEnd(&cacheReadEnd);
-    if (NS_FAILED(rv))
-        return;
-
-    TimeStamp domainLookupStart;
-    rv = aTimedChannel->GetDomainLookupStart(&domainLookupStart);
-    if (NS_FAILED(rv))
-        return;
-
-    TimeStamp domainLookupEnd;
-    rv = aTimedChannel->GetDomainLookupEnd(&domainLookupEnd);
-    if (NS_FAILED(rv))
-        return;
-
-    TimeStamp connectStart;
-    rv = aTimedChannel->GetConnectStart(&connectStart);
-    if (NS_FAILED(rv))
-        return;
-
-    TimeStamp connectEnd;
-    rv = aTimedChannel->GetConnectEnd(&connectEnd);
-    if (NS_FAILED(rv))
-        return;
-
-    TimeStamp requestStart;
-    rv = aTimedChannel->GetRequestStart(&requestStart);
-    if (NS_FAILED(rv))
-        return;
-
-    TimeStamp responseStart;
-    rv = aTimedChannel->GetResponseStart(&responseStart);
-    if (NS_FAILED(rv))
-        return;
-
-    TimeStamp responseEnd;
-    rv = aTimedChannel->GetResponseEnd(&responseEnd);
-    if (NS_FAILED(rv))
-        return;
-
-#define HTTP_REQUEST_HISTOGRAMS(prefix)                                        \
-    if (!domainLookupStart.IsNull()) {                                         \
-        Telemetry::AccumulateTimeDelta(                                        \
-            Telemetry::HTTP_##prefix##_DNS_ISSUE_TIME,                         \
-            asyncOpen, domainLookupStart);                                     \
-    }                                                                          \
-                                                                               \
-    if (!domainLookupStart.IsNull() && !domainLookupEnd.IsNull()) {            \
-        Telemetry::AccumulateTimeDelta(                                        \
-            Telemetry::HTTP_##prefix##_DNS_LOOKUP_TIME,                        \
-            domainLookupStart, domainLookupEnd);                               \
-    }                                                                          \
-                                                                               \
-    if (!connectStart.IsNull() && !connectEnd.IsNull()) {                      \
-        Telemetry::AccumulateTimeDelta(                                        \
-            Telemetry::HTTP_##prefix##_TCP_CONNECTION,                         \
-            connectStart, connectEnd);                                         \
-    }                                                                          \
-                                                                               \
-                                                                               \
-    if (!requestStart.IsNull() && !responseEnd.IsNull()) {                     \
-        Telemetry::AccumulateTimeDelta(                                        \
-            Telemetry::HTTP_##prefix##_OPEN_TO_FIRST_SENT,                     \
-            asyncOpen, requestStart);                                          \
-                                                                               \
-        Telemetry::AccumulateTimeDelta(                                        \
-            Telemetry::HTTP_##prefix##_FIRST_SENT_TO_LAST_RECEIVED,            \
-            requestStart, responseEnd);                                        \
-                                                                               \
-        if (cacheReadStart.IsNull() && !responseStart.IsNull()) {              \
-            Telemetry::AccumulateTimeDelta(                                    \
-                Telemetry::HTTP_##prefix##_OPEN_TO_FIRST_RECEIVED,             \
-                asyncOpen, responseStart);                                     \
-        }                                                                      \
-    }                                                                          \
-                                                                               \
-    if (!cacheReadStart.IsNull() && !cacheReadEnd.IsNull()) {                  \
-        if (!CacheObserver::UseNewCache()) {                                   \
-            Telemetry::AccumulateTimeDelta(                                    \
-                Telemetry::HTTP_##prefix##_OPEN_TO_FIRST_FROM_CACHE,           \
-                asyncOpen, cacheReadStart);                                    \
-        } else {                                                               \
-            Telemetry::AccumulateTimeDelta(                                    \
-                Telemetry::HTTP_##prefix##_OPEN_TO_FIRST_FROM_CACHE_V2,        \
-                asyncOpen, cacheReadStart);                                    \
-        }                                                                      \
-                                                                               \
-        if (!CacheObserver::UseNewCache()) {                                   \
-            Telemetry::AccumulateTimeDelta(                                    \
-                Telemetry::HTTP_##prefix##_CACHE_READ_TIME,                    \
-                cacheReadStart, cacheReadEnd);                                 \
-        } else {                                                               \
-            Telemetry::AccumulateTimeDelta(                                    \
-                Telemetry::HTTP_##prefix##_CACHE_READ_TIME_V2,                 \
-                cacheReadStart, cacheReadEnd);                                 \
-        }                                                                      \
-                                                                               \
-        if (!requestStart.IsNull() && !responseEnd.IsNull()) {                 \
-            Telemetry::AccumulateTimeDelta(                                    \
-                Telemetry::HTTP_##prefix##_REVALIDATION,                       \
-                requestStart, responseEnd);                                    \
-        }                                                                      \
-    }                                                                          \
-                                                                               \
-    if (!cacheReadEnd.IsNull()) {                                              \
-        Telemetry::AccumulateTimeDelta(                                        \
-            Telemetry::HTTP_##prefix##_COMPLETE_LOAD,                          \
-            asyncOpen, cacheReadEnd);                                          \
-                                                                               \
-        if (!CacheObserver::UseNewCache()) {                                   \
-            Telemetry::AccumulateTimeDelta(                                    \
-                Telemetry::HTTP_##prefix##_COMPLETE_LOAD_CACHED,               \
-                asyncOpen, cacheReadEnd);                                      \
-        } else {                                                               \
-            Telemetry::AccumulateTimeDelta(                                    \
-                Telemetry::HTTP_##prefix##_COMPLETE_LOAD_CACHED_V2,            \
-                asyncOpen, cacheReadEnd);                                      \
-        }                                                                      \
-    }                                                                          \
-    else if (!responseEnd.IsNull()) {                                          \
-        if (!CacheObserver::UseNewCache()) {                                   \
-            Telemetry::AccumulateTimeDelta(                                    \
-                Telemetry::HTTP_##prefix##_COMPLETE_LOAD,                      \
-                asyncOpen, responseEnd);                                       \
-            Telemetry::AccumulateTimeDelta(                                    \
-                Telemetry::HTTP_##prefix##_COMPLETE_LOAD_NET,                  \
-                asyncOpen, responseEnd);                                       \
-        } else {                                                               \
-            Telemetry::AccumulateTimeDelta(                                    \
-                Telemetry::HTTP_##prefix##_COMPLETE_LOAD_V2,                   \
-                asyncOpen, responseEnd);                                       \
-            Telemetry::AccumulateTimeDelta(                                    \
-                Telemetry::HTTP_##prefix##_COMPLETE_LOAD_NET_V2,               \
-                asyncOpen, responseEnd);                                       \
-        }                                                                      \
-    }
-
-    if (aDefaultRequest) {
-        HTTP_REQUEST_HISTOGRAMS(PAGE)
-    } else {
-        HTTP_REQUEST_HISTOGRAMS(SUB)
-    }
-#undef HTTP_REQUEST_HISTOGRAMS
-}
 
 nsresult nsLoadGroup::MergeLoadFlags(nsIRequest *aRequest, nsLoadFlags& outFlags)
 {
diff --git a/netwerk/base/nsLoadGroup.h b/netwerk/base/nsLoadGroup.h
index 28d4c29..200f01b 100644
--- a/netwerk/base/nsLoadGroup.h
+++ b/netwerk/base/nsLoadGroup.h
@@ -58,11 +58,6 @@ protected:
 
     nsresult MergeLoadFlags(nsIRequest *aRequest, nsLoadFlags& flags);
 
-private:
-    void TelemetryReport();
-    void TelemetryReportChannel(nsITimedChannel *timedChannel,
-                                bool defaultRequest);
-
 protected:
     uint32_t                        mForegroundCount;
     uint32_t                        mLoadFlags;
@@ -85,8 +80,6 @@ protected:
     /* Telemetry */
     mozilla::TimeStamp              mDefaultRequestCreationTime;
     bool                            mDefaultLoadIsTimed;
-    uint32_t                        mTimedRequests;
-    uint32_t                        mCachedRequests;
 
     /* For nsPILoadGroupInternal */
     uint32_t                        mTimedNonCachedRequestsUntilOnEndPageLoad;
diff --git a/netwerk/base/nsUDPSocket.cpp b/netwerk/base/nsUDPSocket.cpp
index de37351..2bdfd81 100644
--- a/netwerk/base/nsUDPSocket.cpp
+++ b/netwerk/base/nsUDPSocket.cpp
@@ -7,7 +7,6 @@
 #include "mozilla/Endian.h"
 #include "mozilla/dom/TypedArray.h"
 #include "mozilla/HoldDropJSObjects.h"
-#include "mozilla/Telemetry.h"
 
 #include "nsSocketTransport2.h"
 #include "nsUDPSocket.h"
@@ -128,20 +127,11 @@ private:
   // released only on the thread func.
   nsRefPtr<nsUDPSocketCloseThread> mSelf;
 
-  // Telemetry probes.
-  TimeStamp mBeforeClose;
-  TimeStamp mAfterClose;
-
-  // Active threads (roughly) counter, modified only on the main thread
-  // and used only for telemetry reports.
-  static uint32_t sActiveThreadsCount;
-
   // Switches to true on "xpcom-shutdown-threads" notification and since
   // then it makes the code fallback to a direct call to PR_Close().
   static bool sPastShutdown;
 };
 
-uint32_t nsUDPSocketCloseThread::sActiveThreadsCount = 0;
 bool nsUDPSocketCloseThread::sPastShutdown = false;
 
 NS_IMPL_ISUPPORTS(nsUDPSocketCloseThread, nsIObserver);
@@ -199,8 +189,6 @@ nsUDPSocketCloseThread::AddObserver()
 {
   MOZ_ASSERT(NS_IsMainThread());
 
-  ++sActiveThreadsCount;
-
   nsCOMPtr<nsIObserverService> obs = services::GetObserverService();
   if (obs) {
     obs->AddObserver(this, "xpcom-shutdown-threads", false);
@@ -218,11 +206,6 @@ nsUDPSocketCloseThread::JoinAndRemove()
     PR_JoinThread(mThread);
     mThread = nullptr;
 
-    Telemetry::Accumulate(Telemetry::UDP_SOCKET_PARALLEL_CLOSE_COUNT, sActiveThreadsCount);
-    Telemetry::AccumulateTimeDelta(Telemetry::UDP_SOCKET_CLOSE_TIME, mBeforeClose, mAfterClose);
-
-    MOZ_ASSERT(sActiveThreadsCount > 0);
-    --sActiveThreadsCount;
   }
 
   nsCOMPtr<nsIObserverService> obs = services::GetObserverService();
@@ -253,13 +236,9 @@ nsUDPSocketCloseThread::ThreadFunc()
 {
   PR_SetCurrentThreadName("UDP socket close");
 
-  mBeforeClose = TimeStamp::Now();
-
   PR_Close(mFd);
   mFd = nullptr;
 
-  mAfterClose = TimeStamp::Now();
-
   // Join and remove the observer on the main thread.
   nsCOMPtr<nsIRunnable> event = NS_NewRunnableMethod(
     this, &nsUDPSocketCloseThread::JoinAndRemove);
diff --git a/netwerk/cache/nsCacheEntryDescriptor.cpp b/netwerk/cache/nsCacheEntryDescriptor.cpp
index 115ae93..7114d4b 100644
--- a/netwerk/cache/nsCacheEntryDescriptor.cpp
+++ b/netwerk/cache/nsCacheEntryDescriptor.cpp
@@ -43,7 +43,7 @@ public:
         nsresult status = NS_OK;
 
         {
-            nsCacheServiceAutoLock lock(LOCK_TELEM(NSASYNCDOOMEVENT_RUN));
+            nsCacheServiceAutoLock lock;
 
             if (mDescriptor->mCacheEntry) {
                 status = nsCacheService::gService->DoomEntry_Internal(
@@ -113,7 +113,7 @@ nsCacheEntryDescriptor::GetClientID(char ** result)
 {
     NS_ENSURE_ARG_POINTER(result);
 
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETCLIENTID));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     return ClientIDFromCacheKey(*(mCacheEntry->Key()), result);
@@ -124,7 +124,7 @@ NS_IMETHODIMP
 nsCacheEntryDescriptor::GetDeviceID(char ** aDeviceID)
 {
     NS_ENSURE_ARG_POINTER(aDeviceID);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETDEVICEID));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     const char* deviceID = mCacheEntry->GetDeviceID();
@@ -141,7 +141,7 @@ nsCacheEntryDescriptor::GetDeviceID(char ** aDeviceID)
 NS_IMETHODIMP
 nsCacheEntryDescriptor::GetKey(nsACString &result)
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETKEY));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     return ClientKeyFromCacheKey(*(mCacheEntry->Key()), result);
@@ -152,7 +152,7 @@ NS_IMETHODIMP
 nsCacheEntryDescriptor::GetFetchCount(int32_t *result)
 {
     NS_ENSURE_ARG_POINTER(result);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETFETCHCOUNT));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     *result = mCacheEntry->FetchCount();
@@ -164,7 +164,7 @@ NS_IMETHODIMP
 nsCacheEntryDescriptor::GetLastFetched(uint32_t *result)
 {
     NS_ENSURE_ARG_POINTER(result);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETLASTFETCHED));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     *result = mCacheEntry->LastFetched();
@@ -176,7 +176,7 @@ NS_IMETHODIMP
 nsCacheEntryDescriptor::GetLastModified(uint32_t *result)
 {
     NS_ENSURE_ARG_POINTER(result);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETLASTMODIFIED));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     *result = mCacheEntry->LastModified();
@@ -188,7 +188,7 @@ NS_IMETHODIMP
 nsCacheEntryDescriptor::GetExpirationTime(uint32_t *result)
 {
     NS_ENSURE_ARG_POINTER(result);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETEXPIRATIONTIME));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     *result = mCacheEntry->ExpirationTime();
@@ -199,7 +199,7 @@ nsCacheEntryDescriptor::GetExpirationTime(uint32_t *result)
 NS_IMETHODIMP
 nsCacheEntryDescriptor::SetExpirationTime(uint32_t expirationTime)
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_SETEXPIRATIONTIME));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     mCacheEntry->SetExpirationTime(expirationTime);
@@ -211,7 +211,7 @@ nsCacheEntryDescriptor::SetExpirationTime(uint32_t expirationTime)
 NS_IMETHODIMP nsCacheEntryDescriptor::IsStreamBased(bool *result)
 {
     NS_ENSURE_ARG_POINTER(result);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_ISSTREAMBASED));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     *result = mCacheEntry->IsStreamData();
@@ -221,7 +221,7 @@ NS_IMETHODIMP nsCacheEntryDescriptor::IsStreamBased(bool *result)
 NS_IMETHODIMP nsCacheEntryDescriptor::GetPredictedDataSize(int64_t *result)
 {
     NS_ENSURE_ARG_POINTER(result);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETPREDICTEDDATASIZE));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry) return NS_ERROR_NOT_AVAILABLE;
 
     *result = mCacheEntry->PredictedDataSize();
@@ -231,7 +231,7 @@ NS_IMETHODIMP nsCacheEntryDescriptor::GetPredictedDataSize(int64_t *result)
 NS_IMETHODIMP nsCacheEntryDescriptor::SetPredictedDataSize(int64_t
                                                            predictedSize)
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_SETPREDICTEDDATASIZE));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     mCacheEntry->SetPredictedDataSize(predictedSize);
@@ -241,7 +241,7 @@ NS_IMETHODIMP nsCacheEntryDescriptor::SetPredictedDataSize(int64_t
 NS_IMETHODIMP nsCacheEntryDescriptor::GetDataSize(uint32_t *result)
 {
     NS_ENSURE_ARG_POINTER(result);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETDATASIZE));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     const char* val = mCacheEntry->GetMetaDataElement("uncompressed-len");
@@ -258,7 +258,7 @@ NS_IMETHODIMP nsCacheEntryDescriptor::GetDataSize(uint32_t *result)
 NS_IMETHODIMP nsCacheEntryDescriptor::GetStorageDataSize(uint32_t *result)
 {
     NS_ENSURE_ARG_POINTER(result);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETSTORAGEDATASIZE));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     *result = mCacheEntry->DataSize();
@@ -270,7 +270,7 @@ NS_IMETHODIMP nsCacheEntryDescriptor::GetStorageDataSize(uint32_t *result)
 nsresult
 nsCacheEntryDescriptor::RequestDataSizeChange(int32_t deltaSize)
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_REQUESTDATASIZECHANGE));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     nsresult  rv;
@@ -288,7 +288,7 @@ nsCacheEntryDescriptor::RequestDataSizeChange(int32_t deltaSize)
 NS_IMETHODIMP
 nsCacheEntryDescriptor::SetDataSize(uint32_t dataSize)
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_SETDATASIZE));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     // XXX review for signed/unsigned math errors
@@ -317,7 +317,7 @@ nsCacheEntryDescriptor::OpenInputStream(uint32_t offset, nsIInputStream ** resul
 
     nsInputStreamWrapper* cacheInput = nullptr;
     {
-        nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_OPENINPUTSTREAM));
+        nsCacheServiceAutoLock lock;
         if (!mCacheEntry)                  return NS_ERROR_NOT_AVAILABLE;
         if (!mCacheEntry->IsStreamData())  return NS_ERROR_CACHE_DATA_IS_NOT_STREAM;
 
@@ -352,7 +352,7 @@ nsCacheEntryDescriptor::OpenOutputStream(uint32_t offset, nsIOutputStream ** res
 
     nsOutputStreamWrapper* cacheOutput = nullptr;
     {
-        nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_OPENOUTPUTSTREAM));
+        nsCacheServiceAutoLock lock;
         if (!mCacheEntry)                  return NS_ERROR_NOT_AVAILABLE;
         if (!mCacheEntry->IsStreamData())  return NS_ERROR_CACHE_DATA_IS_NOT_STREAM;
 
@@ -390,7 +390,7 @@ NS_IMETHODIMP
 nsCacheEntryDescriptor::GetCacheElement(nsISupports ** result)
 {
     NS_ENSURE_ARG_POINTER(result);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETCACHEELEMENT));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)                 return NS_ERROR_NOT_AVAILABLE;
     if (mCacheEntry->IsStreamData())  return NS_ERROR_CACHE_DATA_IS_STREAM;
 
@@ -402,7 +402,7 @@ nsCacheEntryDescriptor::GetCacheElement(nsISupports ** result)
 NS_IMETHODIMP
 nsCacheEntryDescriptor::SetCacheElement(nsISupports * cacheElement)
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_SETCACHEELEMENT));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)                 return NS_ERROR_NOT_AVAILABLE;
     if (mCacheEntry->IsStreamData())  return NS_ERROR_CACHE_DATA_IS_STREAM;
 
@@ -423,7 +423,7 @@ NS_IMETHODIMP
 nsCacheEntryDescriptor::GetStoragePolicy(nsCacheStoragePolicy *result)
 {
     NS_ENSURE_ARG_POINTER(result);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETSTORAGEPOLICY));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
     
     *result = mCacheEntry->StoragePolicy();
@@ -434,7 +434,7 @@ nsCacheEntryDescriptor::GetStoragePolicy(nsCacheStoragePolicy *result)
 NS_IMETHODIMP
 nsCacheEntryDescriptor::SetStoragePolicy(nsCacheStoragePolicy policy)
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_SETSTORAGEPOLICY));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
     // XXX validate policy against session?
     
@@ -461,7 +461,7 @@ NS_IMETHODIMP
 nsCacheEntryDescriptor::GetFile(nsIFile ** result)
 {
     NS_ENSURE_ARG_POINTER(result);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETFILE));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     return nsCacheService::GetFileForEntry(mCacheEntry, result);
@@ -472,7 +472,7 @@ NS_IMETHODIMP
 nsCacheEntryDescriptor::GetSecurityInfo(nsISupports ** result)
 {
     NS_ENSURE_ARG_POINTER(result);
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETSECURITYINFO));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     *result = mCacheEntry->SecurityInfo();
@@ -484,7 +484,7 @@ nsCacheEntryDescriptor::GetSecurityInfo(nsISupports ** result)
 NS_IMETHODIMP
 nsCacheEntryDescriptor::SetSecurityInfo(nsISupports * securityInfo)
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_SETSECURITYINFO));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     mCacheEntry->SetSecurityInfo(securityInfo);
@@ -496,7 +496,7 @@ nsCacheEntryDescriptor::SetSecurityInfo(nsISupports * securityInfo)
 NS_IMETHODIMP
 nsCacheEntryDescriptor::Doom()
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_DOOM));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     return nsCacheService::DoomEntry(mCacheEntry);
@@ -506,7 +506,7 @@ nsCacheEntryDescriptor::Doom()
 NS_IMETHODIMP
 nsCacheEntryDescriptor::DoomAndFailPendingRequests(nsresult status)
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_DOOMANDFAILPENDINGREQUESTS));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     return NS_ERROR_NOT_IMPLEMENTED;
@@ -544,7 +544,7 @@ nsCacheEntryDescriptor::AsyncDoom(nsICacheListener *listener)
 NS_IMETHODIMP
 nsCacheEntryDescriptor::MarkValid()
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_MARKVALID));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     nsresult  rv = nsCacheService::ValidateEntry(mCacheEntry);
@@ -559,7 +559,7 @@ nsCacheEntryDescriptor::Close()
     nsTArray<nsRefPtr<nsInputStreamWrapper> > inputWrappers;
 
     {
-        nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_CLOSE));
+        nsCacheServiceAutoLock lock;
         if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
         // Make sure no other stream can be opened
@@ -585,7 +585,7 @@ nsCacheEntryDescriptor::Close()
 
     inputWrappers.Clear();
 
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_CLOSE));
+    nsCacheServiceAutoLock lock;
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
 
     // XXX perhaps closing descriptors should clear/sever transports
@@ -604,7 +604,7 @@ nsCacheEntryDescriptor::GetMetaDataElement(const char *key, char **result)
     NS_ENSURE_ARG_POINTER(key);
     *result = nullptr;
 
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_GETMETADATAELEMENT));
+    nsCacheServiceAutoLock lock;
     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_NOT_AVAILABLE);
 
     const char *value;
@@ -624,7 +624,7 @@ nsCacheEntryDescriptor::SetMetaDataElement(const char *key, const char *value)
 {
     NS_ENSURE_ARG_POINTER(key);
 
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_SETMETADATAELEMENT));
+    nsCacheServiceAutoLock lock;
     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_NOT_AVAILABLE);
 
     // XXX allow null value, for clearing key?
@@ -639,7 +639,7 @@ nsCacheEntryDescriptor::SetMetaDataElement(const char *key, const char *value)
 NS_IMETHODIMP
 nsCacheEntryDescriptor::VisitMetaData(nsICacheMetaDataVisitor * visitor)
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHEENTRYDESCRIPTOR_VISITMETADATA)); 
+    nsCacheServiceAutoLock lock; 
     // XXX check callers, we're calling out of module
     NS_ENSURE_ARG_POINTER(visitor);
     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
@@ -667,7 +667,7 @@ nsCacheEntryDescriptor::nsInputStreamWrapper::Release()
     }
 
     if (desc)
-        nsCacheService::Lock(LOCK_TELEM(NSINPUTSTREAMWRAPPER_RELEASE));
+        nsCacheService::Lock();
 
     nsrefcnt count;
     NS_PRECONDITION(0 != mRefCnt, "dup release");
@@ -709,7 +709,7 @@ nsInputStreamWrapper::LazyInit()
     if (!mDescriptor)
         return NS_ERROR_NOT_AVAILABLE;
 
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSINPUTSTREAMWRAPPER_LAZYINIT));
+    nsCacheServiceAutoLock lock;
 
     nsCacheAccessMode mode;
     nsresult rv = mDescriptor->GetAccessGranted(&mode);
@@ -755,7 +755,7 @@ nsInputStreamWrapper::CloseInternal()
         return;
     }
 
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSINPUTSTREAMWRAPPER_CLOSEINTERNAL));
+    nsCacheServiceAutoLock lock;
 
     if (mDescriptor) {
         mDescriptor->mInputWrappers.RemoveElement(this);
@@ -859,8 +859,7 @@ nsCacheEntryDescriptor::nsDecompressInputStreamWrapper::Release()
     }
 
     if (desc)
-        nsCacheService::Lock(LOCK_TELEM(
-                             NSDECOMPRESSINPUTSTREAMWRAPPER_RELEASE));
+        nsCacheService::Lock();
 
     nsrefcnt count;
     NS_PRECONDITION(0 != mRefCnt, "dup release");
@@ -1049,7 +1048,7 @@ nsCacheEntryDescriptor::nsOutputStreamWrapper::Release()
     }
 
     if (desc)
-        nsCacheService::Lock(LOCK_TELEM(NSOUTPUTSTREAMWRAPPER_RELEASE));
+        nsCacheService::Lock();
 
     nsrefcnt count;
     NS_PRECONDITION(0 != mRefCnt, "dup release");
@@ -1089,7 +1088,7 @@ nsOutputStreamWrapper::LazyInit()
     if (!mDescriptor)
         return NS_ERROR_NOT_AVAILABLE;
 
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSOUTPUTSTREAMWRAPPER_LAZYINIT));
+    nsCacheServiceAutoLock lock;
 
     nsCacheAccessMode mode;
     nsresult rv = mDescriptor->GetAccessGranted(&mode);
@@ -1163,7 +1162,7 @@ nsOutputStreamWrapper::CloseInternal()
         return;
     }
 
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSOUTPUTSTREAMWRAPPER_CLOSEINTERNAL));
+    nsCacheServiceAutoLock lock;
 
     if (mDescriptor) {
         mDescriptor->mOutputWrapper = nullptr;
@@ -1279,7 +1278,7 @@ nsCacheEntryDescriptor::nsCompressOutputStreamWrapper::Release()
     }
 
     if (desc)
-        nsCacheService::Lock(LOCK_TELEM(NSCOMPRESSOUTPUTSTREAMWRAPPER_RELEASE));
+        nsCacheService::Lock();
 
     nsrefcnt count;
     NS_PRECONDITION(0 != mRefCnt, "dup release");
diff --git a/netwerk/cache/nsCacheService.cpp b/netwerk/cache/nsCacheService.cpp
index 2167664..f1e62ca 100644
--- a/netwerk/cache/nsCacheService.cpp
+++ b/netwerk/cache/nsCacheService.cpp
@@ -211,7 +211,7 @@ public:
 
     NS_IMETHOD Notify(nsITimer* aTimer) override {
         if (nsCacheService::gService) {
-            nsCacheServiceAutoLock autoLock(LOCK_TELEM(NSSETDISKSMARTSIZECALLBACK_NOTIFY));
+            nsCacheServiceAutoLock autoLock;
             nsCacheService::gService->SetDiskSmartSize_Locked();
             nsCacheService::gService->mSmartSizeTimer = nullptr;
         }
@@ -295,7 +295,7 @@ public:
     }
     NS_IMETHOD Run()
     {
-        nsCacheServiceAutoLock autoLock(LOCK_TELEM(NSBLOCKONCACHETHREADEVENT_RUN));
+        nsCacheServiceAutoLock autoLock;
 #ifdef PR_LOGGING
         CACHE_LOG_DEBUG(("nsBlockOnCacheThreadEvent [%p]\n", this));
 #endif
@@ -985,7 +985,7 @@ public:
         NS_ASSERTION(mRequest->mListener,
                      "Sync OpenCacheEntry() posted to background thread!");
 
-        nsCacheServiceAutoLock lock(LOCK_TELEM(NSPROCESSREQUESTEVENT_RUN));
+        nsCacheServiceAutoLock lock;
         rv = nsCacheService::gService->ProcessRequest(mRequest,
                                                       false,
                                                       nullptr);
@@ -1030,7 +1030,7 @@ public:
 
     NS_IMETHOD Run()
     {
-        nsCacheServiceAutoLock lock(LOCK_TELEM(NSDOOMEVENT_RUN));
+        nsCacheServiceAutoLock lock;
 
         bool foundActive = true;
         nsresult status = NS_ERROR_NOT_AVAILABLE;
@@ -1195,13 +1195,12 @@ nsCacheService::Shutdown()
     }
 
     nsCOMPtr<nsIThread> cacheIOThread;
-    Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_SHUTDOWN> totalTimer;
 
     bool shouldSanitize = false;
     nsCOMPtr<nsIFile> parentDir;
 
     {
-        nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_SHUTDOWN));
+        nsCacheServiceAutoLock lock;
         NS_ASSERTION(mInitialized,
             "can't shutdown nsCacheService unless it has been initialized.");
         if (!mInitialized)
@@ -1216,7 +1215,7 @@ nsCacheService::Shutdown()
     UnregisterWeakMemoryReporter(this);
 
     {
-        nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_SHUTDOWN));
+        nsCacheServiceAutoLock lock;
         NS_ASSERTION(mInitialized, "Bad state");
 
         mInitialized = false;
@@ -1269,10 +1268,8 @@ nsCacheService::Shutdown()
             if (NS_SUCCEEDED(parentDir->Exists(&exists)) && exists)
                 nsDeleteDir::DeleteDir(parentDir, false);
         }
-        Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_SHUTDOWN_CLEAR_PRIVATE> timer;
         nsDeleteDir::Shutdown(shouldSanitize);
     } else {
-        Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_DELETEDIR_SHUTDOWN> timer;
         nsDeleteDir::Shutdown(shouldSanitize);
     }
 }
@@ -1374,7 +1371,7 @@ nsCacheService::EvictEntriesForClient(const char *          clientID,
         new EvictionNotifierRunnable(NS_ISUPPORTS_CAST(nsICacheService*, this));
     NS_DispatchToMainThread(r);
 
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_EVICTENTRIESFORCLIENT));
+    nsCacheServiceAutoLock lock;
     nsresult res = NS_OK;
 
     if (storagePolicy == nsICache::STORE_ANYWHERE ||
@@ -1423,7 +1420,7 @@ nsCacheService::IsStorageEnabledForPolicy(nsCacheStoragePolicy  storagePolicy,
                                           bool *              result)
 {
     if (gService == nullptr) return NS_ERROR_NOT_AVAILABLE;
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_ISSTORAGEENABLEDFORPOLICY));
+    nsCacheServiceAutoLock lock;
 
     *result = gService->IsStorageEnabledForPolicy_Locked(storagePolicy);
     return NS_OK;
@@ -1479,7 +1476,7 @@ nsresult nsCacheService::VisitEntriesInternal(nsICacheVisitor *visitor)
 {
     NS_ENSURE_ARG_POINTER(visitor);
 
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_VISITENTRIES));
+    nsCacheServiceAutoLock lock;
 
     if (!(mEnableDiskDevice || mEnableMemoryDevice))
         return NS_ERROR_NOT_AVAILABLE;
@@ -1561,7 +1558,7 @@ NS_IMETHODIMP nsCacheService::GetCacheIOTarget(nsIEventTarget * *aCacheIOTarget)
     // read from the main thread without the lock. This is useful to prevent
     // blocking the main thread on other cache operations.
     if (!NS_IsMainThread()) {
-        Lock(LOCK_TELEM(NSCACHESERVICE_GETCACHEIOTARGET));
+        Lock();
     }
 
     nsresult rv;
@@ -1631,9 +1628,6 @@ nsCacheService::CreateDiskDevice()
         return rv;
     }
 
-    Telemetry::Accumulate(Telemetry::DISK_CACHE_SMART_SIZE_USING_OLD_MAX,
-                          mObserver->ShouldUseOldMaxSmartSize());
-
     NS_ASSERTION(!mSmartSizeTimer, "Smartsize timer was already fired!");
 
     // Disk device is usually created during the startup. Delay smart size
@@ -1973,7 +1967,7 @@ nsCacheService::ProcessRequest(nsCacheRequest *           request,
                 // XXX this is probably wrong...
                 Unlock();
                 rv = request->WaitForValidation();
-                Lock(LOCK_TELEM(NSCACHESERVICE_PROCESSREQUEST));
+                Lock();
             }
 
             PR_REMOVE_AND_INIT_LINK(request);
@@ -2086,7 +2080,7 @@ nsCacheService::OpenCacheEntry(nsCacheSession *           session,
     }
     else {
 
-        nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_OPENCACHEENTRY));
+        nsCacheServiceAutoLock lock;
         rv = gService->ProcessRequest(request, true, result);
 
         // delete requests that have completed
@@ -2212,7 +2206,6 @@ nsCacheService::ActivateEntry(nsCacheRequest * request,
 nsCacheEntry *
 nsCacheService::SearchCacheDevices(nsCString * key, nsCacheStoragePolicy policy, bool *collision)
 {
-    Telemetry::AutoTimer<Telemetry::CACHE_DEVICE_SEARCH_2> timer;
     nsCacheEntry * entry = nullptr;
 
     MOZ_EVENT_TRACER_NAME_OBJECT(key, key->BeginReading());
@@ -2401,14 +2394,14 @@ nsCacheService::OnProfileShutdown()
         return;
     }
     {
-        nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_ONPROFILESHUTDOWN));
+        nsCacheServiceAutoLock lock;
         gService->mClearingEntries = true;
         gService->DoomActiveEntries(nullptr);
     }
 
     gService->CloseAllStreams();
 
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_ONPROFILESHUTDOWN));
+    nsCacheServiceAutoLock lock;
     gService->ClearDoomList();
 
     // Make sure to wait for any pending cache-operations before
@@ -2444,7 +2437,7 @@ nsCacheService::OnProfileChanged()
 
     CACHE_LOG_DEBUG(("nsCacheService::OnProfileChanged"));
  
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_ONPROFILECHANGED));
+    nsCacheServiceAutoLock lock;
     
     gService->mEnableDiskDevice    = gService->mObserver->DiskCacheEnabled();
     gService->mEnableOfflineDevice = gService->mObserver->OfflineCacheEnabled();
@@ -2498,7 +2491,7 @@ void
 nsCacheService::SetDiskCacheEnabled(bool    enabled)
 {
     if (!gService)  return;
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_SETDISKCACHEENABLED));
+    nsCacheServiceAutoLock lock;
     gService->mEnableDiskDevice = enabled;
 }
 
@@ -2507,7 +2500,7 @@ void
 nsCacheService::SetDiskCacheCapacity(int32_t  capacity)
 {
     if (!gService)  return;
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_SETDISKCACHECAPACITY));
+    nsCacheServiceAutoLock lock;
 
     if (gService->mDiskDevice) {
         gService->mDiskDevice->SetCapacity(capacity);
@@ -2520,7 +2513,7 @@ void
 nsCacheService::SetDiskCacheMaxEntrySize(int32_t  maxSize)
 {
     if (!gService)  return;
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_SETDISKCACHEMAXENTRYSIZE));
+    nsCacheServiceAutoLock lock;
 
     if (gService->mDiskDevice) {
         gService->mDiskDevice->SetMaxEntrySize(maxSize);
@@ -2531,7 +2524,7 @@ void
 nsCacheService::SetMemoryCacheMaxEntrySize(int32_t  maxSize)
 {
     if (!gService)  return;
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_SETMEMORYCACHEMAXENTRYSIZE));
+    nsCacheServiceAutoLock lock;
 
     if (gService->mMemoryDevice) {
         gService->mMemoryDevice->SetMaxEntrySize(maxSize);
@@ -2542,7 +2535,7 @@ void
 nsCacheService::SetOfflineCacheEnabled(bool    enabled)
 {
     if (!gService)  return;
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_SETOFFLINECACHEENABLED));
+    nsCacheServiceAutoLock lock;
     gService->mEnableOfflineDevice = enabled;
 }
 
@@ -2550,7 +2543,7 @@ void
 nsCacheService::SetOfflineCacheCapacity(int32_t  capacity)
 {
     if (!gService)  return;
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_SETOFFLINECACHECAPACITY));
+    nsCacheServiceAutoLock lock;
 
     if (gService->mOfflineDevice) {
         gService->mOfflineDevice->SetCapacity(capacity);
@@ -2567,7 +2560,7 @@ nsCacheService::SetMemoryCache()
 
     CACHE_LOG_DEBUG(("nsCacheService::SetMemoryCache"));
 
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_SETMEMORYCACHE));
+    nsCacheServiceAutoLock lock;
 
     gService->mEnableMemoryDevice = gService->mObserver->MemoryCacheEnabled();
 
@@ -2676,34 +2669,16 @@ nsCacheService::LockReleased()
 }
 
 void
-nsCacheService::Lock(mozilla::Telemetry::ID mainThreadLockerID)
+nsCacheService::Lock()
 {
-    mozilla::Telemetry::ID lockerID;
-    mozilla::Telemetry::ID generalID;
-
-    if (NS_IsMainThread()) {
-        lockerID = mainThreadLockerID;
-        generalID = mozilla::Telemetry::CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_2;
-    } else {
-        lockerID = mozilla::Telemetry::HistogramCount;
-        generalID = mozilla::Telemetry::CACHE_SERVICE_LOCK_WAIT_2;
-    }
-
     TimeStamp start(TimeStamp::Now());
     MOZ_EVENT_TRACER_WAIT(nsCacheService::gService, "net::cache::lock");
 
     gService->mLock.Lock();
     gService->LockAcquired();
 
-    TimeStamp stop(TimeStamp::Now());
     MOZ_EVENT_TRACER_EXEC(nsCacheService::gService, "net::cache::lock");
 
-    // Telemetry isn't thread safe on its own, but this is OK because we're
-    // protecting it with the cache lock. 
-    if (lockerID != mozilla::Telemetry::HistogramCount) {
-        mozilla::Telemetry::AccumulateTimeDelta(lockerID, start, stop);
-    }
-    mozilla::Telemetry::AccumulateTimeDelta(generalID, start, stop);
 }
 
 void
@@ -2714,7 +2689,6 @@ nsCacheService::Unlock()
     nsTArray<nsISupports*> doomed;
     doomed.SwapElements(gService->mDoomedObjects);
 
-    gService->LockReleased();
     gService->mLock.Unlock();
 
     MOZ_EVENT_TRACER_DONE(nsCacheService::gService, "net::cache::lock");
@@ -3019,7 +2993,7 @@ nsCacheService::CloseAllStreams()
     nsTArray<nsRefPtr<nsCacheEntryDescriptor::nsOutputStreamWrapper> > outputs;
 
     {
-        nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_CLOSEALLSTREAMS));
+        nsCacheServiceAutoLock lock;
 
         nsTArray<nsCacheEntry*> entries;
 
@@ -3141,7 +3115,7 @@ nsCacheService::LogCacheStatistics()
 nsresult
 nsCacheService::SetDiskSmartSize()
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_SETDISKSMARTSIZE));
+    nsCacheServiceAutoLock lock;
 
     if (!gService) return NS_ERROR_NOT_AVAILABLE;
 
@@ -3242,7 +3216,7 @@ IsEntryPrivate(nsCacheEntry* entry)
 void
 nsCacheService::LeavePrivateBrowsing()
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSCACHESERVICE_LEAVEPRIVATEBROWSING));
+    nsCacheServiceAutoLock lock;
 
     gService->DoomActiveEntries(IsEntryPrivate);
 
@@ -3260,8 +3234,7 @@ nsCacheService::CollectReports(nsIHandleReportCallback* aHandleReport,
 {
     size_t disk = 0;
     if (mDiskDevice) {
-        nsCacheServiceAutoLock
-            lock(LOCK_TELEM(NSCACHESERVICE_DISKDEVICEHEAPSIZE));
+        nsCacheServiceAutoLock lock;
         disk = mDiskDevice->SizeOfIncludingThis(DiskCacheDeviceMallocSizeOf);
     }
 
diff --git a/netwerk/cache/nsCacheService.h b/netwerk/cache/nsCacheService.h
index 309d29d..b9ec2a1 100644
--- a/netwerk/cache/nsCacheService.h
+++ b/netwerk/cache/nsCacheService.h
@@ -22,7 +22,7 @@
 #include "nsRefPtrHashtable.h"
 #include "mozilla/CondVar.h"
 #include "mozilla/Mutex.h"
-#include "mozilla/Telemetry.h"
+#include "mozilla/TimeStamp.h"
 
 class nsCacheRequest;
 class nsCacheProfilePrefObserver;
@@ -254,7 +254,7 @@ private:
      * Internal Methods
      */
 
-    static void      Lock(::mozilla::Telemetry::ID mainThreadLockerID);
+    static void      Lock();
     static void      Unlock();
     void             LockAcquired();
     void             LockReleased();
@@ -386,15 +386,12 @@ private:
  *  nsCacheServiceAutoLock
  ******************************************************************************/
 
-#define LOCK_TELEM(x) \
-  (::mozilla::Telemetry::CACHE_SERVICE_LOCK_WAIT_MAINTHREAD_##x)
-
 // Instantiate this class to acquire the cache service lock for a particular
 // execution scope.
 class nsCacheServiceAutoLock {
 public:
-    explicit nsCacheServiceAutoLock(mozilla::Telemetry::ID mainThreadLockerID) {
-        nsCacheService::Lock(mainThreadLockerID);
+    explicit nsCacheServiceAutoLock() {
+        nsCacheService::Lock();
     }
     ~nsCacheServiceAutoLock() {
         nsCacheService::Unlock();
diff --git a/netwerk/cache/nsDeleteDir.cpp b/netwerk/cache/nsDeleteDir.cpp
index 4572d30..ee71b24 100644
--- a/netwerk/cache/nsDeleteDir.cpp
+++ b/netwerk/cache/nsDeleteDir.cpp
@@ -7,7 +7,6 @@
 #include "nsDeleteDir.h"
 #include "nsIFile.h"
 #include "nsString.h"
-#include "mozilla/Telemetry.h"
 #include "nsITimer.h"
 #include "nsISimpleEnumerator.h"
 #include "nsAutoPtr.h"
@@ -150,7 +149,6 @@ nsDeleteDir::DestroyThread()
 void
 nsDeleteDir::TimerCallback(nsITimer *aTimer, void *arg)
 {
-  Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_DELETEDIR> timer;
   {
     MutexAutoLock lock(gInstance->mLock);
 
@@ -188,8 +186,6 @@ nsDeleteDir::TimerCallback(nsITimer *aTimer, void *arg)
 nsresult
 nsDeleteDir::DeleteDir(nsIFile *dirIn, bool moveToTrash, uint32_t delay)
 {
-  Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_TRASHRENAME> timer;
-
   if (!gInstance)
     return NS_ERROR_NOT_INITIALIZED;
 
diff --git a/netwerk/cache/nsDiskCacheBinding.cpp b/netwerk/cache/nsDiskCacheBinding.cpp
index 637bb73..81f97f7 100644
--- a/netwerk/cache/nsDiskCacheBinding.cpp
+++ b/netwerk/cache/nsDiskCacheBinding.cpp
@@ -89,7 +89,7 @@ nsDiskCacheBinding::~nsDiskCacheBinding()
     // Grab the cache lock since the binding is stored in nsCacheEntry::mData
     // and it is released using nsCacheService::ReleaseObject_Locked() which
     // releases the object outside the cache lock.
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSDISKCACHEBINDING_DESTRUCTOR));
+    nsCacheServiceAutoLock lock;
 
     NS_ASSERTION(PR_CLIST_IS_EMPTY(this), "binding deleted while still on list");
     if (!PR_CLIST_IS_EMPTY(this))
diff --git a/netwerk/cache/nsDiskCacheDevice.cpp b/netwerk/cache/nsDiskCacheDevice.cpp
index 77141410..2066a4a 100644
--- a/netwerk/cache/nsDiskCacheDevice.cpp
+++ b/netwerk/cache/nsDiskCacheDevice.cpp
@@ -45,7 +45,6 @@
 
 #include "nsThreadUtils.h"
 #include "mozilla/MemoryReporting.h"
-#include "mozilla/Telemetry.h"
 
 static const char DISK_CACHE_DEVICE_ID[] = { "disk" };
 using namespace mozilla;
@@ -64,7 +63,7 @@ public:
 
     NS_IMETHOD Run()
     {
-        nsCacheServiceAutoLock lock(LOCK_TELEM(NSDISKCACHEDEVICEDEACTIVATEENTRYEVENT_RUN));
+        nsCacheServiceAutoLock lock;
 #ifdef PR_LOGGING
         CACHE_LOG_DEBUG(("nsDiskCacheDeviceDeactivateEntryEvent[%p]\n", this));
 #endif
@@ -89,7 +88,7 @@ public:
 
     NS_IMETHOD Run()
     {
-        nsCacheServiceAutoLock lock(LOCK_TELEM(NSEVICTDISKCACHEENTRIESEVENT_RUN));
+        nsCacheServiceAutoLock lock;
         mDevice->EvictDiskCacheEntries(mDevice->mCacheCapacity);
         return NS_OK;
     }
@@ -466,7 +465,6 @@ nsDiskCacheDevice::GetDeviceID()
 nsCacheEntry *
 nsDiskCacheDevice::FindEntry(nsCString * key, bool *collision)
 {
-    Telemetry::AutoTimer<Telemetry::CACHE_DISK_SEARCH_2> timer;
     if (!Initialized())  return nullptr;  // NS_ERROR_NOT_INITIALIZED
     if (mClearingDiskCache)  return nullptr;
     nsDiskCacheRecord       record;
@@ -964,7 +962,6 @@ nsDiskCacheDevice::EvictEntries(const char * clientID)
 nsresult
 nsDiskCacheDevice::OpenDiskCache()
 {
-    Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_OPEN> timer;
     // if we don't have a cache directory, create one and open it
     bool exists;
     nsresult rv = mCacheDirectory->Exists(&exists);
@@ -974,17 +971,13 @@ nsDiskCacheDevice::OpenDiskCache()
     if (exists) {
         // Try opening cache map file.
         nsDiskCache::CorruptCacheInfo corruptInfo;
-        rv = mCacheMap.Open(mCacheDirectory, &corruptInfo, true);
+        rv = mCacheMap.Open(mCacheDirectory, &corruptInfo);
 
         if (NS_SUCCEEDED(rv)) {
-            Telemetry::Accumulate(Telemetry::DISK_CACHE_CORRUPT_DETAILS,
-                                  corruptInfo);
         } else if (rv == NS_ERROR_ALREADY_INITIALIZED) {
           NS_WARNING("nsDiskCacheDevice::OpenDiskCache: already open!");
         } else {
             // Consider cache corrupt: delete it
-            Telemetry::Accumulate(Telemetry::DISK_CACHE_CORRUPT_DETAILS,
-                                  corruptInfo);
             // delay delete by 1 minute to avoid IO thrash at startup
             rv = nsDeleteDir::DeleteDir(mCacheDirectory, true, 60000);
             if (NS_FAILED(rv))
@@ -1004,7 +997,7 @@ nsDiskCacheDevice::OpenDiskCache()
     
         // reopen the cache map     
         nsDiskCache::CorruptCacheInfo corruptInfo;
-        rv = mCacheMap.Open(mCacheDirectory, &corruptInfo, false);
+        rv = mCacheMap.Open(mCacheDirectory, &corruptInfo);
         if (NS_FAILED(rv))
             return rv;
     }
diff --git a/netwerk/cache/nsDiskCacheDeviceSQL.cpp b/netwerk/cache/nsDiskCacheDeviceSQL.cpp
index 7caa3ea..10341b9 100644
--- a/netwerk/cache/nsDiskCacheDeviceSQL.cpp
+++ b/netwerk/cache/nsDiskCacheDeviceSQL.cpp
@@ -38,8 +38,6 @@
 #include "nsICacheVisitor.h"
 #include "nsISeekableStream.h"
 
-#include "mozilla/Telemetry.h"
-
 #include "sqlite3.h"
 #include "mozilla/storage.h"
 
@@ -1495,7 +1493,6 @@ nsOfflineCacheDevice::GetDeviceID()
 nsCacheEntry *
 nsOfflineCacheDevice::FindEntry(nsCString *fullKey, bool *collision)
 {
-  mozilla::Telemetry::AutoTimer<mozilla::Telemetry::CACHE_OFFLINE_SEARCH_2> timer;
   LOG(("nsOfflineCacheDevice::FindEntry [key=%s]\n", fullKey->get()));
 
   // SELECT * FROM moz_cache WHERE key = ?
diff --git a/netwerk/cache/nsDiskCacheMap.cpp b/netwerk/cache/nsDiskCacheMap.cpp
index d294e0e..fcf34e2 100644
--- a/netwerk/cache/nsDiskCacheMap.cpp
+++ b/netwerk/cache/nsDiskCacheMap.cpp
@@ -18,7 +18,6 @@
 #include "nsSerializationHelper.h"
 
 #include "mozilla/MemoryReporting.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/VisualEventTracer.h"
 #include <algorithm>
 
@@ -34,8 +33,7 @@ using namespace mozilla;
 
 nsresult
 nsDiskCacheMap::Open(nsIFile *  cacheDirectory,
-                     nsDiskCache::CorruptCacheInfo *  corruptInfo,
-                     bool reportCacheCleanTelemetryData)
+                     nsDiskCache::CorruptCacheInfo *  corruptInfo)
 {
     NS_ENSURE_ARG_POINTER(corruptInfo);
 
@@ -66,8 +64,7 @@ nsDiskCacheMap::Open(nsIFile *  cacheDirectory,
     uint32_t mapSize = PR_Available(mMapFD);    
 
     if (NS_FAILED(InitCacheClean(cacheDirectory,
-                                 corruptInfo,
-                                 reportCacheCleanTelemetryData))) {
+                                 corruptInfo))) {
         // corruptInfo is set in the call to InitCacheClean
         goto error_exit;
     }
@@ -183,9 +180,6 @@ nsDiskCacheMap::Open(nsIFile *  cacheDirectory,
         goto error_exit;
     }
     
-    Telemetry::Accumulate(Telemetry::HTTP_DISK_CACHE_OVERHEAD,
-                          (uint32_t)SizeOfExcludingThis(moz_malloc_size_of));
-
     *corruptInfo = nsDiskCache::kNotCorrupt;
     return NS_OK;
     
@@ -1250,8 +1244,7 @@ nsDiskCacheMap::SizeOfExcludingThis(MallocSizeOf aMallocSizeOf)
 
 nsresult
 nsDiskCacheMap::InitCacheClean(nsIFile *  cacheDirectory,
-                               nsDiskCache::CorruptCacheInfo *  corruptInfo,
-                               bool reportCacheCleanTelemetryData)
+                               nsDiskCache::CorruptCacheInfo *  corruptInfo)
 {
     // The _CACHE_CLEAN_ file will be used in the future to determine
     // if the cache is clean or not. 
@@ -1263,7 +1256,7 @@ nsDiskCacheMap::InitCacheClean(nsIFile *  cacheDirectory,
                  NS_LITERAL_CSTRING("_CACHE_CLEAN_"));
         if (NS_SUCCEEDED(rv)) {
             // Check if the file already exists, if it does, we will later read the
-            // value and report it to telemetry.
+            // value
             cacheCleanFile->Exists(&cacheCleanFileExists);
         }
     }
@@ -1287,12 +1280,9 @@ nsDiskCacheMap::InitCacheClean(nsIFile *  cacheDirectory,
         int32_t bytesRead = PR_Read(mCleanFD, &clean, 1);
         if (bytesRead != 1) {
             NS_WARNING("Could not read _CACHE_CLEAN_ file contents");
-        } else if (reportCacheCleanTelemetryData) {
-            Telemetry::Accumulate(Telemetry::DISK_CACHE_REDUCTION_TRIAL,
-                                  clean == '1' ? 1 : 0);
         }
-    }
 
+    }
     // Create a timer that will be used to validate the cache
     // as long as an activity threshold was met
     mCleanCacheTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
@@ -1352,11 +1342,9 @@ nsDiskCacheMap::InvalidateCache()
     if (!mIsDirtyCacheFlushed) {
         rv = WriteCacheClean(false);
         if (NS_FAILED(rv)) {
-          Telemetry::Accumulate(Telemetry::DISK_CACHE_INVALIDATION_SUCCESS, 0);
           return rv;
         }
 
-        Telemetry::Accumulate(Telemetry::DISK_CACHE_INVALIDATION_SUCCESS, 1);
         mIsDirtyCacheFlushed = true;
     }
 
@@ -1383,7 +1371,7 @@ nsDiskCacheMap::ResetCacheTimer(int32_t timeout)
 void
 nsDiskCacheMap::RevalidateTimerCallback(nsITimer *aTimer, void *arg)
 {
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSDISKCACHEMAP_REVALIDATION));
+    nsCacheServiceAutoLock lock;
     if (!nsCacheService::gService->mDiskDevice ||
         !nsCacheService::gService->mDiskDevice->Initialized()) {
         return;
@@ -1426,7 +1414,6 @@ nsDiskCacheMap::RevalidateCache()
     nsresult rv;
 
     if (!IsCacheInSafeState()) {
-        Telemetry::Accumulate(Telemetry::DISK_CACHE_REVALIDATION_SAFE, 0);
         CACHE_LOG_DEBUG(("CACHE: Revalidation should not performed because "
                          "cache not in a safe state\n"));
         // Normally we would return an error here, but there is a bug where
@@ -1434,24 +1421,14 @@ nsDiskCacheMap::RevalidateCache()
         // until browser shutdown.  So we allow revalidation for the time being
         // to get proper telemetry data of how much the cache corruption plan
         // would help.
-    } else {
-        Telemetry::Accumulate(Telemetry::DISK_CACHE_REVALIDATION_SAFE, 1);
     }
 
-    // We want this after the lock to prove that flushing a file isn't that expensive
-    Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_REVALIDATION> totalTimer;
-
-    // If telemetry data shows it is worth it, we'll be flushing headers and
-    // records before flushing the clean cache file.
-  
     // Write out the _CACHE_CLEAN_ file with '1'
     rv = WriteCacheClean(true);
     if (NS_FAILED(rv)) {
-        Telemetry::Accumulate(Telemetry::DISK_CACHE_REVALIDATION_SUCCESS, 0);
         return rv;
     }
 
-    Telemetry::Accumulate(Telemetry::DISK_CACHE_REVALIDATION_SUCCESS, 1);
     mIsDirtyCacheFlushed = false;
 
     return NS_OK;
diff --git a/netwerk/cache/nsDiskCacheMap.h b/netwerk/cache/nsDiskCacheMap.h
index b638ab8..77af258 100644
--- a/netwerk/cache/nsDiskCacheMap.h
+++ b/netwerk/cache/nsDiskCacheMap.h
@@ -408,8 +408,7 @@ public:
  *  Returns error if it detects change in format or cache wasn't closed.
  */
     nsresult  Open( nsIFile *  cacheDirectory,
-                    nsDiskCache::CorruptCacheInfo *  corruptInfo,
-                    bool reportCacheCleanTelemetryData);
+                    nsDiskCache::CorruptCacheInfo *  corruptInfo);
     nsresult  Close(bool flush);
     nsresult  Trim();
 
@@ -542,8 +541,7 @@ private:
 
     // Initializes the _CACHE_CLEAN_ related functionality
     nsresult InitCacheClean(nsIFile *  cacheDirectory,
-                            nsDiskCache::CorruptCacheInfo *  corruptInfo,
-                            bool reportCacheCleanTelemetryData);
+                            nsDiskCache::CorruptCacheInfo *  corruptInfo);
     // Writes out a value of '0' or '1' in the _CACHE_CLEAN_ file
     nsresult WriteCacheClean(bool clean);
     // Resets the timout for revalidating the cache
diff --git a/netwerk/cache/nsDiskCacheStreams.cpp b/netwerk/cache/nsDiskCacheStreams.cpp
index e3238e5..3768992 100644
--- a/netwerk/cache/nsDiskCacheStreams.cpp
+++ b/netwerk/cache/nsDiskCacheStreams.cpp
@@ -13,7 +13,6 @@
 #include "mozilla/FileUtils.h"
 #include "nsThreadUtils.h"
 #include "mozilla/MemoryReporting.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/TimeStamp.h"
 #include <algorithm>
 #include "mozilla/VisualEventTracer.h"
@@ -321,7 +320,7 @@ nsDiskCacheStreamIO::Close()
     mozilla::TimeStamp start = mozilla::TimeStamp::Now();
 
     // grab service lock
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSDISKCACHESTREAMIO_CLOSEOUTPUTSTREAM));
+    nsCacheServiceAutoLock lock;
 
     if (!mBinding) {    // if we're severed, just clear member variables
         mOutputStreamIsOpen = false;
@@ -332,13 +331,6 @@ nsDiskCacheStreamIO::Close()
     if (NS_FAILED(rv))
         NS_WARNING("CloseOutputStream() failed");
 
-    mozilla::Telemetry::ID id;
-    if (NS_IsMainThread())
-        id = mozilla::Telemetry::NETWORK_DISK_CACHE_STREAMIO_CLOSE_MAIN_THREAD;
-    else
-        id = mozilla::Telemetry::NETWORK_DISK_CACHE_STREAMIO_CLOSE;
-    mozilla::Telemetry::AccumulateTimeDelta(id, start);
-
     return rv;
 }
 
@@ -427,7 +419,7 @@ nsDiskCacheStreamIO::Write( const char * buffer,
     }
 
     // grab service lock
-    nsCacheServiceAutoLock lock(LOCK_TELEM(NSDISKCACHESTREAMIO_WRITE));
+    nsCacheServiceAutoLock lock;
     if (!mBinding)  return NS_ERROR_NOT_AVAILABLE;
 
     if (mInStreamCount) {
diff --git a/netwerk/cache/nsMemoryCacheDevice.cpp b/netwerk/cache/nsMemoryCacheDevice.cpp
index 8e839ff..635ffcc 100644
--- a/netwerk/cache/nsMemoryCacheDevice.cpp
+++ b/netwerk/cache/nsMemoryCacheDevice.cpp
@@ -13,7 +13,6 @@
 #include "nsCRT.h"
 #include "nsReadableUtils.h"
 #include "mozilla/MathAlgorithms.h"
-#include "mozilla/Telemetry.h"
 #include <algorithm>
 
 // The memory cache implements the "LRU-SP" caching algorithm
@@ -113,7 +112,6 @@ nsMemoryCacheDevice::GetDeviceID()
 nsCacheEntry *
 nsMemoryCacheDevice::FindEntry(nsCString * key, bool *collision)
 {
-    mozilla::Telemetry::AutoTimer<mozilla::Telemetry::CACHE_MEMORY_SEARCH_2> timer;
     nsCacheEntry * entry = mMemCacheEntries.GetEntry(key);
     if (!entry)  return nullptr;
 
diff --git a/netwerk/cache2/CacheEntry.cpp b/netwerk/cache2/CacheEntry.cpp
index da49545..ee39ecc 100644
--- a/netwerk/cache2/CacheEntry.cpp
+++ b/netwerk/cache2/CacheEntry.cpp
@@ -25,7 +25,6 @@
 #include "nsProxyRelease.h"
 #include "nsSerializationHelper.h"
 #include "nsThreadUtils.h"
-#include "mozilla/Telemetry.h"
 #include <math.h>
 #include <algorithm>
 
@@ -369,13 +368,6 @@ bool CacheEntry::Load(bool aTruncate, bool aPriority)
   BackgroundOp(Ops::REGISTER);
 
   bool directLoad = aTruncate || !mUseDisk;
-  if (directLoad) {
-    // mLoadStart will be used to calculate telemetry of life-time of this entry.
-    // Low resulution is then enough.
-    mLoadStart = TimeStamp::NowLoRes();
-  } else {
-    mLoadStart = TimeStamp::Now();
-  }
 
   {
     mozilla::MutexAutoUnlock unlock(mLock);
@@ -410,21 +402,6 @@ NS_IMETHODIMP CacheEntry::OnFileReady(nsresult aResult, bool aIsNew)
   LOG(("CacheEntry::OnFileReady [this=%p, rv=0x%08x, new=%d]",
       this, aResult, aIsNew));
 
-  MOZ_ASSERT(!mLoadStart.IsNull());
-
-  if (NS_SUCCEEDED(aResult)) {
-    if (aIsNew) {
-      mozilla::Telemetry::AccumulateTimeDelta(
-        mozilla::Telemetry::NETWORK_CACHE_V2_MISS_TIME_MS,
-        mLoadStart);
-    }
-    else {
-      mozilla::Telemetry::AccumulateTimeDelta(
-        mozilla::Telemetry::NETWORK_CACHE_V2_HIT_TIME_MS,
-        mLoadStart);
-    }
-  }
-
   // OnFileReady, that is the only code that can transit from LOADING
   // to any follow-on state, can only be invoked ones on an entry,
   // thus no need to lock.  Until this moment there is no consumer that
diff --git a/netwerk/cache2/CacheFile.cpp b/netwerk/cache2/CacheFile.cpp
index afea2c1..aa74111 100644
--- a/netwerk/cache2/CacheFile.cpp
+++ b/netwerk/cache2/CacheFile.cpp
@@ -14,7 +14,6 @@
 #include <algorithm>
 #include "nsComponentManagerUtils.h"
 #include "nsProxyRelease.h"
-#include "mozilla/Telemetry.h"
 
 // When CACHE_CHUNKS is defined we always cache unused chunks in mCacheChunks.
 // When it is not defined, we always release the chunks ASAP, i.e. we cache
@@ -1504,33 +1503,6 @@ CacheFile::BytesFromChunk(uint32_t aIndex)
   return std::min(advance, tail);
 }
 
-static uint32_t
-StatusToTelemetryEnum(nsresult aStatus)
-{
-  if (NS_SUCCEEDED(aStatus)) {
-    return 0;
-  }
-
-  switch (aStatus) {
-    case NS_BASE_STREAM_CLOSED:
-      return 0; // Log this as a success
-    case NS_ERROR_OUT_OF_MEMORY:
-      return 2;
-    case NS_ERROR_FILE_DISK_FULL:
-      return 3;
-    case NS_ERROR_FILE_CORRUPTED:
-      return 4;
-    case NS_ERROR_FILE_NOT_FOUND:
-      return 5;
-    case NS_BINDING_ABORTED:
-      return 6;
-    default:
-      return 1; // other error
-  }
-
-  NS_NOTREACHED("We should never get here");
-}
-
 nsresult
 CacheFile::RemoveInput(CacheFileInputStream *aInput, nsresult aStatus)
 {
@@ -1552,9 +1524,6 @@ CacheFile::RemoveInput(CacheFileInputStream *aInput, nsresult aStatus)
   // chunks that won't be used anymore.
   mCachedChunks.Enumerate(&CacheFile::CleanUpCachedChunks, this);
 
-  Telemetry::Accumulate(Telemetry::NETWORK_CACHE_V2_INPUT_STREAM_STATUS,
-                        StatusToTelemetryEnum(aStatus));
-
   return NS_OK;
 }
 
@@ -1590,9 +1559,6 @@ CacheFile::RemoveOutput(CacheFileOutputStream *aOutput, nsresult aStatus)
   // Notify close listener as the last action
   aOutput->NotifyCloseListener();
 
-  Telemetry::Accumulate(Telemetry::NETWORK_CACHE_V2_OUTPUT_STREAM_STATUS,
-                        StatusToTelemetryEnum(aStatus));
-
   return NS_OK;
 }
 
diff --git a/netwerk/cache2/CacheFileIOManager.cpp b/netwerk/cache2/CacheFileIOManager.cpp
index 14b568e..a62437e 100644
--- a/netwerk/cache2/CacheFileIOManager.cpp
+++ b/netwerk/cache2/CacheFileIOManager.cpp
@@ -21,7 +21,6 @@
 #include "nsIObserverService.h"
 #include "nsICacheStorageVisitor.h"
 #include "nsISizeOf.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/DebugOnly.h"
 #include "mozilla/Services.h"
 #include "nsDirectoryServiceUtils.h"
@@ -1148,8 +1147,6 @@ CacheFileIOManager::Shutdown()
     return NS_ERROR_NOT_INITIALIZED;
   }
 
-  Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_SHUTDOWN_V2> shutdownTimer;
-
   CacheIndex::PreShutdown();
 
   ShutdownMetadataWriteScheduling();
@@ -1176,7 +1173,6 @@ CacheFileIOManager::Shutdown()
   CacheIndex::Shutdown();
 
   if (CacheObserver::ClearCacheOnShutdown()) {
-    Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE2_SHUTDOWN_CLEAR_PRIVATE> totalTimer;
     gInstance->SyncRemoveAllCacheFiles();
   }
 
@@ -3458,7 +3454,6 @@ CacheFileIOManager::GetDoomedFile(nsIFile **_retval)
     leafName.Truncate();
   }
 
-//  Telemetry::Accumulate(Telemetry::DISK_CACHE_GETDOOMEDFILE_ITERATIONS, iter);
 
   file.swap(*_retval);
   return NS_OK;
diff --git a/netwerk/cache2/CacheFileMetadata.cpp b/netwerk/cache2/CacheFileMetadata.cpp
index 9136572..1430cbc 100644
--- a/netwerk/cache2/CacheFileMetadata.cpp
+++ b/netwerk/cache2/CacheFileMetadata.cpp
@@ -14,7 +14,6 @@
 #include "nsICacheEntry.h" // for nsICacheEntryMetaDataVisitor
 #include "../cache/nsCacheUtils.h"
 #include "nsIFile.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/DebugOnly.h"
 #include "prnetdb.h"
 
diff --git a/netwerk/cache2/CacheStorageService.cpp b/netwerk/cache2/CacheStorageService.cpp
index c80de37..642b8a3 100644
--- a/netwerk/cache2/CacheStorageService.cpp
+++ b/netwerk/cache2/CacheStorageService.cpp
@@ -872,8 +872,6 @@ CacheStorageService::RegisterEntry(CacheEntry* aEntry)
   if (mShutdown || !aEntry->CanRegister())
     return;
 
-  TelemetryRecordEntryCreation(aEntry);
-
   LOG(("CacheStorageService::RegisterEntry [entry=%p]", aEntry));
 
   MemoryPool& pool = Pool(aEntry->IsUsingDisk());
@@ -891,8 +889,6 @@ CacheStorageService::UnregisterEntry(CacheEntry* aEntry)
   if (!aEntry->IsRegistered())
     return;
 
-  TelemetryRecordEntryRemoval(aEntry);
-
   LOG(("CacheStorageService::UnregisterEntry [entry=%p]", aEntry));
 
   MemoryPool& pool = Pool(aEntry->IsUsingDisk());
@@ -1857,113 +1853,6 @@ CacheStorageService::GetCacheEntryInfo(CacheEntry* aEntry,
                          fetchCount, lastModified, expirationTime);
 }
 
-// Telementry collection
-
-namespace { // anon
-
-bool TelemetryEntryKey(CacheEntry const* entry, nsAutoCString& key)
-{
-  nsAutoCString entryKey;
-  nsresult rv = entry->HashingKey(entryKey);
-  if (NS_FAILED(rv))
-    return false;
-
-  if (entry->GetStorageID().IsEmpty()) {
-    // Hopefully this will be const-copied, saves some memory
-    key = entryKey;
-  } else {
-    key.Assign(entry->GetStorageID());
-    key.Append(':');
-    key.Append(entryKey);
-  }
-
-  return true;
-}
-
-PLDHashOperator PrunePurgeTimeStamps(
-  const nsACString& aKey, TimeStamp& aTimeStamp, void* aClosure)
-{
-  TimeStamp* now = static_cast<TimeStamp*>(aClosure);
-  static TimeDuration const fifteenMinutes = TimeDuration::FromSeconds(900);
-
-  if (*now - aTimeStamp > fifteenMinutes) {
-    // We are not interested in resurrection of entries after 15 minutes
-    // of time.  This is also the limit for the telemetry.
-    return PL_DHASH_REMOVE;
-  }
-
-  return PL_DHASH_NEXT;
-}
-
-} // anon
-
-void
-CacheStorageService::TelemetryPrune(TimeStamp &now)
-{
-  static TimeDuration const oneMinute = TimeDuration::FromSeconds(60);
-  static TimeStamp dontPruneUntil = now + oneMinute;
-  if (now < dontPruneUntil)
-    return;
-
-  mPurgeTimeStamps.Enumerate(PrunePurgeTimeStamps, &now);
-  dontPruneUntil = now + oneMinute;
-}
-
-void
-CacheStorageService::TelemetryRecordEntryCreation(CacheEntry const* entry)
-{
-  MOZ_ASSERT(CacheStorageService::IsOnManagementThread());
-
-  nsAutoCString key;
-  if (!TelemetryEntryKey(entry, key))
-    return;
-
-  TimeStamp now = TimeStamp::NowLoRes();
-  TelemetryPrune(now);
-
-  // When an entry is craeted (registered actually) we check if there is
-  // a timestamp marked when this very same cache entry has been removed
-  // (deregistered) because of over-memory-limit purging.  If there is such
-  // a timestamp found accumulate telemetry on how long the entry was away.
-  TimeStamp timeStamp;
-  if (!mPurgeTimeStamps.Get(key, &timeStamp))
-    return;
-
-  mPurgeTimeStamps.Remove(key);
-
-  Telemetry::AccumulateTimeDelta(Telemetry::HTTP_CACHE_ENTRY_RELOAD_TIME,
-                                 timeStamp, TimeStamp::NowLoRes());
-}
-
-void
-CacheStorageService::TelemetryRecordEntryRemoval(CacheEntry const* entry)
-{
-  MOZ_ASSERT(CacheStorageService::IsOnManagementThread());
-
-  // Doomed entries must not be considered, we are only interested in purged
-  // entries.  Note that the mIsDoomed flag is always set before deregistration
-  // happens.
-  if (entry->IsDoomed())
-    return;
-
-  nsAutoCString key;
-  if (!TelemetryEntryKey(entry, key))
-    return;
-
-  // When an entry is removed (deregistered actually) we put a timestamp for this
-  // entry to the hashtable so that when the entry is created (registered) again
-  // we know how long it was away.  Also accumulate number of AsyncOpen calls on
-  // the entry, this tells us how efficiently the pool actually works.
-
-  TimeStamp now = TimeStamp::NowLoRes();
-  TelemetryPrune(now);
-  mPurgeTimeStamps.Put(key, now);
-
-  Telemetry::Accumulate(Telemetry::HTTP_CACHE_ENTRY_REUSE_COUNT, entry->UseCount());
-  Telemetry::AccumulateTimeDelta(Telemetry::HTTP_CACHE_ENTRY_ALIVE_TIME,
-                                 entry->LoadStart(), TimeStamp::NowLoRes());
-}
-
 // nsIMemoryReporter
 
 size_t
diff --git a/netwerk/cache2/CacheStorageService.h b/netwerk/cache2/CacheStorageService.h
index 72ece79..57f3ba5 100644
--- a/netwerk/cache2/CacheStorageService.h
+++ b/netwerk/cache2/CacheStorageService.h
@@ -171,12 +171,6 @@ private:
   bool IsForcedValidEntry(nsACString &aCacheEntryKey);
 
 private:
-  // These are helpers for telemetry monitorying of the memory pools.
-  void TelemetryPrune(TimeStamp &now);
-  void TelemetryRecordEntryCreation(CacheEntry const* entry);
-  void TelemetryRecordEntryRemoval(CacheEntry const* entry);
-
-private:
   // Following methods are thread safe to call.
   friend class CacheStorage;
 
@@ -357,11 +351,6 @@ private:
     uint32_t mWhat;
   };
 
-  // Used just for telemetry purposes, accessed only on the management thread.
-  // Note: not included in the memory reporter, this is not expected to be huge
-  // and also would be complicated to report since reporting happens on the main
-  // thread but this table is manipulated on the management thread.
-  nsDataHashtable<nsCStringHashKey, mozilla::TimeStamp> mPurgeTimeStamps;
 };
 
 template<class T>
diff --git a/netwerk/cache2/OldWrappers.cpp b/netwerk/cache2/OldWrappers.cpp
index 1022ed1..40e2ef5 100644
--- a/netwerk/cache2/OldWrappers.cpp
+++ b/netwerk/cache2/OldWrappers.cpp
@@ -21,7 +21,6 @@
 #include "nsNetCID.h"
 #include "nsNetUtil.h"
 #include "nsProxyRelease.h"
-#include "mozilla/Telemetry.h"
 
 static NS_DEFINE_CID(kStreamTransportServiceCID,
                      NS_STREAMTRANSPORTSERVICE_CID);
@@ -793,24 +792,6 @@ _OldCacheLoad::Run()
       return NS_OK;
     }
 
-    if (NS_SUCCEEDED(mStatus)) {
-      if (mFlags & nsICacheStorage::OPEN_TRUNCATE) {
-        mozilla::Telemetry::AccumulateTimeDelta(
-          mozilla::Telemetry::NETWORK_CACHE_V1_TRUNCATE_TIME_MS,
-          mLoadStart);
-      }
-      else if (mNew) {
-        mozilla::Telemetry::AccumulateTimeDelta(
-          mozilla::Telemetry::NETWORK_CACHE_V1_MISS_TIME_MS,
-          mLoadStart);
-      }
-      else {
-        mozilla::Telemetry::AccumulateTimeDelta(
-          mozilla::Telemetry::NETWORK_CACHE_V1_HIT_TIME_MS,
-          mLoadStart);
-      }
-    }
-
     if (!(mFlags & CHECK_MULTITHREADED))
       Check();
 
diff --git a/netwerk/cookie/nsCookieService.cpp b/netwerk/cookie/nsCookieService.cpp
index 164f5fd..47c5999 100644
--- a/netwerk/cookie/nsCookieService.cpp
+++ b/netwerk/cookie/nsCookieService.cpp
@@ -44,7 +44,6 @@
 #include "mozilla/storage.h"
 #include "mozilla/AutoRestore.h"
 #include "mozilla/FileUtils.h"
-#include "mozilla/Telemetry.h"
 #include "nsIAppsService.h"
 #include "mozIApplication.h"
 #include "nsIConsoleService.h"
@@ -848,10 +847,6 @@ nsCookieService::TryInitDB(bool aRecreateDB)
     NS_ENSURE_SUCCESS(rv, RESULT_FAILURE);
   }
 
-  // This block provides scope for the Telemetry AutoTimer
-  {
-    Telemetry::AutoTimer<Telemetry::MOZ_SQLITE_COOKIES_OPEN_READAHEAD_MS>
-      telemetry;
     ReadAheadFile(mDefaultDBState->cookieFile);
 
     // open a connection to the cookie database, and only cache our connection
@@ -860,7 +855,6 @@ nsCookieService::TryInitDB(bool aRecreateDB)
     rv = mStorageService->OpenUnsharedDatabase(mDefaultDBState->cookieFile,
       getter_AddRefs(mDefaultDBState->dbConn));
     NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
-  }
 
   // Set up our listeners.
   mDefaultDBState->insertListener = new InsertCookieDBListener(mDefaultDBState);
diff --git a/netwerk/dns/nsHostResolver.cpp b/netwerk/dns/nsHostResolver.cpp
index 54ebfdd..34edc04 100644
--- a/netwerk/dns/nsHostResolver.cpp
+++ b/netwerk/dns/nsHostResolver.cpp
@@ -32,7 +32,6 @@
 
 #include "mozilla/HashFunctions.h"
 #include "mozilla/TimeStamp.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/VisualEventTracer.h"
 #include "mozilla/DebugOnly.h"
 #include "mozilla/Preferences.h"
@@ -230,7 +229,6 @@ nsHostRecord::CopyExpirationTimesAndFlagsFrom(const nsHostRecord *aFromHostRecor
 
 nsHostRecord::~nsHostRecord()
 {
-    Telemetry::Accumulate(Telemetry::DNS_BLACKLIST_COUNT, mBlacklistedCount);
     delete addr_info;
     delete addr;
 }
@@ -801,7 +799,6 @@ nsHostResolver::ResolveHost(const char            *host,
                      LOG_HOST(host, netInterface)));
                 // put reference to host record on stack...
                 result = he->rec;
-                Telemetry::Accumulate(Telemetry::DNS_LOOKUP_METHOD2, METHOD_HIT);
 
                 // For entries that are in the grace period
                 // or all cached negative entries, use the cache but start a new
@@ -811,8 +808,6 @@ nsHostResolver::ResolveHost(const char            *host,
                 if (he->rec->negative) {
                     LOG(("  Negative cache entry for host [%s%s%s].\n",
                          LOG_HOST(host, netInterface)));
-                    Telemetry::Accumulate(Telemetry::DNS_LOOKUP_METHOD2,
-                                          METHOD_NEGATIVE_HIT);
                     status = NS_ERROR_UNKNOWN_HOST;
                 }
             }
@@ -820,8 +815,6 @@ nsHostResolver::ResolveHost(const char            *host,
             // go ahead and use it.
             else if (he->rec->addr) {
                 LOG(("  Using cached address for IP Literal [%s].\n", host));
-                Telemetry::Accumulate(Telemetry::DNS_LOOKUP_METHOD2,
-                                      METHOD_LITERAL);
                 result = he->rec;
             }
             // try parsing the host name as an IP address literal to short
@@ -834,8 +827,6 @@ nsHostResolver::ResolveHost(const char            *host,
                 he->rec->addr = new NetAddr();
                 PRNetAddrToNetAddr(&tempAddr, he->rec->addr);
                 // put reference to host record on stack...
-                Telemetry::Accumulate(Telemetry::DNS_LOOKUP_METHOD2,
-                                      METHOD_LITERAL);
                 result = he->rec;
             }
             else if (mPendingCount >= MAX_NON_PRIORITY_REQUESTS &&
@@ -845,8 +836,6 @@ nsHostResolver::ResolveHost(const char            *host,
                      "host [%s%s%s].\n",
                      IsMediumPriority(flags) ? "medium" : "low",
                      LOG_HOST(host, netInterface)));
-                Telemetry::Accumulate(Telemetry::DNS_LOOKUP_METHOD2,
-                                      METHOD_OVERFLOW);
                 // This is a lower priority request and we are swamped, so refuse it.
                 rv = NS_ERROR_DNS_LOOKUP_QUEUE_FULL;
             }
@@ -911,8 +900,6 @@ nsHostResolver::ResolveHost(const char            *host,
                             if (he->rec->negative) {
                                 status = NS_ERROR_UNKNOWN_HOST;
                             }
-                            Telemetry::Accumulate(Telemetry::DNS_LOOKUP_METHOD2,
-                                                  METHOD_HIT);
                             ConditionallyRefreshRecord(he->rec, host);
                         }
                         // For AF_INET6, a new lookup means another AF_UNSPEC
@@ -926,8 +913,6 @@ nsHostResolver::ResolveHost(const char            *host,
                             result = he->rec;
                             he->rec->negative = true;
                             status = NS_ERROR_UNKNOWN_HOST;
-                            Telemetry::Accumulate(Telemetry::DNS_LOOKUP_METHOD2,
-                                                  METHOD_NEGATIVE_HIT);
                         }
                     }
                 }
@@ -941,8 +926,6 @@ nsHostResolver::ResolveHost(const char            *host,
                     PR_APPEND_LINK(callback, &he->rec->callbacks);
                     he->rec->flags = flags;
                     rv = IssueLookup(he->rec);
-                    Telemetry::Accumulate(Telemetry::DNS_LOOKUP_METHOD2,
-                                          METHOD_NETWORK_FIRST);
                     if (NS_FAILED(rv)) {
                         PR_REMOVE_AND_INIT_LINK(callback);
                     }
@@ -959,8 +942,6 @@ nsHostResolver::ResolveHost(const char            *host,
 
                 PR_APPEND_LINK(callback, &he->rec->callbacks);
                 if (he->rec->onQueue) {
-                    Telemetry::Accumulate(Telemetry::DNS_LOOKUP_METHOD2,
-                                          METHOD_NETWORK_SHARED);
 
                     // Consider the case where we are on a pending queue of
                     // lower priority than the request is being made at.
@@ -1117,12 +1098,6 @@ nsHostResolver::ConditionallyRefreshRecord(nsHostRecord *rec, const char *host)
             rec->negative ? "negative" :"positive", host));
         IssueLookup(rec);
 
-        if (!rec->negative) {
-            // negative entries are constantly being refreshed, only
-            // track positive grace period induced renewals
-            Telemetry::Accumulate(Telemetry::DNS_LOOKUP_METHOD2,
-                METHOD_RENEWAL);
-        }
     }
     return NS_OK;
 }
@@ -1301,13 +1276,6 @@ nsHostResolver::OnLookupComplete(nsHostRecord* rec, nsresult status, AddrInfo* r
                 PR_REMOVE_AND_INIT_LINK(head);
                 PL_DHashTableRemove(&mDB, (nsHostKey *) head);
 
-                if (!head->negative) {
-                    // record the age of the entry upon eviction.
-                    TimeDuration age = TimeStamp::NowLoRes() - head->mValidStart;
-                    Telemetry::Accumulate(Telemetry::DNS_CLEANUP_AGE,
-                                          static_cast<uint32_t>(age.ToSeconds() / 60));
-                }
-
                 // release reference to rec owned by mEvictionQ
                 NS_RELEASE(head);
             }
@@ -1453,27 +1421,6 @@ nsHostResolver::ThreadFunc(void *arg)
                                  getTtl);
         }
 #endif
-
-        TimeDuration elapsed = TimeStamp::Now() - startTime;
-        uint32_t millis = static_cast<uint32_t>(elapsed.ToMilliseconds());
-
-        if (NS_SUCCEEDED(status)) {
-            Telemetry::ID histogramID;
-            if (!rec->addr_info_gencnt) {
-                // Time for initial lookup.
-                histogramID = Telemetry::DNS_LOOKUP_TIME;
-            } else if (!getTtl) {
-                // Time for renewal; categorized by expiration strategy.
-                histogramID = Telemetry::DNS_RENEWAL_TIME;
-            } else {
-                // Time to get TTL; categorized by expiration strategy.
-                histogramID = Telemetry::DNS_RENEWAL_TIME_FOR_TTL;
-            }
-            Telemetry::Accumulate(histogramID, millis);
-        } else {
-            Telemetry::Accumulate(Telemetry::DNS_FAILED_LOOKUP_TIME, millis);
-        }
-
         // OnLookupComplete may release "rec", long before we lose it.
         LOG(("DNS lookup thread - lookup completed for host [%s%s%s]: %s.\n",
              LOG_HOST(rec->host, rec->netInterface),
diff --git a/netwerk/protocol/http/ASpdySession.cpp b/netwerk/protocol/http/ASpdySession.cpp
index aed5d54..d745260 100644
--- a/netwerk/protocol/http/ASpdySession.cpp
+++ b/netwerk/protocol/http/ASpdySession.cpp
@@ -21,8 +21,6 @@
 #include "SpdySession31.h"
 #include "Http2Session.h"
 
-#include "mozilla/Telemetry.h"
-
 namespace mozilla {
 namespace net {
 
@@ -51,8 +49,6 @@ ASpdySession::NewSpdySession(uint32_t version,
   // from a list provided in the SERVER HELLO filtered by our acceptable
   // versions, so there is no risk of the server ignoring our prefs.
 
-  Telemetry::Accumulate(Telemetry::SPDY_VERSION2, version);
-
   if (version == SPDY_VERSION_31) {
     return new SpdySession31(aTransport);
   } else if (version == HTTP_VERSION_2_DRAFT_LATEST || version == HTTP_VERSION_2 ||
@@ -71,23 +67,18 @@ SpdyInformation::SpdyInformation()
 {
   // highest index of enabled protocols is the
   // most preferred for ALPN negotiaton
-  Version[0] = SPDY_VERSION_31;
   VersionString[0] = NS_LITERAL_CSTRING("spdy/3.1");
   ALPNCallbacks[0] = SpdySessionTrue;
 
-  Version[1] = HTTP_VERSION_2;
   VersionString[1] = NS_LITERAL_CSTRING("h2");
   ALPNCallbacks[1] = Http2Session::ALPNCallback;
 
-  Version[2] = HTTP_VERSION_2_DRAFT_15; // 14 and 15 are aliased
   VersionString[2] = NS_LITERAL_CSTRING("h2-14");
   ALPNCallbacks[2] = Http2Session::ALPNCallback;
 
-  Version[3] = HTTP_VERSION_2_DRAFT_15; // 14 and 15 are aliased
   VersionString[3] = NS_LITERAL_CSTRING("h2-15");
   ALPNCallbacks[3] = Http2Session::ALPNCallback;
 
-  Version[4] = HTTP_VERSION_2_DRAFT_LATEST;
   VersionString[4] = NS_LITERAL_CSTRING(HTTP2_DRAFT_LATEST_TOKEN);
   ALPNCallbacks[4] = Http2Session::ALPNCallback;
 }
diff --git a/netwerk/protocol/http/ASpdySession.h b/netwerk/protocol/http/ASpdySession.h
index 9283111..4cfbc27 100644
--- a/netwerk/protocol/http/ASpdySession.h
+++ b/netwerk/protocol/http/ASpdySession.h
@@ -108,7 +108,6 @@ public:
   // determine if a version of the protocol is enabled for index < kCount
   bool ProtocolEnabled(uint32_t index) const;
 
-  uint8_t   Version[kCount]; // telemetry enum e.g. SPDY_VERSION_31
   nsCString VersionString[kCount]; // npn string e.g. "spdy/3.1"
 
   // the ALPNCallback function allows the protocol stack to decide whether or
diff --git a/netwerk/protocol/http/Http2Session.cpp b/netwerk/protocol/http/Http2Session.cpp
index 0a32321..ecb5e40 100644
--- a/netwerk/protocol/http/Http2Session.cpp
+++ b/netwerk/protocol/http/Http2Session.cpp
@@ -19,7 +19,6 @@
 #include "Http2Stream.h"
 #include "Http2Push.h"
 
-#include "mozilla/Telemetry.h"
 #include "mozilla/Preferences.h"
 #include "nsHttp.h"
 #include "nsHttpHandler.h"
@@ -90,7 +89,6 @@ Http2Session::Http2Session(nsISocketTransport *aSocketTransport, uint32_t versio
   , mGoAwayID(0)
   , mOutgoingGoAwayID(0)
   , mConcurrent(0)
-  , mServerPushedResources(0)
   , mServerInitialStreamWindow(kDefaultRwin)
   , mLocalSessionWindow(kDefaultRwin)
   , mServerSessionWindow(kDefaultRwin)
@@ -206,10 +204,6 @@ Http2Session::~Http2Session()
         this, mDownstreamState));
 
   mStreamTransactionHash.Enumerate(ShutdownEnumerator, this);
-  Telemetry::Accumulate(Telemetry::SPDY_PARALLEL_STREAMS, mConcurrentHighWater);
-  Telemetry::Accumulate(Telemetry::SPDY_REQUEST_PER_CONN, (mNextStreamID - 1) / 2);
-  Telemetry::Accumulate(Telemetry::SPDY_SERVER_INITIATED_STREAMS,
-                        mServerPushedResources);
 }
 
 void
@@ -1495,13 +1489,11 @@ Http2Session::RecvSettings(Http2Session *self)
 
     case SETTINGS_TYPE_MAX_CONCURRENT:
       self->mMaxConcurrent = value;
-      Telemetry::Accumulate(Telemetry::SPDY_SETTINGS_MAX_STREAMS, value);
       self->ProcessPending();
       break;
 
     case SETTINGS_TYPE_INITIAL_WINDOW:
       {
-        Telemetry::Accumulate(Telemetry::SPDY_SETTINGS_IW, value >> 10);
         int32_t delta = value - self->mServerInitialStreamWindow;
         self->mServerInitialStreamWindow = value;
 
@@ -1604,7 +1596,6 @@ Http2Session::RecvPushPromise(Http2Session *self)
     return rv;
 
   Http2Stream *associatedStream = self->mInputFrameDataStream;
-  ++(self->mServerPushedResources);
 
   // Anytime we start using the high bit of stream ID (either client or server)
   // begin to migrate to a new session.
@@ -2393,8 +2384,6 @@ Http2Session::ReadyToProcessDataFrame(enum internalStateType newState)
              newState == DISCARDING_DATA_FRAME_PADDING);
   ChangeDownstreamState(newState);
 
-  Telemetry::Accumulate(Telemetry::SPDY_CHUNK_RECVD,
-                        mInputFrameDataSize >> 10);
   mLastDataReadEpoch = mLastReadEpoch;
 
   if (!mInputFrameID) {
diff --git a/netwerk/protocol/http/Http2Session.h b/netwerk/protocol/http/Http2Session.h
index a06802a..c213c26 100644
--- a/netwerk/protocol/http/Http2Session.h
+++ b/netwerk/protocol/http/Http2Session.h
@@ -430,9 +430,6 @@ private:
   // below the current value
   uint32_t             mConcurrent;
 
-  // The number of server initiated promises, tracked for telemetry
-  uint32_t             mServerPushedResources;
-
   // The server rwin for new streams as determined from a SETTINGS frame
   uint32_t             mServerInitialStreamWindow;
 
diff --git a/netwerk/protocol/http/Http2Stream.cpp b/netwerk/protocol/http/Http2Stream.cpp
index 319f1d2..1b5e5be 100644
--- a/netwerk/protocol/http/Http2Stream.cpp
+++ b/netwerk/protocol/http/Http2Stream.cpp
@@ -21,7 +21,6 @@
 #include "Http2Push.h"
 #include "TunnelUtils.h"
 
-#include "mozilla/Telemetry.h"
 #include "nsAlgorithm.h"
 #include "nsHttp.h"
 #include "nsHttpHandler.h"
@@ -588,8 +587,6 @@ Http2Stream::GenerateOpen()
     outputOffset += frameLen;
   }
 
-  Telemetry::Accumulate(Telemetry::SPDY_SYN_SIZE, compressedData.Length());
-
   // The size of the input headers is approximate
   uint32_t ratio =
     compressedData.Length() * 100 /
@@ -597,7 +594,6 @@ Http2Stream::GenerateOpen()
      mFlatHttpRequestHeaders.Length());
 
   mFlatHttpRequestHeaders.Truncate();
-  Telemetry::Accumulate(Telemetry::SPDY_SYN_RATIO, ratio);
   return NS_OK;
 }
 
@@ -944,13 +940,6 @@ Http2Stream::ConvertResponseHeaders(Http2Decompressor *decompressor,
     return NS_ERROR_ILLEGAL_VALUE;
   }
 
-  if (aHeadersIn.Length() && aHeadersOut.Length()) {
-    Telemetry::Accumulate(Telemetry::SPDY_SYN_REPLY_SIZE, aHeadersIn.Length());
-    uint32_t ratio =
-      aHeadersIn.Length() * 100 / aHeadersOut.Length();
-    Telemetry::Accumulate(Telemetry::SPDY_SYN_REPLY_RATIO, ratio);
-  }
-
   // The decoding went ok. Now we can customize and clean up.
 
   aHeadersIn.Truncate();
diff --git a/netwerk/protocol/http/SpdySession31.cpp b/netwerk/protocol/http/SpdySession31.cpp
index b279038..782302d 100644
--- a/netwerk/protocol/http/SpdySession31.cpp
+++ b/netwerk/protocol/http/SpdySession31.cpp
@@ -13,7 +13,6 @@
 #undef LOG_ENABLED
 #define LOG_ENABLED() LOG5_ENABLED()
 
-#include "mozilla/Telemetry.h"
 #include "mozilla/Preferences.h"
 #include "nsHttp.h"
 #include "nsHttpHandler.h"
@@ -64,7 +63,6 @@ SpdySession31::SpdySession31(nsISocketTransport *aSocketTransport)
   , mDataPending(false)
   , mGoAwayID(0)
   , mConcurrent(0)
-  , mServerPushedResources(0)
   , mServerInitialStreamWindow(kDefaultRwin)
   , mLocalSessionWindow(kDefaultRwin)
   , mRemoteSessionWindow(kDefaultRwin)
@@ -147,10 +145,6 @@ SpdySession31::~SpdySession31()
   deflateEnd(&mUpstreamZlib);
 
   mStreamTransactionHash.Enumerate(ShutdownEnumerator, this);
-  Telemetry::Accumulate(Telemetry::SPDY_PARALLEL_STREAMS, mConcurrentHighWater);
-  Telemetry::Accumulate(Telemetry::SPDY_REQUEST_PER_CONN, (mNextStreamID - 1) / 2);
-  Telemetry::Accumulate(Telemetry::SPDY_SERVER_INITIATED_STREAMS,
-                        mServerPushedResources);
 }
 
 void
@@ -1046,8 +1040,6 @@ SpdySession31::HandleSynStream(SpdySession31 *self)
     return rv;
   SpdyStream31 *associatedStream = self->mInputFrameDataStream;
 
-  ++(self->mServerPushedResources);
-
   // Anytime we start using the high bit of stream ID (either client or server)
   // begin to migrate to a new session.
   if (streamID >= kMaxStreamID)
@@ -1445,21 +1437,8 @@ SpdySession31::HandleSettings(SpdySession31 *self)
 
     switch (id)
     {
-    case SETTINGS_TYPE_UPLOAD_BW:
-      Telemetry::Accumulate(Telemetry::SPDY_SETTINGS_UL_BW, value);
-      break;
-
-    case SETTINGS_TYPE_DOWNLOAD_BW:
-      Telemetry::Accumulate(Telemetry::SPDY_SETTINGS_DL_BW, value);
-      break;
-
-    case SETTINGS_TYPE_RTT:
-      Telemetry::Accumulate(Telemetry::SPDY_SETTINGS_RTT, value);
-      break;
-
     case SETTINGS_TYPE_MAX_CONCURRENT:
       self->mMaxConcurrent = value;
-      Telemetry::Accumulate(Telemetry::SPDY_SETTINGS_MAX_STREAMS, value);
       self->ProcessPending();
       break;
 
@@ -1471,15 +1450,9 @@ SpdySession31::HandleSettings(SpdySession31 *self)
         if (ci)
           gHttpHandler->ConnMgr()->ReportSpdyCWNDSetting(ci, value);
       }
-      Telemetry::Accumulate(Telemetry::SPDY_SETTINGS_CWND, value);
-      break;
-
-    case SETTINGS_TYPE_DOWNLOAD_RETRANS_RATE:
-      Telemetry::Accumulate(Telemetry::SPDY_SETTINGS_RETRANS, value);
       break;
 
     case SETTINGS_TYPE_INITIAL_WINDOW:
-      Telemetry::Accumulate(Telemetry::SPDY_SETTINGS_IW, value >> 10);
       {
         int32_t delta = value - self->mServerInitialStreamWindow;
         self->mServerInitialStreamWindow = value;
@@ -2071,8 +2044,6 @@ SpdySession31::WriteSegments(nsAHttpSegmentWriter *writer,
     else {
       ChangeDownstreamState(PROCESSING_DATA_FRAME);
 
-      Telemetry::Accumulate(Telemetry::SPDY_CHUNK_RECVD,
-                            mInputFrameDataSize >> 10);
       mLastDataReadEpoch = mLastReadEpoch;
 
       uint32_t streamID =
diff --git a/netwerk/protocol/http/SpdySession31.h b/netwerk/protocol/http/SpdySession31.h
index 83b24cb..ccf8043 100644
--- a/netwerk/protocol/http/SpdySession31.h
+++ b/netwerk/protocol/http/SpdySession31.h
@@ -371,9 +371,6 @@ private:
   // below the current value
   uint32_t             mConcurrent;
 
-  // The number of server initiated SYN-STREAMS, tracked for telemetry
-  uint32_t             mServerPushedResources;
-
   // The server rwin for new streams as determined from a SETTINGS frame
   uint32_t             mServerInitialStreamWindow;
 
diff --git a/netwerk/protocol/http/SpdyStream31.cpp b/netwerk/protocol/http/SpdyStream31.cpp
index e142384..fc7022f 100644
--- a/netwerk/protocol/http/SpdyStream31.cpp
+++ b/netwerk/protocol/http/SpdyStream31.cpp
@@ -13,7 +13,6 @@
 #undef LOG_ENABLED
 #define LOG_ENABLED() LOG5_ENABLED()
 
-#include "mozilla/Telemetry.h"
 #include "nsAlgorithm.h"
 #include "nsHttp.h"
 #include "nsHttpHandler.h"
@@ -575,15 +574,12 @@ SpdyStream31::GenerateSynFrame()
     mTxInlineFrame[4] = SpdySession31::kFlag_Data_FIN;
   }
 
-  Telemetry::Accumulate(Telemetry::SPDY_SYN_SIZE, mTxInlineFrameUsed - 18);
-
   // The size of the input headers is approximate
   uint32_t ratio =
     (mTxInlineFrameUsed - 18) * 100 /
     (11 + mTransaction->RequestHead()->RequestURI().Length() +
      mFlatHttpRequestHeaders.Length());
 
-  Telemetry::Accumulate(Telemetry::SPDY_SYN_RATIO, ratio);
   return NS_OK;
 }
 
@@ -1195,13 +1191,6 @@ SpdyStream31::ConvertHeaders(nsACString &aHeadersOut)
   if (NS_FAILED(rv))
     return (rv == NS_ERROR_NOT_AVAILABLE) ? NS_ERROR_ILLEGAL_VALUE : rv;
 
-  if (mDecompressedBytes && mDecompressBufferUsed) {
-    Telemetry::Accumulate(Telemetry::SPDY_SYN_REPLY_SIZE, mDecompressedBytes);
-    uint32_t ratio =
-      mDecompressedBytes * 100 / mDecompressBufferUsed;
-    Telemetry::Accumulate(Telemetry::SPDY_SYN_REPLY_RATIO, ratio);
-  }
-
   aHeadersOut.Truncate();
   aHeadersOut.SetCapacity(mDecompressBufferUsed + 64);
 
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
index aad5035..3248cb2 100644
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -71,7 +71,6 @@
 #include "nsCRT.h"
 #include "nsPerformance.h"
 #include "CacheObserver.h"
-#include "mozilla/Telemetry.h"
 #include "AlternateServices.h"
 #include "InterceptedChannel.h"
 #include "nsIHttpPushListener.h"
@@ -99,30 +98,6 @@ static NS_DEFINE_CID(kStreamListenerTeeCID, NS_STREAMLISTENERTEE_CID);
 static NS_DEFINE_CID(kStreamTransportServiceCID,
                      NS_STREAMTRANSPORTSERVICE_CID);
 
-enum CacheDisposition {
-    kCacheHit = 1,
-    kCacheHitViaReval = 2,
-    kCacheMissedViaReval = 3,
-    kCacheMissed = 4
-};
-
-void
-AccumulateCacheHitTelemetry(CacheDisposition hitOrMiss)
-{
-    if (!CacheObserver::UseNewCache()) {
-        Telemetry::Accumulate(Telemetry::HTTP_CACHE_DISPOSITION_2, hitOrMiss);
-    }
-    else {
-        Telemetry::Accumulate(Telemetry::HTTP_CACHE_DISPOSITION_2_V2, hitOrMiss);
-
-        int32_t experiment = CacheObserver::HalfLifeExperiment();
-        if (experiment > 0 && hitOrMiss == kCacheMissed) {
-            Telemetry::Accumulate(Telemetry::HTTP_CACHE_MISS_HALFLIFE_EXPERIMENT,
-                                  experiment - 1);
-        }
-    }
-}
-
 // Computes and returns a SHA1 hash of the input buffer. The input buffer
 // must be a null-terminated string.
 nsresult
@@ -390,8 +365,6 @@ nsHttpChannel::ContinueConnect()
                 event->Revoke();
             }
 
-            AccumulateCacheHitTelemetry(kCacheHit);
-
             return rv;
         }
         else if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
@@ -1425,15 +1398,6 @@ nsHttpChannel::ProcessResponse()
 
     uint32_t httpStatus = mResponseHead->Status();
 
-    // Gather data on whether the transaction and page (if this is
-    // the initial page load) is being loaded with SSL.
-    Telemetry::Accumulate(Telemetry::HTTP_TRANSACTION_IS_SSL,
-                          mConnectionInfo->EndToEndSSL());
-    if (mLoadFlags & LOAD_INITIAL_DOCUMENT_URI) {
-        Telemetry::Accumulate(Telemetry::HTTP_PAGELOAD_IS_SSL,
-                              mConnectionInfo->EndToEndSSL());
-    }
-
     LOG(("nsHttpChannel::ProcessResponse [this=%p httpStatus=%u]\n",
         this, httpStatus));
 
@@ -1587,35 +1551,6 @@ nsHttpChannel::ProcessResponse()
         break;
     }
 
-    CacheDisposition cacheDisposition;
-    if (!mDidReval)
-        cacheDisposition = kCacheMissed;
-    else if (successfulReval)
-        cacheDisposition = kCacheHitViaReval;
-    else
-        cacheDisposition = kCacheMissedViaReval;
-
-    AccumulateCacheHitTelemetry(cacheDisposition);
-    Telemetry::Accumulate(Telemetry::HTTP_RESPONSE_VERSION,
-                          mResponseHead->Version());
-
-#if defined(ANDROID)
-    if (gHttpHandler->IsTelemetryEnabled()) {
-      // Gather telemetry on being sent a WAP content-type
-      // This check will catch (at least) the following content types:
-      // application/wml+xml, application/vnd.wap.xhtml+xml,
-      // text/vnd.wap.wml, application/vnd.wap.wmlc
-      bool isWap = false;
-      if (!mResponseHead->ContentType().IsEmpty() && (
-          mResponseHead->ContentType().Find(".wap") != -1 ||
-          mResponseHead->ContentType().Find("/wml") != -1)) {
-        isWap = true;
-      }
-
-      Telemetry::Accumulate(Telemetry::HTTP_WAP_CONTENT_TYPE_RECEIVED, isWap);
-    }
-#endif
-
     return rv;
 }
 
@@ -2572,7 +2507,6 @@ nsHttpChannel::ProcessNotModified()
                 PipelineFeedbackInfo(mConnectionInfo,
                                      nsHttpConnectionMgr::RedCorruptedContent,
                                      nullptr, 0);
-        Telemetry::Accumulate(Telemetry::CACHE_LM_INCONSISTENT, true);
     }
 
     // merge any new headers with the cached response headers
@@ -2720,11 +2654,6 @@ nsHttpChannel::ContinueProcessFallback(nsresult rv)
     if (NS_FAILED(rv))
         return rv;
 
-    if (mLoadFlags & LOAD_INITIAL_DOCUMENT_URI) {
-        Telemetry::Accumulate(Telemetry::HTTP_OFFLINE_CACHE_DOCUMENT_LOAD,
-                              true);
-    }
-
     // close down this channel
     Cancel(NS_BINDING_REDIRECTED);
 
@@ -3456,11 +3385,6 @@ nsHttpChannel::OnNormalCacheEntryAvailable(nsICacheEntry *aEntry,
     if (NS_SUCCEEDED(aEntryStatus)) {
         mCacheEntry = aEntry;
         mCacheEntryIsWriteOnly = aNew;
-
-        if (mLoadFlags & LOAD_INITIAL_DOCUMENT_URI) {
-            Telemetry::Accumulate(Telemetry::HTTP_OFFLINE_CACHE_DOCUMENT_LOAD,
-                                  false);
-        }
     }
 
     return NS_OK;
@@ -3491,11 +3415,6 @@ nsHttpChannel::OnOfflineCacheEntryAvailable(nsICacheEntry *aEntry,
         mCacheEntry = aEntry;
         mCacheEntryIsWriteOnly = false;
 
-        if (mLoadFlags & LOAD_INITIAL_DOCUMENT_URI && !mApplicationCacheForWrite) {
-            Telemetry::Accumulate(Telemetry::HTTP_OFFLINE_CACHE_DOCUMENT_LOAD,
-                                  true);
-        }
-
         return NS_OK;
     }
 
@@ -4982,12 +4901,9 @@ nsHttpChannel::BeginConnect()
 
         LOG(("nsHttpChannel %p Using connection info from altsvc mapping", this));
         mapping->GetConnectionInfo(getter_AddRefs(mConnectionInfo), proxyInfo);
-        Telemetry::Accumulate(Telemetry::HTTP_TRANSACTION_USE_ALTSVC, true);
-        Telemetry::Accumulate(Telemetry::HTTP_TRANSACTION_USE_ALTSVC_OE, !isHttps);
     } else {
         LOG(("nsHttpChannel %p Using default connection info", this));
         mConnectionInfo = new nsHttpConnectionInfo(host, port, EmptyCString(), mUsername, proxyInfo, isHttps);
-        Telemetry::Accumulate(Telemetry::HTTP_TRANSACTION_USE_ALTSVC, false);
     }
 
     mAuthProvider =
diff --git a/netwerk/protocol/http/nsHttpConnection.cpp b/netwerk/protocol/http/nsHttpConnection.cpp
index 1cfa354..0d28d30 100644
--- a/netwerk/protocol/http/nsHttpConnection.cpp
+++ b/netwerk/protocol/http/nsHttpConnection.cpp
@@ -15,7 +15,6 @@
 
 #include "ASpdySession.h"
 #include "mozilla/ChaosMode.h"
-#include "mozilla/Telemetry.h"
 #include "nsHttpConnection.h"
 #include "nsHttpHandler.h"
 #include "nsHttpPipeline.h"
@@ -103,18 +102,12 @@ nsHttpConnection::~nsHttpConnection()
     if (!mEverUsedSpdy) {
         LOG(("nsHttpConnection %p performed %d HTTP/1.x transactions\n",
              this, mHttp1xTransactionCount));
-        Telemetry::Accumulate(Telemetry::HTTP_REQUEST_PER_CONN,
-                              mHttp1xTransactionCount);
     }
 
     if (mTotalBytesRead) {
         uint32_t totalKBRead = static_cast<uint32_t>(mTotalBytesRead >> 10);
         LOG(("nsHttpConnection %p read %dkb on connection spdy=%d\n",
              this, totalKBRead, mEverUsedSpdy));
-        Telemetry::Accumulate(mEverUsedSpdy ?
-                              Telemetry::SPDY_KBREAD_PER_CONN :
-                              Telemetry::HTTP_KBREAD_PER_CONN,
-                              totalKBRead);
     }
 }
 
@@ -404,9 +397,15 @@ nsHttpConnection::EnsureNPNComplete(nsresult &aOut0RTTWriteHandshakeValue,
         }
         if (!ealyDataAccepted) {
             uint32_t infoIndex;
+            uint8_t   Version[4];
+            Version[0] = SPDY_VERSION_31;
+            Version[1] = HTTP_VERSION_2;
+            Version[2] = HTTP_VERSION_2_DRAFT_15; // 14 and 15 are aliased
+            Version[3] = HTTP_VERSION_2_DRAFT_15; // 14 and 15 are aliased
+            Version[4] = HTTP_VERSION_2_DRAFT_LATEST;
             const SpdyInformation *info = gHttpHandler->SpdyInfo();
             if (NS_SUCCEEDED(info->GetNPNIndex(negotiatedNPN, &infoIndex))) {
-                StartSpdy(info->Version[infoIndex]);
+                StartSpdy(Version[infoIndex]);
             }
         } else {
           LOG(("nsHttpConnection::EnsureNPNComplete [this=%p] - %d bytes "
@@ -414,7 +413,6 @@ nsHttpConnection::EnsureNPNComplete(nsresult &aOut0RTTWriteHandshakeValue,
           mContentBytesWritten = mContentBytesWritten0RTT;
         }
 
-        Telemetry::Accumulate(Telemetry::SPDY_NPN_CONNECT, UsingSpdy());
     }
 
 npnComplete:
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.cpp b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
index 1456c25..50af135 100644
--- a/netwerk/protocol/http/nsHttpConnectionMgr.cpp
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
@@ -23,7 +23,6 @@
 #include "mozilla/net/DNS.h"
 #include "nsISocketTransport.h"
 #include "nsISSLSocketControl.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/net/DashboardTypes.h"
 #include "NullHttpTransaction.h"
 #include "nsIDNSRecord.h"
@@ -34,8 +33,6 @@
 #include "mozilla/ChaosMode.h"
 #include "mozilla/unused.h"
 
-#include "mozilla/Telemetry.h"
-
 // defined by the socket transport service while active
 extern PRThread *gSocketThread;
 
@@ -895,7 +892,6 @@ nsHttpConnectionMgr::GetSpdyPreferredEnt(nsConnectionEntry *aOriginalEntry)
              "with %s connections. rv=%x isJoined=%d",
              preferred->mConnInfo->Host(), aOriginalEntry->mConnInfo->Host(),
              rv, isJoined));
-        Telemetry::Accumulate(Telemetry::SPDY_NPN_JOIN, false);
         return nullptr;
     }
 
@@ -905,7 +901,6 @@ nsHttpConnectionMgr::GetSpdyPreferredEnt(nsConnectionEntry *aOriginalEntry)
          "so %s will be coalesced with %s",
          preferred->mConnInfo->Host(), aOriginalEntry->mConnInfo->Host(),
          aOriginalEntry->mConnInfo->Host(), preferred->mConnInfo->Host()));
-    Telemetry::Accumulate(Telemetry::SPDY_NPN_JOIN, true);
     return preferred;
 }
 
@@ -1514,14 +1509,6 @@ nsHttpConnectionMgr::MakeNewConnection(nsConnectionEntry *ent,
                 transport->SetConnectionFlags(flags);
             }
 
-            Telemetry::AutoCounter<Telemetry::HTTPCONNMGR_USED_SPECULATIVE_CONN> usedSpeculativeConn;
-            ++usedSpeculativeConn;
-
-            if (ent->mHalfOpens[i]->IsFromPredictor()) {
-              Telemetry::AutoCounter<Telemetry::PREDICTOR_TOTAL_PRECONNECTS_USED> totalPreconnectsUsed;
-              ++totalPreconnectsUsed;
-            }
-
             // return OK because we have essentially opened a new connection
             // by converting a speculative half-open to general use
             return NS_OK;
@@ -1672,14 +1659,6 @@ nsHttpConnectionMgr::AddToShortestPipeline(nsConnectionEntry *ent,
         ent->SetYellowConnection(bestConn);
 
     if (!trans->GetPendingTime().IsNull()) {
-        if (trans->UsesPipelining())
-            AccumulateTimeDelta(
-                Telemetry::TRANSACTION_WAIT_TIME_HTTP_PIPELINES,
-                trans->GetPendingTime(), TimeStamp::Now());
-        else
-            AccumulateTimeDelta(
-                Telemetry::TRANSACTION_WAIT_TIME_HTTP,
-                trans->GetPendingTime(), TimeStamp::Now());
         trans->SetPendingTime(false);
     }
     return true;
@@ -1955,8 +1934,6 @@ nsHttpConnectionMgr::DispatchTransaction(nsConnectionEntry *ent,
         rv = conn->Activate(trans, caps, priority);
         MOZ_ASSERT(NS_SUCCEEDED(rv), "SPDY Cannot Fail Dispatch");
         if (NS_SUCCEEDED(rv) && !trans->GetPendingTime().IsNull()) {
-            AccumulateTimeDelta(Telemetry::TRANSACTION_WAIT_TIME_SPDY,
-                trans->GetPendingTime(), TimeStamp::Now());
             trans->SetPendingTime(false);
         }
         return rv;
@@ -1973,12 +1950,6 @@ nsHttpConnectionMgr::DispatchTransaction(nsConnectionEntry *ent,
     rv = DispatchAbstractTransaction(ent, trans, caps, conn, priority);
 
     if (NS_SUCCEEDED(rv) && !trans->GetPendingTime().IsNull()) {
-        if (trans->UsesPipelining())
-            AccumulateTimeDelta(Telemetry::TRANSACTION_WAIT_TIME_HTTP_PIPELINES,
-                trans->GetPendingTime(), TimeStamp::Now());
-        else
-            AccumulateTimeDelta(Telemetry::TRANSACTION_WAIT_TIME_HTTP,
-                trans->GetPendingTime(), TimeStamp::Now());
         trans->SetPendingTime(false);
     }
     return rv;
@@ -2072,21 +2043,6 @@ nsHttpConnectionMgr::BuildPipeline(nsConnectionEntry *ent,
     return NS_OK;
 }
 
-void
-nsHttpConnectionMgr::ReportProxyTelemetry(nsConnectionEntry *ent)
-{
-    enum { PROXY_NONE = 1, PROXY_HTTP = 2, PROXY_SOCKS = 3, PROXY_HTTPS = 4 };
-
-    if (!ent->mConnInfo->UsingProxy())
-        Telemetry::Accumulate(Telemetry::HTTP_PROXY_TYPE, PROXY_NONE);
-    else if (ent->mConnInfo->UsingHttpsProxy())
-        Telemetry::Accumulate(Telemetry::HTTP_PROXY_TYPE, PROXY_HTTPS);
-    else if (ent->mConnInfo->UsingHttpProxy())
-        Telemetry::Accumulate(Telemetry::HTTP_PROXY_TYPE, PROXY_HTTP);
-    else
-        Telemetry::Accumulate(Telemetry::HTTP_PROXY_TYPE, PROXY_SOCKS);
-}
-
 nsresult
 nsHttpConnectionMgr::ProcessNewTransaction(nsHttpTransaction *trans)
 {
@@ -2128,8 +2084,6 @@ nsHttpConnectionMgr::ProcessNewTransaction(nsHttpTransaction *trans)
         ent = preferredEntry;
     }
 
-    ReportProxyTelemetry(ent);
-
     // Check if the transaction already has a sticky reference to a connection.
     // If so, then we can just use it directly by transferring its reference
     // to the new connection variable instead of searching for a new one
@@ -2228,13 +2182,9 @@ nsHttpConnectionMgr::CreateTransport(nsConnectionEntry *ent,
     if (speculative) {
         sock->SetSpeculative(true);
         sock->SetAllow1918(allow1918);
-        Telemetry::AutoCounter<Telemetry::HTTPCONNMGR_TOTAL_SPECULATIVE_CONN> totalSpeculativeConn;
-        ++totalSpeculativeConn;
 
         if (isFromPredictor) {
           sock->SetIsFromPredictor(true);
-          Telemetry::AutoCounter<Telemetry::PREDICTOR_TOTAL_PRECONNECTS_CREATED> totalPreconnectsCreated;
-          ++totalPreconnectsCreated;
         }
     }
 
@@ -3964,16 +3914,6 @@ nsConnectionEntry::RemoveHalfOpen(nsHalfOpenSocket *halfOpen)
     // will result in it not being present in the halfopen table. That's expected.
     if (mHalfOpens.RemoveElement(halfOpen)) {
 
-        if (halfOpen->IsSpeculative()) {
-            Telemetry::AutoCounter<Telemetry::HTTPCONNMGR_UNUSED_SPECULATIVE_CONN> unusedSpeculativeConn;
-            ++unusedSpeculativeConn;
-
-            if (halfOpen->IsFromPredictor()) {
-                Telemetry::AutoCounter<Telemetry::PREDICTOR_TOTAL_PRECONNECTS_UNUSED> totalPreconnectsUnused;
-                ++totalPreconnectsUnused;
-            }
-        }
-
         MOZ_ASSERT(gHttpHandler->ConnMgr()->mNumHalfOpenConns);
         if (gHttpHandler->ConnMgr()->mNumHalfOpenConns) { // just in case
             gHttpHandler->ConnMgr()->mNumHalfOpenConns--;
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.h b/netwerk/protocol/http/nsHttpConnectionMgr.h
index 2e9f7ee..63d1cac 100644
--- a/netwerk/protocol/http/nsHttpConnectionMgr.h
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.h
@@ -570,7 +570,6 @@ private:
     nsresult ProcessNewTransaction(nsHttpTransaction *);
     nsresult EnsureSocketThreadTarget();
     void     ClosePersistentConnections(nsConnectionEntry *ent);
-    void     ReportProxyTelemetry(nsConnectionEntry *ent);
     nsresult CreateTransport(nsConnectionEntry *, nsAHttpTransaction *,
                              uint32_t, bool, bool, bool);
     void     AddActiveConn(nsHttpConnection *, nsConnectionEntry *);
diff --git a/netwerk/protocol/http/nsHttpHandler.cpp b/netwerk/protocol/http/nsHttpHandler.cpp
index 8c61bf8..528f70a 100644
--- a/netwerk/protocol/http/nsHttpHandler.cpp
+++ b/netwerk/protocol/http/nsHttpHandler.cpp
@@ -50,7 +50,6 @@
 #include "nsINetworkLinkService.h"
 
 #include "mozilla/net/NeckoChild.h"
-#include "mozilla/Telemetry.h"
 
 #if defined(XP_UNIX)
 #include <sys/utsname.h>
@@ -84,7 +83,6 @@ extern PRThread *gSocketThread;
 #define BROWSER_PREF_PREFIX     "browser.cache."
 #define DONOTTRACK_HEADER_ENABLED "privacy.donottrackheader.enabled"
 #define H2MANDATORY_SUITE        "security.ssl3.ecdhe_rsa_aes_128_gcm_sha256"
-#define TELEMETRY_ENABLED        "toolkit.telemetry.enabled"
 #define ALLOW_EXPERIMENTS        "network.allow-experiments"
 #define SAFE_HINT_HEADER_VALUE   "safeHint.enabled"
 
@@ -177,8 +175,6 @@ nsHttpHandler::nsHttpHandler()
     , mDoNotTrackEnabled(false)
     , mSafeHintEnabled(false)
     , mParentalControlEnabled(false)
-    , mTelemetryEnabled(false)
-    , mAllowExperiments(true)
     , mHandlerActive(false)
     , mEnableSpdy(false)
     , mSpdyV31(true)
@@ -275,7 +271,6 @@ nsHttpHandler::Init()
         prefBranch->AddObserver(INTL_ACCEPT_LANGUAGES, this, true);
         prefBranch->AddObserver(BROWSER_PREF("disk_cache_ssl"), this, true);
         prefBranch->AddObserver(DONOTTRACK_HEADER_ENABLED, this, true);
-        prefBranch->AddObserver(TELEMETRY_ENABLED, this, true);
         prefBranch->AddObserver(H2MANDATORY_SUITE, this, true);
         prefBranch->AddObserver(HTTP_PREF("tcp_keepalive.short_lived_connections"), this, true);
         prefBranch->AddObserver(HTTP_PREF("tcp_keepalive.long_lived_connections"), this, true);
@@ -1448,19 +1443,6 @@ nsHttpHandler::PrefsChanged(nsIPrefBranch *prefs, const char *pref)
     // includes telemetry and allow-experiments because of the abtest profile
     bool requestTokenBucketUpdated = false;
 
-    //
-    // Telemetry
-    //
-
-    if (PREF_CHANGED(TELEMETRY_ENABLED)) {
-        cVar = false;
-        requestTokenBucketUpdated = true;
-        rv = prefs->GetBoolPref(TELEMETRY_ENABLED, &cVar);
-        if (NS_SUCCEEDED(rv)) {
-            mTelemetryEnabled = cVar;
-        }
-    }
-
     // "security.ssl3.ecdhe_rsa_aes_128_gcm_sha256" is the required h2 interop
     // suite.
 
@@ -1472,48 +1454,6 @@ nsHttpHandler::PrefsChanged(nsIPrefBranch *prefs, const char *pref)
         }
     }
 
-    //
-    // network.allow-experiments
-    //
-    if (PREF_CHANGED(ALLOW_EXPERIMENTS)) {
-        cVar = true;
-        requestTokenBucketUpdated = true;
-        rv = prefs->GetBoolPref(ALLOW_EXPERIMENTS, &cVar);
-        if (NS_SUCCEEDED(rv)) {
-            mAllowExperiments = cVar;
-        }
-    }
-
-    //
-    // Test HTTP Pipelining (bug796192)
-    // If experiments are allowed and pipelining is Off,
-    // turn it On for just 10 minutes
-    //
-    if (mAllowExperiments && !mPipeliningEnabled &&
-        PREF_CHANGED(HTTP_PREF("pipelining.abtest"))) {
-        rv = prefs->GetBoolPref(HTTP_PREF("pipelining.abtest"), &cVar);
-        if (NS_SUCCEEDED(rv)) {
-            // If option is enabled, only test for ~1% of sessions
-            if (cVar && !(rand() % 128)) {
-                mCapabilities |=  NS_HTTP_ALLOW_PIPELINING;
-                if (mPipelineTestTimer)
-                    mPipelineTestTimer->Cancel();
-                mPipelineTestTimer =
-                    do_CreateInstance("@mozilla.org/timer;1", &rv);
-                if (NS_SUCCEEDED(rv)) {
-                    rv = mPipelineTestTimer->InitWithFuncCallback(
-                        TimerCallback, this, 10*60*1000, // 10 minutes
-                        nsITimer::TYPE_ONE_SHOT);
-                }
-            } else {
-                mCapabilities &= ~NS_HTTP_ALLOW_PIPELINING;
-                if (mPipelineTestTimer) {
-                    mPipelineTestTimer->Cancel();
-                    mPipelineTestTimer = nullptr;
-                }
-            }
-        }
-    }
     if (requestTokenBucketUpdated) {
         MakeNewRequestTokenBucket();
     }
@@ -2004,11 +1944,6 @@ nsHttpHandler::Observe(nsISupports *subject,
         // depend on this value.
         mSessionStartTime = NowInSeconds();
 
-        if (!mDoNotTrackEnabled) {
-            Telemetry::Accumulate(Telemetry::DNT_USAGE, 2);
-        } else {
-            Telemetry::Accumulate(Telemetry::DNT_USAGE, 1);
-        }
     } else if (!strcmp(topic, "profile-change-net-restore")) {
         // initialize connection manager
         InitConnectionMgr();
diff --git a/netwerk/protocol/http/nsHttpHandler.h b/netwerk/protocol/http/nsHttpHandler.h
index f37beea..f599eb0 100644
--- a/netwerk/protocol/http/nsHttpHandler.h
+++ b/netwerk/protocol/http/nsHttpHandler.h
@@ -92,8 +92,6 @@ public:
     bool           EnforceAssocReq()         { return mEnforceAssocReq; }
 
     bool           IsPersistentHttpsCachingEnabled() { return mEnablePersistentHttpsCaching; }
-    bool           IsTelemetryEnabled() { return mTelemetryEnabled; }
-    bool           AllowExperiments() { return mTelemetryEnabled && mAllowExperiments; }
 
     bool           IsSpdyEnabled() { return mEnableSpdy; }
     bool           IsSpdyV31Enabled() { return mSpdyV31; }
@@ -464,12 +462,6 @@ private:
     bool           mSafeHintEnabled;
     bool           mParentalControlEnabled;
 
-    // Whether telemetry is reported or not
-    uint32_t           mTelemetryEnabled : 1;
-
-    // The value of network.allow-experiments
-    uint32_t           mAllowExperiments : 1;
-
     // true in between init and shutdown states
     uint32_t           mHandlerActive : 1;
 
diff --git a/netwerk/protocol/rtsp/controller/RtspController.cpp b/netwerk/protocol/rtsp/controller/RtspController.cpp
index 5d5b9b7..77074dd 100644
--- a/netwerk/protocol/rtsp/controller/RtspController.cpp
+++ b/netwerk/protocol/rtsp/controller/RtspController.cpp
@@ -32,7 +32,6 @@
 #include "nsProxyRelease.h"
 #include "nsNetUtil.h"
 #include "mozilla/Attributes.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/TimeStamp.h"
 #include "prlog.h"
 
diff --git a/netwerk/protocol/websocket/WebSocketChannel.cpp b/netwerk/protocol/websocket/WebSocketChannel.cpp
index f30b386..626c64b 100644
--- a/netwerk/protocol/websocket/WebSocketChannel.cpp
+++ b/netwerk/protocol/websocket/WebSocketChannel.cpp
@@ -50,7 +50,6 @@
 #include "nsProxyRelease.h"
 #include "nsNetUtil.h"
 #include "mozilla/StaticMutex.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/TimeStamp.h"
 #include "mozilla/CheckedInt.h"
 
@@ -2709,36 +2708,6 @@ WebSocketChannel::StartWebsocketData()
   return mSocketIn->AsyncWait(this, 0, 0, mSocketThread);
 }
 
-void
-WebSocketChannel::ReportConnectionTelemetry()
-{ 
-  // 3 bits are used. high bit is for wss, middle bit for failed,
-  // and low bit for proxy..
-  // 0 - 7 : ws-ok-plain, ws-ok-proxy, ws-failed-plain, ws-failed-proxy,
-  //         wss-ok-plain, wss-ok-proxy, wss-failed-plain, wss-failed-proxy
-
-  bool didProxy = false;
-
-  nsCOMPtr<nsIProxyInfo> pi;
-  nsCOMPtr<nsIProxiedChannel> pc = do_QueryInterface(mChannel);
-  if (pc)
-    pc->GetProxyInfo(getter_AddRefs(pi));
-  if (pi) {
-    nsAutoCString proxyType;
-    pi->GetType(proxyType);
-    if (!proxyType.IsEmpty() &&
-        !proxyType.EqualsLiteral("direct"))
-      didProxy = true;
-  }
-
-  uint8_t value = (mEncrypted ? (1 << 2) : 0) | 
-    (!mGotUpgradeOK ? (1 << 1) : 0) |
-    (didProxy ? (1 << 0) : 0);
-
-  LOG(("WebSocketChannel::ReportConnectionTelemetry() %p %d", this, value));
-  Telemetry::Accumulate(Telemetry::WEBSOCKETS_HANDSHAKE_TYPE, value);
-}
-
 // nsIDNSListener
 
 NS_IMETHODIMP
@@ -3547,8 +3516,6 @@ WebSocketChannel::OnStopRequest(nsIRequest *aRequest,
        this, aRequest, aContext, aStatusCode));
   MOZ_ASSERT(NS_IsMainThread(), "not main thread");
 
-  ReportConnectionTelemetry();
-
   // This is the end of the HTTP upgrade transaction, the
   // upgraded streams live on
 
diff --git a/netwerk/protocol/websocket/WebSocketChannel.h b/netwerk/protocol/websocket/WebSocketChannel.h
index 77a919a..1881d49 100644
--- a/netwerk/protocol/websocket/WebSocketChannel.h
+++ b/netwerk/protocol/websocket/WebSocketChannel.h
@@ -151,7 +151,6 @@ private:
   nsresult DoAdmissionDNS();
   nsresult StartWebsocketData();
   uint16_t ResultToCloseCode(nsresult resultCode);
-  void     ReportConnectionTelemetry();
 
   void StopSession(nsresult reason);
   void AbortSession(nsresult reason);
diff --git a/security/manager/boot/public/moz.build b/security/manager/boot/public/moz.build
index b0879c6..96652bb 100644
--- a/security/manager/boot/public/moz.build
+++ b/security/manager/boot/public/moz.build
@@ -7,7 +7,6 @@
 XPIDL_SOURCES += [
     'nsIBufEntropyCollector.idl',
     'nsICertBlocklist.idl',
-    'nsISecurityUITelemetry.idl',
     'nsISSLStatusProvider.idl',
 ]
 
diff --git a/security/manager/boot/public/nsISecurityUITelemetry.idl b/security/manager/boot/public/nsISecurityUITelemetry.idl
deleted file mode 100644
index dd15d16..0000000
--- a/security/manager/boot/public/nsISecurityUITelemetry.idl
+++ /dev/null
@@ -1,146 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "nsISupports.idl"
-
-[scriptable, uuid(f7259bf4-1f2b-4e9e-8983-1978cc076fa1)]
-
-interface nsISecurityUITelemetry : nsISupports {
-
-/*
- * Addon installation warnings
- */
-
-// Firefox prevented this site from asking you to install addon
-const uint32_t WARNING_ADDON_ASKING_PREVENTED = 1;
-// User clicks through and allows site to ask to install addons
-const uint32_t WARNING_ADDON_ASKING_PREVENTED_CLICK_THROUGH = 2;
-// Are you sure you want to install this addon? Only install addons you trust
-const uint32_t WARNING_CONFIRM_ADDON_INSTALL = 3;
-// User clicked she is sure after waiting 3secs
-const uint32_t WARNING_CONFIRM_ADDON_INSTALL_CLICK_THROUGH  = 4;
-
-
-/*
- * modal dialogs/warnings 
- */
-
-//     removed WARNING_ENTERING_SECURE_SITE = 5;
-//     removed WARNING_ENTERING_WEAK_SITE = 6;
-//     removed WARNING_LEAVING_SECURE_SITE = 7;
-//     removed WARNING_MIXED_CONTENT  = 8;
-
-// For confirmation dialogs, the clickthrough constant needs to be 1
-// more than the dialog constant so that
-// WARNING_CONFIRM_<X> + 1 == WARNING_CONFIRM_<X>_CLICK_THROUGH
-const uint32_t WARNING_CONFIRM_POST_TO_INSECURE_FROM_SECURE = 9;
-const uint32_t WARNING_CONFIRM_POST_TO_INSECURE_FROM_SECURE_CLICK_THROUGH = 10;
-//     removed WARNING_CONFIRM_POST_TO_INSECURE_FROM_INSECURE = 11;
-//     removed WARNING_CONFIRM_POST_TO_INSECURE_FROM_INSECURE_CLICK_THROUGH = 12;
-
-/*
- * Phishing / Malware page warnings
- * deprecated: we use the _TOP and _FRAME versions below
- */
-
-const uint32_t WARNING_MALWARE_PAGE = 13;
-const uint32_t WARNING_MALWARE_PAGE_WHY_BLOCKED = 14;
-const uint32_t WARNING_MALWARE_PAGE_GET_ME_OUT_OF_HERE = 15;
-const uint32_t WARNING_MALWARE_PAGE_IGNORE_WARNING = 16;
-
-const uint32_t WARNING_PHISHING_PAGE = 17;
-const uint32_t WARNING_PHISHING_PAGE_WHY_BLOCKED = 18;
-const uint32_t WARNING_PHISHING_PAGE_GET_ME_OUT_OF_HERE = 19;
-const uint32_t WARNING_PHISHING_PAGE_IGNORE_WARNING = 20;
-
-/* 
- * SSL Error dialogs
- * deprecated: we use the _TOP versions below
- */
-
-const uint32_t WARNING_BAD_CERT = 21;
-const uint32_t WARNING_BAD_CERT_STS = 22;
-const uint32_t WARNING_BAD_CERT_CLICK_ADD_EXCEPTION = 23;
-const uint32_t WARNING_BAD_CERT_CLICK_VIEW_CERT = 24;
-const uint32_t WARNING_BAD_CERT_DONT_REMEMBER_EXCEPTION = 25;
-const uint32_t WARNING_BAD_CERT_GET_ME_OUT_OF_HERE = 27;
-const uint32_t WARNING_BAD_CERT_UNDERSTAND_RISKS = 28;
-const uint32_t WARNING_BAD_CERT_TECHINICAL_DETAILS = 29;
-
-/*
- * Note that if we add more possibilities in the warning dialogs,
- * it is a new experiment and we shouldn't reuse these buckets.
- */
-const uint32_t WARNING_BAD_CERT_ADD_EXCEPTION_BASE = 30;
-const uint32_t WARNING_BAD_CERT_ADD_EXCEPTION_FLAG_UNTRUSTED = 1;
-const uint32_t WARNING_BAD_CERT_ADD_EXCEPTION_FLAG_DOMAIN = 2;
-const uint32_t WARNING_BAD_CERT_ADD_EXCEPTION_FLAG_TIME = 4;
-
-const uint32_t WARNING_BAD_CERT_CONFIRM_ADD_EXCEPTION_BASE = 38;
-const uint32_t WARNING_BAD_CERT_CONFIRM_ADD_EXCEPTION_FLAG_UNTRUSTED = 1;
-const uint32_t WARNING_BAD_CERT_CONFIRM_ADD_EXCEPTION_FLAG_DOMAIN = 2;
-const uint32_t WARNING_BAD_CERT_CONFIRM_ADD_EXCEPTION_FLAG_TIME = 4;
-// This uses up buckets till 45
-
-/*
- * Geolocation Popup Telemetry
- */
-
-const uint32_t WARNING_GEOLOCATION_REQUEST = 46;
-const uint32_t WARNING_GEOLOCATION_REQUEST_SHARE_LOCATION = 47;
-const uint32_t WARNING_GEOLOCATION_REQUEST_ALWAYS_SHARE = 48;
-const uint32_t WARNING_GEOLOCATION_REQUEST_NEVER_SHARE = 49;
-// It would be nice to measure the two cases of user clicking
-// "not now", and user closing the popup. This is currently not implemented.
-
-/*
- * Firefox Update Errors: UI is only thrown after 
- * repeated errors. We only measure when the UI is shown.
- */
-const uint32_t WARNING_INSECURE_UPDATE = 50;
-const uint32_t WARNING_NO_SECURE_UPDATE = 51;
-
-const uint32_t WARNING_MALWARE_PAGE_TOP = 52;
-const uint32_t WARNING_MALWARE_PAGE_TOP_WHY_BLOCKED = 53;
-const uint32_t WARNING_MALWARE_PAGE_TOP_GET_ME_OUT_OF_HERE = 54;
-const uint32_t WARNING_MALWARE_PAGE_TOP_IGNORE_WARNING = 55;
-
-const uint32_t WARNING_PHISHING_PAGE_TOP = 56;
-const uint32_t WARNING_PHISHING_PAGE_TOP_WHY_BLOCKED = 57;
-const uint32_t WARNING_PHISHING_PAGE_TOP_GET_ME_OUT_OF_HERE = 58;
-const uint32_t WARNING_PHISHING_PAGE_TOP_IGNORE_WARNING = 59;
-
-const uint32_t WARNING_MALWARE_PAGE_FRAME = 60;
-const uint32_t WARNING_MALWARE_PAGE_FRAME_WHY_BLOCKED = 61;
-const uint32_t WARNING_MALWARE_PAGE_FRAME_GET_ME_OUT_OF_HERE = 62;
-const uint32_t WARNING_MALWARE_PAGE_FRAME_IGNORE_WARNING = 63;
-
-const uint32_t WARNING_PHISHING_PAGE_FRAME = 64;
-const uint32_t WARNING_PHISHING_PAGE_FRAME_WHY_BLOCKED = 65;
-const uint32_t WARNING_PHISHING_PAGE_FRAME_GET_ME_OUT_OF_HERE = 66;
-const uint32_t WARNING_PHISHING_PAGE_FRAME_IGNORE_WARNING = 67;
-
-const uint32_t WARNING_BAD_CERT_TOP = 68;
-const uint32_t WARNING_BAD_CERT_TOP_STS = 69;
-const uint32_t WARNING_BAD_CERT_TOP_CLICK_ADD_EXCEPTION = 70;
-const uint32_t WARNING_BAD_CERT_TOP_CLICK_VIEW_CERT = 71;
-const uint32_t WARNING_BAD_CERT_TOP_DONT_REMEMBER_EXCEPTION = 72;
-const uint32_t WARNING_BAD_CERT_TOP_GET_ME_OUT_OF_HERE = 73;
-const uint32_t WARNING_BAD_CERT_TOP_UNDERSTAND_RISKS = 74;
-const uint32_t WARNING_BAD_CERT_TOP_TECHNICAL_DETAILS = 75;
-
-const uint32_t WARNING_BAD_CERT_TOP_ADD_EXCEPTION_BASE = 76;
-const uint32_t WARNING_BAD_CERT_TOP_ADD_EXCEPTION_FLAG_UNTRUSTED = 1;
-const uint32_t WARNING_BAD_CERT_TOP_ADD_EXCEPTION_FLAG_DOMAIN = 2;
-const uint32_t WARNING_BAD_CERT_TOP_ADD_EXCEPTION_FLAG_TIME = 4;
-
-const uint32_t WARNING_BAD_CERT_TOP_CONFIRM_ADD_EXCEPTION_BASE = 84;
-const uint32_t WARNING_BAD_CERT_TOP_CONFIRM_ADD_EXCEPTION_FLAG_UNTRUSTED = 1;
-const uint32_t WARNING_BAD_CERT_TOP_CONFIRM_ADD_EXCEPTION_FLAG_DOMAIN = 2;
-const uint32_t WARNING_BAD_CERT_TOP_CONFIRM_ADD_EXCEPTION_FLAG_TIME = 4;
-// This uses up buckets till 91 (including)
-// We only have buckets up to 100.
-};
diff --git a/security/manager/boot/src/DataStorage.cpp b/security/manager/boot/src/DataStorage.cpp
index 516100f..74c26ee 100644
--- a/security/manager/boot/src/DataStorage.cpp
+++ b/security/manager/boot/src/DataStorage.cpp
@@ -8,7 +8,6 @@
 
 #include "mozilla/Preferences.h"
 #include "mozilla/Services.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/unused.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsDirectoryServiceUtils.h"
@@ -204,8 +203,6 @@ DataStorage::Reader::Run()
       }
     } while (true);
 
-    Telemetry::Accumulate(Telemetry::DATA_STORAGE_ENTRIES,
-                          mDataStorage->mPersistentDataTable.Count());
   }
 
   return NS_OK;
diff --git a/security/manager/boot/src/PublicKeyPinningService.cpp b/security/manager/boot/src/PublicKeyPinningService.cpp
index bb09adb..b212201 100644
--- a/security/manager/boot/src/PublicKeyPinningService.cpp
+++ b/security/manager/boot/src/PublicKeyPinningService.cpp
@@ -6,7 +6,6 @@
 
 #include "cert.h"
 #include "mozilla/Base64.h"
-#include "mozilla/Telemetry.h"
 #include "nsISiteSecurityService.h"
 #include "nssb64.h"
 #include "nsServiceManagerUtils.h"
@@ -16,7 +15,6 @@
 #include "pkix/stdkeywords.h"
 #include "pkix/pkixtypes.h"
 #include "prlog.h"
-#include "RootCertificateTelemetryUtils.h"
 #include "ScopedNSSTypes.h"
 #include "seccomon.h"
 #include "sechash.h"
diff --git a/security/manager/boot/src/RootCertificateTelemetryUtils.cpp b/security/manager/boot/src/RootCertificateTelemetryUtils.cpp
deleted file mode 100644
index 6cb5255..0000000
--- a/security/manager/boot/src/RootCertificateTelemetryUtils.cpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "RootCertificateTelemetryUtils.h"
-
-#include "prlog.h"
-#include "RootHashes.inc" // Note: Generated by genRootCAHashes.js
-#include "ScopedNSSTypes.h"
-#include "mozilla/ArrayUtils.h"
-
-// Note: New CAs will show up as UNKNOWN_ROOT until
-// RootHashes.inc is updated to include them. 0 is reserved by
-// genRootCAHashes.js for the unknowns.
-#define UNKNOWN_ROOT  0
-#define HASH_FAILURE -1
-
-namespace mozilla { namespace psm { 
-
-#if defined(PR_LOGGING)
-PRLogModuleInfo* gPublicKeyPinningTelemetryLog =
-  PR_NewLogModule("PublicKeyPinningTelemetryService");
-#endif
-
-// Used in the BinarySearch method, this does a memcmp between the pointer
-// provided to its construtor and whatever the binary search is looking for.
-//
-// This implementation assumes everything to be of HASH_LEN, so it should not
-// be used generically.
-class BinaryHashSearchArrayComparator
-{
-public:
-  explicit BinaryHashSearchArrayComparator(const uint8_t* aTarget, size_t len)
-    : mTarget(aTarget)
-  {
-    NS_ASSERTION(len == HASH_LEN, "Hashes should be of the same length.");
-  }
-
-  int operator()(const CertAuthorityHash val) const {
-    return memcmp(mTarget, val.hash, HASH_LEN);
-  }
-
-private:
-  const uint8_t* mTarget;
-};
-
-// Perform a hash of the provided cert, then search in the RootHashes.inc data
-// structure for a matching bin number.
-int32_t
-RootCABinNumber(const SECItem* cert)
-{
-  Digest digest;
-
-  // Compute SHA256 hash of the certificate
-  nsresult rv = digest.DigestBuf(SEC_OID_SHA256, cert->data, cert->len);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return HASH_FAILURE;
-  }
-
-  // Compare against list of stored hashes
-  size_t idx;
-
-  PR_LOG(gPublicKeyPinningTelemetryLog, PR_LOG_DEBUG,
-           ("pkpinTelem: First bytes %02hx %02hx %02hx %02hx\n",
-            digest.get().data[0], digest.get().data[1], digest.get().data[2], digest.get().data[3]));
-
-  if (mozilla::BinarySearchIf(ROOT_TABLE, 0, ArrayLength(ROOT_TABLE),
-          BinaryHashSearchArrayComparator(
-            reinterpret_cast<const uint8_t*>(digest.get().data), digest.get().len),
-         &idx)) {
-
-    PR_LOG(gPublicKeyPinningTelemetryLog, PR_LOG_DEBUG,
-          ("pkpinTelem: Telemetry index was %lu, bin is %d\n",
-           idx, ROOT_TABLE[idx].binNumber));
-    return (int32_t) ROOT_TABLE[idx].binNumber;
-  }
-
-  // Didn't match.
-  return UNKNOWN_ROOT;
-}
-
-
-// Attempt to increment the appropriate bin in the provided Telemetry probe ID. If
-// there was a hash failure, we do nothing.
-void
-AccumulateTelemetryForRootCA(mozilla::Telemetry::ID probe, 
-  const CERTCertificate* cert)
-{
-  int32_t binId = RootCABinNumber(&cert->derCert);
-
-  if (binId != HASH_FAILURE) {
-    Accumulate(probe, binId);
-  }
-}
-
-} // namespace psm
-} // namespace mozilla
\ No newline at end of file
diff --git a/security/manager/boot/src/RootCertificateTelemetryUtils.h b/security/manager/boot/src/RootCertificateTelemetryUtils.h
deleted file mode 100644
index 7ed3e54..0000000
--- a/security/manager/boot/src/RootCertificateTelemetryUtils.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef RootCertificateTelemetryUtils_h
-#define RootCertificateTelemetryUtils_h
-
-#include "mozilla/Telemetry.h"
-#include "certt.h"
-
-namespace mozilla { namespace psm {
-
-void
-AccumulateTelemetryForRootCA(mozilla::Telemetry::ID probe, const CERTCertificate* cert);
-
-} // namespace psm
-} // namespace mozilla
-
-#endif // RootCertificateTelemetryUtils_h
diff --git a/security/manager/boot/src/RootHashes.inc b/security/manager/boot/src/RootHashes.inc
deleted file mode 100644
index 949b84d..0000000
--- a/security/manager/boot/src/RootHashes.inc
+++ /dev/null
@@ -1,924 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-/*****************************************************************************/
-/* This is an automatically generated file. If you're not                    */
-/* RootCertificateTelemetryUtils.cpp, you shouldn't be #including it.        */
-/*****************************************************************************/
-
-#define HASH_LEN 32
-struct CertAuthorityHash {
- const uint8_t hash[HASH_LEN];
- const int32_t binNumber;
-};
-
-static const struct CertAuthorityHash ROOT_TABLE[] = {
-  {
-    /* Entrust_Root_Certification_Authority___EC1 */
-    { 0x02, 0xED, 0x0E, 0xB2, 0x8C, 0x14, 0xDA, 0x45, 0x16, 0x5C, 0x56, 0x67, 0x91, 0x70, 0x0D, 0x64,
-      0x51, 0xD7, 0xFB, 0x56, 0xF0, 0xB2, 0xAB, 0x1D, 0x3B, 0x8E, 0xB0, 0x70, 0xE5, 0x6E, 0xDF, 0xF5 },
-      147 /* Bin Number */
-  },
-  {
-    /* AffirmTrust_Commercial */
-    { 0x03, 0x76, 0xAB, 0x1D, 0x54, 0xC5, 0xF9, 0x80, 0x3C, 0xE4, 0xB2, 0xE2, 0x01, 0xA0, 0xEE, 0x7E,
-      0xEF, 0x7B, 0x57, 0xB6, 0x36, 0xE8, 0xA9, 0x3C, 0x9B, 0x8D, 0x48, 0x60, 0xC9, 0x6F, 0x5F, 0xA7 },
-      93 /* Bin Number */
-  },
-  {
-    /* ACEDICOM_Root */
-    { 0x03, 0x95, 0x0F, 0xB4, 0x9A, 0x53, 0x1F, 0x3E, 0x19, 0x91, 0x94, 0x23, 0x98, 0xDF, 0xA9, 0xE0,
-      0xEA, 0x32, 0xD7, 0xBA, 0x1C, 0xDD, 0x9B, 0xC8, 0x5D, 0xB5, 0x7E, 0xD9, 0x40, 0x0B, 0x43, 0x4A },
-      83 /* Bin Number */
-  },
-  {
-    /* Autoridad_de_Certificacion_Firmaprofesional_CIF_A62634068 */
-    { 0x04, 0x04, 0x80, 0x28, 0xBF, 0x1F, 0x28, 0x64, 0xD4, 0x8F, 0x9A, 0xD4, 0xD8, 0x32, 0x94, 0x36,
-      0x6A, 0x82, 0x88, 0x56, 0x55, 0x3F, 0x3B, 0x14, 0x30, 0x3F, 0x90, 0x14, 0x7F, 0x5D, 0x40, 0xEF },
-      86 /* Bin Number */
-  },
-  {
-    /* Chambers_of_Commerce_Root___2008 */
-    { 0x06, 0x3E, 0x4A, 0xFA, 0xC4, 0x91, 0xDF, 0xD3, 0x32, 0xF3, 0x08, 0x9B, 0x85, 0x42, 0xE9, 0x46,
-      0x17, 0xD8, 0x93, 0xD7, 0xFE, 0x94, 0x4E, 0x10, 0xA7, 0x93, 0x7E, 0xE2, 0x9D, 0x96, 0x93, 0xC0 },
-      88 /* Bin Number */
-  },
-  {
-    /* DST_Root_CA_X3 */
-    { 0x06, 0x87, 0x26, 0x03, 0x31, 0xA7, 0x24, 0x03, 0xD9, 0x09, 0xF1, 0x05, 0xE6, 0x9B, 0xCF, 0x0D,
-      0x32, 0xE1, 0xBD, 0x24, 0x93, 0xFF, 0xC6, 0xD9, 0x20, 0x6D, 0x11, 0xBC, 0xD6, 0x77, 0x07, 0x39 },
-      44 /* Bin Number */
-  },
-  {
-    /* AddTrust_Public_CA_Root */
-    { 0x07, 0x91, 0xCA, 0x07, 0x49, 0xB2, 0x07, 0x82, 0xAA, 0xD3, 0xC7, 0xD7, 0xBD, 0x0C, 0xDF, 0xC9,
-      0x48, 0x58, 0x35, 0x84, 0x3E, 0xB2, 0xD7, 0x99, 0x60, 0x09, 0xCE, 0x43, 0xAB, 0x6C, 0x69, 0x27 },
-      10 /* Bin Number */
-  },
-  {
-    /* OU_Equifax_Secure_Certificate_Authority_O_Equifax_C_US */
-    { 0x08, 0x29, 0x7A, 0x40, 0x47, 0xDB, 0xA2, 0x36, 0x80, 0xC7, 0x31, 0xDB, 0x6E, 0x31, 0x76, 0x53,
-      0xCA, 0x78, 0x48, 0xE1, 0xBE, 0xBD, 0x3A, 0x0B, 0x01, 0x79, 0xA7, 0x07, 0xF9, 0x2C, 0xF1, 0x78 },
-      1 /* Bin Number */
-  },
-  {
-    /* AffirmTrust_Networking */
-    { 0x0A, 0x81, 0xEC, 0x5A, 0x92, 0x97, 0x77, 0xF1, 0x45, 0x90, 0x4A, 0xF3, 0x8D, 0x5D, 0x50, 0x9F,
-      0x66, 0xB5, 0xE2, 0xC5, 0x8F, 0xCD, 0xB5, 0x31, 0x05, 0x8B, 0x0E, 0x17, 0xF3, 0xF0, 0xB4, 0x1B },
-      94 /* Bin Number */
-  },
-  {
-    /* Chambers_of_Commerce_Root */
-    { 0x0C, 0x25, 0x8A, 0x12, 0xA5, 0x67, 0x4A, 0xEF, 0x25, 0xF2, 0x8B, 0xA7, 0xDC, 0xFA, 0xEC, 0xEE,
-      0xA3, 0x48, 0xE5, 0x41, 0xE6, 0xF5, 0xCC, 0x4E, 0xE6, 0x3B, 0x71, 0xB3, 0x61, 0x60, 0x6A, 0xC3 },
-      31 /* Bin Number */
-  },
-  {
-    /* COMODO_Certification_Authority */
-    { 0x0C, 0x2C, 0xD6, 0x3D, 0xF7, 0x80, 0x6F, 0xA3, 0x99, 0xED, 0xE8, 0x09, 0x11, 0x6B, 0x57, 0x5B,
-      0xF8, 0x79, 0x89, 0xF0, 0x65, 0x18, 0xF9, 0x80, 0x8C, 0x86, 0x05, 0x03, 0x17, 0x8B, 0xAF, 0x66 },
-      54 /* Bin Number */
-  },
-  {
-    /* Buypass_Class_2_CA_1 */
-    { 0x0F, 0x4E, 0x9C, 0xDD, 0x26, 0x4B, 0x02, 0x55, 0x50, 0xD1, 0x70, 0x80, 0x63, 0x40, 0x21, 0x4F,
-      0xE9, 0x44, 0x34, 0xC9, 0xB0, 0x2F, 0x69, 0x7E, 0xC7, 0x10, 0xFC, 0x5F, 0xEA, 0xFB, 0x5E, 0x38 },
-      67 /* Bin Number */
-  },
-  {
-    /* Class_2_Primary_CA */
-    { 0x0F, 0x99, 0x3C, 0x8A, 0xEF, 0x97, 0xBA, 0xAF, 0x56, 0x87, 0x14, 0x0E, 0xD5, 0x9A, 0xD1, 0x82,
-      0x1B, 0xB4, 0xAF, 0xAC, 0xF0, 0xAA, 0x9A, 0x58, 0xB5, 0xD5, 0x7A, 0x33, 0x8A, 0x3A, 0xFB, 0xCB },
-      43 /* Bin Number */
-  },
-  {
-    /* Global_Chambersign_Root___2008 */
-    { 0x13, 0x63, 0x35, 0x43, 0x93, 0x34, 0xA7, 0x69, 0x80, 0x16, 0xA0, 0xD3, 0x24, 0xDE, 0x72, 0x28,
-      0x4E, 0x07, 0x9D, 0x7B, 0x52, 0x20, 0xBB, 0x8F, 0xBD, 0x74, 0x78, 0x16, 0xEE, 0xBE, 0xBA, 0xCA },
-      89 /* Bin Number */
-  },
-  {
-    /* OU_Starfield_Class_2_Certification_Authority_O__Starfield_Technologies__Inc___C_US */
-    { 0x14, 0x65, 0xFA, 0x20, 0x53, 0x97, 0xB8, 0x76, 0xFA, 0xA6, 0xF0, 0xA9, 0x95, 0x8E, 0x55, 0x90,
-      0xE4, 0x0F, 0xCC, 0x7F, 0xAA, 0x4F, 0xB7, 0xC2, 0xC8, 0x67, 0x75, 0x21, 0xFB, 0x5F, 0xB6, 0x58 },
-      36 /* Bin Number */
-  },
-  {
-    /* Network_Solutions_Certificate_Authority */
-    { 0x15, 0xF0, 0xBA, 0x00, 0xA3, 0xAC, 0x7A, 0xF3, 0xAC, 0x88, 0x4C, 0x07, 0x2B, 0x10, 0x11, 0xA0,
-      0x77, 0xBD, 0x77, 0xC0, 0x97, 0xF4, 0x01, 0x64, 0xB2, 0xF8, 0x59, 0x8A, 0xBD, 0x83, 0x86, 0x0C },
-      55 /* Bin Number */
-  },
-  {
-    /* Baltimore_CyberTrust_Root */
-    { 0x16, 0xAF, 0x57, 0xA9, 0xF6, 0x76, 0xB0, 0xAB, 0x12, 0x60, 0x95, 0xAA, 0x5E, 0xBA, 0xDE, 0xF2,
-      0x2A, 0xB3, 0x11, 0x19, 0xD6, 0x44, 0xAC, 0x95, 0xCD, 0x4B, 0x93, 0xDB, 0xF3, 0xF2, 0x6A, 0xEB },
-      7 /* Bin Number */
-  },
-  {
-    /* COMODO_ECC_Certification_Authority */
-    { 0x17, 0x93, 0x92, 0x7A, 0x06, 0x14, 0x54, 0x97, 0x89, 0xAD, 0xCE, 0x2F, 0x8F, 0x34, 0xF7, 0xF0,
-      0xB6, 0x6D, 0x0F, 0x3A, 0xE3, 0xA3, 0xB8, 0x4D, 0x21, 0xEC, 0x15, 0xDB, 0xBA, 0x4F, 0xAD, 0xC7 },
-      57 /* Bin Number */
-  },
-  {
-    /* GlobalSign */
-    { 0x17, 0x9F, 0xBC, 0x14, 0x8A, 0x3D, 0xD0, 0x0F, 0xD2, 0x4E, 0xA1, 0x34, 0x58, 0xCC, 0x43, 0xBF,
-      0xA7, 0xF5, 0x9C, 0x81, 0x82, 0xD7, 0x83, 0xA5, 0x13, 0xF6, 0xEB, 0xEC, 0x10, 0x0C, 0x89, 0x24 },
-      141 /* Bin Number */
-  },
-  {
-    /* QuoVadis_Root_CA_3 */
-    { 0x18, 0xF1, 0xFC, 0x7F, 0x20, 0x5D, 0xF8, 0xAD, 0xDD, 0xEB, 0x7F, 0xE0, 0x07, 0xDD, 0x57, 0xE3,
-      0xAF, 0x37, 0x5A, 0x9C, 0x4D, 0x8D, 0x73, 0x54, 0x6B, 0xF4, 0xF1, 0xFE, 0xD1, 0xE1, 0x8D, 0x35 },
-      25 /* Bin Number */
-  },
-  {
-    /* Swisscom_Root_CA_1 */
-    { 0x21, 0xDB, 0x20, 0x12, 0x36, 0x60, 0xBB, 0x2E, 0xD4, 0x18, 0x20, 0x5D, 0xA1, 0x1E, 0xE7, 0xA8,
-      0x5A, 0x65, 0xE2, 0xBC, 0x6E, 0x55, 0xB5, 0xAF, 0x7E, 0x78, 0x99, 0xC8, 0xA2, 0x66, 0xD9, 0x2E },
-      39 /* Bin Number */
-  },
-  {
-    /* VeriSign_Universal_Root_Certification_Authority */
-    { 0x23, 0x99, 0x56, 0x11, 0x27, 0xA5, 0x71, 0x25, 0xDE, 0x8C, 0xEF, 0xEA, 0x61, 0x0D, 0xDF, 0x2F,
-      0xA0, 0x78, 0xB5, 0xC8, 0x06, 0x7F, 0x4E, 0x82, 0x82, 0x90, 0xBF, 0xB8, 0x60, 0xE8, 0x4B, 0x3C },
-      75 /* Bin Number */
-  },
-  {
-    /* Izenpe_com */
-    { 0x25, 0x30, 0xCC, 0x8E, 0x98, 0x32, 0x15, 0x02, 0xBA, 0xD9, 0x6F, 0x9B, 0x1F, 0xBA, 0x1B, 0x09,
-      0x9E, 0x2D, 0x29, 0x9E, 0x0F, 0x45, 0x48, 0xBB, 0x91, 0x4F, 0x36, 0x3B, 0xC0, 0xD4, 0x53, 0x1F },
-      87 /* Bin Number */
-  },
-  {
-    /* Certinomis___Root_CA */
-    { 0x2A, 0x99, 0xF5, 0xBC, 0x11, 0x74, 0xB7, 0x3C, 0xBB, 0x1D, 0x62, 0x08, 0x84, 0xE0, 0x1C, 0x34,
-      0xE5, 0x1C, 0xCB, 0x39, 0x78, 0xDA, 0x12, 0x5F, 0x0E, 0x33, 0x26, 0x88, 0x83, 0xBF, 0x41, 0x58 },
-      151 /* Bin Number */
-  },
-  {
-    /* Starfield_Root_Certificate_Authority___G2 */
-    { 0x2C, 0xE1, 0xCB, 0x0B, 0xF9, 0xD2, 0xF9, 0xE1, 0x02, 0x99, 0x3F, 0xBE, 0x21, 0x51, 0x52, 0xC3,
-      0xB2, 0xDD, 0x0C, 0xAB, 0xDE, 0x1C, 0x68, 0xE5, 0x31, 0x9B, 0x83, 0x91, 0x54, 0xDB, 0xB7, 0xF5 },
-      91 /* Bin Number */
-  },
-  {
-    /* OU_ApplicationCA_O_Japanese_Government_C_JP */
-    { 0x2D, 0x47, 0x43, 0x7D, 0xE1, 0x79, 0x51, 0x21, 0x5A, 0x12, 0xF3, 0xC5, 0x8E, 0x51, 0xC7, 0x29,
-      0xA5, 0x80, 0x26, 0xEF, 0x1F, 0xCC, 0x0A, 0x5F, 0xB3, 0xD9, 0xDC, 0x01, 0x2F, 0x60, 0x0D, 0x19 },
-      70 /* Bin Number */
-  },
-  {
-    /* IdenTrust_Public_Sector_Root_CA_1 */
-    { 0x30, 0xD0, 0x89, 0x5A, 0x9A, 0x44, 0x8A, 0x26, 0x20, 0x91, 0x63, 0x55, 0x22, 0xD1, 0xF5, 0x20,
-      0x10, 0xB5, 0x86, 0x7A, 0xCA, 0xE1, 0x2C, 0x78, 0xEF, 0x95, 0x8F, 0xD4, 0xF4, 0x38, 0x9F, 0x2F },
-      145 /* Bin Number */
-  },
-  {
-    /* DigiCert_Global_Root_G3 */
-    { 0x31, 0xAD, 0x66, 0x48, 0xF8, 0x10, 0x41, 0x38, 0xC7, 0x38, 0xF3, 0x9E, 0xA4, 0x32, 0x01, 0x33,
-      0x39, 0x3E, 0x3A, 0x18, 0xCC, 0x02, 0x29, 0x6E, 0xF9, 0x7C, 0x2A, 0xC9, 0xEF, 0x67, 0x31, 0xD0 },
-      133 /* Bin Number */
-  },
-  {
-    /* Microsec_e_Szigno_Root_CA */
-    { 0x32, 0x7A, 0x3D, 0x76, 0x1A, 0xBA, 0xDE, 0xA0, 0x34, 0xEB, 0x99, 0x84, 0x06, 0x27, 0x5C, 0xB1,
-      0xA4, 0x77, 0x6E, 0xFD, 0xAE, 0x2F, 0xDF, 0x6D, 0x01, 0x68, 0xEA, 0x1C, 0x4F, 0x55, 0x67, 0xD0 },
-      61 /* Bin Number */
-  },
-  {
-    /* EBG_Elektronik_Sertifika_Hizmet_Sa_lay_c_s_ */
-    { 0x35, 0xAE, 0x5B, 0xDD, 0xD8, 0xF7, 0xAE, 0x63, 0x5C, 0xFF, 0xBA, 0x56, 0x82, 0xA8, 0xF0, 0x0B,
-      0x95, 0xF4, 0x84, 0x62, 0xC7, 0x10, 0x8E, 0xE9, 0xA0, 0xE5, 0x29, 0x2B, 0x07, 0x4A, 0xAF, 0xB2 },
-      68 /* Bin Number */
-  },
-  {
-    /* GeoTrust_Primary_Certification_Authority */
-    { 0x37, 0xD5, 0x10, 0x06, 0xC5, 0x12, 0xEA, 0xAB, 0x62, 0x64, 0x21, 0xF1, 0xEC, 0x8C, 0x92, 0x01,
-      0x3F, 0xC5, 0xF8, 0x2A, 0xE9, 0x8E, 0xE5, 0x33, 0xEB, 0x46, 0x19, 0xB8, 0xDE, 0xB4, 0xD0, 0x6C },
-      49 /* Bin Number */
-  },
-  {
-    /* Staat_der_Nederlanden_Root_CA___G3 */
-    { 0x3C, 0x4F, 0xB0, 0xB9, 0x5A, 0xB8, 0xB3, 0x00, 0x32, 0xF4, 0x32, 0xB8, 0x6F, 0x53, 0x5F, 0xE1,
-      0x72, 0xC1, 0x85, 0xD0, 0xFD, 0x39, 0x86, 0x58, 0x37, 0xCF, 0x36, 0x18, 0x7F, 0xA6, 0xF4, 0x28 },
-      142 /* Bin Number */
-  },
-  {
-    /* Microsec_e_Szigno_Root_CA_2009 */
-    { 0x3C, 0x5F, 0x81, 0xFE, 0xA5, 0xFA, 0xB8, 0x2C, 0x64, 0xBF, 0xA2, 0xEA, 0xEC, 0xAF, 0xCD, 0xE8,
-      0xE0, 0x77, 0xFC, 0x86, 0x20, 0xA7, 0xCA, 0xE5, 0x37, 0x16, 0x3D, 0xF3, 0x6E, 0xDB, 0xF3, 0x78 },
-      84 /* Bin Number */
-  },
-  {
-    /* PSCProcert */
-    { 0x3C, 0xFC, 0x3C, 0x14, 0xD1, 0xF6, 0x84, 0xFF, 0x17, 0xE3, 0x8C, 0x43, 0xCA, 0x44, 0x0C, 0x00,
-      0xB9, 0x67, 0xEC, 0x93, 0x3E, 0x8B, 0xFE, 0x06, 0x4C, 0xA1, 0xD7, 0x2C, 0x90, 0xF2, 0xAD, 0xB0 },
-      116 /* Bin Number */
-  },
-  {
-    /* EE_Certification_Centre_Root_CA */
-    { 0x3E, 0x84, 0xBA, 0x43, 0x42, 0x90, 0x85, 0x16, 0xE7, 0x75, 0x73, 0xC0, 0x99, 0x2F, 0x09, 0x79,
-      0xCA, 0x08, 0x4E, 0x46, 0x85, 0x68, 0x1F, 0xF1, 0x95, 0xCC, 0xBA, 0x8A, 0x22, 0x9B, 0x8A, 0x76 },
-      112 /* Bin Number */
-  },
-  {
-    /* DigiCert_Assured_ID_Root_CA */
-    { 0x3E, 0x90, 0x99, 0xB5, 0x01, 0x5E, 0x8F, 0x48, 0x6C, 0x00, 0xBC, 0xEA, 0x9D, 0x11, 0x1E, 0xE7,
-      0x21, 0xFA, 0xBA, 0x35, 0x5A, 0x89, 0xBC, 0xF1, 0xDF, 0x69, 0x56, 0x1E, 0x3D, 0xC6, 0x32, 0x5C },
-      40 /* Bin Number */
-  },
-  {
-    /* Trusted_Certificate_Services */
-    { 0x3F, 0x06, 0xE5, 0x56, 0x81, 0xD4, 0x96, 0xF5, 0xBE, 0x16, 0x9E, 0xB5, 0x38, 0x9F, 0x9F, 0x2B,
-      0x8F, 0xF6, 0x1E, 0x17, 0x08, 0xDF, 0x68, 0x81, 0x72, 0x48, 0x49, 0xCD, 0x5D, 0x27, 0xCB, 0x69 },
-      22 /* Bin Number */
-  },
-  {
-    /* OISTE_WISeKey_Global_Root_GA_CA */
-    { 0x41, 0xC9, 0x23, 0x86, 0x6A, 0xB4, 0xCA, 0xD6, 0xB7, 0xAD, 0x57, 0x80, 0x81, 0x58, 0x2E, 0x02,
-      0x07, 0x97, 0xA6, 0xCB, 0xDF, 0x4F, 0xFF, 0x78, 0xCE, 0x83, 0x96, 0xB3, 0x89, 0x37, 0xD7, 0xF5 },
-      60 /* Bin Number */
-  },
-  {
-    /* Secure_Global_CA */
-    { 0x42, 0x00, 0xF5, 0x04, 0x3A, 0xC8, 0x59, 0x0E, 0xBB, 0x52, 0x7D, 0x20, 0x9E, 0xD1, 0x50, 0x30,
-      0x29, 0xFB, 0xCB, 0xD4, 0x1C, 0xA1, 0xB5, 0x06, 0xEC, 0x27, 0xF1, 0x5A, 0xDE, 0x7D, 0xAC, 0x69 },
-      53 /* Bin Number */
-  },
-  {
-    /* DigiCert_Global_Root_CA */
-    { 0x43, 0x48, 0xA0, 0xE9, 0x44, 0x4C, 0x78, 0xCB, 0x26, 0x5E, 0x05, 0x8D, 0x5E, 0x89, 0x44, 0xB4,
-      0xD8, 0x4F, 0x96, 0x62, 0xBD, 0x26, 0xDB, 0x25, 0x7F, 0x89, 0x34, 0xA4, 0x43, 0xC7, 0x01, 0x61 },
-      41 /* Bin Number */
-  },
-  {
-    /* Entrust_Root_Certification_Authority___G2 */
-    { 0x43, 0xDF, 0x57, 0x74, 0xB0, 0x3E, 0x7F, 0xEF, 0x5F, 0xE4, 0x0D, 0x93, 0x1A, 0x7B, 0xED, 0xF1,
-      0xBB, 0x2E, 0x6B, 0x42, 0x73, 0x8C, 0x4E, 0x6D, 0x38, 0x41, 0x10, 0x3D, 0x3A, 0xA7, 0xF3, 0x39 },
-      146 /* Bin Number */
-  },
-  {
-    /* Go_Daddy_Root_Certificate_Authority___G2 */
-    { 0x45, 0x14, 0x0B, 0x32, 0x47, 0xEB, 0x9C, 0xC8, 0xC5, 0xB4, 0xF0, 0xD7, 0xB5, 0x30, 0x91, 0xF7,
-      0x32, 0x92, 0x08, 0x9E, 0x6E, 0x5A, 0x63, 0xE2, 0x74, 0x9D, 0xD3, 0xAC, 0xA9, 0x19, 0x8E, 0xDA },
-      90 /* Bin Number */
-  },
-  {
-    /* T_RKTRUST_Elektronik_Sertifika_Hizmet_Sa_lay_c_s__H5 */
-    { 0x49, 0x35, 0x1B, 0x90, 0x34, 0x44, 0xC1, 0x85, 0xCC, 0xDC, 0x5C, 0x69, 0x3D, 0x24, 0xD8, 0x55,
-      0x5C, 0xB2, 0x08, 0xD6, 0xA8, 0x14, 0x13, 0x07, 0x69, 0x9F, 0x4A, 0xF0, 0x63, 0x19, 0x9D, 0x78 },
-      149 /* Bin Number */
-  },
-  {
-    /* D_TRUST_Root_Class_3_CA_2_2009 */
-    { 0x49, 0xE7, 0xA4, 0x42, 0xAC, 0xF0, 0xEA, 0x62, 0x87, 0x05, 0x00, 0x54, 0xB5, 0x25, 0x64, 0xB6,
-      0x50, 0xE4, 0xF4, 0x9E, 0x42, 0xE3, 0x48, 0xD6, 0xAA, 0x38, 0xE0, 0x39, 0xE9, 0x57, 0xB1, 0xC1 },
-      114 /* Bin Number */
-  },
-  {
-    /* thawte_Primary_Root_CA___G3 */
-    { 0x4B, 0x03, 0xF4, 0x58, 0x07, 0xAD, 0x70, 0xF2, 0x1B, 0xFC, 0x2C, 0xAE, 0x71, 0xC9, 0xFD, 0xE4,
-      0x60, 0x4C, 0x06, 0x4C, 0xF5, 0xFF, 0xB6, 0x86, 0xBA, 0xE5, 0xDB, 0xAA, 0xD7, 0xFD, 0xD3, 0x4C },
-      73 /* Bin Number */
-  },
-  {
-    /* Certification_Authority_of_WoSign */
-    { 0x4B, 0x22, 0xD5, 0xA6, 0xAE, 0xC9, 0x9F, 0x3C, 0xDB, 0x79, 0xAA, 0x5E, 0xC0, 0x68, 0x38, 0x47,
-      0x9C, 0xD5, 0xEC, 0xBA, 0x71, 0x64, 0xF7, 0xF2, 0x2D, 0xC1, 0xD6, 0x5F, 0x63, 0xD8, 0x57, 0x08 },
-      135 /* Bin Number */
-  },
-  {
-    /* Staat_der_Nederlanden_EV_Root_CA */
-    { 0x4D, 0x24, 0x91, 0x41, 0x4C, 0xFE, 0x95, 0x67, 0x46, 0xEC, 0x4C, 0xEF, 0xA6, 0xCF, 0x6F, 0x72,
-      0xE2, 0x8A, 0x13, 0x29, 0x43, 0x2F, 0x9D, 0x8A, 0x90, 0x7A, 0xC4, 0xCB, 0x5D, 0xAD, 0xC1, 0x5A },
-      143 /* Bin Number */
-  },
-  {
-    /* USERTrust_ECC_Certification_Authority */
-    { 0x4F, 0xF4, 0x60, 0xD5, 0x4B, 0x9C, 0x86, 0xDA, 0xBF, 0xBC, 0xFC, 0x57, 0x12, 0xE0, 0x40, 0x0D,
-      0x2B, 0xED, 0x3F, 0xBC, 0x4D, 0x4F, 0xBD, 0xAA, 0x86, 0xE0, 0x6A, 0xDC, 0xD2, 0xA9, 0xAD, 0x7A },
-      139 /* Bin Number */
-  },
-  {
-    /* OU_Security_Communication_RootCA2_O__SECOM_Trust_Systems_CO__LTD___C_JP */
-    { 0x51, 0x3B, 0x2C, 0xEC, 0xB8, 0x10, 0xD4, 0xCD, 0xE5, 0xDD, 0x85, 0x39, 0x1A, 0xDF, 0xC6, 0xC2,
-      0xDD, 0x60, 0xD8, 0x7B, 0xB7, 0x36, 0xD2, 0xB5, 0x21, 0x48, 0x4A, 0xA4, 0x7A, 0x0E, 0xBE, 0xF6 },
-      102 /* Bin Number */
-  },
-  {
-    /* COMODO_RSA_Certification_Authority */
-    { 0x52, 0xF0, 0xE1, 0xC4, 0xE5, 0x8E, 0xC6, 0x29, 0x29, 0x1B, 0x60, 0x31, 0x7F, 0x07, 0x46, 0x71,
-      0xB8, 0x5D, 0x7E, 0xA8, 0x0D, 0x5B, 0x07, 0x27, 0x34, 0x63, 0x53, 0x4B, 0x32, 0xB4, 0x02, 0x34 },
-      137 /* Bin Number */
-  },
-  {
-    /* DigiCert_Trusted_Root_G4 */
-    { 0x55, 0x2F, 0x7B, 0xDC, 0xF1, 0xA7, 0xAF, 0x9E, 0x6C, 0xE6, 0x72, 0x01, 0x7F, 0x4F, 0x12, 0xAB,
-      0xF7, 0x72, 0x40, 0xC7, 0x8E, 0x76, 0x1A, 0xC2, 0x03, 0xD1, 0xD9, 0xD2, 0x0A, 0xC8, 0x99, 0x88 },
-      134 /* Bin Number */
-  },
-  {
-    /* Actalis_Authentication_Root_CA */
-    { 0x55, 0x92, 0x60, 0x84, 0xEC, 0x96, 0x3A, 0x64, 0xB9, 0x6E, 0x2A, 0xBE, 0x01, 0xCE, 0x0B, 0xA8,
-      0x6A, 0x64, 0xFB, 0xFE, 0xBC, 0xC7, 0xAA, 0xB5, 0xAF, 0xC1, 0x55, 0xB3, 0x7F, 0xD7, 0x60, 0x66 },
-      105 /* Bin Number */
-  },
-  {
-    /* Starfield_Services_Root_Certificate_Authority___G2 */
-    { 0x56, 0x8D, 0x69, 0x05, 0xA2, 0xC8, 0x87, 0x08, 0xA4, 0xB3, 0x02, 0x51, 0x90, 0xED, 0xCF, 0xED,
-      0xB1, 0x97, 0x4A, 0x60, 0x6A, 0x13, 0xC6, 0xE5, 0x29, 0x0F, 0xCB, 0x2A, 0xE6, 0x3E, 0xDA, 0xB5 },
-      92 /* Bin Number */
-  },
-  {
-    /* TWCA_Global_Root_CA */
-    { 0x59, 0x76, 0x90, 0x07, 0xF7, 0x68, 0x5D, 0x0F, 0xCD, 0x50, 0x87, 0x2F, 0x9F, 0x95, 0xD5, 0x75,
-      0x5A, 0x5B, 0x2B, 0x45, 0x7D, 0x81, 0xF3, 0x69, 0x2B, 0x61, 0x0A, 0x98, 0x67, 0x2F, 0x0E, 0x1B },
-      122 /* Bin Number */
-  },
-  {
-    /* Certum_Trusted_Network_CA */
-    { 0x5C, 0x58, 0x46, 0x8D, 0x55, 0xF5, 0x8E, 0x49, 0x7E, 0x74, 0x39, 0x82, 0xD2, 0xB5, 0x00, 0x10,
-      0xB6, 0xD1, 0x65, 0x37, 0x4A, 0xCF, 0x83, 0xA7, 0xD4, 0xA3, 0x2D, 0xB7, 0x68, 0xC4, 0x40, 0x8E },
-      97 /* Bin Number */
-  },
-  {
-    /* CFCA_EV_ROOT */
-    { 0x5C, 0xC3, 0xD7, 0x8E, 0x4E, 0x1D, 0x5E, 0x45, 0x54, 0x7A, 0x04, 0xE6, 0x87, 0x3E, 0x64, 0xF9,
-      0x0C, 0xF9, 0x53, 0x6D, 0x1C, 0xCC, 0x2E, 0xF8, 0x00, 0xF3, 0x55, 0xC4, 0xC5, 0xFD, 0x70, 0xFD },
-      148 /* Bin Number */
-  },
-  {
-    /* IdenTrust_Commercial_Root_CA_1 */
-    { 0x5D, 0x56, 0x49, 0x9B, 0xE4, 0xD2, 0xE0, 0x8B, 0xCF, 0xCA, 0xD0, 0x8A, 0x3E, 0x38, 0x72, 0x3D,
-      0x50, 0x50, 0x3B, 0xDE, 0x70, 0x69, 0x48, 0xE4, 0x2F, 0x55, 0x60, 0x30, 0x19, 0xE5, 0x28, 0xAE },
-      144 /* Bin Number */
-  },
-  {
-    /* GeoTrust_Primary_Certification_Authority___G2 */
-    { 0x5E, 0xDB, 0x7A, 0xC4, 0x3B, 0x82, 0xA0, 0x6A, 0x87, 0x61, 0xE8, 0xD7, 0xBE, 0x49, 0x79, 0xEB,
-      0xF2, 0x61, 0x1F, 0x7D, 0xD7, 0x9B, 0xF9, 0x1C, 0x1C, 0x6B, 0x56, 0x6A, 0x21, 0x9E, 0xD7, 0x66 },
-      74 /* Bin Number */
-  },
-  {
-    /* SwissSign_Gold_CA___G2 */
-    { 0x62, 0xDD, 0x0B, 0xE9, 0xB9, 0xF5, 0x0A, 0x16, 0x3E, 0xA0, 0xF8, 0xE7, 0x5C, 0x05, 0x3B, 0x1E,
-      0xCA, 0x57, 0xEA, 0x55, 0xC8, 0x68, 0x8F, 0x64, 0x7C, 0x68, 0x81, 0xF2, 0xC8, 0x35, 0x7B, 0x95 },
-      47 /* Bin Number */
-  },
-  {
-    /* Staat_der_Nederlanden_Root_CA___G2 */
-    { 0x66, 0x8C, 0x83, 0x94, 0x7D, 0xA6, 0x3B, 0x72, 0x4B, 0xEC, 0xE1, 0x74, 0x3C, 0x31, 0xA0, 0xE6,
-      0xAE, 0xD0, 0xDB, 0x8E, 0xC5, 0xB3, 0x1B, 0xE3, 0x77, 0xBB, 0x78, 0x4F, 0x91, 0xB6, 0x71, 0x6F },
-      78 /* Bin Number */
-  },
-  {
-    /* AddTrust_External_CA_Root */
-    { 0x68, 0x7F, 0xA4, 0x51, 0x38, 0x22, 0x78, 0xFF, 0xF0, 0xC8, 0xB1, 0x1F, 0x8D, 0x43, 0xD5, 0x76,
-      0x67, 0x1C, 0x6E, 0xB2, 0xBC, 0xEA, 0xB4, 0x13, 0xFB, 0x83, 0xD9, 0x65, 0xD0, 0x6D, 0x2F, 0xF2 },
-      9 /* Bin Number */
-  },
-  {
-    /* VeriSign_Class_3_Public_Primary_Certification_Authority___G4 */
-    { 0x69, 0xDD, 0xD7, 0xEA, 0x90, 0xBB, 0x57, 0xC9, 0x3E, 0x13, 0x5D, 0xC8, 0x5E, 0xA6, 0xFC, 0xD5,
-      0x48, 0x0B, 0x60, 0x32, 0x39, 0xBD, 0xC4, 0x54, 0xFC, 0x75, 0x8B, 0x2A, 0x26, 0xCF, 0x7F, 0x79 },
-      76 /* Bin Number */
-  },
-  {
-    /* Visa_eCommerce_Root */
-    { 0x69, 0xFA, 0xC9, 0xBD, 0x55, 0xFB, 0x0A, 0xC7, 0x8D, 0x53, 0xBB, 0xEE, 0x5C, 0xF1, 0xD5, 0x97,
-      0x98, 0x9F, 0xD0, 0xAA, 0xAB, 0x20, 0xA2, 0x51, 0x51, 0xBD, 0xF1, 0x73, 0x3E, 0xE7, 0xD1, 0x22 },
-      18 /* Bin Number */
-  },
-  {
-    /* NetLock_Arany__Class_Gold__F_tan_s_tv_ny */
-    { 0x6C, 0x61, 0xDA, 0xC3, 0xA2, 0xDE, 0xF0, 0x31, 0x50, 0x6B, 0xE0, 0x36, 0xD2, 0xA6, 0xFE, 0x40,
-      0x19, 0x94, 0xFB, 0xD1, 0x3D, 0xF9, 0xC8, 0xD4, 0x66, 0x59, 0x92, 0x74, 0xC4, 0x46, 0xEC, 0x98 },
-      77 /* Bin Number */
-  },
-  {
-    /* Entrust_net_Certification_Authority__2048_ */
-    { 0x6D, 0xC4, 0x71, 0x72, 0xE0, 0x1C, 0xBC, 0xB0, 0xBF, 0x62, 0x58, 0x0D, 0x89, 0x5F, 0xE2, 0xB8,
-      0xAC, 0x9A, 0xD4, 0xF8, 0x73, 0x80, 0x1E, 0x0C, 0x10, 0xB9, 0xC8, 0x37, 0xD2, 0x1E, 0xB1, 0x77 },
-      6 /* Bin Number */
-  },
-  {
-    /* UTN_USERFirst_Hardware */
-    { 0x6E, 0xA5, 0x47, 0x41, 0xD0, 0x04, 0x66, 0x7E, 0xED, 0x1B, 0x48, 0x16, 0x63, 0x4A, 0xA3, 0xA7,
-      0x9E, 0x6E, 0x4B, 0x96, 0x95, 0x0F, 0x82, 0x79, 0xDA, 0xFC, 0x8D, 0x9B, 0xD8, 0x81, 0x21, 0x37 },
-      30 /* Bin Number */
-  },
-  {
-    /* AffirmTrust_Premium */
-    { 0x70, 0xA7, 0x3F, 0x7F, 0x37, 0x6B, 0x60, 0x07, 0x42, 0x48, 0x90, 0x45, 0x34, 0xB1, 0x14, 0x82,
-      0xD5, 0xBF, 0x0E, 0x69, 0x8E, 0xCC, 0x49, 0x8D, 0xF5, 0x25, 0x77, 0xEB, 0xF2, 0xE9, 0x3B, 0x9A },
-      95 /* Bin Number */
-  },
-  {
-    /* Entrust_Root_Certification_Authority */
-    { 0x73, 0xC1, 0x76, 0x43, 0x4F, 0x1B, 0xC6, 0xD5, 0xAD, 0xF4, 0x5B, 0x0E, 0x76, 0xE7, 0x27, 0x28,
-      0x7C, 0x8D, 0xE5, 0x76, 0x16, 0xC1, 0xE6, 0xE6, 0x14, 0x1A, 0x2B, 0x2C, 0xBC, 0x7D, 0x8E, 0x4C },
-      12 /* Bin Number */
-  },
-  {
-    /* DigiCert_High_Assurance_EV_Root_CA */
-    { 0x74, 0x31, 0xE5, 0xF4, 0xC3, 0xC1, 0xCE, 0x46, 0x90, 0x77, 0x4F, 0x0B, 0x61, 0xE0, 0x54, 0x40,
-      0x88, 0x3B, 0xA9, 0xA0, 0x1E, 0xD0, 0x0B, 0xA6, 0xAB, 0xD7, 0x80, 0x6E, 0xD3, 0xB1, 0x18, 0xCF },
-      42 /* Bin Number */
-  },
-  {
-    /* O_Government_Root_Certification_Authority_C_TW */
-    { 0x76, 0x00, 0x29, 0x5E, 0xEF, 0xE8, 0x5B, 0x9E, 0x1F, 0xD6, 0x24, 0xDB, 0x76, 0x06, 0x2A, 0xAA,
-      0xAE, 0x59, 0x81, 0x8A, 0x54, 0xD2, 0x77, 0x4C, 0xD4, 0xC0, 0xB2, 0xC0, 0x11, 0x31, 0xE1, 0xB3 },
-      38 /* Bin Number */
-  },
-  {
-    /* DST_ACES_CA_X6 */
-    { 0x76, 0x7C, 0x95, 0x5A, 0x76, 0x41, 0x2C, 0x89, 0xAF, 0x68, 0x8E, 0x90, 0xA1, 0xC7, 0x0F, 0x55,
-      0x6C, 0xFD, 0x6B, 0x60, 0x25, 0xDB, 0xEA, 0x10, 0x41, 0x6D, 0x7E, 0xB6, 0x83, 0x1F, 0x8C, 0x40 },
-      45 /* Bin Number */
-  },
-  {
-    /* Sonera_Class2_CA */
-    { 0x79, 0x08, 0xB4, 0x03, 0x14, 0xC1, 0x38, 0x10, 0x0B, 0x51, 0x8D, 0x07, 0x35, 0x80, 0x7F, 0xFB,
-      0xFC, 0xF8, 0x51, 0x8A, 0x00, 0x95, 0x33, 0x71, 0x05, 0xBA, 0x38, 0x6B, 0x15, 0x3D, 0xD9, 0x27 },
-      27 /* Bin Number */
-  },
-  {
-    /* A_Trust_nQual_03 */
-    { 0x79, 0x3C, 0xBF, 0x45, 0x59, 0xB9, 0xFD, 0xE3, 0x8A, 0xB2, 0x2D, 0xF1, 0x68, 0x69, 0xF6, 0x98,
-      0x81, 0xAE, 0x14, 0xC4, 0xB0, 0x13, 0x9A, 0xC7, 0x88, 0xA7, 0x8A, 0x1A, 0xFC, 0xCA, 0x02, 0xFB },
-      100 /* Bin Number */
-  },
-  {
-    /* DigiCert_Assured_ID_Root_G2 */
-    { 0x7D, 0x05, 0xEB, 0xB6, 0x82, 0x33, 0x9F, 0x8C, 0x94, 0x51, 0xEE, 0x09, 0x4E, 0xEB, 0xFE, 0xFA,
-      0x79, 0x53, 0xA1, 0x14, 0xED, 0xB2, 0xF4, 0x49, 0x49, 0x45, 0x2F, 0xAB, 0x7D, 0x2F, 0xC1, 0x85 },
-      130 /* Bin Number */
-  },
-  {
-    /* DigiCert_Assured_ID_Root_G3 */
-    { 0x7E, 0x37, 0xCB, 0x8B, 0x4C, 0x47, 0x09, 0x0C, 0xAB, 0x36, 0x55, 0x1B, 0xA6, 0xF4, 0x5D, 0xB8,
-      0x40, 0x68, 0x0F, 0xBA, 0x16, 0x6A, 0x95, 0x2D, 0xB1, 0x00, 0x71, 0x7F, 0x43, 0x05, 0x3F, 0xC2 },
-      131 /* Bin Number */
-  },
-  {
-    /* NetLock_Kozjegyzoi__Class_A__Tanusitvanykiado */
-    { 0x7F, 0x12, 0xCD, 0x5F, 0x7E, 0x5E, 0x29, 0x0E, 0xC7, 0xD8, 0x51, 0x79, 0xD5, 0xB7, 0x2C, 0x20,
-      0xA5, 0xBE, 0x75, 0x08, 0xFF, 0xDB, 0x5B, 0xF8, 0x1A, 0xB9, 0x68, 0x4A, 0x7F, 0xC9, 0xF6, 0x67 },
-      33 /* Bin Number */
-  },
-  {
-    /* AddTrust_Qualified_CA_Root */
-    { 0x80, 0x95, 0x21, 0x08, 0x05, 0xDB, 0x4B, 0xBC, 0x35, 0x5E, 0x44, 0x28, 0xD8, 0xFD, 0x6E, 0xC2,
-      0xCD, 0xE3, 0xAB, 0x5F, 0xB9, 0x7A, 0x99, 0x42, 0x98, 0x8E, 0xB8, 0xF4, 0xDC, 0xD0, 0x60, 0x16 },
-      11 /* Bin Number */
-  },
-  {
-    /* QuoVadis_Root_CA_2 */
-    { 0x85, 0xA0, 0xDD, 0x7D, 0xD7, 0x20, 0xAD, 0xB7, 0xFF, 0x05, 0xF8, 0x3D, 0x54, 0x2B, 0x20, 0x9D,
-      0xC7, 0xFF, 0x45, 0x28, 0xF7, 0xD6, 0x77, 0xB1, 0x83, 0x89, 0xFE, 0xA5, 0xE5, 0xC4, 0x9E, 0x86 },
-      24 /* Bin Number */
-  },
-  {
-    /* UTN___DATACorp_SGC */
-    { 0x85, 0xFB, 0x2F, 0x91, 0xDD, 0x12, 0x27, 0x5A, 0x01, 0x45, 0xB6, 0x36, 0x53, 0x4F, 0x84, 0x02,
-      0x4A, 0xD6, 0x8B, 0x69, 0xB8, 0xEE, 0x88, 0x68, 0x4F, 0xF7, 0x11, 0x37, 0x58, 0x05, 0xB3, 0x48 },
-      29 /* Bin Number */
-  },
-  {
-    /* EC_ACC */
-    { 0x88, 0x49, 0x7F, 0x01, 0x60, 0x2F, 0x31, 0x54, 0x24, 0x6A, 0xE2, 0x8C, 0x4D, 0x5A, 0xEF, 0x10,
-      0xF1, 0xD8, 0x7E, 0xBB, 0x76, 0x62, 0x6F, 0x4A, 0xE0, 0xB7, 0xF9, 0x5B, 0xA7, 0x96, 0x87, 0x99 },
-      103 /* Bin Number */
-  },
-  {
-    /* QuoVadis_Root_CA_3_G3 */
-    { 0x88, 0xEF, 0x81, 0xDE, 0x20, 0x2E, 0xB0, 0x18, 0x45, 0x2E, 0x43, 0xF8, 0x64, 0x72, 0x5C, 0xEA,
-      0x5F, 0xBD, 0x1F, 0xC2, 0xD9, 0xD2, 0x05, 0x73, 0x07, 0x09, 0xC5, 0xD8, 0xB8, 0x69, 0x0F, 0x46 },
-      129 /* Bin Number */
-  },
-  {
-    /* QuoVadis_Root_CA_1_G3 */
-    { 0x8A, 0x86, 0x6F, 0xD1, 0xB2, 0x76, 0xB5, 0x7E, 0x57, 0x8E, 0x92, 0x1C, 0x65, 0x82, 0x8A, 0x2B,
-      0xED, 0x58, 0xE9, 0xF2, 0xF2, 0x88, 0x05, 0x41, 0x34, 0xB7, 0xF1, 0xF4, 0xBF, 0xC9, 0xCC, 0x74 },
-      127 /* Bin Number */
-  },
-  {
-    /* Root_CA_Generalitat_Valenciana */
-    { 0x8C, 0x4E, 0xDF, 0xD0, 0x43, 0x48, 0xF3, 0x22, 0x96, 0x9E, 0x7E, 0x29, 0xA4, 0xCD, 0x4D, 0xCA,
-      0x00, 0x46, 0x55, 0x06, 0x1C, 0x16, 0xE1, 0xB0, 0x76, 0x42, 0x2E, 0xF3, 0x42, 0xAD, 0x63, 0x0E },
-      99 /* Bin Number */
-  },
-  {
-    /* AddTrust_Class_1_CA_Root */
-    { 0x8C, 0x72, 0x09, 0x27, 0x9A, 0xC0, 0x4E, 0x27, 0x5E, 0x16, 0xD0, 0x7F, 0xD3, 0xB7, 0x75, 0xE8,
-      0x01, 0x54, 0xB5, 0x96, 0x80, 0x46, 0xE3, 0x1F, 0x52, 0xDD, 0x25, 0x76, 0x63, 0x24, 0xE9, 0xA7 },
-      8 /* Bin Number */
-  },
-  {
-    /* thawte_Primary_Root_CA */
-    { 0x8D, 0x72, 0x2F, 0x81, 0xA9, 0xC1, 0x13, 0xC0, 0x79, 0x1D, 0xF1, 0x36, 0xA2, 0x96, 0x6D, 0xB2,
-      0x6C, 0x95, 0x0A, 0x97, 0x1D, 0xB4, 0x6B, 0x41, 0x99, 0xF4, 0xEA, 0x54, 0xB7, 0x8B, 0xFB, 0x9F },
-      50 /* Bin Number */
-  },
-  {
-    /* T_RKTRUST_Elektronik_Sertifika_Hizmet_Sa_lay_c_s__H6 */
-    { 0x8D, 0xE7, 0x86, 0x55, 0xE1, 0xBE, 0x7F, 0x78, 0x47, 0x80, 0x0B, 0x93, 0xF6, 0x94, 0xD2, 0x1D,
-      0x36, 0x8C, 0xC0, 0x6E, 0x03, 0x3E, 0x7F, 0xAB, 0x04, 0xBB, 0x5E, 0xB9, 0x9D, 0xA6, 0xB7, 0x00 },
-      150 /* Bin Number */
-  },
-  {
-    /* QuoVadis_Root_CA_2_G3 */
-    { 0x8F, 0xE4, 0xFB, 0x0A, 0xF9, 0x3A, 0x4D, 0x0D, 0x67, 0xDB, 0x0B, 0xEB, 0xB2, 0x3E, 0x37, 0xC7,
-      0x1B, 0xF3, 0x25, 0xDC, 0xBC, 0xDD, 0x24, 0x0E, 0xA0, 0x4D, 0xAF, 0x58, 0xB4, 0x7E, 0x18, 0x40 },
-      128 /* Bin Number */
-  },
-  {
-    /* T_TeleSec_GlobalRoot_Class_2 */
-    { 0x91, 0xE2, 0xF5, 0x78, 0x8D, 0x58, 0x10, 0xEB, 0xA7, 0xBA, 0x58, 0x73, 0x7D, 0xE1, 0x54, 0x8A,
-      0x8E, 0xCA, 0xCD, 0x01, 0x45, 0x98, 0xBC, 0x0B, 0x14, 0x3E, 0x04, 0x1B, 0x17, 0x05, 0x25, 0x52 },
-      125 /* Bin Number */
-  },
-  {
-    /* CA_Disig */
-    { 0x92, 0xBF, 0x51, 0x19, 0xAB, 0xEC, 0xCA, 0xD0, 0xB1, 0x33, 0x2D, 0xC4, 0xE1, 0xD0, 0x5F, 0xBA,
-      0x75, 0xB5, 0x67, 0x90, 0x44, 0xEE, 0x0C, 0xA2, 0x6E, 0x93, 0x1F, 0x74, 0x4F, 0x2F, 0x33, 0xCF },
-      79 /* Bin Number */
-  },
-  {
-    /* Cybertrust_Global_Root */
-    { 0x96, 0x0A, 0xDF, 0x00, 0x63, 0xE9, 0x63, 0x56, 0x75, 0x0C, 0x29, 0x65, 0xDD, 0x0A, 0x08, 0x67,
-      0xDA, 0x0B, 0x9C, 0xBD, 0x6E, 0x77, 0x71, 0x4A, 0xEA, 0xFB, 0x23, 0x49, 0xAB, 0x39, 0x3D, 0xA3 },
-      64 /* Bin Number */
-  },
-  {
-    /* T_RKTRUST_Elektronik_Sertifika_Hizmet_Sa_lay_c_s_ */
-    { 0x97, 0x8C, 0xD9, 0x66, 0xF2, 0xFA, 0xA0, 0x7B, 0xA7, 0xAA, 0x95, 0x00, 0xD9, 0xC0, 0x2E, 0x9D,
-      0x77, 0xF2, 0xCD, 0xAD, 0xA6, 0xAD, 0x6B, 0xA7, 0x4A, 0xF4, 0xB9, 0x1C, 0x66, 0x59, 0x3C, 0x50 },
-      113 /* Bin Number */
-  },
-  {
-    /* Buypass_Class_2_Root_CA */
-    { 0x9A, 0x11, 0x40, 0x25, 0x19, 0x7C, 0x5B, 0xB9, 0x5D, 0x94, 0xE6, 0x3D, 0x55, 0xCD, 0x43, 0x79,
-      0x08, 0x47, 0xB6, 0x46, 0xB2, 0x3C, 0xDF, 0x11, 0xAD, 0xA4, 0xA0, 0x0E, 0xFF, 0x15, 0xFB, 0x48 },
-      109 /* Bin Number */
-  },
-  {
-    /* ACCVRAIZ1 */
-    { 0x9A, 0x6E, 0xC0, 0x12, 0xE1, 0xA7, 0xDA, 0x9D, 0xBE, 0x34, 0x19, 0x4D, 0x47, 0x8A, 0xD7, 0xC0,
-      0xDB, 0x18, 0x22, 0xFB, 0x07, 0x1D, 0xF1, 0x29, 0x81, 0x49, 0x6E, 0xD1, 0x04, 0x38, 0x41, 0x13 },
-      121 /* Bin Number */
-  },
-  {
-    /* VeriSign_Class_3_Public_Primary_Certification_Authority___G5 */
-    { 0x9A, 0xCF, 0xAB, 0x7E, 0x43, 0xC8, 0xD8, 0x80, 0xD0, 0x6B, 0x26, 0x2A, 0x94, 0xDE, 0xEE, 0xE4,
-      0xB4, 0x65, 0x99, 0x89, 0xC3, 0xD0, 0xCA, 0xF1, 0x9B, 0xAF, 0x64, 0x05, 0xE4, 0x1A, 0xB7, 0xDF },
-      51 /* Bin Number */
-  },
-  {
-    /* GeoTrust_Universal_CA_2 */
-    { 0xA0, 0x23, 0x4F, 0x3B, 0xC8, 0x52, 0x7C, 0xA5, 0x62, 0x8E, 0xEC, 0x81, 0xAD, 0x5D, 0x69, 0x89,
-      0x5D, 0xA5, 0x68, 0x0D, 0xC9, 0x1D, 0x1C, 0xB8, 0x47, 0x7F, 0x33, 0xF8, 0x78, 0xB9, 0x5B, 0x0B },
-      17 /* Bin Number */
-  },
-  {
-    /* GeoTrust_Universal_CA */
-    { 0xA0, 0x45, 0x9B, 0x9F, 0x63, 0xB2, 0x25, 0x59, 0xF5, 0xFA, 0x5D, 0x4C, 0x6D, 0xB3, 0xF9, 0xF7,
-      0x2F, 0xF1, 0x93, 0x42, 0x03, 0x35, 0x78, 0xF0, 0x73, 0xBF, 0x1D, 0x1B, 0x46, 0xCB, 0xB9, 0x12 },
-      16 /* Bin Number */
-  },
-  {
-    /* OU_Security_Communication_EV_RootCA1_O__SECOM_Trust_Systems_CO__LTD___C_JP */
-    { 0xA2, 0x2D, 0xBA, 0x68, 0x1E, 0x97, 0x37, 0x6E, 0x2D, 0x39, 0x7D, 0x72, 0x8A, 0xAE, 0x3A, 0x9B,
-      0x62, 0x96, 0xB9, 0xFD, 0xBA, 0x60, 0xBC, 0x2E, 0x11, 0xF6, 0x47, 0xF2, 0xC6, 0x75, 0xFB, 0x37 },
-      59 /* Bin Number */
-  },
-  {
-    /* thawte_Primary_Root_CA___G2 */
-    { 0xA4, 0x31, 0x0D, 0x50, 0xAF, 0x18, 0xA6, 0x44, 0x71, 0x90, 0x37, 0x2A, 0x86, 0xAF, 0xAF, 0x8B,
-      0x95, 0x1F, 0xFB, 0x43, 0x1D, 0x83, 0x7F, 0x1E, 0x56, 0x88, 0xB4, 0x59, 0x71, 0xED, 0x15, 0x57 },
-      72 /* Bin Number */
-  },
-  {
-    /* QuoVadis_Root_Certification_Authority */
-    { 0xA4, 0x5E, 0xDE, 0x3B, 0xBB, 0xF0, 0x9C, 0x8A, 0xE1, 0x5C, 0x72, 0xEF, 0xC0, 0x72, 0x68, 0xD6,
-      0x93, 0xA2, 0x1C, 0x99, 0x6F, 0xD5, 0x1E, 0x67, 0xCA, 0x07, 0x94, 0x60, 0xFD, 0x6D, 0x88, 0x73 },
-      23 /* Bin Number */
-  },
-  {
-    /* WellsSecure_Public_Root_Certificate_Authority */
-    { 0xA7, 0x12, 0x72, 0xAE, 0xAA, 0xA3, 0xCF, 0xE8, 0x72, 0x7F, 0x7F, 0xB3, 0x9F, 0x0F, 0xB3, 0xD1,
-      0xE5, 0x42, 0x6E, 0x90, 0x60, 0xB0, 0x6E, 0xE6, 0xF1, 0x3E, 0x9A, 0x3C, 0x58, 0x33, 0xCD, 0x43 },
-      56 /* Bin Number */
-  },
-  {
-    /* OU_RSA_Security_2048_V3_O_RSA_Security_Inc */
-    { 0xAF, 0x8B, 0x67, 0x62, 0xA1, 0xE5, 0x28, 0x22, 0x81, 0x61, 0xA9, 0x5D, 0x5C, 0x55, 0x9E, 0xE2,
-      0x66, 0x27, 0x8F, 0x75, 0xD7, 0x9E, 0x83, 0x01, 0x89, 0xA5, 0x03, 0x50, 0x6A, 0xBD, 0x6B, 0x4C },
-      13 /* Bin Number */
-  },
-  {
-    /* E_Tugra_Certification_Authority */
-    { 0xB0, 0xBF, 0xD5, 0x2B, 0xB0, 0xD7, 0xD9, 0xBD, 0x92, 0xBF, 0x5D, 0x4D, 0xC1, 0x3D, 0xA2, 0x55,
-      0xC0, 0x2C, 0x54, 0x2F, 0x37, 0x83, 0x65, 0xEA, 0x89, 0x39, 0x11, 0xF5, 0x5E, 0x55, 0xF2, 0x3C },
-      124 /* Bin Number */
-  },
-  {
-    /* GeoTrust_Primary_Certification_Authority___G3 */
-    { 0xB4, 0x78, 0xB8, 0x12, 0x25, 0x0D, 0xF8, 0x78, 0x63, 0x5C, 0x2A, 0xA7, 0xEC, 0x7D, 0x15, 0x5E,
-      0xAA, 0x62, 0x5E, 0xE8, 0x29, 0x16, 0xE2, 0xCD, 0x29, 0x43, 0x61, 0x88, 0x6C, 0xD1, 0xFB, 0xD4 },
-      71 /* Bin Number */
-  },
-  {
-    /* Deutsche_Telekom_Root_CA_2 */
-    { 0xB6, 0x19, 0x1A, 0x50, 0xD0, 0xC3, 0x97, 0x7F, 0x7D, 0xA9, 0x9B, 0xCD, 0xAA, 0xC8, 0x6A, 0x22,
-      0x7D, 0xAE, 0xB9, 0x67, 0x9E, 0xC7, 0x0B, 0xA3, 0xB0, 0xC9, 0xD9, 0x22, 0x71, 0xC1, 0x70, 0xD3 },
-      63 /* Bin Number */
-  },
-  {
-    /* IGC_A */
-    { 0xB9, 0xBE, 0xA7, 0x86, 0x0A, 0x96, 0x2E, 0xA3, 0x61, 0x1D, 0xAB, 0x97, 0xAB, 0x6D, 0xA3, 0xE2,
-      0x1C, 0x10, 0x68, 0xB9, 0x7D, 0x55, 0x57, 0x5E, 0xD0, 0xE1, 0x12, 0x79, 0xC1, 0x1C, 0x89, 0x32 },
-      58 /* Bin Number */
-  },
-  {
-    /* Hellenic_Academic_and_Research_Institutions_RootCA_2011 */
-    { 0xBC, 0x10, 0x4F, 0x15, 0xA4, 0x8B, 0xE7, 0x09, 0xDC, 0xA5, 0x42, 0xA7, 0xE1, 0xD4, 0xB9, 0xDF,
-      0x6F, 0x05, 0x45, 0x27, 0xE8, 0x02, 0xEA, 0xA9, 0x2D, 0x59, 0x54, 0x44, 0x25, 0x8A, 0xFE, 0x71 },
-      104 /* Bin Number */
-  },
-  {
-    /* AffirmTrust_Premium_ECC */
-    { 0xBD, 0x71, 0xFD, 0xF6, 0xDA, 0x97, 0xE4, 0xCF, 0x62, 0xD1, 0x64, 0x7A, 0xDD, 0x25, 0x81, 0xB0,
-      0x7D, 0x79, 0xAD, 0xF8, 0x39, 0x7E, 0xB4, 0xEC, 0xBA, 0x9C, 0x5E, 0x84, 0x88, 0x82, 0x14, 0x23 },
-      96 /* Bin Number */
-  },
-  {
-    /* Secure_Certificate_Services */
-    { 0xBD, 0x81, 0xCE, 0x3B, 0x4F, 0x65, 0x91, 0xD1, 0x1A, 0x67, 0xB5, 0xFC, 0x7A, 0x47, 0xFD, 0xEF,
-      0x25, 0x52, 0x1B, 0xF9, 0xAA, 0x4E, 0x18, 0xB9, 0xE3, 0xDF, 0x2E, 0x34, 0xA7, 0x80, 0x3B, 0xE8 },
-      21 /* Bin Number */
-  },
-  {
-    /* SwissSign_Silver_CA___G2 */
-    { 0xBE, 0x6C, 0x4D, 0xA2, 0xBB, 0xB9, 0xBA, 0x59, 0xB6, 0xF3, 0x93, 0x97, 0x68, 0x37, 0x42, 0x46,
-      0xC3, 0xC0, 0x05, 0x99, 0x3F, 0xA9, 0x8F, 0x02, 0x0D, 0x1D, 0xED, 0xBE, 0xD4, 0x8A, 0x81, 0xD5 },
-      48 /* Bin Number */
-  },
-  {
-    /* GlobalSign */
-    { 0xBE, 0xC9, 0x49, 0x11, 0xC2, 0x95, 0x56, 0x76, 0xDB, 0x6C, 0x0A, 0x55, 0x09, 0x86, 0xD7, 0x6E,
-      0x3B, 0xA0, 0x05, 0x66, 0x7C, 0x44, 0x2C, 0x97, 0x62, 0xB4, 0xFB, 0xB7, 0x73, 0xDE, 0x22, 0x8C },
-      140 /* Bin Number */
-  },
-  {
-    /* SecureSign_RootCA11 */
-    { 0xBF, 0x0F, 0xEE, 0xFB, 0x9E, 0x3A, 0x58, 0x1A, 0xD5, 0xF9, 0xE9, 0xDB, 0x75, 0x89, 0x98, 0x57,
-      0x43, 0xD2, 0x61, 0x08, 0x5C, 0x4D, 0x31, 0x4F, 0x6F, 0x5D, 0x72, 0x59, 0xAA, 0x42, 0x16, 0x12 },
-      82 /* Bin Number */
-  },
-  {
-    /* TWCA_Root_Certification_Authority */
-    { 0xBF, 0xD8, 0x8F, 0xE1, 0x10, 0x1C, 0x41, 0xAE, 0x3E, 0x80, 0x1B, 0xF8, 0xBE, 0x56, 0x35, 0x0E,
-      0xE9, 0xBA, 0xD1, 0xA6, 0xB9, 0xBD, 0x51, 0x5E, 0xDC, 0x5C, 0x6D, 0x5B, 0x87, 0x11, 0xAC, 0x44 },
-      101 /* Bin Number */
-  },
-  {
-    /* OU_ePKI_Root_Certification_Authority_O__Chunghwa_Telecom_Co___Ltd___C_TW */
-    { 0xC0, 0xA6, 0xF4, 0xDC, 0x63, 0xA2, 0x4B, 0xFD, 0xCF, 0x54, 0xEF, 0x2A, 0x6A, 0x08, 0x2A, 0x0A,
-      0x72, 0xDE, 0x35, 0x80, 0x3E, 0x2F, 0xF5, 0xFF, 0x52, 0x7A, 0xE5, 0xD8, 0x72, 0x06, 0xDF, 0xD5 },
-      65 /* Bin Number */
-  },
-  {
-    /* OU_Trustis_FPS_Root_CA_O_Trustis_Limited_C_GB */
-    { 0xC1, 0xB4, 0x82, 0x99, 0xAB, 0xA5, 0x20, 0x8F, 0xE9, 0x63, 0x0A, 0xCE, 0x55, 0xCA, 0x68, 0xA0,
-      0x3E, 0xDA, 0x5A, 0x51, 0x9C, 0x88, 0x02, 0xA0, 0xD3, 0xA6, 0x73, 0xBE, 0x8F, 0x8E, 0x55, 0x7D },
-      106 /* Bin Number */
-  },
-  {
-    /* OU_Go_Daddy_Class_2_Certification_Authority_O__The_Go_Daddy_Group__Inc___C_US */
-    { 0xC3, 0x84, 0x6B, 0xF2, 0x4B, 0x9E, 0x93, 0xCA, 0x64, 0x27, 0x4C, 0x0E, 0xC6, 0x7C, 0x1E, 0xCC,
-      0x5E, 0x02, 0x4F, 0xFC, 0xAC, 0xD2, 0xD7, 0x40, 0x19, 0x35, 0x0E, 0x81, 0xFE, 0x54, 0x6A, 0xE4 },
-      35 /* Bin Number */
-  },
-  {
-    /* T_RKTRUST_Elektronik_Sertifika_Hizmet_Sa_lay_c_s_ */
-    { 0xC4, 0x70, 0xCF, 0x54, 0x7E, 0x23, 0x02, 0xB9, 0x77, 0xFB, 0x29, 0xDD, 0x71, 0xA8, 0x9A, 0x7B,
-      0x6C, 0x1F, 0x60, 0x77, 0x7B, 0x03, 0x29, 0xF5, 0x60, 0x17, 0xF3, 0x28, 0xBF, 0x4F, 0x6B, 0xE6 },
-      46 /* Bin Number */
-  },
-  {
-    /* StartCom_Certification_Authority */
-    { 0xC7, 0x66, 0xA9, 0xBE, 0xF2, 0xD4, 0x07, 0x1C, 0x86, 0x3A, 0x31, 0xAA, 0x49, 0x20, 0xE8, 0x13,
-      0xB2, 0xD1, 0x98, 0x60, 0x8C, 0xB7, 0xB7, 0xCF, 0xE2, 0x11, 0x43, 0xB8, 0x36, 0xDF, 0x09, 0xEA },
-      37 /* Bin Number */
-  },
-  {
-    /* StartCom_Certification_Authority_G2 */
-    { 0xC7, 0xBA, 0x65, 0x67, 0xDE, 0x93, 0xA7, 0x98, 0xAE, 0x1F, 0xAA, 0x79, 0x1E, 0x71, 0x2D, 0x37,
-      0x8F, 0xAE, 0x1F, 0x93, 0xC4, 0x39, 0x7F, 0xEA, 0x44, 0x1B, 0xB7, 0xCB, 0xE6, 0xFD, 0x59, 0x95 },
-      108 /* Bin Number */
-  },
-  {
-    /* GeoTrust_Global_CA_2 */
-    { 0xCA, 0x2D, 0x82, 0xA0, 0x86, 0x77, 0x07, 0x2F, 0x8A, 0xB6, 0x76, 0x4F, 0xF0, 0x35, 0x67, 0x6C,
-      0xFE, 0x3E, 0x5E, 0x32, 0x5E, 0x01, 0x21, 0x72, 0xDF, 0x3F, 0x92, 0x09, 0x6D, 0xB7, 0x9B, 0x85 },
-      15 /* Bin Number */
-  },
-  {
-    /* GlobalSign */
-    { 0xCA, 0x42, 0xDD, 0x41, 0x74, 0x5F, 0xD0, 0xB8, 0x1E, 0xB9, 0x02, 0x36, 0x2C, 0xF9, 0xD8, 0xBF,
-      0x71, 0x9D, 0xA1, 0xBD, 0x1B, 0x1E, 0xFC, 0x94, 0x6F, 0x5B, 0x4C, 0x99, 0xF4, 0x2C, 0x1B, 0x9E },
-      3 /* Bin Number */
-  },
-  {
-    /* DigiCert_Global_Root_G2 */
-    { 0xCB, 0x3C, 0xCB, 0xB7, 0x60, 0x31, 0xE5, 0xE0, 0x13, 0x8F, 0x8D, 0xD3, 0x9A, 0x23, 0xF9, 0xDE,
-      0x47, 0xFF, 0xC3, 0x5E, 0x43, 0xC1, 0x14, 0x4C, 0xEA, 0x27, 0xD4, 0x6A, 0x5A, 0xB1, 0xCB, 0x5F },
-      132 /* Bin Number */
-  },
-  {
-    /* GlobalSign */
-    { 0xCB, 0xB5, 0x22, 0xD7, 0xB7, 0xF1, 0x27, 0xAD, 0x6A, 0x01, 0x13, 0x86, 0x5B, 0xDF, 0x1C, 0xD4,
-      0x10, 0x2E, 0x7D, 0x07, 0x59, 0xAF, 0x63, 0x5A, 0x7C, 0xF4, 0x72, 0x0D, 0xC9, 0x63, 0xC5, 0x3B },
-      85 /* Bin Number */
-  },
-  {
-    /* XRamp_Global_Certification_Authority */
-    { 0xCE, 0xCD, 0xDC, 0x90, 0x50, 0x99, 0xD8, 0xDA, 0xDF, 0xC5, 0xB1, 0xD2, 0x09, 0xB7, 0x37, 0xCB,
-      0xE2, 0xC1, 0x8C, 0xFB, 0x2C, 0x10, 0xC0, 0xFF, 0x0B, 0xCF, 0x0D, 0x32, 0x86, 0xFC, 0x1A, 0xA2 },
-      34 /* Bin Number */
-  },
-  {
-    /* Staat_der_Nederlanden_Root_CA */
-    { 0xD4, 0x1D, 0x82, 0x9E, 0x8C, 0x16, 0x59, 0x82, 0x2A, 0xF9, 0x3F, 0xCE, 0x62, 0xBF, 0xFC, 0xDE,
-      0x26, 0x4F, 0xC8, 0x4E, 0x8B, 0x95, 0x0C, 0x5F, 0xF2, 0x75, 0xD0, 0x52, 0x35, 0x46, 0x95, 0xA3 },
-      28 /* Bin Number */
-  },
-  {
-    /* CA______ */
-    { 0xD6, 0xF0, 0x34, 0xBD, 0x94, 0xAA, 0x23, 0x3F, 0x02, 0x97, 0xEC, 0xA4, 0x24, 0x5B, 0x28, 0x39,
-      0x73, 0xE4, 0x47, 0xAA, 0x59, 0x0F, 0x31, 0x0C, 0x77, 0xF4, 0x8F, 0xDF, 0x83, 0x11, 0x22, 0x54 },
-      136 /* Bin Number */
-  },
-  {
-    /* AAA_Certificate_Services */
-    { 0xD7, 0xA7, 0xA0, 0xFB, 0x5D, 0x7E, 0x27, 0x31, 0xD7, 0x71, 0xE9, 0x48, 0x4E, 0xBC, 0xDE, 0xF7,
-      0x1D, 0x5F, 0x0C, 0x3E, 0x0A, 0x29, 0x48, 0x78, 0x2B, 0xC8, 0x3E, 0xE0, 0xEA, 0x69, 0x9E, 0xF4 },
-      20 /* Bin Number */
-  },
-  {
-    /* Certum_CA */
-    { 0xD8, 0xE0, 0xFE, 0xBC, 0x1D, 0xB2, 0xE3, 0x8D, 0x00, 0x94, 0x0F, 0x37, 0xD2, 0x7D, 0x41, 0x34,
-      0x4D, 0x99, 0x3E, 0x73, 0x4B, 0x99, 0xD5, 0x65, 0x6D, 0x97, 0x78, 0xD4, 0xD8, 0x14, 0x36, 0x24 },
-      19 /* Bin Number */
-  },
-  {
-    /* Swisscom_Root_EV_CA_2 */
-    { 0xD9, 0x5F, 0xEA, 0x3C, 0xA4, 0xEE, 0xDC, 0xE7, 0x4C, 0xD7, 0x6E, 0x75, 0xFC, 0x6D, 0x1F, 0xF6,
-      0x2C, 0x44, 0x1F, 0x0F, 0xA8, 0xBC, 0x77, 0xF0, 0x34, 0xB1, 0x9E, 0x5D, 0xB2, 0x58, 0x01, 0x5D },
-      118 /* Bin Number */
-  },
-  {
-    /* TeliaSonera_Root_CA_v1 */
-    { 0xDD, 0x69, 0x36, 0xFE, 0x21, 0xF8, 0xF0, 0x77, 0xC1, 0x23, 0xA1, 0xA5, 0x21, 0xC1, 0x22, 0x24,
-      0xF7, 0x22, 0x55, 0xB7, 0x3E, 0x03, 0xA7, 0x26, 0x06, 0x93, 0xE8, 0xA2, 0x4B, 0x0F, 0xA3, 0x89 },
-      123 /* Bin Number */
-  },
-  {
-    /* StartCom_Certification_Authority */
-    { 0xE1, 0x78, 0x90, 0xEE, 0x09, 0xA3, 0xFB, 0xF4, 0xF4, 0x8B, 0x9C, 0x41, 0x4A, 0x17, 0xD6, 0x37,
-      0xB7, 0xA5, 0x06, 0x47, 0xE9, 0xBC, 0x75, 0x23, 0x22, 0x72, 0x7F, 0xCC, 0x17, 0x42, 0xA9, 0x11 },
-      107 /* Bin Number */
-  },
-  {
-    /* CA_Disig_Root_R2 */
-    { 0xE2, 0x3D, 0x4A, 0x03, 0x6D, 0x7B, 0x70, 0xE9, 0xF5, 0x95, 0xB1, 0x42, 0x20, 0x79, 0xD2, 0xB9,
-      0x1E, 0xDF, 0xBB, 0x1F, 0xB6, 0x51, 0xA0, 0x63, 0x3E, 0xAA, 0x8A, 0x9D, 0xC5, 0xF8, 0x07, 0x03 },
-      120 /* Bin Number */
-  },
-  {
-    /* VeriSign_Class_4_Public_Primary_Certification_Authority___G3 */
-    { 0xE3, 0x89, 0x36, 0x0D, 0x0F, 0xDB, 0xAE, 0xB3, 0xD2, 0x50, 0x58, 0x4B, 0x47, 0x30, 0x31, 0x4E,
-      0x22, 0x2F, 0x39, 0xC1, 0x56, 0xA0, 0x20, 0x14, 0x4E, 0x8D, 0x96, 0x05, 0x61, 0x79, 0x15, 0x06 },
-      5 /* Bin Number */
-  },
-  {
-    /* Certigna */
-    { 0xE3, 0xB6, 0xA2, 0xDB, 0x2E, 0xD7, 0xCE, 0x48, 0x84, 0x2F, 0x7A, 0xC5, 0x32, 0x41, 0xC7, 0xB7,
-      0x1D, 0x54, 0x14, 0x4B, 0xFB, 0x40, 0xC1, 0x1F, 0x3F, 0x1D, 0x0B, 0x42, 0xF5, 0xEE, 0xA1, 0x2D },
-      62 /* Bin Number */
-  },
-  {
-    /* T_B_TAK_UEKAE_K_k_Sertifika_Hizmet_Sa_lay_c_s____S_r_m_3 */
-    { 0xE4, 0xC7, 0x34, 0x30, 0xD7, 0xA5, 0xB5, 0x09, 0x25, 0xDF, 0x43, 0x37, 0x0A, 0x0D, 0x21, 0x6E,
-      0x9A, 0x79, 0xB9, 0xD6, 0xDB, 0x83, 0x73, 0xA0, 0xC6, 0x9E, 0xB1, 0xCC, 0x31, 0xC7, 0xC5, 0x2A },
-      66 /* Bin Number */
-  },
-  {
-    /* OU_Security_Communication_RootCA1_O_SECOM_Trust_net_C_JP */
-    { 0xE7, 0x5E, 0x72, 0xED, 0x9F, 0x56, 0x0E, 0xEC, 0x6E, 0xB4, 0x80, 0x00, 0x73, 0xA4, 0x3F, 0xC3,
-      0xAD, 0x19, 0x19, 0x5A, 0x39, 0x22, 0x82, 0x01, 0x78, 0x95, 0x97, 0x4A, 0x99, 0x02, 0x6B, 0x6C },
-      26 /* Bin Number */
-  },
-  {
-    /* USERTrust_RSA_Certification_Authority */
-    { 0xE7, 0x93, 0xC9, 0xB0, 0x2F, 0xD8, 0xAA, 0x13, 0xE2, 0x1C, 0x31, 0x22, 0x8A, 0xCC, 0xB0, 0x81,
-      0x19, 0x64, 0x3B, 0x74, 0x9C, 0x89, 0x89, 0x64, 0xB1, 0x74, 0x6D, 0x46, 0xC3, 0xD4, 0xCB, 0xD2 },
-      138 /* Bin Number */
-  },
-  {
-    /* OU_certSIGN_ROOT_CA_O_certSIGN_C_RO */
-    { 0xEA, 0xA9, 0x62, 0xC4, 0xFA, 0x4A, 0x6B, 0xAF, 0xEB, 0xE4, 0x15, 0x19, 0x6D, 0x35, 0x1C, 0xCD,
-      0x88, 0x8D, 0x4F, 0x53, 0xF3, 0xFA, 0x8A, 0xE6, 0xD7, 0xC4, 0x66, 0xA9, 0x4E, 0x60, 0x42, 0xBB },
-      69 /* Bin Number */
-  },
-  {
-    /* VeriSign_Class_3_Public_Primary_Certification_Authority___G3 */
-    { 0xEB, 0x04, 0xCF, 0x5E, 0xB1, 0xF3, 0x9A, 0xFA, 0x76, 0x2F, 0x2B, 0xB1, 0x20, 0xF2, 0x96, 0xCB,
-      0xA5, 0x20, 0xC1, 0xB9, 0x7D, 0xB1, 0x58, 0x95, 0x65, 0xB8, 0x1C, 0xB9, 0xA1, 0x7B, 0x72, 0x44 },
-      4 /* Bin Number */
-  },
-  {
-    /* GlobalSign_Root_CA */
-    { 0xEB, 0xD4, 0x10, 0x40, 0xE4, 0xBB, 0x3E, 0xC7, 0x42, 0xC9, 0xE3, 0x81, 0xD3, 0x1E, 0xF2, 0xA4,
-      0x1A, 0x48, 0xB6, 0x68, 0x5C, 0x96, 0xE7, 0xCE, 0xF3, 0xC1, 0xDF, 0x6C, 0xD4, 0x33, 0x1C, 0x99 },
-      2 /* Bin Number */
-  },
-  {
-    /* Juur_SK */
-    { 0xEC, 0xC3, 0xE9, 0xC3, 0x40, 0x75, 0x03, 0xBE, 0xE0, 0x91, 0xAA, 0x95, 0x2F, 0x41, 0x34, 0x8F,
-      0xF8, 0x8B, 0xAA, 0x86, 0x3B, 0x22, 0x64, 0xBE, 0xFA, 0xC8, 0x07, 0x90, 0x15, 0x74, 0xE9, 0x39 },
-      80 /* Bin Number */
-  },
-  {
-    /* Buypass_Class_3_Root_CA */
-    { 0xED, 0xF7, 0xEB, 0xBC, 0xA2, 0x7A, 0x2A, 0x38, 0x4D, 0x38, 0x7B, 0x7D, 0x40, 0x10, 0xC6, 0x66,
-      0xE2, 0xED, 0xB4, 0x84, 0x3E, 0x4C, 0x29, 0xB4, 0xAE, 0x1D, 0x5B, 0x93, 0x32, 0xE6, 0xB2, 0x4D },
-      110 /* Bin Number */
-  },
-  {
-    /* D_TRUST_Root_Class_3_CA_2_EV_2009 */
-    { 0xEE, 0xC5, 0x49, 0x6B, 0x98, 0x8C, 0xE9, 0x86, 0x25, 0xB9, 0x34, 0x09, 0x2E, 0xEC, 0x29, 0x08,
-      0xBE, 0xD0, 0xB0, 0xF3, 0x16, 0xC2, 0xD4, 0x73, 0x0C, 0x84, 0xEA, 0xF1, 0xF3, 0xD3, 0x48, 0x81 },
-      115 /* Bin Number */
-  },
-  {
-    /* Global_Chambersign_Root */
-    { 0xEF, 0x3C, 0xB4, 0x17, 0xFC, 0x8E, 0xBF, 0x6F, 0x97, 0x87, 0x6C, 0x9E, 0x4E, 0xCE, 0x39, 0xDE,
-      0x1E, 0xA5, 0xFE, 0x64, 0x91, 0x41, 0xD1, 0x02, 0x8B, 0x7D, 0x11, 0xC0, 0xB2, 0x29, 0x8C, 0xED },
-      32 /* Bin Number */
-  },
-  {
-    /* Swisscom_Root_CA_2 */
-    { 0xF0, 0x9B, 0x12, 0x2C, 0x71, 0x14, 0xF4, 0xA0, 0x9B, 0xD4, 0xEA, 0x4F, 0x4A, 0x99, 0xD5, 0x58,
-      0xB4, 0x6E, 0x4C, 0x25, 0xCD, 0x81, 0x14, 0x0D, 0x29, 0xC0, 0x56, 0x13, 0x91, 0x4C, 0x38, 0x41 },
-      117 /* Bin Number */
-  },
-  {
-    /* SecureTrust_CA */
-    { 0xF1, 0xC1, 0xB5, 0x0A, 0xE5, 0xA2, 0x0D, 0xD8, 0x03, 0x0E, 0xC9, 0xF6, 0xBC, 0x24, 0x82, 0x3D,
-      0xD3, 0x67, 0xB5, 0x25, 0x57, 0x59, 0xB4, 0xE7, 0x1B, 0x61, 0xFC, 0xE9, 0xF7, 0x37, 0x5D, 0x73 },
-      52 /* Bin Number */
-  },
-  {
-    /* Atos_TrustedRoot_2011 */
-    { 0xF3, 0x56, 0xBE, 0xA2, 0x44, 0xB7, 0xA9, 0x1E, 0xB3, 0x5D, 0x53, 0xCA, 0x9A, 0xD7, 0x86, 0x4A,
-      0xCE, 0x01, 0x8E, 0x2D, 0x35, 0xD5, 0xF8, 0xF9, 0x6D, 0xDF, 0x68, 0xA6, 0xF4, 0x1A, 0xA4, 0x74 },
-      126 /* Bin Number */
-  },
-  {
-    /* CA_Disig_Root_R1 */
-    { 0xF9, 0x6F, 0x23, 0xF4, 0xC3, 0xE7, 0x9C, 0x07, 0x7A, 0x46, 0x98, 0x8D, 0x5A, 0xF5, 0x90, 0x06,
-      0x76, 0xA0, 0xF0, 0x39, 0xCB, 0x64, 0x5D, 0xD1, 0x75, 0x49, 0xB2, 0x16, 0xC8, 0x24, 0x40, 0xCE },
-      119 /* Bin Number */
-  },
-  {
-    /* Hongkong_Post_Root_CA_1 */
-    { 0xF9, 0xE6, 0x7D, 0x33, 0x6C, 0x51, 0x00, 0x2A, 0xC0, 0x54, 0xC6, 0x32, 0x02, 0x2D, 0x66, 0xDD,
-      0xA2, 0xE7, 0xE3, 0xFF, 0xF1, 0x0A, 0xD0, 0x61, 0xED, 0x31, 0xD8, 0xBB, 0xB4, 0x10, 0xCF, 0xB2 },
-      81 /* Bin Number */
-  },
-  {
-    /* Certinomis___Autorit__Racine */
-    { 0xFC, 0xBF, 0xE2, 0x88, 0x62, 0x06, 0xF7, 0x2B, 0x27, 0x59, 0x3C, 0x8B, 0x07, 0x02, 0x97, 0xE1,
-      0x2D, 0x76, 0x9E, 0xD1, 0x0E, 0xD7, 0x93, 0x07, 0x05, 0xA8, 0x09, 0x8E, 0xFF, 0xC1, 0x4D, 0x17 },
-      98 /* Bin Number */
-  },
-  {
-    /* T_TeleSec_GlobalRoot_Class_3 */
-    { 0xFD, 0x73, 0xDA, 0xD3, 0x1C, 0x64, 0x4F, 0xF1, 0xB4, 0x3B, 0xEF, 0x0C, 0xCD, 0xDA, 0x96, 0x71,
-      0x0B, 0x9C, 0xD9, 0x87, 0x5E, 0xCA, 0x7E, 0x31, 0x70, 0x7A, 0xF3, 0xE9, 0x6D, 0x52, 0x2B, 0xBD },
-      111 /* Bin Number */
-  },
-  {
-    /* GeoTrust_Global_CA */
-    { 0xFF, 0x85, 0x6A, 0x2D, 0x25, 0x1D, 0xCD, 0x88, 0xD3, 0x66, 0x56, 0xF4, 0x50, 0x12, 0x67, 0x98,
-      0xCF, 0xAB, 0xAA, 0xDE, 0x40, 0x79, 0x9C, 0x72, 0x2D, 0xE4, 0xD2, 0xB5, 0xDB, 0x36, 0xA7, 0x3A },
-      14 /* Bin Number */
-  },
-};
-
diff --git a/security/manager/boot/src/moz.build b/security/manager/boot/src/moz.build
index e181f84..eafb50e 100644
--- a/security/manager/boot/src/moz.build
+++ b/security/manager/boot/src/moz.build
@@ -17,7 +17,6 @@ UNIFIED_SOURCES += [
     'nsSecurityHeaderParser.cpp',
     'nsSiteSecurityService.cpp',
     'PublicKeyPinningService.cpp',
-    'RootCertificateTelemetryUtils.cpp',
 ]
 
 LOCAL_INCLUDES += [
diff --git a/security/manager/pki/resources/content/exceptionDialog.js b/security/manager/pki/resources/content/exceptionDialog.js
index 640791f8..07f967e 100644
--- a/security/manager/pki/resources/content/exceptionDialog.js
+++ b/security/manager/pki/resources/content/exceptionDialog.js
@@ -11,8 +11,6 @@ var gCert;
 var gChecking;
 var gBroken;
 var gNeedReset;
-var gSecHistogram;
-var gNsISecTel;
 
 Components.utils.import("resource://gre/modules/PrivateBrowsingUtils.jsm");
 
@@ -46,10 +44,6 @@ function initExceptionDialog() {
   gDialog = document.documentElement;
   gBundleBrand = document.getElementById("brand_bundle");
   gPKIBundle = document.getElementById("pippki_bundle");
-  gSecHistogram = Components.classes["@mozilla.org/base/telemetry;1"].
-                    getService(Components.interfaces.nsITelemetry).
-                    getHistogramById("SECURITY_UI");
-  gNsISecTel = Components.interfaces.nsISecurityUITelemetry;
 
   var brandName = gBundleBrand.getString("brandShortName");
   setText("warningText", gPKIBundle.getFormattedString("addExceptionBrandedWarning2", [brandName]));
@@ -183,7 +177,6 @@ function updateCertStatus() {
   var shortDesc3, longDesc3;
   var use2 = false;
   var use3 = false;
-  let bucketId = gNsISecTel.WARNING_BAD_CERT_TOP_ADD_EXCEPTION_BASE;
   if(gCert) {
     if(gBroken) { 
       var mms = "addExceptionDomainMismatchShort";
@@ -194,13 +187,11 @@ function updateCertStatus() {
       var utl = "addExceptionUnverifiedOrBadSignatureLong2";
       var use1 = false;
       if (gSSLStatus.isDomainMismatch) {
-        bucketId += gNsISecTel.WARNING_BAD_CERT_TOP_ADD_EXCEPTION_FLAG_DOMAIN;
         use1 = true;
         shortDesc = mms;
         longDesc  = mml;
       }
       if (gSSLStatus.isNotValidAtThisTime) {
-        bucketId += gNsISecTel.WARNING_BAD_CERT_TOP_ADD_EXCEPTION_FLAG_TIME;
         if (!use1) {
           use1 = true;
           shortDesc = exs;
@@ -213,7 +204,6 @@ function updateCertStatus() {
         }
       }
       if (gSSLStatus.isUntrusted) {
-        bucketId += gNsISecTel.WARNING_BAD_CERT_TOP_ADD_EXCEPTION_FLAG_UNTRUSTED;
         if (!use1) {
           use1 = true;
           shortDesc = uts;
@@ -230,7 +220,6 @@ function updateCertStatus() {
           longDesc3  = utl;
         }
       }
-      gSecHistogram.add(bucketId);
 
       // In these cases, we do want to enable the "Add Exception" button
       gDialog.getButton("extra1").disabled = false;
@@ -302,7 +291,6 @@ function updateCertStatus() {
  * Handle user request to display certificate details
  */
 function viewCertButtonClick() {
-  gSecHistogram.add(gNsISecTel.WARNING_BAD_CERT_TOP_CLICK_VIEW_CERT);
   if (gCert)
     viewCertHelper(this, gCert);
     
@@ -318,26 +306,19 @@ function addException() {
   var overrideService = Components.classes["@mozilla.org/security/certoverride;1"]
                                   .getService(Components.interfaces.nsICertOverrideService);
   var flags = 0;
-  let confirmBucketId = gNsISecTel.WARNING_BAD_CERT_TOP_CONFIRM_ADD_EXCEPTION_BASE;
   if (gSSLStatus.isUntrusted) {
     flags |= overrideService.ERROR_UNTRUSTED;
-    confirmBucketId += gNsISecTel.WARNING_BAD_CERT_TOP_CONFIRM_ADD_EXCEPTION_FLAG_UNTRUSTED;
   }
   if (gSSLStatus.isDomainMismatch) {
     flags |= overrideService.ERROR_MISMATCH;
-    confirmBucketId += gNsISecTel.WARNING_BAD_CERT_TOP_CONFIRM_ADD_EXCEPTION_FLAG_DOMAIN;
   }
   if (gSSLStatus.isNotValidAtThisTime) {
     flags |= overrideService.ERROR_TIME;
-    confirmBucketId += gNsISecTel.WARNING_BAD_CERT_TOP_CONFIRM_ADD_EXCEPTION_FLAG_TIME;
   }
   
   var permanentCheckbox = document.getElementById("permanent");
   var shouldStorePermanently = permanentCheckbox.checked && !inPrivateBrowsingMode();
-  if(!permanentCheckbox.checked)
-   gSecHistogram.add(gNsISecTel.WARNING_BAD_CERT_TOP_DONT_REMEMBER_EXCEPTION);
 
-  gSecHistogram.add(confirmBucketId);
   var uri = getURI();
   overrideService.rememberValidityOverride(
     uri.asciiHost, uri.port,
diff --git a/security/manager/ssl/src/SSLServerCertVerification.cpp b/security/manager/ssl/src/SSLServerCertVerification.cpp
index 9d4e780..f3821f0 100644
--- a/security/manager/ssl/src/SSLServerCertVerification.cpp
+++ b/security/manager/ssl/src/SSLServerCertVerification.cpp
@@ -112,7 +112,6 @@
 
 #include "mozilla/Assertions.h"
 #include "mozilla/Mutex.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/net/DNS.h"
 #include "mozilla/unused.h"
 #include "nsIThreadPool.h"
@@ -121,7 +120,6 @@
 #include "nsComponentManagerUtils.h"
 #include "nsServiceManagerUtils.h"
 #include "PSMRunnable.h"
-#include "RootCertificateTelemetryUtils.h"
 #include "SharedSSLState.h"
 #include "nsContentUtils.h"
 #include "nsURLHelper.h"
@@ -146,11 +144,6 @@ namespace {
 // do not use a nsCOMPtr to avoid static initializer/destructor
 nsIThreadPool* gCertVerificationThreadPool = nullptr;
 
-// We avoid using a mutex for the success case to avoid lock-related
-// performance issues. However, we do use a lock in the error case to simplify
-// the code, since performance in the error case is not important.
-Mutex* gSSLVerificationTelemetryMutex = nullptr;
-
 // We add a mutex to serialize PKCS11 database operations
 Mutex* gSSLVerificationPK11Mutex = nullptr;
 
@@ -169,7 +162,6 @@ Mutex* gSSLVerificationPK11Mutex = nullptr;
 void
 InitializeSSLServerCertVerificationThreads()
 {
-  gSSLVerificationTelemetryMutex = new Mutex("SSLVerificationTelemetryMutex");
   gSSLVerificationPK11Mutex = new Mutex("SSLVerificationPK11Mutex");
   // TODO: tuning, make parameters preferences
   // XXX: instantiate nsThreadPool directly, to make this more bulletproof.
@@ -203,10 +195,6 @@ void StopSSLServerCertVerificationThreads()
     gCertVerificationThreadPool->Shutdown();
     NS_RELEASE(gCertVerificationThreadPool);
   }
-  if (gSSLVerificationTelemetryMutex) {
-    delete gSSLVerificationTelemetryMutex;
-    gSSLVerificationTelemetryMutex = nullptr;
-  }
   if (gSSLVerificationPK11Mutex) {
     delete gSSLVerificationPK11Mutex;
     gSSLVerificationPK11Mutex = nullptr;
@@ -240,8 +228,6 @@ public:
 
   SSLServerCertVerificationResult(TransportSecurityInfo* infoObject,
                                   PRErrorCode errorCode,
-                                  Telemetry::ID telemetryID = Telemetry::HistogramCount,
-                                  uint32_t telemetryValue = -1,
                                   SSLErrorMessageType errorMessageType =
                                       PlainErrorMessage);
 
@@ -251,8 +237,6 @@ private:
 public:
   const PRErrorCode mErrorCode;
   const SSLErrorMessageType mErrorMessageType;
-  const Telemetry::ID mTelemetryID;
-  const uint32_t mTelemetryValue;
 };
 
 class CertErrorRunnable : public SyncRunnableBase
@@ -544,21 +528,6 @@ CertErrorRunnable::CheckCertOverrides()
     }
 
     if (!remaining_display_errors) {
-      // This can double- or triple-count one certificate with multiple
-      // different types of errors. Since this is telemetry and we just
-      // want a ballpark answer, we don't care.
-      if (mErrorCodeTrust != 0) {
-        uint32_t probeValue = MapOverridableErrorToProbeValue(mErrorCodeTrust);
-        Telemetry::Accumulate(Telemetry::SSL_CERT_ERROR_OVERRIDES, probeValue);
-      }
-      if (mErrorCodeMismatch != 0) {
-        uint32_t probeValue = MapOverridableErrorToProbeValue(mErrorCodeMismatch);
-        Telemetry::Accumulate(Telemetry::SSL_CERT_ERROR_OVERRIDES, probeValue);
-      }
-      if (mErrorCodeTime != 0) {
-        uint32_t probeValue = MapOverridableErrorToProbeValue(mErrorCodeTime);
-        Telemetry::Accumulate(Telemetry::SSL_CERT_ERROR_OVERRIDES, probeValue);
-      }
 
       // all errors are covered by override rules, so let's accept the cert
       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
@@ -604,8 +573,6 @@ CertErrorRunnable::CheckCertOverrides()
   SSLServerCertVerificationResult* result =
     new SSLServerCertVerificationResult(mInfoObject,
                                         errorCodeToReport,
-                                        Telemetry::HistogramCount,
-                                        -1,
                                         OverridableCertErrorMessage);
 
   LogInvalidCertError(mInfoObject,
@@ -639,9 +606,6 @@ CreateCertErrorRunnable(CertVerifier& certVerifier,
   MOZ_ASSERT(infoObject);
   MOZ_ASSERT(cert);
 
-  uint32_t probeValue = MapCertErrorToProbeValue(defaultErrorCodeToReport);
-  Telemetry::Accumulate(Telemetry::SSL_CERT_VERIFICATION_ERRORS, probeValue);
-
   uint32_t collected_errors = 0;
   PRErrorCode errorCodeTrust = 0;
   PRErrorCode errorCodeMismatch = 0;
@@ -840,26 +804,6 @@ BlockServerCertChangeForSpdy(nsNSSSocketInfo* infoObject,
   return SECFailure;
 }
 
-void
-AccumulateSubjectCommonNameTelemetry(const char* commonName,
-                                     bool commonNameInSubjectAltNames)
-{
-  if (!commonName) {
-    // 1 means no common name present
-    Telemetry::Accumulate(Telemetry::BR_9_2_2_SUBJECT_COMMON_NAME, 1);
-  } else if (!commonNameInSubjectAltNames) {
-    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
-           ("BR telemetry: common name '%s' not in subject alt. names "
-            "(or the subject alt. names extension is not present)\n",
-            commonName));
-    // 2 means the common name is not present in subject alt names
-    Telemetry::Accumulate(Telemetry::BR_9_2_2_SUBJECT_COMMON_NAME, 2);
-  } else {
-    // 0 means the common name is present in subject alt names
-    Telemetry::Accumulate(Telemetry::BR_9_2_2_SUBJECT_COMMON_NAME, 0);
-  }
-}
-
 // Returns true if and only if commonName ends with altName (minus its leading
 // "*"). altName has already been checked to be of the form "*.<something>".
 // commonName may be NULL.
@@ -871,296 +815,6 @@ TryMatchingWildcardSubjectAltName(const char* commonName,
          StringEndsWith(nsDependentCString(commonName), Substring(altName, 1));
 }
 
-// Gathers telemetry on Baseline Requirements 9.2.1 (Subject Alternative
-// Names Extension) and 9.2.2 (Subject Common Name Field).
-// Specifically:
-//  - whether or not the subject common name field is present
-//  - whether or not the subject alternative names extension is present
-//  - if there is a malformed entry in the subject alt. names extension
-//  - if there is an entry in the subject alt. names extension corresponding
-//    to the subject common name
-// Telemetry is only gathered for certificates that chain to a trusted root
-// in Mozilla's Root CA program.
-// certList consists of a validated certificate chain. The end-entity
-// certificate is first and the root (trust anchor) is last.
-void
-GatherBaselineRequirementsTelemetry(const ScopedCERTCertList& certList)
-{
-  CERTCertListNode* endEntityNode = CERT_LIST_HEAD(certList);
-  CERTCertListNode* rootNode = CERT_LIST_TAIL(certList);
-  PR_ASSERT(!(CERT_LIST_END(endEntityNode, certList) ||
-              CERT_LIST_END(rootNode, certList)));
-  if (CERT_LIST_END(endEntityNode, certList) ||
-      CERT_LIST_END(rootNode, certList)) {
-    return;
-  }
-  CERTCertificate* cert = endEntityNode->cert;
-  PR_ASSERT(cert);
-  if (!cert) {
-    return;
-  }
-  mozilla::pkix::ScopedPtr<char, PORT_Free_string> commonName(
-    CERT_GetCommonName(&cert->subject));
-  // This only applies to certificates issued by authorities in our root
-  // program.
-  CERTCertificate* rootCert = rootNode->cert;
-  PR_ASSERT(rootCert);
-  if (!rootCert) {
-    return;
-  }
-  bool isBuiltIn = false;
-  SECStatus rv = IsCertBuiltInRoot(rootCert, isBuiltIn);
-  if (rv != SECSuccess || !isBuiltIn) {
-    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
-           ("BR telemetry: root certificate for '%s' is not a built-in root "
-            "(or IsCertBuiltInRoot failed)\n", commonName.get()));
-    return;
-  }
-  SECItem altNameExtension;
-  rv = CERT_FindCertExtension(cert, SEC_OID_X509_SUBJECT_ALT_NAME,
-                              &altNameExtension);
-  if (rv != SECSuccess) {
-    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
-           ("BR telemetry: no subject alt names extension for '%s'\n",
-            commonName.get()));
-    // 1 means there is no subject alt names extension
-    Telemetry::Accumulate(Telemetry::BR_9_2_1_SUBJECT_ALT_NAMES, 1);
-    AccumulateSubjectCommonNameTelemetry(commonName.get(), false);
-    return;
-  }
-
-  ScopedPLArenaPool arena(PORT_NewArena(DER_DEFAULT_CHUNKSIZE));
-  CERTGeneralName* subjectAltNames =
-    CERT_DecodeAltNameExtension(arena, &altNameExtension);
-  // CERT_FindCertExtension takes a pointer to a SECItem and allocates memory
-  // in its data field. This is a bad way to do this because we can't use a
-  // ScopedSECItem and neither is that memory tracked by an arena. We have to
-  // manually reach in and free the memory.
-  PORT_Free(altNameExtension.data);
-  if (!subjectAltNames) {
-    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
-           ("BR telemetry: could not decode subject alt names for '%s'\n",
-            commonName.get()));
-    // 2 means the subject alt names extension could not be decoded
-    Telemetry::Accumulate(Telemetry::BR_9_2_1_SUBJECT_ALT_NAMES, 2);
-    AccumulateSubjectCommonNameTelemetry(commonName.get(), false);
-    return;
-  }
-
-  CERTGeneralName* currentName = subjectAltNames;
-  bool commonNameInSubjectAltNames = false;
-  bool nonDNSNameOrIPAddressPresent = false;
-  bool malformedDNSNameOrIPAddressPresent = false;
-  bool nonFQDNPresent = false;
-  do {
-    nsAutoCString altName;
-    if (currentName->type == certDNSName) {
-      altName.Assign(reinterpret_cast<char*>(currentName->name.other.data),
-                     currentName->name.other.len);
-      nsDependentCString altNameWithoutWildcard(altName, 0);
-      if (StringBeginsWith(altNameWithoutWildcard, NS_LITERAL_CSTRING("*."))) {
-        altNameWithoutWildcard.Rebind(altName, 2);
-        commonNameInSubjectAltNames |=
-          TryMatchingWildcardSubjectAltName(commonName.get(), altName);
-      }
-      // net_IsValidHostName appears to return true for valid IP addresses,
-      // which would be invalid for a DNS name.
-      // Note that the net_IsValidHostName check will catch things like
-      // "a.*.example.com".
-      if (!net_IsValidHostName(altNameWithoutWildcard) ||
-          net_IsValidIPv4Addr(altName.get(), altName.Length()) ||
-          net_IsValidIPv6Addr(altName.get(), altName.Length())) {
-        PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
-               ("BR telemetry: DNSName '%s' not valid (for '%s')\n",
-                altName.get(), commonName.get()));
-        malformedDNSNameOrIPAddressPresent = true;
-      }
-      if (altName.FindChar('.') == kNotFound) {
-        nonFQDNPresent = true;
-      }
-    } else if (currentName->type == certIPAddress) {
-      // According to DNS.h, this includes space for the null-terminator
-      char buf[net::kNetAddrMaxCStrBufSize] = { 0 };
-      PRNetAddr addr;
-      if (currentName->name.other.len == 4) {
-        addr.inet.family = PR_AF_INET;
-        memcpy(&addr.inet.ip, currentName->name.other.data,
-               currentName->name.other.len);
-        if (PR_NetAddrToString(&addr, buf, sizeof(buf) - 1) != PR_SUCCESS) {
-        PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
-               ("BR telemetry: IPAddress (v4) not valid (for '%s')\n",
-                commonName.get()));
-          malformedDNSNameOrIPAddressPresent = true;
-        } else {
-          altName.Assign(buf);
-        }
-      } else if (currentName->name.other.len == 16) {
-        addr.inet.family = PR_AF_INET6;
-        memcpy(&addr.ipv6.ip, currentName->name.other.data,
-               currentName->name.other.len);
-        if (PR_NetAddrToString(&addr, buf, sizeof(buf) - 1) != PR_SUCCESS) {
-        PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
-               ("BR telemetry: IPAddress (v6) not valid (for '%s')\n",
-                commonName.get()));
-          malformedDNSNameOrIPAddressPresent = true;
-        } else {
-          altName.Assign(buf);
-        }
-      } else {
-        PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
-               ("BR telemetry: IPAddress not valid (for '%s')\n",
-                commonName.get()));
-        malformedDNSNameOrIPAddressPresent = true;
-      }
-    } else {
-      PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
-             ("BR telemetry: non-DNSName, non-IPAddress present for '%s'\n",
-              commonName.get()));
-      nonDNSNameOrIPAddressPresent = true;
-    }
-    if (commonName && altName.Equals(commonName.get())) {
-      commonNameInSubjectAltNames = true;
-    }
-    currentName = CERT_GetNextGeneralName(currentName);
-  } while (currentName && currentName != subjectAltNames);
-
-  if (nonDNSNameOrIPAddressPresent) {
-    // 3 means there's an entry that isn't an ip address or dns name
-    Telemetry::Accumulate(Telemetry::BR_9_2_1_SUBJECT_ALT_NAMES, 3);
-  }
-  if (malformedDNSNameOrIPAddressPresent) {
-    // 4 means there's a malformed ip address or dns name entry
-    Telemetry::Accumulate(Telemetry::BR_9_2_1_SUBJECT_ALT_NAMES, 4);
-  }
-  if (nonFQDNPresent) {
-    // 5 means there's a DNS name entry with a non-fully-qualified domain name
-    Telemetry::Accumulate(Telemetry::BR_9_2_1_SUBJECT_ALT_NAMES, 5);
-  }
-  if (!nonDNSNameOrIPAddressPresent && !malformedDNSNameOrIPAddressPresent &&
-      !nonFQDNPresent) {
-    // 0 means the extension is acceptable
-    Telemetry::Accumulate(Telemetry::BR_9_2_1_SUBJECT_ALT_NAMES, 0);
-  }
-
-  AccumulateSubjectCommonNameTelemetry(commonName.get(),
-                                       commonNameInSubjectAltNames);
-}
-
-// Gather telemetry on whether the end-entity cert for a server has the
-// required TLS Server Authentication EKU, or any others
-void
-GatherEKUTelemetry(const ScopedCERTCertList& certList)
-{
-  CERTCertListNode* endEntityNode = CERT_LIST_HEAD(certList);
-  CERTCertListNode* rootNode = CERT_LIST_TAIL(certList);
-  PR_ASSERT(!(CERT_LIST_END(endEntityNode, certList) ||
-              CERT_LIST_END(rootNode, certList)));
-  if (CERT_LIST_END(endEntityNode, certList) ||
-      CERT_LIST_END(rootNode, certList)) {
-    return;
-  }
-  CERTCertificate* endEntityCert = endEntityNode->cert;
-  PR_ASSERT(endEntityCert);
-  if (!endEntityCert) {
-    return;
-  }
-
-  // Only log telemetry if the root CA is built-in
-  CERTCertificate* rootCert = rootNode->cert;
-  PR_ASSERT(rootCert);
-  if (!rootCert) {
-    return;
-  }
-  bool isBuiltIn = false;
-  SECStatus rv = IsCertBuiltInRoot(rootCert, isBuiltIn);
-  if (rv != SECSuccess || !isBuiltIn) {
-    return;
-  }
-
-  // Find the EKU extension, if present
-  bool foundEKU = false;
-  SECOidTag oidTag;
-  CERTCertExtension* ekuExtension = nullptr;
-  for (size_t i = 0; endEntityCert->extensions && endEntityCert->extensions[i];
-       i++) {
-    oidTag = SECOID_FindOIDTag(&endEntityCert->extensions[i]->id);
-    if (oidTag == SEC_OID_X509_EXT_KEY_USAGE) {
-      foundEKU = true;
-      ekuExtension = endEntityCert->extensions[i];
-    }
-  }
-
-  if (!foundEKU) {
-    Telemetry::Accumulate(Telemetry::SSL_SERVER_AUTH_EKU, 0);
-    return;
-  }
-
-  // Parse the EKU extension
-  ScopedCERTOidSequence ekuSequence(
-    CERT_DecodeOidSequence(&ekuExtension->value));
-  if (!ekuSequence) {
-    return;
-  }
-
-  // Search through the available EKUs
-  bool foundServerAuth = false;
-  bool foundOther = false;
-  for (SECItem** oids = ekuSequence->oids; oids && *oids; oids++) {
-    oidTag = SECOID_FindOIDTag(*oids);
-    if (oidTag == SEC_OID_EXT_KEY_USAGE_SERVER_AUTH) {
-      foundServerAuth = true;
-    } else {
-      foundOther = true;
-    }
-  }
-
-  // Cases 3 is included only for completeness.  It should never
-  // appear in these statistics, because CheckExtendedKeyUsage()
-  // should require the EKU extension, if present, to contain the
-  // value id_kp_serverAuth.
-  if (foundServerAuth && !foundOther) {
-    Telemetry::Accumulate(Telemetry::SSL_SERVER_AUTH_EKU, 1);
-  } else if (foundServerAuth && foundOther) {
-    Telemetry::Accumulate(Telemetry::SSL_SERVER_AUTH_EKU, 2);
-  } else if (!foundServerAuth) {
-    Telemetry::Accumulate(Telemetry::SSL_SERVER_AUTH_EKU, 3);
-  }
-}
-
-// Gathers telemetry on which CA is the root of a given cert chain.
-// If the root is a built-in root, then the telemetry makes a count
-// by root.  Roots that are not built-in are counted in one bin.
-void
-GatherRootCATelemetry(const ScopedCERTCertList& certList)
-{
-  CERTCertListNode* rootNode = CERT_LIST_TAIL(certList);
-  PR_ASSERT(rootNode);
-  if (!rootNode) {
-    return;
-  }
-  PR_ASSERT(!CERT_LIST_END(rootNode, certList));
-  if (CERT_LIST_END(rootNode, certList)) {
-    return;
-  }
-  CERTCertificate* rootCert = rootNode->cert;
-  PR_ASSERT(rootCert);
-  if (!rootCert) {
-    return;
-  }
-  AccumulateTelemetryForRootCA(Telemetry::CERT_VALIDATION_SUCCESS_BY_CA,
-                               rootCert);
-}
-
-// There are various things that we want to measure about certificate
-// chains that we accept.  This is a single entry point for all of them.
-void
-GatherSuccessfulValidationTelemetry(const ScopedCERTCertList& certList)
-{
-  GatherBaselineRequirementsTelemetry(certList);
-  GatherEKUTelemetry(certList);
-  GatherRootCATelemetry(certList);
-}
-
 SECStatus
 AuthCertificate(CertVerifier& certVerifier,
                 TransportSecurityInfo* infoObject,
@@ -1197,14 +851,6 @@ AuthCertificate(CertVerifier& certVerifier,
     savedErrorCode = PR_GetError();
   }
 
-  if (ocspStaplingStatus != CertVerifier::OCSP_STAPLING_NEVER_CHECKED) {
-    Telemetry::Accumulate(Telemetry::SSL_OCSP_STAPLING, ocspStaplingStatus);
-  }
-  if (keySizeStatus != KeySizeStatus::NeverChecked) {
-    Telemetry::Accumulate(Telemetry::CERT_CHAIN_KEY_SIZE_STATUS,
-                          static_cast<uint32_t>(keySizeStatus));
-  }
-
   // We want to remember the CA certs in the temp db, so that the application can find the
   // complete chain at any time it might need it.
   // But we keep only those CA certs in the temp db, that we didn't already know.
@@ -1222,7 +868,6 @@ AuthCertificate(CertVerifier& certVerifier,
   }
 
   if (rv == SECSuccess) {
-    GatherSuccessfulValidationTelemetry(certList);
 
     // The connection may get terminated, for example, if the server requires
     // a client cert. Let's provide a minimal SSLStatus
@@ -1340,10 +985,6 @@ SSLServerCertVerificationJob::Run()
   if (mInfoObject->isAlreadyShutDown()) {
     error = SEC_ERROR_USER_CANCELLED;
   } else {
-    Telemetry::ID successTelemetry
-      = Telemetry::SSL_SUCCESFUL_CERT_VALIDATION_TIME_MOZILLAPKIX;
-    Telemetry::ID failureTelemetry
-      = Telemetry::SSL_INITIAL_FAILED_CERT_VALIDATION_TIME_MOZILLAPKIX;
 
     // Reset the error code here so we can detect if AuthCertificate fails to
     // set the error code if/when it fails.
@@ -1354,21 +995,14 @@ SSLServerCertVerificationJob::Run()
     if (rv == SECSuccess) {
       uint32_t interval = (uint32_t) ((TimeStamp::Now() - mJobStartTime).ToMilliseconds());
       RefPtr<SSLServerCertVerificationResult> restart(
-        new SSLServerCertVerificationResult(mInfoObject, 0,
-                                            successTelemetry, interval));
+        new SSLServerCertVerificationResult(mInfoObject, 0));
       restart->Dispatch();
-      Telemetry::Accumulate(Telemetry::SSL_CERT_ERROR_OVERRIDES, 1);
       return NS_OK;
     }
 
     // Note: the interval is not calculated once as PR_GetError MUST be called
     // before any other  function call
     error = PR_GetError();
-    {
-      TimeStamp now = TimeStamp::Now();
-      MutexAutoLock telemetryMutex(*gSSLVerificationTelemetryMutex);
-      Telemetry::AccumulateTimeDelta(failureTelemetry, mJobStartTime, now);
-    }
     if (error != 0) {
       RefPtr<CertErrorRunnable> runnable(
           CreateCertErrorRunnable(*mCertVerifier, error, mInfoObject,
@@ -1513,7 +1147,6 @@ AuthCertificateHook(void* arg, PRFileDesc* fd, PRBool checkSig, PRBool isServer)
                                  peerCertChain, stapledOCSPResponse,
                                  providerFlags, now);
   if (rv == SECSuccess) {
-    Telemetry::Accumulate(Telemetry::SSL_CERT_ERROR_OVERRIDES, 1);
     return SECSuccess;
   }
 
@@ -1601,19 +1234,11 @@ void EnsureServerVerificationInitialized()
 
 SSLServerCertVerificationResult::SSLServerCertVerificationResult(
         TransportSecurityInfo* infoObject, PRErrorCode errorCode,
-        Telemetry::ID telemetryID, uint32_t telemetryValue,
         SSLErrorMessageType errorMessageType)
   : mInfoObject(infoObject)
   , mErrorCode(errorCode)
   , mErrorMessageType(errorMessageType)
-  , mTelemetryID(telemetryID)
-  , mTelemetryValue(telemetryValue)
 {
-// We accumulate telemetry for (only) successful validations on the main thread
-// to avoid adversely affecting performance by acquiring the mutex that we use
-// when accumulating the telemetry for unsuccessful validations. Unsuccessful
-// validations times are accumulated elsewhere.
-MOZ_ASSERT(telemetryID == Telemetry::HistogramCount || errorCode == 0);
 }
 
 void
@@ -1632,10 +1257,6 @@ SSLServerCertVerificationResult::Dispatch()
 NS_IMETHODIMP
 SSLServerCertVerificationResult::Run()
 {
-  // TODO: Assert that we're on the socket transport thread
-  if (mTelemetryID != Telemetry::HistogramCount) {
-     Telemetry::Accumulate(mTelemetryID, mTelemetryValue);
-  }
   // XXX: This cast will be removed by the next patch
   ((nsNSSSocketInfo*) mInfoObject.get())
     ->SetCertVerificationResult(mErrorCode, mErrorMessageType);
diff --git a/security/manager/ssl/src/nsCertOverrideService.cpp b/security/manager/ssl/src/nsCertOverrideService.cpp
index 22c1b4a..3f658ea 100644
--- a/security/manager/ssl/src/nsCertOverrideService.cpp
+++ b/security/manager/ssl/src/nsCertOverrideService.cpp
@@ -9,7 +9,6 @@
 #include "NSSCertDBTrustDomain.h"
 #include "ScopedNSSTypes.h"
 #include "SharedSSLState.h"
-#include "mozilla/Telemetry.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsCRT.h"
 #include "nsILineInputStream.h"
@@ -149,7 +148,6 @@ nsCertOverrideService::Observe(nsISupports     *,
       mSettingsFile = nullptr;
     }
     Read();
-    CountPermanentOverrideTelemetry();
   }
 
   return NS_OK;
@@ -615,17 +613,6 @@ CountPermanentEntriesCallback(nsCertOverrideEntry* aEntry, void* aArg)
   return PL_DHASH_NEXT;
 }
 
-void
-nsCertOverrideService::CountPermanentOverrideTelemetry()
-{
-  ReentrantMonitorAutoEnter lock(monitor);
-  uint32_t overrideCount = 0;
-  mSettingsTable.EnumerateEntries(CountPermanentEntriesCallback,
-                                  &overrideCount);
-  Telemetry::Accumulate(Telemetry::SSL_PERMANENT_CERT_ERROR_OVERRIDES,
-                        overrideCount);
-}
-
 static bool
 matchesDBKey(nsIX509Cert *cert, const char *match_dbkey)
 {
diff --git a/security/manager/ssl/src/nsCertOverrideService.h b/security/manager/ssl/src/nsCertOverrideService.h
index 97245aa..5ab1dce 100644
--- a/security/manager/ssl/src/nsCertOverrideService.h
+++ b/security/manager/ssl/src/nsCertOverrideService.h
@@ -165,8 +165,6 @@ protected:
     SECOidTag mOidTagForStoringNewHashes;
     nsCString mDottedOidForStoringNewHashes;
 
-    void CountPermanentOverrideTelemetry();
-
     void RemoveAllFromMemory();
     nsresult Read();
     nsresult Write();
diff --git a/security/manager/ssl/src/nsNSSCallbacks.cpp b/security/manager/ssl/src/nsNSSCallbacks.cpp
index 742167b..edc094f 100644
--- a/security/manager/ssl/src/nsNSSCallbacks.cpp
+++ b/security/manager/ssl/src/nsNSSCallbacks.cpp
@@ -6,7 +6,6 @@
 
 #include "nsNSSCallbacks.h"
 #include "pkix/pkixtypes.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/TimeStamp.h"
 #include "nsNSSComponent.h"
 #include "nsNSSIOLayer.h"
@@ -32,19 +31,8 @@ using namespace mozilla::psm;
 extern PRLogModuleInfo* gPIPNSSLog;
 #endif
 
-static void AccumulateCipherSuite(Telemetry::ID probe,
-                                  const SSLChannelInfo& channelInfo);
-
 namespace {
 
-// Bits in bit mask for SSL_REASONS_FOR_NOT_FALSE_STARTING telemetry probe
-// These bits are numbered so that the least subtle issues have higher values.
-// This should make it easier for us to interpret the results.
-const uint32_t NPN_NOT_NEGOTIATED = 64;
-const uint32_t POSSIBLE_VERSION_DOWNGRADE = 4;
-const uint32_t POSSIBLE_CIPHER_SUITE_DOWNGRADE = 2;
-const uint32_t KEA_NOT_SUPPORTED = 1;
-
 }
 
 class nsHTTPDownloadEvent : public nsRunnable {
@@ -480,31 +468,6 @@ nsNSSHttpRequestSession::internal_send_receive_attempt(bool &retryable_error,
     }
   }
 
-  if (!event->mStartTime.IsNull()) {
-    if (request_canceled) {
-      Telemetry::Accumulate(Telemetry::CERT_VALIDATION_HTTP_REQUEST_RESULT, 0);
-      Telemetry::AccumulateTimeDelta(
-        Telemetry::CERT_VALIDATION_HTTP_REQUEST_CANCELED_TIME,
-        event->mStartTime, TimeStamp::Now());
-    }
-    else if (NS_SUCCEEDED(mListener->mResultCode) &&
-             mListener->mHttpResponseCode == 200) {
-      Telemetry::Accumulate(Telemetry::CERT_VALIDATION_HTTP_REQUEST_RESULT, 1);
-      Telemetry::AccumulateTimeDelta(
-        Telemetry::CERT_VALIDATION_HTTP_REQUEST_SUCCEEDED_TIME,
-        event->mStartTime, TimeStamp::Now());
-    }
-    else {
-      Telemetry::Accumulate(Telemetry::CERT_VALIDATION_HTTP_REQUEST_RESULT, 2);
-      Telemetry::AccumulateTimeDelta(
-        Telemetry::CERT_VALIDATION_HTTP_REQUEST_FAILED_TIME,
-        event->mStartTime, TimeStamp::Now());
-    }
-  }
-  else {
-    Telemetry::Accumulate(Telemetry::CERT_VALIDATION_HTTP_REQUEST_RESULT, 3);
-  }
-
   if (request_canceled)
     return SECFailure;
 
@@ -920,7 +883,6 @@ PreliminaryHandshakeDone(PRFileDesc* fd)
     else {
       infoObject->SetNegotiatedNPN(nullptr, 0);
     }
-    mozilla::Telemetry::Accumulate(Telemetry::SSL_NPN_TYPE, state);
   }
   else {
     infoObject->SetNegotiatedNPN(nullptr, 0);
@@ -974,7 +936,7 @@ CanFalseStartCallback(PRFileDesc* fd, void* client_data, PRBool *canFalseStart)
     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
                                       "SSL Version must be TLS 1.2, was %x\n", fd,
                                       static_cast<int32_t>(channelInfo.protocolVersion)));
-    reasonsForNotFalseStarting |= POSSIBLE_VERSION_DOWNGRADE;
+    reasonsForNotFalseStarting |= 1;
   }
 
   // See bug 952863 for why ECDHE is allowed, but DHE (and RSA) are not.
@@ -982,7 +944,7 @@ CanFalseStartCallback(PRFileDesc* fd, void* client_data, PRBool *canFalseStart)
     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
                                       "unsupported KEA %d\n", fd,
                                       static_cast<int32_t>(channelInfo.keaType)));
-    reasonsForNotFalseStarting |= KEA_NOT_SUPPORTED;
+    reasonsForNotFalseStarting |= 2;
   }
 
   // Prevent downgrade attacks on the symmetric cipher. We do not allow CBC
@@ -993,7 +955,7 @@ CanFalseStartCallback(PRFileDesc* fd, void* client_data, PRBool *canFalseStart)
            ("CanFalseStartCallback [%p] failed - non-AEAD cipher used, %d, "
             "is not supported with False Start.\n", fd,
             static_cast<int32_t>(cipherInfo.symCipher)));
-    reasonsForNotFalseStarting |= POSSIBLE_CIPHER_SUITE_DOWNGRADE;
+    reasonsForNotFalseStarting |= 4;
   }
 
   // XXX: An attacker can choose which protocols are advertised in the
@@ -1010,13 +972,10 @@ CanFalseStartCallback(PRFileDesc* fd, void* client_data, PRBool *canFalseStart)
         !negotiatedNPN.Length()) {
       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
                                         "NPN cannot be verified\n", fd));
-      reasonsForNotFalseStarting |= NPN_NOT_NEGOTIATED;
+      reasonsForNotFalseStarting |= 8;
     }
   }
 
-  Telemetry::Accumulate(Telemetry::SSL_REASONS_FOR_NOT_FALSE_STARTING,
-                        reasonsForNotFalseStarting);
-
   if (reasonsForNotFalseStarting == 0) {
     *canFalseStart = PR_TRUE;
     infoObject->SetFalseStarted();
@@ -1027,106 +986,6 @@ CanFalseStartCallback(PRFileDesc* fd, void* client_data, PRBool *canFalseStart)
   return SECSuccess;
 }
 
-static void
-AccumulateNonECCKeySize(Telemetry::ID probe, uint32_t bits)
-{
-  unsigned int value = bits <   512 ?  1 : bits ==   512 ?  2
-                     : bits <   768 ?  3 : bits ==   768 ?  4
-                     : bits <  1024 ?  5 : bits ==  1024 ?  6
-                     : bits <  1280 ?  7 : bits ==  1280 ?  8
-                     : bits <  1536 ?  9 : bits ==  1536 ? 10
-                     : bits <  2048 ? 11 : bits ==  2048 ? 12
-                     : bits <  3072 ? 13 : bits ==  3072 ? 14
-                     : bits <  4096 ? 15 : bits ==  4096 ? 16
-                     : bits <  8192 ? 17 : bits ==  8192 ? 18
-                     : bits < 16384 ? 19 : bits == 16384 ? 20
-                     : 0;
-  Telemetry::Accumulate(probe, value);
-}
-
-// XXX: This attempts to map a bit count to an ECC named curve identifier. In
-// the vast majority of situations, we only have the Suite B curves available.
-// In that case, this mapping works fine. If we were to have more curves
-// available, the mapping would be ambiguous since there could be multiple
-// named curves for a given size (e.g. secp256k1 vs. secp256r1). We punt on
-// that for now. See also NSS bug 323674.
-static void
-AccumulateECCCurve(Telemetry::ID probe, uint32_t bits)
-{
-  unsigned int value = bits == 256 ? 23 // P-256
-                     : bits == 384 ? 24 // P-384
-                     : bits == 521 ? 25 // P-521
-                     : 0; // Unknown
-  Telemetry::Accumulate(probe, value);
-}
-
-static void
-AccumulateCipherSuite(Telemetry::ID probe, const SSLChannelInfo& channelInfo)
-{
-  uint32_t value;
-  switch (channelInfo.cipherSuite) {
-    // ECDHE key exchange
-    case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: value = 1; break;
-    case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: value = 2; break;
-    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: value = 3; break;
-    case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: value = 4; break;
-    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: value = 5; break;
-    case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: value = 6; break;
-    case TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: value = 7; break;
-    case TLS_ECDHE_RSA_WITH_RC4_128_SHA: value = 8; break;
-    case TLS_ECDHE_ECDSA_WITH_RC4_128_SHA: value = 9; break;
-    case TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA: value = 10; break;
-    case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: value = 11; break;
-    case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: value = 12; break;
-    case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: value = 13; break;
-    case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: value = 14; break;
-    // DHE key exchange
-    case TLS_DHE_RSA_WITH_AES_128_CBC_SHA: value = 21; break;
-    case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: value = 22; break;
-    case TLS_DHE_RSA_WITH_AES_256_CBC_SHA: value = 23; break;
-    case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: value = 24; break;
-    case TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA: value = 25; break;
-    case TLS_DHE_DSS_WITH_AES_128_CBC_SHA: value = 26; break;
-    case TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: value = 27; break;
-    case TLS_DHE_DSS_WITH_AES_256_CBC_SHA: value = 28; break;
-    case TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: value = 29; break;
-    case TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA: value = 30; break;
-    // ECDH key exchange
-    case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: value = 41; break;
-    case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: value = 42; break;
-    case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: value = 43; break;
-    case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: value = 44; break;
-    case TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA: value = 45; break;
-    case TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA: value = 46; break;
-    case TLS_ECDH_ECDSA_WITH_RC4_128_SHA: value = 47; break;
-    case TLS_ECDH_RSA_WITH_RC4_128_SHA: value = 48; break;
-    // RSA key exchange
-    case TLS_RSA_WITH_AES_128_CBC_SHA: value = 61; break;
-    case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA: value = 62; break;
-    case TLS_RSA_WITH_AES_256_CBC_SHA: value = 63; break;
-    case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA: value = 64; break;
-    case SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA: value = 65; break;
-    case TLS_RSA_WITH_3DES_EDE_CBC_SHA: value = 66; break;
-    case TLS_RSA_WITH_SEED_CBC_SHA: value = 67; break;
-    case TLS_RSA_WITH_RC4_128_SHA: value = 68; break;
-    case TLS_RSA_WITH_RC4_128_MD5: value = 69; break;
-    case TLS_RSA_WITH_AES_256_GCM_SHA384: value = 70; break;
-    case TLS_RSA_WITH_AES_256_CBC_SHA256: value = 71; break;
-    case TLS_RSA_WITH_AES_128_GCM_SHA256: value = 72; break;
-    case TLS_RSA_WITH_AES_128_CBC_SHA256: value = 73; break;    
-    // TLS 1.3 PSK resumption
-    case TLS_AES_128_GCM_SHA256: value = 74; break;
-    case TLS_CHACHA20_POLY1305_SHA256: value = 75; break;
-    case TLS_AES_256_GCM_SHA384: value = 76; break;
-    // unknown
-    default:
-      value = 0;
-      break;
-  }
-  MOZ_ASSERT(value != 0);
-  Telemetry::Accumulate(probe, value);
-}
-
 void HandshakeCallback(PRFileDesc* fd, void* client_data) {
   nsNSSShutDownPreventionLock locker;
   SECStatus rv;
@@ -1159,14 +1018,6 @@ void HandshakeCallback(PRFileDesc* fd, void* client_data) {
   rv = SSL_GetChannelInfo(fd, &channelInfo, sizeof(channelInfo));
   MOZ_ASSERT(rv == SECSuccess);
   if (rv == SECSuccess) {
-    // Get the protocol version for telemetry
-    // 0=ssl3, 1=tls1, 2=tls1.1, 3=tls1.2, 4=tls1.3
-    unsigned int versionEnum = channelInfo.protocolVersion & 0xFF;
-    Telemetry::Accumulate(Telemetry::SSL_HANDSHAKE_VERSION, versionEnum);
-    AccumulateCipherSuite(
-      infoObject->IsFullHandshake() ? Telemetry::SSL_CIPHER_SUITE_FULL
-                                    : Telemetry::SSL_CIPHER_SUITE_RESUMED,
-      channelInfo);
 
     SSLCipherSuiteInfo cipherInfo;
     rv = SSL_GetCipherSuiteInfo(channelInfo.cipherSuite, &cipherInfo,
@@ -1177,67 +1028,9 @@ void HandshakeCallback(PRFileDesc* fd, void* client_data) {
         channelInfo.protocolVersion <= SSL_LIBRARY_VERSION_3_0;
       usesWeakCipher = cipherInfo.symCipher == ssl_calg_rc4;
 
-      // keyExchange null=0, rsa=1, dh=2, fortezza=3, ecdh=4
-      Telemetry::Accumulate(
-        infoObject->IsFullHandshake()
-          ? Telemetry::SSL_KEY_EXCHANGE_ALGORITHM_FULL
-          : Telemetry::SSL_KEY_EXCHANGE_ALGORITHM_RESUMED,
-        channelInfo.keaType);
-
       DebugOnly<int16_t> KEAUsed;
       MOZ_ASSERT(NS_SUCCEEDED(infoObject->GetKEAUsed(&KEAUsed)) &&
                  (KEAUsed == channelInfo.keaType));
-
-      if (infoObject->IsFullHandshake()) {
-        switch (channelInfo.keaType) {
-          case ssl_kea_rsa:
-            AccumulateNonECCKeySize(Telemetry::SSL_KEA_RSA_KEY_SIZE_FULL,
-                                    channelInfo.keaKeyBits);
-            break;
-          case ssl_kea_dh:
-            AccumulateNonECCKeySize(Telemetry::SSL_KEA_DHE_KEY_SIZE_FULL,
-                                    channelInfo.keaKeyBits);
-            break;
-          case ssl_kea_ecdh:
-            AccumulateECCCurve(Telemetry::SSL_KEA_ECDHE_CURVE_FULL,
-                               channelInfo.keaKeyBits);
-            break;
-          default:
-            MOZ_CRASH("impossible KEA");
-            break;
-        }
-
-        Telemetry::Accumulate(Telemetry::SSL_AUTH_ALGORITHM_FULL,
-                              channelInfo.authType);
-
-        // RSA key exchange doesn't use a signature for auth.
-        if (channelInfo.keaType != ssl_kea_rsa) {
-          switch (channelInfo.authType) {
-            case ssl_auth_rsa:
-            case ssl_auth_rsa_sign:
-              AccumulateNonECCKeySize(Telemetry::SSL_AUTH_RSA_KEY_SIZE_FULL,
-                                      channelInfo.authKeyBits);
-              break;
-            case ssl_auth_dsa:
-              AccumulateNonECCKeySize(Telemetry::SSL_AUTH_DSA_KEY_SIZE_FULL,
-                                      channelInfo.authKeyBits);
-              break;
-            case ssl_auth_ecdsa:
-              AccumulateECCCurve(Telemetry::SSL_AUTH_ECDSA_CURVE_FULL,
-                                 channelInfo.authKeyBits);
-              break;
-            default:
-              MOZ_CRASH("impossible auth algorithm");
-              break;
-          }
-        }
-      }
-
-      Telemetry::Accumulate(
-          infoObject->IsFullHandshake()
-            ? Telemetry::SSL_SYMMETRIC_CIPHER_FULL
-            : Telemetry::SSL_SYMMETRIC_CIPHER_RESUMED,
-          cipherInfo.symCipher);
     }
   }
 
diff --git a/security/manager/ssl/src/nsNSSComponent.cpp b/security/manager/ssl/src/nsNSSComponent.cpp
index d235c1f..707d7f3 100644
--- a/security/manager/ssl/src/nsNSSComponent.cpp
+++ b/security/manager/ssl/src/nsNSSComponent.cpp
@@ -8,7 +8,6 @@
 
 #include "ExtendedValidation.h"
 #include "NSSCertDBTrustDomain.h"
-#include "mozilla/Telemetry.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsCertVerificationThread.h"
 #include "nsAppDirectoryServiceDefs.h"
@@ -906,13 +905,6 @@ void nsNSSComponent::setValidationOptions(bool isInitialSetting,
   bool ocspRequired = ocspEnabled &&
     Preferences::GetBool("security.OCSP.require", false);
 
-  // We measure the setting of the pref at startup only to minimize noise by
-  // addons that may muck with the settings, though it probably doesn't matter.
-  if (isInitialSetting) {
-    Telemetry::Accumulate(Telemetry::CERT_OCSP_ENABLED, ocspEnabled);
-    Telemetry::Accumulate(Telemetry::CERT_OCSP_REQUIRED, ocspRequired);
-  }
-
   bool ocspStaplingEnabled = Preferences::GetBool("security.ssl.enable_ocsp_stapling",
                                                   true);
   PublicSSLState()->SetOCSPStaplingEnabled(ocspStaplingEnabled);
diff --git a/security/manager/ssl/src/nsNSSIOLayer.cpp b/security/manager/ssl/src/nsNSSIOLayer.cpp
index 70a0115..963fbdc 100644
--- a/security/manager/ssl/src/nsNSSIOLayer.cpp
+++ b/security/manager/ssl/src/nsNSSIOLayer.cpp
@@ -12,7 +12,6 @@
 #include "mozilla/BinarySearch.h"
 #include "mozilla/Casting.h"
 #include "mozilla/DebugOnly.h"
-#include "mozilla/Telemetry.h"
 
 #include "prlog.h"
 #include "prmem.h"
@@ -318,9 +317,6 @@ nsNSSSocketInfo::NoteTimeUntilReady()
 
   mNotedTimeUntilReady = true;
 
-  // This will include TCP and proxy tunnel wait time
-  Telemetry::AccumulateTimeDelta(Telemetry::SSL_TIME_UNTIL_READY,
-                                 mSocketCreationTimestamp, TimeStamp::Now());
   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
          ("[%p] nsNSSSocketInfo::NoteTimeUntilReady\n", mFd));
 }
@@ -328,31 +324,6 @@ nsNSSSocketInfo::NoteTimeUntilReady()
 void
 nsNSSSocketInfo::SetHandshakeCompleted()
 {
-  if (!mHandshakeCompleted) {
-    enum HandshakeType {
-      Resumption = 1,
-      FalseStarted = 2,
-      ChoseNotToFalseStart = 3,
-      NotAllowedToFalseStart = 4,
-    };
-
-    HandshakeType handshakeType = !IsFullHandshake() ? Resumption
-                                : mFalseStarted ? FalseStarted
-                                : mFalseStartCallbackCalled ? ChoseNotToFalseStart
-                                : NotAllowedToFalseStart;
-
-    // This will include TCP and proxy tunnel wait time
-    Telemetry::AccumulateTimeDelta(Telemetry::SSL_TIME_UNTIL_HANDSHAKE_FINISHED,
-                                   mSocketCreationTimestamp, TimeStamp::Now());
-
-    // If the handshake is completed for the first time from just 1 callback
-    // that means that TLS session resumption must have been used.
-    Telemetry::Accumulate(Telemetry::SSL_RESUMED_SESSION,
-                          handshakeType == Resumption);
-    Telemetry::Accumulate(Telemetry::SSL_HANDSHAKE_TYPE, handshakeType);
-  }
-
-
     // Remove the plain text layer as it is not needed anymore.
     // The plain text layer is not always present - so its not a fatal error
     // if it cannot be removed
@@ -731,11 +702,6 @@ nsNSSSocketInfo::SetCertVerificationResult(PRErrorCode errorCode,
     SetCanceled(errorCode, errorMessageType);
   }
 
-  if (mPlaintextBytesRead && !errorCode) {
-    Telemetry::Accumulate(Telemetry::SSL_BYTES_BEFORE_CERT_CALLBACK,
-                          AssertedCast<uint32_t>(mPlaintextBytesRead));
-  }
-
   mCertVerificationState = after_cert_verification;
 }
 
@@ -1201,29 +1167,6 @@ class SSLErrorRunnable : public SyncRunnableBase
 
 namespace {
 
-uint32_t tlsIntoleranceTelemetryBucket(PRErrorCode err)
-{
-  // returns a numeric code for where we track various errors in telemetry
-  // only errors that cause version fallback are tracked,
-  // so this is also used to determine which errors can cause version fallback
-  switch (err) {
-    case SSL_ERROR_BAD_MAC_ALERT: return 1;
-    case SSL_ERROR_BAD_MAC_READ: return 2;
-    case SSL_ERROR_HANDSHAKE_FAILURE_ALERT: return 3;
-    case SSL_ERROR_HANDSHAKE_UNEXPECTED_ALERT: return 4;
-    case SSL_ERROR_ILLEGAL_PARAMETER_ALERT: return 6;
-    case SSL_ERROR_NO_CYPHER_OVERLAP: return 7;
-    case SSL_ERROR_UNSUPPORTED_VERSION: return 10;
-    case SSL_ERROR_PROTOCOL_VERSION_ALERT: return 11;
-    case SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE: return 13;
-    case SSL_ERROR_DECODE_ERROR_ALERT: return 14;
-    case PR_CONNECT_RESET_ERROR: return 16;
-    case PR_END_OF_FILE_ERROR: return 17;
-    case SSL_ERROR_INTERNAL_ERROR_ALERT: return 18;
-    default: return 0;
-  }
-}
-
 bool
 retryDueToTLSIntolerance(PRErrorCode err, nsNSSSocketInfo* socketInfo)
 {
@@ -1245,15 +1188,6 @@ retryDueToTLSIntolerance(PRErrorCode err, nsNSSSocketInfo* socketInfo)
     // this as a hard failure, but forget any intolerance so that later attempts
     // don't use this version (i.e., range.max) and trigger the error again.
 
-    // First, track the original cause of the version fallback.  This uses the
-    // same buckets as the telemetry below, except that bucket 0 will include
-    // all cases where there wasn't an original reason.
-    PRErrorCode originalReason =
-      helpers.getIntoleranceReason(socketInfo->GetHostName(),
-                                   socketInfo->GetPort());
-    Telemetry::Accumulate(Telemetry::SSL_VERSION_FALLBACK_INAPPROPRIATE,
-                          tlsIntoleranceTelemetryBucket(originalReason));
-
     helpers.forgetIntolerance(socketInfo->GetHostName(),
                               socketInfo->GetPort());
 
@@ -1273,11 +1207,8 @@ retryDueToTLSIntolerance(PRErrorCode err, nsNSSSocketInfo* socketInfo)
       nsNSSComponent::AreAnyWeakCiphersEnabled()) {
     if (helpers.rememberStrongCiphersFailed(socketInfo->GetHostName(),
                                             socketInfo->GetPort(), err)) {
-      Telemetry::Accumulate(Telemetry::SSL_WEAK_CIPHERS_FALLBACK,
-                            tlsIntoleranceTelemetryBucket(err));
       return true;
     }
-    Telemetry::Accumulate(Telemetry::SSL_WEAK_CIPHERS_FALLBACK, 0);
   }
 
   // When not using a proxy we'll see a connection reset error.
@@ -1301,51 +1232,12 @@ retryDueToTLSIntolerance(PRErrorCode err, nsNSSSocketInfo* socketInfo)
     return false;
   }
 
-  uint32_t reason = tlsIntoleranceTelemetryBucket(err);
-  if (reason == 0) {
-    return false;
-  }
-
-  Telemetry::ID pre;
-  Telemetry::ID post;
-  switch (range.max) {
-    case SSL_LIBRARY_VERSION_TLS_1_3:
-      pre = Telemetry::SSL_TLS13_INTOLERANCE_REASON_PRE;
-      post = Telemetry::SSL_TLS13_INTOLERANCE_REASON_POST;
-      break;
-    case SSL_LIBRARY_VERSION_TLS_1_2:
-      pre = Telemetry::SSL_TLS12_INTOLERANCE_REASON_PRE;
-      post = Telemetry::SSL_TLS12_INTOLERANCE_REASON_POST;
-      break;
-    case SSL_LIBRARY_VERSION_TLS_1_1:
-      pre = Telemetry::SSL_TLS11_INTOLERANCE_REASON_PRE;
-      post = Telemetry::SSL_TLS11_INTOLERANCE_REASON_POST;
-      break;
-    case SSL_LIBRARY_VERSION_TLS_1_0:
-      pre = Telemetry::SSL_TLS10_INTOLERANCE_REASON_PRE;
-      post = Telemetry::SSL_TLS10_INTOLERANCE_REASON_POST;
-      break;
-    case SSL_LIBRARY_VERSION_3_0:
-      pre = Telemetry::SSL_SSL30_INTOLERANCE_REASON_PRE;
-      post = Telemetry::SSL_SSL30_INTOLERANCE_REASON_POST;
-      break;
-    default:
-      MOZ_CRASH("impossible TLS version");
-      return false;
-  }
-
-  // The difference between _PRE and _POST represents how often we avoided
-  // TLS intolerance fallback due to remembered tolerance.
-  Telemetry::Accumulate(pre, reason);
-
   if (!helpers.rememberIntolerantAtVersion(socketInfo->GetHostName(),
                                            socketInfo->GetPort(),
                                            range.min, range.max, err)) {
     return false;
   }
 
-  Telemetry::Accumulate(post, reason);
-
   return true;
 }
 
diff --git a/security/manager/ssl/src/nsNTLMAuthModule.cpp b/security/manager/ssl/src/nsNTLMAuthModule.cpp
index ced249e..bffa9b6 100644
--- a/security/manager/ssl/src/nsNTLMAuthModule.cpp
+++ b/security/manager/ssl/src/nsNTLMAuthModule.cpp
@@ -12,7 +12,6 @@
 #include "mozilla/Endian.h"
 #include "mozilla/Likely.h"
 #include "mozilla/Preferences.h"
-#include "mozilla/Telemetry.h"
 #include "nsCOMPtr.h"
 #include "nsComponentManagerUtils.h"
 #include "nsICryptoHash.h"
@@ -1003,16 +1002,6 @@ nsNTLMAuthModule::Init(const char      *serviceName,
   mUsername = username;
   mPassword = password;
 
-  static bool sTelemetrySent = false;
-  if (!sTelemetrySent) {
-      mozilla::Telemetry::Accumulate(
-          mozilla::Telemetry::NTLM_MODULE_USED_2,
-          serviceFlags & nsIAuthModule::REQ_PROXY_AUTH
-              ? NTLM_MODULE_GENERIC_PROXY
-              : NTLM_MODULE_GENERIC_DIRECT);
-      sTelemetrySent = true;
-  }
-
   return NS_OK;
 }
 
diff --git a/security/manager/ssl/tests/unit/test_cert_overrides.js b/security/manager/ssl/tests/unit/test_cert_overrides.js
index 140348e..a04d01b 100644
--- a/security/manager/ssl/tests/unit/test_cert_overrides.js
+++ b/security/manager/ssl/tests/unit/test_cert_overrides.js
@@ -25,40 +25,6 @@ function add_non_overridable_test(aHost, aExpectedError) {
     });
 }
 
-function check_telemetry() {
-  let histogram = Cc["@mozilla.org/base/telemetry;1"]
-                    .getService(Ci.nsITelemetry)
-                    .getHistogramById("SSL_CERT_ERROR_OVERRIDES")
-                    .snapshot();
-  do_check_eq(histogram.counts[ 0], 0);
-  do_check_eq(histogram.counts[ 2], 7); // SEC_ERROR_UNKNOWN_ISSUER
-  do_check_eq(histogram.counts[ 3], 1); // SEC_ERROR_CA_CERT_INVALID
-  do_check_eq(histogram.counts[ 4], 0); // SEC_ERROR_UNTRUSTED_ISSUER
-  do_check_eq(histogram.counts[ 5], 1); // SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE
-  do_check_eq(histogram.counts[ 6], 0); // SEC_ERROR_UNTRUSTED_CERT
-  do_check_eq(histogram.counts[ 7], 0); // SEC_ERROR_INADEQUATE_KEY_USAGE
-  do_check_eq(histogram.counts[ 8], 2); // SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
-  do_check_eq(histogram.counts[ 9], 6); // SSL_ERROR_BAD_CERT_DOMAIN
-  do_check_eq(histogram.counts[10], 5); // SEC_ERROR_EXPIRED_CERTIFICATE
-  do_check_eq(histogram.counts[11], 2); // MOZILLA_PKIX_ERROR_CA_CERT_USED_AS_END_ENTITY
-  do_check_eq(histogram.counts[12], 1); // MOZILLA_PKIX_ERROR_V1_CERT_USED_AS_CA
-  do_check_eq(histogram.counts[13], 0); // MOZILLA_PKIX_ERROR_INADEQUATE_KEY_SIZE
-  do_check_eq(histogram.counts[14], 2); // MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
-  do_check_eq(histogram.counts[15], 1); // MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
-  do_check_eq(histogram.counts[16], 2); // SEC_ERROR_INVALID_TIME
-
-  let keySizeHistogram = Cc["@mozilla.org/base/telemetry;1"]
-                           .getService(Ci.nsITelemetry)
-                           .getHistogramById("CERT_CHAIN_KEY_SIZE_STATUS")
-                           .snapshot();
-  do_check_eq(keySizeHistogram.counts[0], 0);
-  do_check_eq(keySizeHistogram.counts[1], 0); // 0 successful verifications of 2048-bit keys
-  do_check_eq(keySizeHistogram.counts[2], 4); // 4 successful verifications of 1024-bit keys
-  do_check_eq(keySizeHistogram.counts[3], 48); // 48 verification failures
-
-  run_next_test();
-}
-
 function run_test() {
   add_tls_server_setup("BadCertServer");
 
@@ -72,10 +38,6 @@ function run_test() {
   add_combo_tests();
   add_distrust_tests();
 
-  add_test(function () {
-    fakeOCSPResponder.stop(check_telemetry);
-  });
-
   run_next_test();
 }
 
diff --git a/security/manager/ssl/tests/unit/test_ocsp_stapling.js b/security/manager/ssl/tests/unit/test_ocsp_stapling.js
index 7b1d99c..75cdd10 100644
--- a/security/manager/ssl/tests/unit/test_ocsp_stapling.js
+++ b/security/manager/ssl/tests/unit/test_ocsp_stapling.js
@@ -148,19 +148,6 @@ function add_tests(certDB, otherTestCA) {
                 getXPCOMStatusFromNSS(SEC_ERROR_REVOKED_CERTIFICATE), true);
 }
 
-function check_ocsp_stapling_telemetry() {
-  let histogram = Cc["@mozilla.org/base/telemetry;1"]
-                    .getService(Ci.nsITelemetry)
-                    .getHistogramById("SSL_OCSP_STAPLING")
-                    .snapshot();
-  do_check_eq(histogram.counts[0], 0); // histogram bucket 0 is unused
-  do_check_eq(histogram.counts[1], 5); // 5 connections with a good response
-  do_check_eq(histogram.counts[2], 18); // 18 connections with no stapled resp.
-  do_check_eq(histogram.counts[3], 0); // 0 connections with an expired response
-  do_check_eq(histogram.counts[4], 21); // 21 connections with bad responses
-  run_next_test();
-}
-
 function run_test() {
   do_get_profile();
 
@@ -181,9 +168,5 @@ function run_test() {
 
   add_tests(certDB, otherTestCA);
 
-  add_test(function () {
-    fakeOCSPResponder.stop(check_ocsp_stapling_telemetry);
-  });
-
   run_next_test();
 }
diff --git a/security/manager/ssl/tests/unit/test_ocsp_stapling_expired.js b/security/manager/ssl/tests/unit/test_ocsp_stapling_expired.js
index 8db4748..e4ba6f1 100644
--- a/security/manager/ssl/tests/unit/test_ocsp_stapling_expired.js
+++ b/security/manager/ssl/tests/unit/test_ocsp_stapling_expired.js
@@ -148,19 +148,6 @@ function run_test() {
                 ocspResponseUnknown);
 
   add_test(function () { ocspResponder.stop(run_next_test); });
-  add_test(check_ocsp_stapling_telemetry);
   run_next_test();
 }
 
-function check_ocsp_stapling_telemetry() {
-  let histogram = Cc["@mozilla.org/base/telemetry;1"]
-                    .getService(Ci.nsITelemetry)
-                    .getHistogramById("SSL_OCSP_STAPLING")
-                    .snapshot();
-  do_check_eq(histogram.counts[0], 0); // histogram bucket 0 is unused
-  do_check_eq(histogram.counts[1], 0); // 0 connections with a good response
-  do_check_eq(histogram.counts[2], 0); // 0 connections with no stapled resp.
-  do_check_eq(histogram.counts[3], 21); // 21 connections with an expired response
-  do_check_eq(histogram.counts[4], 0); // 0 connections with bad responses
-  run_next_test();
-}
diff --git a/security/manager/ssl/tests/unit/test_pinning.js b/security/manager/ssl/tests/unit/test_pinning.js
index 2902f94..2740200 100644
--- a/security/manager/ssl/tests/unit/test_pinning.js
+++ b/security/manager/ssl/tests/unit/test_pinning.js
@@ -187,35 +187,6 @@ function test_enforce_test_mode() {
   add_clear_override("unknownissuer.test-mode.pinning.example.com");
 }
 
-function check_pinning_telemetry() {
-  let service = Cc["@mozilla.org/base/telemetry;1"].getService(Ci.nsITelemetry);
-  let prod_histogram = service.getHistogramById("CERT_PINNING_RESULTS")
-                         .snapshot();
-  let test_histogram = service.getHistogramById("CERT_PINNING_TEST_RESULTS")
-                         .snapshot();
-  // Because all of our test domains are pinned to user-specified trust
-  // anchors, effectively only strict mode and enforce test-mode get evaluated
-  do_check_eq(prod_histogram.counts[0], 4); // Failure count
-  do_check_eq(prod_histogram.counts[1], 4); // Success count
-  do_check_eq(test_histogram.counts[0], 2); // Failure count
-  do_check_eq(test_histogram.counts[1], 0); // Success count
-
-  let moz_prod_histogram = service.getHistogramById("CERT_PINNING_MOZ_RESULTS")
-                             .snapshot();
-  let moz_test_histogram =
-    service.getHistogramById("CERT_PINNING_MOZ_TEST_RESULTS").snapshot();
-  do_check_eq(moz_prod_histogram.counts[0], 0); // Failure count
-  do_check_eq(moz_prod_histogram.counts[1], 0); // Success count
-  do_check_eq(moz_test_histogram.counts[0], 0); // Failure count
-  do_check_eq(moz_test_histogram.counts[1], 0); // Success count
-
-  let per_host_histogram =
-    service.getHistogramById("CERT_PINNING_MOZ_RESULTS_BY_HOST").snapshot();
-  do_check_eq(per_host_histogram.counts[0], 0); // Failure count
-  do_check_eq(per_host_histogram.counts[1], 2); // Success count
-  run_next_test();
-}
-
 function run_test() {
   add_tls_server_setup("BadCertServer");
 
@@ -227,8 +198,5 @@ function run_test() {
   test_disabled();
   test_enforce_test_mode();
 
-  add_test(function () {
-    check_pinning_telemetry();
-  });
   run_next_test();
 }
diff --git a/toolkit/components/telemetry/Histograms.json b/toolkit/components/telemetry/Histograms.json
index d02db61..10d486a 100644
--- a/toolkit/components/telemetry/Histograms.json
+++ b/toolkit/components/telemetry/Histograms.json
@@ -226,7 +226,7 @@
   "GC_REASON_2": {
     "expires_in_version": "never",
     "kind": "enumerated",
-    "n_values": "JS::gcreason::NUM_TELEMETRY_REASONS",
+    "n_values": 10,
     "description": "Reason (enum value) for initiating a GC"
   },
   "GC_IS_COMPARTMENTAL": {
diff --git a/toolkit/content/browser-child.js b/toolkit/content/browser-child.js
index cbab0d0..615a54e 100644
--- a/toolkit/content/browser-child.js
+++ b/toolkit/content/browser-child.js
@@ -431,7 +431,6 @@ addEventListener("ZoomChangeUsingMouseWheel", function () {
 
 addMessageListener("UpdateCharacterSet", function (aMessage) {
   docShell.charset = aMessage.data.value;
-  docShell.gatherCharsetMenuTelemetry();
 });
 
 /**
diff --git a/toolkit/content/widgets/browser.xml b/toolkit/content/widgets/browser.xml
index da11d25..a7c016d 100644
--- a/toolkit/content/widgets/browser.xml
+++ b/toolkit/content/widgets/browser.xml
@@ -482,7 +482,6 @@
                 onget="return this.docShell.charset;">
         <setter><![CDATA[
           this.docShell.charset = val;
-          this.docShell.gatherCharsetMenuTelemetry();
         ]]></setter>
       </property>
 
diff --git a/toolkit/mozapps/extensions/amWebInstallListener.js b/toolkit/mozapps/extensions/amWebInstallListener.js
index 901beef..7d1f48c 100644
--- a/toolkit/mozapps/extensions/amWebInstallListener.js
+++ b/toolkit/mozapps/extensions/amWebInstallListener.js
@@ -172,10 +172,6 @@ Installer.prototype = {
     args.wrappedJSObject = args;
 
     try {
-      Cc["@mozilla.org/base/telemetry;1"].
-            getService(Ci.nsITelemetry).
-            getHistogramById("SECURITY_UI").
-            add(Ci.nsISecurityUITelemetry.WARNING_CONFIRM_ADDON_INSTALL);
       let parentWindow = null;
       if (this.browser) {
         parentWindow = this.browser.ownerDocument.defaultView;
diff --git a/toolkit/mozapps/extensions/content/xpinstallConfirm.js b/toolkit/mozapps/extensions/content/xpinstallConfirm.js
index 678e370..289de55 100644
--- a/toolkit/mozapps/extensions/content/xpinstallConfirm.js
+++ b/toolkit/mozapps/extensions/content/xpinstallConfirm.js
@@ -179,10 +179,6 @@ XPInstallConfirm.init = function XPInstallConfirm_init()
 
 XPInstallConfirm.onOK = function XPInstallConfirm_onOk()
 {
-  Components.classes["@mozilla.org/base/telemetry;1"].
-    getService(Components.interfaces.nsITelemetry).
-    getHistogramById("SECURITY_UI").
-    add(Components.interfaces.nsISecurityUITelemetry.WARNING_CONFIRM_ADDON_INSTALL_CLICK_THROUGH);
   // Perform the install or cancel after the window has unloaded
   XPInstallConfirm._installOK = true;
   return true;
diff --git a/toolkit/mozapps/update/content/updates.js b/toolkit/mozapps/update/content/updates.js
index c1949ce..dca0a42 100644
--- a/toolkit/mozapps/update/content/updates.js
+++ b/toolkit/mozapps/update/content/updates.js
@@ -166,13 +166,6 @@ var gUpdates = {
                     finished: 16,
                     finishedBackground: 17,
                     installed: 18 };
-    try {
-      Services.telemetry.getHistogramById("UPDATER_WIZ_LAST_PAGE_CODE").
-        add(pageMap[pageID] || pageMap.invalid);
-    }
-    catch (e) {
-      Components.utils.reportError(e);
-    }
   },
 
   /**
@@ -1731,9 +1724,6 @@ var gErrorExtraPage = {
   onPageShow: function() {
     gUpdates.setButtons(null, null, "okButton", true);
     gUpdates.wiz.getButton("finish").focus();
-    let secHistogram = CoC["@mozilla.org/base/telemetry;1"].
-                                  getService(CoI.nsITelemetry).
-                                  getHistogramById("SECURITY_UI");
 
     if (Services.prefs.prefHasUserValue(PREF_APP_UPDATE_CERT_ERRORS))
       Services.prefs.clearUserPref(PREF_APP_UPDATE_CERT_ERRORS);
@@ -1743,12 +1733,10 @@ var gErrorExtraPage = {
 
     if (gUpdates.update.errorCode == CERT_ATTR_CHECK_FAILED_HAS_UPDATE) {
       document.getElementById("errorCertAttrHasUpdateLabel").hidden = false;
-      secHistogram.add(CoI.nsISecurityUITelemetry.WARNING_INSECURE_UPDATE);
     }
     else {
       if (gUpdates.update.errorCode == CERT_ATTR_CHECK_FAILED_NO_UPDATE){
         document.getElementById("errorCertCheckNoUpdateLabel").hidden = false;
-        secHistogram.add(CoI.nsISecurityUITelemetry.WARNING_NO_SECURE_UPDATE);
       }
       else
         document.getElementById("genericBackgroundErrorLabel").hidden = false;
diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
index 424c76b..70cc45e 100644
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -161,6 +161,7 @@
 #include "mozilla/LinkedList.h"
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/SegmentedVector.h"
+#include "mozilla/TimeStamp.h"
 
 #include "nsCycleCollectionParticipant.h"
 #include "nsCycleCollectionNoteRootCallback.h"
@@ -184,7 +185,6 @@
 
 #include "mozilla/Likely.h"
 #include "mozilla/PoisonIOInterposer.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/ThreadLocal.h"
 
 using namespace mozilla;
@@ -527,15 +527,6 @@ public:
 #define CC_GRAPH_ASSERT(b)
 #endif
 
-#define CC_TELEMETRY(_name, _value)                                            \
-    PR_BEGIN_MACRO                                                             \
-    if (NS_IsMainThread()) {                                                   \
-      Telemetry::Accumulate(Telemetry::CYCLE_COLLECTOR##_name, _value);        \
-    } else {                                                                   \
-      Telemetry::Accumulate(Telemetry::CYCLE_COLLECTOR_WORKER##_name, _value); \
-    }                                                                          \
-    PR_END_MACRO
-
 enum NodeColor { black, white, grey };
 
 // This structure should be kept as small as possible; we may expect
@@ -2955,7 +2946,6 @@ nsCycleCollector::ScanWeakMaps()
 
   if (failed) {
     MOZ_ASSERT(false, "Ran out of memory in ScanWeakMaps");
-    CC_TELEMETRY(_OOM, true);
   }
 }
 
@@ -3098,7 +3088,6 @@ nsCycleCollector::ScanIncrementalRoots()
 
   if (failed) {
     NS_ASSERTION(false, "Ran out of memory in ScanIncrementalRoots");
-    CC_TELEMETRY(_OOM, true);
   }
 }
 
@@ -3161,7 +3150,6 @@ nsCycleCollector::ScanBlackNodes()
 
   if (failed) {
     NS_ASSERTION(false, "Ran out of memory in ScanBlackNodes");
-    CC_TELEMETRY(_OOM, true);
   }
 }
 
@@ -3499,7 +3487,6 @@ nsCycleCollector::FixGrayBits(bool aForceGC, TimeLog& aTimeLog)
 
     bool needGC = !mJSRuntime->AreGCGrayBitsValid();
     // Only do a telemetry ping for non-shutdown CCs.
-    CC_TELEMETRY(_NEED_GC, needGC);
     if (!needGC) {
       return;
     }
@@ -3551,12 +3538,6 @@ nsCycleCollector::CleanupAfterCollection()
   printf(".\ncc: \n");
 #endif
 
-  CC_TELEMETRY( , interval);
-  CC_TELEMETRY(_VISITED_REF_COUNTED, mResults.mVisitedRefCounted);
-  CC_TELEMETRY(_VISITED_GCED, mResults.mVisitedGCed);
-  CC_TELEMETRY(_COLLECTED, mWhiteNodeCount);
-  timeLog.Checkpoint("CleanupAfterCollection::telemetry");
-
   if (mJSRuntime) {
     mJSRuntime->EndCycleCollectionCallback(mResults);
     timeLog.Checkpoint("CleanupAfterCollection::EndCycleCollectionCallback()");
diff --git a/xpcom/base/nsMemoryReporterManager.cpp b/xpcom/base/nsMemoryReporterManager.cpp
index ed56744..5993dc9 100644
--- a/xpcom/base/nsMemoryReporterManager.cpp
+++ b/xpcom/base/nsMemoryReporterManager.cpp
@@ -24,7 +24,6 @@
 #include "mozilla/Attributes.h"
 #include "mozilla/PodOperations.h"
 #include "mozilla/Services.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/dom/PMemoryReportRequestParent.h" // for dom::MemoryReport
 
 #ifdef XP_WIN
@@ -434,7 +433,6 @@ ResidentDistinguishedAmountHelper(int64_t* aN, bool aDoPurge)
 {
 #ifdef HAVE_JEMALLOC_STATS
   if (aDoPurge) {
-    Telemetry::AutoTimer<Telemetry::MEMORY_FREE_PURGED_PAGES_MS> timer;
     jemalloc_purge_freed_pages();
   }
 #endif
diff --git a/xpcom/build/LateWriteChecks.cpp b/xpcom/build/LateWriteChecks.cpp
index e697d60..6b31317 100644
--- a/xpcom/build/LateWriteChecks.cpp
+++ b/xpcom/build/LateWriteChecks.cpp
@@ -12,7 +12,6 @@
 #include "mozilla/SHA1.h"
 #include "mozilla/Scoped.h"
 #include "mozilla/StaticPtr.h"
-#include "mozilla/Telemetry.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsDirectoryServiceUtils.h"
 #include "nsPrintfCString.h"
@@ -120,7 +119,7 @@ LateWriteObserver::Observe(IOInterposeObserver::Observation& aOb)
   }
 
   // If we have shutdown mode SCM_NOTHING or we can't record then abort
-  if (gShutdownChecks == SCM_NOTHING || !Telemetry::CanRecord()) {
+  if (gShutdownChecks == SCM_NOTHING) {
     return;
   }
 
@@ -130,7 +129,6 @@ LateWriteObserver::Observe(IOInterposeObserver::Observation& aOb)
 
   NS_StackWalk(RecordStackWalker, /* skipFrames */ 0, /* maxFrames */ 0,
                reinterpret_cast<void*>(&rawStack), 0, nullptr);
-  Telemetry::ProcessedStack stack = Telemetry::GetStackAndModules(rawStack);
 
   nsPrintfCString nameAux("%s%s%s", mProfileDirectory,
                           NS_SLASH, "Telemetry.LateWriteTmpXXXXXX");
@@ -170,7 +168,6 @@ LateWriteObserver::Observe(IOInterposeObserver::Observation& aOb)
   size_t numModules = stack.GetNumModules();
   sha1Stream.Printf("%u\n", (unsigned)numModules);
   for (size_t i = 0; i < numModules; ++i) {
-    Telemetry::ProcessedStack::Module module = stack.GetModule(i);
     sha1Stream.Printf("%s %s\n", module.mBreakpadId.c_str(),
                       module.mName.c_str());
   }
@@ -178,7 +175,6 @@ LateWriteObserver::Observe(IOInterposeObserver::Observation& aOb)
   size_t numFrames = stack.GetStackSize();
   sha1Stream.Printf("%u\n", (unsigned)numFrames);
   for (size_t i = 0; i < numFrames; ++i) {
-    const Telemetry::ProcessedStack::Frame& frame = stack.GetFrame(i);
     // NOTE: We write the offsets, while the atos tool expects a value with
     // the virtual address added. For example, running otool -l on the the firefox
     // binary shows
diff --git a/xpcom/build/PoisonIOInterposerMac.cpp b/xpcom/build/PoisonIOInterposerMac.cpp
index b1898d9..df4149c 100644
--- a/xpcom/build/PoisonIOInterposerMac.cpp
+++ b/xpcom/build/PoisonIOInterposerMac.cpp
@@ -14,7 +14,6 @@
 #include "mozilla/Mutex.h"
 #include "mozilla/ProcessedStack.h"
 #include "mozilla/Scoped.h"
-#include "mozilla/Telemetry.h"
 #include "nsPrintfCString.h"
 #include "nsStackWalk.h"
 #include "nsTraceRefcnt.h"
diff --git a/xpcom/build/XPCOMInit.cpp b/xpcom/build/XPCOMInit.cpp
index 291ab32..c37a3f9 100644
--- a/xpcom/build/XPCOMInit.cpp
+++ b/xpcom/build/XPCOMInit.cpp
@@ -114,7 +114,6 @@ extern nsresult nsStringInputStreamConstructor(nsISupports*, REFNSIID, void**);
 #include "mozilla/Services.h"
 #include "mozilla/Omnijar.h"
 #include "mozilla/HangMonitor.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/BackgroundHangMonitor.h"
 
 #include "nsChromeRegistry.h"
@@ -743,8 +742,6 @@ NS_InitXPCOM2(nsIServiceManager** aResult,
   RegisterStrongMemoryReporter(new NesteggReporter());
 #endif
 
-  mozilla::Telemetry::Init();
-
   mozilla::HangMonitor::Startup();
   mozilla::BackgroundHangMonitor::Startup();
 
diff --git a/xpcom/build/nsXULAppAPI.h b/xpcom/build/nsXULAppAPI.h
index f8b2120..158b1bc 100644
--- a/xpcom/build/nsXULAppAPI.h
+++ b/xpcom/build/nsXULAppAPI.h
@@ -422,9 +422,6 @@ XRE_API(void,
         XRE_InstallX11ErrorHandler, ())
 
 XRE_API(void,
-        XRE_TelemetryAccumulate, (int aID, uint32_t aSample))
-
-XRE_API(void,
         XRE_StartupTimelineRecord, (int aEvent, PRTime aWhen))
 
 XRE_API(void,
diff --git a/xpcom/threads/HangMonitor.cpp b/xpcom/threads/HangMonitor.cpp
index 6f6340d..c5a72f1 100644
--- a/xpcom/threads/HangMonitor.cpp
+++ b/xpcom/threads/HangMonitor.cpp
@@ -13,7 +13,6 @@
 #include "mozilla/Monitor.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/ProcessedStack.h"
-#include "mozilla/Telemetry.h"
 #include "mozilla/StaticPtr.h"
 #include "mozilla/UniquePtr.h"
 #include "nsReadableUtils.h"
@@ -36,10 +35,6 @@ volatile bool gDebugDisableHangMonitor = false;
 
 const char kHangMonitorPrefName[] = "hangmonitor.timeout";
 
-#ifdef REPORT_CHROME_HANGS
-const char kTelemetryPrefName[] = "toolkit.telemetry.enabled";
-#endif
-
 // Monitor protects gShutdown and gTimeout, but not gTimestamp which rely on
 // being atomically set by the processor; synchronization doesn't really matter
 // in this use case.
@@ -57,34 +52,11 @@ bool gShutdown;
 // we're currently not processing events.
 Atomic<PRIntervalTime> gTimestamp(PR_INTERVAL_NO_WAIT);
 
-#ifdef REPORT_CHROME_HANGS
-// Main thread ID used in reporting chrome hangs under Windows
-static HANDLE winMainThreadHandle = nullptr;
-
-// Default timeout for reporting chrome hangs to Telemetry (5 seconds)
-static const int32_t DEFAULT_CHROME_HANG_INTERVAL = 5;
-
-// Maximum number of PCs to gather from the stack
-static const int32_t MAX_CALL_STACK_PCS = 400;
-
-// Chrome hang annotators
-static StaticAutoPtr<std::set<Annotator*>> gAnnotators;
-#endif
-
 // PrefChangedFunc
 void
 PrefChanged(const char*, void*)
 {
   int32_t newval = Preferences::GetInt(kHangMonitorPrefName);
-#ifdef REPORT_CHROME_HANGS
-  // Monitor chrome hangs on the profiling branch if Telemetry enabled
-  if (newval == 0) {
-    bool telemetryEnabled = Preferences::GetBool(kTelemetryPrefName);
-    if (telemetryEnabled) {
-      newval = DEFAULT_CHROME_HANG_INTERVAL;
-    }
-  }
-#endif
   MonitorAutoLock lock(*gMonitor);
   if (newval != gTimeout) {
     gTimeout = newval;
@@ -108,231 +80,6 @@ Crash()
   NS_RUNTIMEABORT("HangMonitor triggered");
 }
 
-#ifdef REPORT_CHROME_HANGS
-class ChromeHangAnnotations : public HangAnnotations
-{
-public:
-  ChromeHangAnnotations();
-  ~ChromeHangAnnotations();
-
-  void AddAnnotation(const nsAString& aName, const int32_t aData) override;
-  void AddAnnotation(const nsAString& aName, const double aData) override;
-  void AddAnnotation(const nsAString& aName, const nsAString& aData) override;
-  void AddAnnotation(const nsAString& aName, const nsACString& aData) override;
-  void AddAnnotation(const nsAString& aName, const bool aData) override;
-
-  size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const override;
-  bool IsEmpty() const override;
-  bool GetEnumerator(Enumerator** aOutEnum) override;
-
-  typedef std::pair<nsString, nsString> AnnotationType;
-  typedef std::vector<AnnotationType> VectorType;
-  typedef VectorType::const_iterator IteratorType;
-
-private:
-  VectorType  mAnnotations;
-};
-
-ChromeHangAnnotations::ChromeHangAnnotations()
-{
-  MOZ_COUNT_CTOR(ChromeHangAnnotations);
-}
-
-ChromeHangAnnotations::~ChromeHangAnnotations()
-{
-  MOZ_COUNT_DTOR(ChromeHangAnnotations);
-}
-
-void
-ChromeHangAnnotations::AddAnnotation(const nsAString& aName, const int32_t aData)
-{
-  nsString dataString;
-  dataString.AppendInt(aData);
-  AnnotationType annotation = std::make_pair(nsString(aName), dataString);
-  mAnnotations.push_back(annotation);
-}
-
-void
-ChromeHangAnnotations::AddAnnotation(const nsAString& aName, const double aData)
-{
-  nsString dataString;
-  dataString.AppendFloat(aData);
-  AnnotationType annotation = std::make_pair(nsString(aName), dataString);
-  mAnnotations.push_back(annotation);
-}
-
-void
-ChromeHangAnnotations::AddAnnotation(const nsAString& aName, const nsAString& aData)
-{
-  AnnotationType annotation = std::make_pair(nsString(aName), nsString(aData));
-  mAnnotations.push_back(annotation);
-}
-
-void
-ChromeHangAnnotations::AddAnnotation(const nsAString& aName, const nsACString& aData)
-{
-  nsString dataString;
-  AppendUTF8toUTF16(aData, dataString);
-  AnnotationType annotation = std::make_pair(nsString(aName), dataString);
-  mAnnotations.push_back(annotation);
-}
-
-void
-ChromeHangAnnotations::AddAnnotation(const nsAString& aName, const bool aData)
-{
-  nsString dataString;
-  dataString += aData ? NS_LITERAL_STRING("true") : NS_LITERAL_STRING("false");
-  AnnotationType annotation = std::make_pair(nsString(aName), dataString);
-  mAnnotations.push_back(annotation);
-}
-
-/**
- * This class itself does not use synchronization but it (and its parent object)
- * should be protected by mutual exclusion in some way. In Telemetry the chrome
- * hang data is protected via TelemetryImpl::mHangReportsMutex.
- */
-class ChromeHangAnnotationEnumerator : public HangAnnotations::Enumerator
-{
-public:
-  ChromeHangAnnotationEnumerator(const ChromeHangAnnotations::VectorType& aAnnotations);
-  ~ChromeHangAnnotationEnumerator();
-
-  virtual bool Next(nsAString& aOutName, nsAString& aOutValue);
-
-private:
-  ChromeHangAnnotations::IteratorType mIterator;
-  ChromeHangAnnotations::IteratorType mEnd;
-};
-
-ChromeHangAnnotationEnumerator::ChromeHangAnnotationEnumerator(
-                          const ChromeHangAnnotations::VectorType& aAnnotations)
-  : mIterator(aAnnotations.begin())
-  , mEnd(aAnnotations.end())
-{
-  MOZ_COUNT_CTOR(ChromeHangAnnotationEnumerator);
-}
-
-ChromeHangAnnotationEnumerator::~ChromeHangAnnotationEnumerator()
-{
-  MOZ_COUNT_DTOR(ChromeHangAnnotationEnumerator);
-}
-
-bool
-ChromeHangAnnotationEnumerator::Next(nsAString& aOutName, nsAString& aOutValue)
-{
-  aOutName.Truncate();
-  aOutValue.Truncate();
-  if (mIterator == mEnd) {
-    return false;
-  }
-  aOutName = mIterator->first;
-  aOutValue = mIterator->second;
-  ++mIterator;
-  return true;
-}
-
-bool
-ChromeHangAnnotations::IsEmpty() const
-{
-  return mAnnotations.empty();
-}
-
-size_t
-ChromeHangAnnotations::SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const
-{
-  size_t result = sizeof(mAnnotations) +
-                  mAnnotations.capacity() * sizeof(AnnotationType);
-  for (IteratorType i = mAnnotations.begin(), e = mAnnotations.end(); i != e;
-       ++i) {
-    result += i->first.SizeOfExcludingThisIfUnshared(aMallocSizeOf);
-    result += i->second.SizeOfExcludingThisIfUnshared(aMallocSizeOf);
-  }
-
-  return result;
-}
-
-bool
-ChromeHangAnnotations::GetEnumerator(HangAnnotations::Enumerator** aOutEnum)
-{
-  if (!aOutEnum) {
-    return false;
-  }
-  *aOutEnum = nullptr;
-  if (mAnnotations.empty()) {
-    return false;
-  }
-  *aOutEnum = new ChromeHangAnnotationEnumerator(mAnnotations);
-  return true;
-}
-
-static void
-ChromeStackWalker(uint32_t aFrameNumber, void* aPC, void* aSP, void* aClosure)
-{
-  MOZ_ASSERT(aClosure);
-  std::vector<uintptr_t>* stack =
-    static_cast<std::vector<uintptr_t>*>(aClosure);
-  if (stack->size() == MAX_CALL_STACK_PCS) {
-    return;
-  }
-  MOZ_ASSERT(stack->size() < MAX_CALL_STACK_PCS);
-  stack->push_back(reinterpret_cast<uintptr_t>(aPC));
-}
-
-static void
-GetChromeHangReport(Telemetry::ProcessedStack& aStack,
-                    int32_t& aSystemUptime,
-                    int32_t& aFirefoxUptime)
-{
-  MOZ_ASSERT(winMainThreadHandle);
-
-  // The thread we're about to suspend might have the alloc lock
-  // so allocate ahead of time
-  std::vector<uintptr_t> rawStack;
-  rawStack.reserve(MAX_CALL_STACK_PCS);
-  DWORD ret = ::SuspendThread(winMainThreadHandle);
-  if (ret == -1) {
-    return;
-  }
-  NS_StackWalk(ChromeStackWalker, /* skipFrames */ 0, /* maxFrames */ 0,
-               reinterpret_cast<void*>(&rawStack),
-               reinterpret_cast<uintptr_t>(winMainThreadHandle), nullptr);
-  ret = ::ResumeThread(winMainThreadHandle);
-  if (ret == -1) {
-    return;
-  }
-  aStack = Telemetry::GetStackAndModules(rawStack);
-
-  // Record system uptime (in minutes) at the time of the hang
-  aSystemUptime = ((GetTickCount() / 1000) - (gTimeout * 2)) / 60;
-
-  // Record Firefox uptime (in minutes) at the time of the hang
-  bool error;
-  TimeStamp processCreation = TimeStamp::ProcessCreation(error);
-  if (!error) {
-    TimeDuration td = TimeStamp::Now() - processCreation;
-    aFirefoxUptime = (static_cast<int32_t>(td.ToSeconds()) - (gTimeout * 2)) / 60;
-  } else {
-    aFirefoxUptime = -1;
-  }
-}
-
-static void
-ChromeHangAnnotatorCallout(ChromeHangAnnotations& aAnnotations)
-{
-  gMonitor->AssertCurrentThreadOwns();
-  MOZ_ASSERT(gAnnotators);
-  if (!gAnnotators) {
-    return;
-  }
-  for (std::set<Annotator*>::iterator i = gAnnotators->begin(),
-                                      e = gAnnotators->end();
-       i != e; ++i) {
-    (*i)->AnnotateHang(aAnnotations);
-  }
-}
-
-#endif
-
 void
 ThreadMain(void*)
 {
@@ -346,13 +93,6 @@ ThreadMain(void*)
   PRIntervalTime lastTimestamp = 0;
   int waitCount = 0;
 
-#ifdef REPORT_CHROME_HANGS
-  Telemetry::ProcessedStack stack;
-  int32_t systemUptime = -1;
-  int32_t firefoxUptime = -1;
-  auto annotations = MakeUnique<ChromeHangAnnotations>();
-#endif
-
   while (true) {
     if (gShutdown) {
       return; // Exit the thread
@@ -373,14 +113,6 @@ ThreadMain(void*)
         timestamp == lastTimestamp &&
         gTimeout > 0) {
       ++waitCount;
-#ifdef REPORT_CHROME_HANGS
-      // Capture the chrome-hang stack + Firefox & system uptimes after
-      // the minimum hang duration has been reached (not when the hang ends)
-      if (waitCount == 2) {
-        GetChromeHangReport(stack, systemUptime, firefoxUptime);
-        ChromeHangAnnotatorCallout(*annotations);
-      }
-#else
       // This is the crash-on-hang feature.
       // See bug 867313 for the quirk in the waitCount comparison
       if (waitCount >= 2) {
@@ -391,17 +123,7 @@ ThreadMain(void*)
           Crash();
         }
       }
-#endif
     } else {
-#ifdef REPORT_CHROME_HANGS
-      if (waitCount >= 2) {
-        uint32_t hangDuration = PR_IntervalToSeconds(now - lastTimestamp);
-        Telemetry::RecordChromeHang(hangDuration, stack, systemUptime,
-                                    firefoxUptime, Move(annotations));
-        stack.Clear();
-        annotations = MakeUnique<ChromeHangAnnotations>();
-      }
-#endif
       lastTimestamp = timestamp;
       waitCount = 0;
     }
@@ -432,16 +154,6 @@ Startup()
   Preferences::RegisterCallback(PrefChanged, kHangMonitorPrefName, nullptr);
   PrefChanged(nullptr, nullptr);
 
-#ifdef REPORT_CHROME_HANGS
-  Preferences::RegisterCallback(PrefChanged, kTelemetryPrefName, nullptr);
-  winMainThreadHandle =
-    OpenThread(THREAD_ALL_ACCESS, FALSE, GetCurrentThreadId());
-  if (!winMainThreadHandle) {
-    return;
-  }
-  gAnnotators = new std::set<Annotator*>();
-#endif
-
   // Don't actually start measuring hangs until we hit the main event loop.
   // This potentially misses a small class of really early startup hangs,
   // but avoids dealing with some xpcshell tests and other situations which
@@ -479,10 +191,6 @@ Shutdown()
   delete gMonitor;
   gMonitor = nullptr;
 
-#ifdef REPORT_CHROME_HANGS
-  // gAnnotators is a StaticAutoPtr, so we just need to null it out.
-  gAnnotators = nullptr;
-#endif
 }
 
 static bool
@@ -545,10 +253,6 @@ NotifyActivity(ActivityType aActivityType)
     // The minimum amount of lag time that we should report for telemetry data.
     // Mozilla's UI responsiveness goal is 50ms
     static const uint32_t kUIResponsivenessThresholdMS = 50;
-    if (cumulativeUILagMS > kUIResponsivenessThresholdMS) {
-      mozilla::Telemetry::Accumulate(mozilla::Telemetry::EVENTLOOP_UI_LAG_EXP_MS,
-                                     cumulativeUILagMS);
-    }
     cumulativeUILagMS = 0;
   }
 
@@ -574,27 +278,11 @@ Suspend()
 void
 RegisterAnnotator(Annotator& aAnnotator)
 {
-#ifdef REPORT_CHROME_HANGS
-  if (GoannaProcessType_Default != XRE_GetProcessType()) {
-    return;
-  }
-  MonitorAutoLock lock(*gMonitor);
-  MOZ_ASSERT(gAnnotators);
-  gAnnotators->insert(&aAnnotator);
-#endif
 }
 
 void
 UnregisterAnnotator(Annotator& aAnnotator)
 {
-#ifdef REPORT_CHROME_HANGS
-  if (GoannaProcessType_Default != XRE_GetProcessType()) {
-    return;
-  }
-  MonitorAutoLock lock(*gMonitor);
-  MOZ_ASSERT(gAnnotators);
-  gAnnotators->erase(&aAnnotator);
-#endif
 }
 
 } // namespace HangMonitor
-- 
2.8.2.windows.1

