From 422a2928d8ac9a5d34a2297817786135885a6aea Mon Sep 17 00:00:00 2001
From: fedor <fedor@mail.ru>
Date: Mon, 26 Mar 2018 00:18:11 +0300
Subject: [PATCH] gmp

---
 browser/installer/package-manifest.in              |    5 +-
 configure.in                                       |   33 -
 dom/locales/en-US/chrome/plugins.properties        |   11 +-
 dom/media/PeerConnection.js                        |   14 -
 dom/media/fmp4/MP4Decoder.cpp                      |    7 -
 dom/media/gmp-plugin-openh264/Makefile.in          |   12 -
 dom/media/gmp-plugin-openh264/fakeopenh264.info    |    4 -
 dom/media/gmp-plugin-openh264/fakeopenh264.voucher |    1 -
 dom/media/gmp-plugin-openh264/moz.build            |   26 -
 dom/media/gmp-plugin/Makefile.in                   |   13 -
 dom/media/gmp-plugin/fake.info                     |    5 -
 dom/media/gmp-plugin/fake.voucher                  |    1 -
 dom/media/gmp-plugin/gmp-fake.cpp                  |  429 -----
 dom/media/gmp-plugin/gmp-test-decryptor.cpp        |  604 -------
 dom/media/gmp-plugin/gmp-test-decryptor.h          |   97 -
 dom/media/gmp-plugin/gmp-test-output-protection.h  |  130 --
 dom/media/gmp-plugin/gmp-test-storage.cpp          |  233 ---
 dom/media/gmp-plugin/gmp-test-storage.h            |   63 -
 dom/media/gmp-plugin/moz.build                     |   28 -
 dom/media/gmp/GMPAudioDecoderChild.cpp             |  172 --
 dom/media/gmp/GMPAudioDecoderChild.h               |   51 -
 dom/media/gmp/GMPAudioDecoderParent.cpp            |  279 ---
 dom/media/gmp/GMPAudioDecoderParent.h              |   64 -
 dom/media/gmp/GMPAudioDecoderProxy.h               |   48 -
 dom/media/gmp/GMPAudioHost.cpp                     |  162 --
 dom/media/gmp/GMPAudioHost.h                       |   71 -
 dom/media/gmp/GMPCallbackBase.h                    |   21 -
 dom/media/gmp/GMPChild.cpp                         |  761 --------
 dom/media/gmp/GMPChild.h                           |  112 --
 dom/media/gmp/GMPDecryptorChild.cpp                |  341 ----
 dom/media/gmp/GMPDecryptorChild.h                  |  130 --
 dom/media/gmp/GMPDecryptorParent.cpp               |  373 ----
 dom/media/gmp/GMPDecryptorParent.h                 |  122 --
 dom/media/gmp/GMPDecryptorProxy.h                  |   95 -
 dom/media/gmp/GMPEncryptedBufferDataImpl.cpp       |  132 --
 dom/media/gmp/GMPEncryptedBufferDataImpl.h         |   91 -
 dom/media/gmp/GMPLoader.cpp                        |  283 ---
 dom/media/gmp/GMPLoader.h                          |   76 -
 dom/media/gmp/GMPMessageUtils.h                    |  252 ---
 dom/media/gmp/GMPParent.cpp                        |  995 ----------
 dom/media/gmp/GMPParent.h                          |  201 ---
 dom/media/gmp/GMPPlatform.cpp                      |  301 ----
 dom/media/gmp/GMPPlatform.h                        |   56 -
 dom/media/gmp/GMPProcessChild.cpp                  |   83 -
 dom/media/gmp/GMPProcessChild.h                    |   43 -
 dom/media/gmp/GMPProcessParent.cpp                 |   88 -
 dom/media/gmp/GMPProcessParent.h                   |   54 -
 dom/media/gmp/GMPService.cpp                       | 1707 ------------------
 dom/media/gmp/GMPService.h                         |  204 ---
 dom/media/gmp/GMPSharedMemManager.cpp              |   98 -
 dom/media/gmp/GMPSharedMemManager.h                |   82 -
 dom/media/gmp/GMPStorageChild.cpp                  |  379 ----
 dom/media/gmp/GMPStorageChild.h                    |  118 --
 dom/media/gmp/GMPStorageParent.cpp                 |  619 -------
 dom/media/gmp/GMPStorageParent.h                   |   63 -
 dom/media/gmp/GMPTimerChild.cpp                    |   67 -
 dom/media/gmp/GMPTimerChild.h                      |   46 -
 dom/media/gmp/GMPTimerParent.cpp                   |  131 --
 dom/media/gmp/GMPTimerParent.h                     |   65 -
 dom/media/gmp/GMPTypes.ipdlh                       |   80 -
 dom/media/gmp/GMPUtils.cpp                         |   38 -
 dom/media/gmp/GMPUtils.h                           |   33 -
 dom/media/gmp/GMPVideoDecoderChild.cpp             |  203 ---
 dom/media/gmp/GMPVideoDecoderChild.h               |   85 -
 dom/media/gmp/GMPVideoDecoderParent.cpp            |  380 ----
 dom/media/gmp/GMPVideoDecoderParent.h              |   91 -
 dom/media/gmp/GMPVideoDecoderProxy.h               |   58 -
 dom/media/gmp/GMPVideoEncodedFrameImpl.cpp         |  324 ----
 dom/media/gmp/GMPVideoEncodedFrameImpl.h           |  121 --
 dom/media/gmp/GMPVideoEncoderChild.cpp             |  183 --
 dom/media/gmp/GMPVideoEncoderChild.h               |   84 -
 dom/media/gmp/GMPVideoEncoderParent.cpp            |  365 ----
 dom/media/gmp/GMPVideoEncoderParent.h              |   88 -
 dom/media/gmp/GMPVideoEncoderProxy.h               |   56 -
 dom/media/gmp/GMPVideoHost.cpp                     |  127 --
 dom/media/gmp/GMPVideoHost.h                       |   57 -
 dom/media/gmp/GMPVideoPlaneImpl.cpp                |  225 ---
 dom/media/gmp/GMPVideoPlaneImpl.h                  |   66 -
 dom/media/gmp/GMPVideoi420FrameImpl.cpp            |  365 ----
 dom/media/gmp/GMPVideoi420FrameImpl.h              |   84 -
 dom/media/gmp/PGMP.ipdl                            |   45 -
 dom/media/gmp/PGMPAudioDecoder.ipdl                |   36 -
 dom/media/gmp/PGMPDecryptor.ipdl                   |   90 -
 dom/media/gmp/PGMPStorage.ipdl                     |   36 -
 dom/media/gmp/PGMPTimer.ipdl                       |   22 -
 dom/media/gmp/PGMPVideoDecoder.ipdl                |   49 -
 dom/media/gmp/PGMPVideoEncoder.ipdl                |   47 -
 dom/media/gmp/README.txt                           |    1 -
 dom/media/gmp/gmp-api/gmp-async-shutdown.h         |   54 -
 dom/media/gmp/gmp-api/gmp-audio-codec.h            |   43 -
 dom/media/gmp/gmp-api/gmp-audio-decode.h           |   84 -
 dom/media/gmp/gmp-api/gmp-audio-host.h             |   32 -
 dom/media/gmp/gmp-api/gmp-audio-samples.h          |   74 -
 dom/media/gmp/gmp-api/gmp-decryption.h             |  361 ----
 dom/media/gmp/gmp-api/gmp-entrypoints.h            |   75 -
 dom/media/gmp/gmp-api/gmp-errors.h                 |   57 -
 dom/media/gmp/gmp-api/gmp-platform.h               |  118 --
 dom/media/gmp/gmp-api/gmp-storage.h                |  141 --
 dom/media/gmp/gmp-api/gmp-video-codec.h            |  225 ---
 dom/media/gmp/gmp-api/gmp-video-decode.h           |  127 --
 dom/media/gmp/gmp-api/gmp-video-encode.h           |  135 --
 dom/media/gmp/gmp-api/gmp-video-frame-encoded.h    |   99 -
 dom/media/gmp/gmp-api/gmp-video-frame-i420.h       |  132 --
 dom/media/gmp/gmp-api/gmp-video-frame.h            |   51 -
 dom/media/gmp/gmp-api/gmp-video-host.h             |   53 -
 dom/media/gmp/gmp-api/gmp-video-plane.h            |   94 -
 dom/media/gmp/mozIGoannaMediaPluginService.idl     |  132 --
 dom/media/gmp/rlz/COPYING                          |   14 -
 dom/media/gmp/rlz/README.mozilla                   |    6 -
 dom/media/gmp/rlz/base/memory/scoped_ptr.h         |   27 -
 dom/media/gmp/rlz/base/string16.h                  |   12 -
 dom/media/gmp/rlz/lib/assert.h                     |   14 -
 dom/media/gmp/rlz/lib/machine_id.h                 |   21 -
 dom/media/gmp/rlz/lib/string_utils.cc              |   34 -
 dom/media/gmp/rlz/lib/string_utils.h               |   20 -
 dom/media/gmp/rlz/moz.build                        |   24 -
 dom/media/gmp/rlz/win/lib/machine_id_win.cc        |  131 --
 dom/media/gtest/TestGMPCrossOrigin.cpp             | 1244 -------------
 dom/media/gtest/moz.build                          |    4 -
 dom/media/moz.build                                |    3 -
 dom/media/platforms/PlatformDecoderModule.cpp      |    9 -
 dom/media/platforms/PlatformDecoderModule.h        |    1 -
 .../platforms/agnostic/gmp/GMPAudioDecoder.cpp     |  225 ---
 dom/media/platforms/agnostic/gmp/GMPAudioDecoder.h |   92 -
 .../platforms/agnostic/gmp/GMPDecoderModule.cpp    |   89 -
 .../platforms/agnostic/gmp/GMPDecoderModule.h      |   40 -
 .../platforms/agnostic/gmp/GMPVideoDecoder.cpp     |  270 ---
 dom/media/platforms/agnostic/gmp/GMPVideoDecoder.h |  110 --
 .../agnostic/gmp/MediaDataDecoderProxy.cpp         |  101 --
 .../platforms/agnostic/gmp/MediaDataDecoderProxy.h |  189 --
 dom/media/platforms/agnostic/gmp/moz.build         |   26 -
 dom/media/platforms/moz.build                      |    2 -
 ipc/app/moz.build                                  |    7 -
 ipc/contentproc/plugin-container.cpp               |   38 +-
 ipc/glue/GoannaChildProcessHost.cpp                |    7 -
 layout/build/nsLayoutModule.cpp                    |    9 -
 media/gmp-clearkey/0.1/AnnexB.cpp                  |   65 -
 media/gmp-clearkey/0.1/AnnexB.h                    |   20 -
 media/gmp-clearkey/0.1/AudioDecoder.cpp            |  315 ----
 media/gmp-clearkey/0.1/AudioDecoder.h              |   73 -
 media/gmp-clearkey/0.1/ClearKeyBase64.cpp          |   82 -
 media/gmp-clearkey/0.1/ClearKeyBase64.h            |   19 -
 .../gmp-clearkey/0.1/ClearKeyDecryptionManager.cpp |  210 ---
 media/gmp-clearkey/0.1/ClearKeyDecryptionManager.h |   47 -
 media/gmp-clearkey/0.1/ClearKeyPersistence.cpp     |  243 ---
 media/gmp-clearkey/0.1/ClearKeyPersistence.h       |   40 -
 media/gmp-clearkey/0.1/ClearKeySession.cpp         |   70 -
 media/gmp-clearkey/0.1/ClearKeySession.h           |   45 -
 media/gmp-clearkey/0.1/ClearKeySessionManager.cpp  |  418 -----
 media/gmp-clearkey/0.1/ClearKeySessionManager.h    |   88 -
 media/gmp-clearkey/0.1/ClearKeyStorage.cpp         |  182 --
 media/gmp-clearkey/0.1/ClearKeyStorage.h           |   36 -
 media/gmp-clearkey/0.1/ClearKeyUtils.cpp           |  530 ------
 media/gmp-clearkey/0.1/ClearKeyUtils.h             |   66 -
 media/gmp-clearkey/0.1/Makefile.in                 |   10 -
 media/gmp-clearkey/0.1/RefCounted.h                |   34 -
 media/gmp-clearkey/0.1/VideoDecoder.cpp            |  436 -----
 media/gmp-clearkey/0.1/VideoDecoder.h              |   91 -
 media/gmp-clearkey/0.1/WMFAACDecoder.cpp           |  366 ----
 media/gmp-clearkey/0.1/WMFAACDecoder.h             |   74 -
 media/gmp-clearkey/0.1/WMFH264Decoder.cpp          |  350 ----
 media/gmp-clearkey/0.1/WMFH264Decoder.h            |   78 -
 media/gmp-clearkey/0.1/WMFSymbols.h                |    8 -
 media/gmp-clearkey/0.1/WMFUtils.cpp                |  256 ---
 media/gmp-clearkey/0.1/WMFUtils.h                  |  279 ---
 media/gmp-clearkey/0.1/clearkey.info.in            |   10 -
 media/gmp-clearkey/0.1/gmp-clearkey.cpp            |   68 -
 media/gmp-clearkey/0.1/gmp-task-utils-generated.h  | 1898 --------------------
 media/gmp-clearkey/0.1/gmp-task-utils.h            |   37 -
 media/gmp-clearkey/0.1/gtest/TestClearKeyUtils.cpp |   75 -
 media/gmp-clearkey/0.1/gtest/moz.build             |   17 -
 media/gmp-clearkey/0.1/moz.build                   |   74 -
 media/gmp-clearkey/0.1/openaes/LICENSE             |   27 -
 media/gmp-clearkey/0.1/openaes/oaes_common.h       |   77 -
 media/gmp-clearkey/0.1/openaes/oaes_config.h       |   46 -
 media/gmp-clearkey/0.1/openaes/oaes_lib.c          | 1391 --------------
 media/gmp-clearkey/0.1/openaes/oaes_lib.h          |  168 --
 media/gmp-clearkey/0.1/openaes/standard.h          |   57 -
 .../src/peerconnection/MediaPipelineFactory.cpp    |    5 -
 .../src/peerconnection/PeerConnectionCtx.cpp       |   69 -
 .../src/peerconnection/PeerConnectionCtx.h         |   18 -
 .../src/peerconnection/PeerConnectionImpl.cpp      |    4 -
 mobile/android/app/mobile.js                       |    3 -
 mobile/android/chrome/content/browser.js           |   13 +-
 modules/libpref/init/all.js                        |   45 -
 python/mozbuild/mozbuild/mach_commands.py          |    4 -
 security/sandbox/linux/Sandbox.cpp                 |   62 -
 security/sandbox/linux/Sandbox.h                   |    6 -
 security/sandbox/linux/SandboxFilter.cpp           |  110 --
 security/sandbox/linux/common/SandboxInfo.cpp      |    5 -
 security/sandbox/linux/common/SandboxInfo.h        |    4 +-
 security/sandbox/mac/Sandbox.h                     |    3 -
 .../win/src/sandboxbroker/sandboxBroker.cpp        |  119 --
 .../sandbox/win/src/sandboxbroker/sandboxBroker.h  |    1 -
 .../tests/xpcshell/test_provider_addons.js         |   33 -
 testing/gtest/rungtests.py                         |    5 -
 testing/mochitest/Makefile.in                      |    8 +-
 testing/mochitest/mach_commands.py                 |   12 -
 testing/mochitest/mochitest_options.py             |    8 -
 testing/mochitest/runtests.py                      |   40 -
 testing/mochitest/runtestsremote.py                |    4 -
 testing/mozharness/scripts/openh264_build.py       |  250 ---
 testing/profiles/prefs_general.js                  |    2 -
 testing/xpcshell/head.js                           |    1 -
 toolkit/components/crashes/CrashManager.jsm        |    3 -
 toolkit/components/crashes/CrashService.js         |    3 -
 toolkit/components/crashes/nsICrashService.idl     |    1 -
 .../crashes/tests/xpcshell/test_crash_manager.js   |    8 -
 .../crashes/tests/xpcshell/test_crash_store.js     |   31 -
 toolkit/content/license.html                       |   35 -
 .../mozapps/extensions/extensions.properties       |    4 -
 toolkit/modules/GMPInstallManager.jsm              |  961 ----------
 toolkit/modules/GMPUtils.jsm                       |  156 --
 toolkit/modules/moz.build                          |    2 -
 .../tests/xpcshell/test_GMPInstallManager.js       |  865 ---------
 toolkit/modules/tests/xpcshell/xpcshell.ini        |    1 -
 toolkit/mozapps/extensions/content/extensions.js   |   23 +-
 toolkit/mozapps/extensions/content/extensions.xml  |    6 -
 toolkit/mozapps/extensions/content/gmpPrefs.xul    |    8 -
 toolkit/mozapps/extensions/extensions.manifest     |    1 -
 .../mozapps/extensions/internal/GMPProvider.jsm    |  606 -------
 toolkit/mozapps/extensions/internal/moz.build      |    1 -
 toolkit/mozapps/extensions/jar.mn                  |    2 -
 .../mozapps/extensions/test/browser/browser.ini    |    1 -
 .../extensions/test/browser/browser_gmpProvider.js |  401 -----
 .../test/xpcshell/test_duplicateplugins.js         |    1 -
 .../extensions/test/xpcshell/test_gmpProvider.js   |  332 ----
 .../extensions/test/xpcshell/test_pluginchange.js  |    2 -
 .../mozapps/extensions/test/xpcshell/xpcshell.ini  |    1 -
 toolkit/toolkit.mozbuild                           |    1 -
 toolkit/xre/nsAppRunner.cpp                        |    2 +-
 toolkit/xre/nsEmbedFunctions.cpp                   |   34 +-
 xpcom/build/nsXULAppAPI.h                          |   13 +-
 xpcom/system/nsIXULRuntime.idl                     |    1 -
 234 files changed, 39 insertions(+), 31824 deletions(-)
 delete mode 100644 dom/media/gmp-plugin-openh264/Makefile.in
 delete mode 100644 dom/media/gmp-plugin-openh264/fakeopenh264.info
 delete mode 100644 dom/media/gmp-plugin-openh264/fakeopenh264.voucher
 delete mode 100644 dom/media/gmp-plugin-openh264/moz.build
 delete mode 100644 dom/media/gmp-plugin/Makefile.in
 delete mode 100644 dom/media/gmp-plugin/fake.info
 delete mode 100644 dom/media/gmp-plugin/fake.voucher
 delete mode 100644 dom/media/gmp-plugin/gmp-fake.cpp
 delete mode 100644 dom/media/gmp-plugin/gmp-test-decryptor.cpp
 delete mode 100644 dom/media/gmp-plugin/gmp-test-decryptor.h
 delete mode 100644 dom/media/gmp-plugin/gmp-test-output-protection.h
 delete mode 100644 dom/media/gmp-plugin/gmp-test-storage.cpp
 delete mode 100644 dom/media/gmp-plugin/gmp-test-storage.h
 delete mode 100644 dom/media/gmp-plugin/moz.build
 delete mode 100644 dom/media/gmp/GMPAudioDecoderChild.cpp
 delete mode 100644 dom/media/gmp/GMPAudioDecoderChild.h
 delete mode 100644 dom/media/gmp/GMPAudioDecoderParent.cpp
 delete mode 100644 dom/media/gmp/GMPAudioDecoderParent.h
 delete mode 100644 dom/media/gmp/GMPAudioDecoderProxy.h
 delete mode 100644 dom/media/gmp/GMPAudioHost.cpp
 delete mode 100644 dom/media/gmp/GMPAudioHost.h
 delete mode 100644 dom/media/gmp/GMPCallbackBase.h
 delete mode 100644 dom/media/gmp/GMPChild.cpp
 delete mode 100644 dom/media/gmp/GMPChild.h
 delete mode 100644 dom/media/gmp/GMPDecryptorChild.cpp
 delete mode 100644 dom/media/gmp/GMPDecryptorChild.h
 delete mode 100644 dom/media/gmp/GMPDecryptorParent.cpp
 delete mode 100644 dom/media/gmp/GMPDecryptorParent.h
 delete mode 100644 dom/media/gmp/GMPDecryptorProxy.h
 delete mode 100644 dom/media/gmp/GMPEncryptedBufferDataImpl.cpp
 delete mode 100644 dom/media/gmp/GMPEncryptedBufferDataImpl.h
 delete mode 100644 dom/media/gmp/GMPLoader.cpp
 delete mode 100644 dom/media/gmp/GMPLoader.h
 delete mode 100644 dom/media/gmp/GMPMessageUtils.h
 delete mode 100644 dom/media/gmp/GMPParent.cpp
 delete mode 100644 dom/media/gmp/GMPParent.h
 delete mode 100644 dom/media/gmp/GMPPlatform.cpp
 delete mode 100644 dom/media/gmp/GMPPlatform.h
 delete mode 100644 dom/media/gmp/GMPProcessChild.cpp
 delete mode 100644 dom/media/gmp/GMPProcessChild.h
 delete mode 100644 dom/media/gmp/GMPProcessParent.cpp
 delete mode 100644 dom/media/gmp/GMPProcessParent.h
 delete mode 100644 dom/media/gmp/GMPService.cpp
 delete mode 100644 dom/media/gmp/GMPService.h
 delete mode 100644 dom/media/gmp/GMPSharedMemManager.cpp
 delete mode 100644 dom/media/gmp/GMPSharedMemManager.h
 delete mode 100644 dom/media/gmp/GMPStorageChild.cpp
 delete mode 100644 dom/media/gmp/GMPStorageChild.h
 delete mode 100644 dom/media/gmp/GMPStorageParent.cpp
 delete mode 100644 dom/media/gmp/GMPStorageParent.h
 delete mode 100644 dom/media/gmp/GMPTimerChild.cpp
 delete mode 100644 dom/media/gmp/GMPTimerChild.h
 delete mode 100644 dom/media/gmp/GMPTimerParent.cpp
 delete mode 100644 dom/media/gmp/GMPTimerParent.h
 delete mode 100644 dom/media/gmp/GMPTypes.ipdlh
 delete mode 100644 dom/media/gmp/GMPUtils.cpp
 delete mode 100644 dom/media/gmp/GMPUtils.h
 delete mode 100644 dom/media/gmp/GMPVideoDecoderChild.cpp
 delete mode 100644 dom/media/gmp/GMPVideoDecoderChild.h
 delete mode 100644 dom/media/gmp/GMPVideoDecoderParent.cpp
 delete mode 100644 dom/media/gmp/GMPVideoDecoderParent.h
 delete mode 100644 dom/media/gmp/GMPVideoDecoderProxy.h
 delete mode 100644 dom/media/gmp/GMPVideoEncodedFrameImpl.cpp
 delete mode 100644 dom/media/gmp/GMPVideoEncodedFrameImpl.h
 delete mode 100644 dom/media/gmp/GMPVideoEncoderChild.cpp
 delete mode 100644 dom/media/gmp/GMPVideoEncoderChild.h
 delete mode 100644 dom/media/gmp/GMPVideoEncoderParent.cpp
 delete mode 100644 dom/media/gmp/GMPVideoEncoderParent.h
 delete mode 100644 dom/media/gmp/GMPVideoEncoderProxy.h
 delete mode 100644 dom/media/gmp/GMPVideoHost.cpp
 delete mode 100644 dom/media/gmp/GMPVideoHost.h
 delete mode 100644 dom/media/gmp/GMPVideoPlaneImpl.cpp
 delete mode 100644 dom/media/gmp/GMPVideoPlaneImpl.h
 delete mode 100644 dom/media/gmp/GMPVideoi420FrameImpl.cpp
 delete mode 100644 dom/media/gmp/GMPVideoi420FrameImpl.h
 delete mode 100644 dom/media/gmp/PGMP.ipdl
 delete mode 100644 dom/media/gmp/PGMPAudioDecoder.ipdl
 delete mode 100644 dom/media/gmp/PGMPDecryptor.ipdl
 delete mode 100644 dom/media/gmp/PGMPStorage.ipdl
 delete mode 100644 dom/media/gmp/PGMPTimer.ipdl
 delete mode 100644 dom/media/gmp/PGMPVideoDecoder.ipdl
 delete mode 100644 dom/media/gmp/PGMPVideoEncoder.ipdl
 delete mode 100644 dom/media/gmp/README.txt
 delete mode 100644 dom/media/gmp/gmp-api/gmp-async-shutdown.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-audio-codec.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-audio-decode.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-audio-host.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-audio-samples.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-decryption.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-entrypoints.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-errors.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-platform.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-storage.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-video-codec.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-video-decode.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-video-encode.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-video-frame-encoded.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-video-frame-i420.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-video-frame.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-video-host.h
 delete mode 100644 dom/media/gmp/gmp-api/gmp-video-plane.h
 delete mode 100644 dom/media/gmp/mozIGoannaMediaPluginService.idl
 delete mode 100644 dom/media/gmp/rlz/COPYING
 delete mode 100644 dom/media/gmp/rlz/README.mozilla
 delete mode 100644 dom/media/gmp/rlz/base/memory/scoped_ptr.h
 delete mode 100644 dom/media/gmp/rlz/base/string16.h
 delete mode 100644 dom/media/gmp/rlz/lib/assert.h
 delete mode 100644 dom/media/gmp/rlz/lib/machine_id.h
 delete mode 100644 dom/media/gmp/rlz/lib/string_utils.cc
 delete mode 100644 dom/media/gmp/rlz/lib/string_utils.h
 delete mode 100644 dom/media/gmp/rlz/moz.build
 delete mode 100644 dom/media/gmp/rlz/win/lib/machine_id_win.cc
 delete mode 100644 dom/media/gtest/TestGMPCrossOrigin.cpp
 delete mode 100644 dom/media/platforms/agnostic/gmp/GMPAudioDecoder.cpp
 delete mode 100644 dom/media/platforms/agnostic/gmp/GMPAudioDecoder.h
 delete mode 100644 dom/media/platforms/agnostic/gmp/GMPDecoderModule.cpp
 delete mode 100644 dom/media/platforms/agnostic/gmp/GMPDecoderModule.h
 delete mode 100644 dom/media/platforms/agnostic/gmp/GMPVideoDecoder.cpp
 delete mode 100644 dom/media/platforms/agnostic/gmp/GMPVideoDecoder.h
 delete mode 100644 dom/media/platforms/agnostic/gmp/MediaDataDecoderProxy.cpp
 delete mode 100644 dom/media/platforms/agnostic/gmp/MediaDataDecoderProxy.h
 delete mode 100644 dom/media/platforms/agnostic/gmp/moz.build
 delete mode 100644 media/gmp-clearkey/0.1/AnnexB.cpp
 delete mode 100644 media/gmp-clearkey/0.1/AnnexB.h
 delete mode 100644 media/gmp-clearkey/0.1/AudioDecoder.cpp
 delete mode 100644 media/gmp-clearkey/0.1/AudioDecoder.h
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeyBase64.cpp
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeyBase64.h
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeyDecryptionManager.cpp
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeyDecryptionManager.h
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeyPersistence.cpp
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeyPersistence.h
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeySession.cpp
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeySession.h
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeySessionManager.cpp
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeySessionManager.h
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeyStorage.cpp
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeyStorage.h
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeyUtils.cpp
 delete mode 100644 media/gmp-clearkey/0.1/ClearKeyUtils.h
 delete mode 100644 media/gmp-clearkey/0.1/Makefile.in
 delete mode 100644 media/gmp-clearkey/0.1/RefCounted.h
 delete mode 100644 media/gmp-clearkey/0.1/VideoDecoder.cpp
 delete mode 100644 media/gmp-clearkey/0.1/VideoDecoder.h
 delete mode 100644 media/gmp-clearkey/0.1/WMFAACDecoder.cpp
 delete mode 100644 media/gmp-clearkey/0.1/WMFAACDecoder.h
 delete mode 100644 media/gmp-clearkey/0.1/WMFH264Decoder.cpp
 delete mode 100644 media/gmp-clearkey/0.1/WMFH264Decoder.h
 delete mode 100644 media/gmp-clearkey/0.1/WMFSymbols.h
 delete mode 100644 media/gmp-clearkey/0.1/WMFUtils.cpp
 delete mode 100644 media/gmp-clearkey/0.1/WMFUtils.h
 delete mode 100644 media/gmp-clearkey/0.1/clearkey.info.in
 delete mode 100644 media/gmp-clearkey/0.1/gmp-clearkey.cpp
 delete mode 100644 media/gmp-clearkey/0.1/gmp-task-utils-generated.h
 delete mode 100644 media/gmp-clearkey/0.1/gmp-task-utils.h
 delete mode 100644 media/gmp-clearkey/0.1/gtest/TestClearKeyUtils.cpp
 delete mode 100644 media/gmp-clearkey/0.1/gtest/moz.build
 delete mode 100644 media/gmp-clearkey/0.1/moz.build
 delete mode 100644 media/gmp-clearkey/0.1/openaes/LICENSE
 delete mode 100644 media/gmp-clearkey/0.1/openaes/oaes_common.h
 delete mode 100644 media/gmp-clearkey/0.1/openaes/oaes_config.h
 delete mode 100644 media/gmp-clearkey/0.1/openaes/oaes_lib.c
 delete mode 100644 media/gmp-clearkey/0.1/openaes/oaes_lib.h
 delete mode 100644 media/gmp-clearkey/0.1/openaes/standard.h
 delete mode 100644 testing/mozharness/scripts/openh264_build.py
 delete mode 100644 toolkit/modules/GMPInstallManager.jsm
 delete mode 100644 toolkit/modules/GMPUtils.jsm
 delete mode 100644 toolkit/modules/tests/xpcshell/test_GMPInstallManager.js
 delete mode 100644 toolkit/mozapps/extensions/content/gmpPrefs.xul
 delete mode 100644 toolkit/mozapps/extensions/internal/GMPProvider.jsm
 delete mode 100644 toolkit/mozapps/extensions/test/browser/browser_gmpProvider.js
 delete mode 100644 toolkit/mozapps/extensions/test/xpcshell/test_gmpProvider.js

diff --git a/browser/installer/package-manifest.in b/browser/installer/package-manifest.in
index fb54ba9..01082ba 100644
--- a/browser/installer/package-manifest.in
+++ b/browser/installer/package-manifest.in
@@ -197,7 +197,6 @@
 @RESPATH@/components/composer.xpt
 @RESPATH@/components/content_events.xpt
 @RESPATH@/components/content_html.xpt
-@RESPATH@/components/content_goannamediaplugins.xpt
 #ifdef MOZ_WEBRTC
 @RESPATH@/components/content_webrtc.xpt
 #endif
@@ -651,6 +650,10 @@
 @BINPATH@/@MOZ_D3DCOMPILER_VISTA_DLL@
 #endif
 
+#ifdef MOZ_D3DCOMPILER_XP_DLL
+@BINPATH@/@MOZ_D3DCOMPILER_XP_DLL@
+#endif
+
 #endif # MOZ_ANGLE_RENDERER
 
 ; [Browser Chrome Files]
diff --git a/configure.in b/configure.in
index cc22c37..c8d795b 100644
--- a/configure.in
+++ b/configure.in
@@ -3868,7 +3868,6 @@ MOZ_TIME_MANAGER=
 MOZ_AUDIO_CHANNEL_MANAGER=
 NSS_NO_LIBPKIX=
 MOZ_CONTENT_SANDBOX=
-MOZ_GMP_SANDBOX=
 MOZ_SANDBOX=
 MOZ_DEVTOOLS=
 
@@ -6145,38 +6144,6 @@ fi
 
 AC_SUBST(MOZ_CONTENT_SANDBOX)
 
-dnl ========================================================
-dnl = Goanna Media Plugin sandboxing
-dnl ========================================================
-case $OS_TARGET in
-WINNT)
-    MOZ_GMP_SANDBOX=$MOZ_SANDBOX
-    ;;
-Linux)
-    case $CPU_ARCH in
-    x86_64|x86)
-        MOZ_GMP_SANDBOX=$MOZ_SANDBOX
-        ;;
-    esac
-    ;;
-Darwin)
-    MOZ_GMP_SANDBOX=$MOZ_SANDBOX
-    ;;
-esac
-
-if test -n "$MOZ_GMP_SANDBOX"; then
-    AC_DEFINE(MOZ_GMP_SANDBOX)
-fi
-
-AC_SUBST(MOZ_GMP_SANDBOX)
-
-if test -z "$MOZ_CONTENT_SANDBOX" -a -z "$MOZ_GMP_SANDBOX"; then
-    MOZ_SANDBOX=
-fi
-
-if test -n "$MOZ_SANDBOX"; then
-    AC_DEFINE(MOZ_SANDBOX)
-fi
 
 AC_SUBST(MOZ_SANDBOX)
 
diff --git a/dom/locales/en-US/chrome/plugins.properties b/dom/locales/en-US/chrome/plugins.properties
index 55b83f3..23ac7e0 100644
--- a/dom/locales/en-US/chrome/plugins.properties
+++ b/dom/locales/en-US/chrome/plugins.properties
@@ -17,13 +17,4 @@ state_enabled=Enabled
 state_disabled=Disabled
 mimetype_label=MIME Type
 description_label=Description
-suffixes_label=Suffixes
-
-# GMP Plugins
-gmp_license_info=License information
-
-openH264_name=OpenH264 Video Codec provided by Cisco Systems, Inc.
-openH264_description=Play back web video and use video chats.
-
-eme-adobe_name=Primetime Content Decryption Module provided by Adobe Systems, Incorporated
-eme-adobe_description=Play back protected web video.
+suffixes_label=Suffixes
\ No newline at end of file
diff --git a/dom/media/PeerConnection.js b/dom/media/PeerConnection.js
index bfd32e6..d52c702 100644
--- a/dom/media/PeerConnection.js
+++ b/dom/media/PeerConnection.js
@@ -46,7 +46,6 @@ function GlobalPCList() {
   Services.obs.addObserver(this, "profile-change-net-teardown", true);
   Services.obs.addObserver(this, "network:offline-about-to-go-offline", true);
   Services.obs.addObserver(this, "network:offline-status-changed", true);
-  Services.obs.addObserver(this, "gmp-plugin-crash", true);
 }
 GlobalPCList.prototype = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver,
@@ -159,19 +158,6 @@ GlobalPCList.prototype = {
         }
       }
       this._networkdown = !this._win.navigator.onLine;
-    } else if (topic == "gmp-plugin-crash") {
-      // a plugin crashed; if it's associated with any of our PCs, fire an
-      // event to the DOM window
-      let sep = data.indexOf(' ');
-      let pluginId = data.slice(0, sep);
-      let rest = data.slice(sep+1);
-      // This presumes no spaces in the name!
-      sep = rest.indexOf(' ');
-      let name = rest.slice(0, sep);
-      let crashId = rest.slice(sep+1);
-      for (let winId in this._list) {
-        broadcastPluginCrash(this._list, winId, pluginId, name, crashId);
-      }
     }
   },
 
diff --git a/dom/media/fmp4/MP4Decoder.cpp b/dom/media/fmp4/MP4Decoder.cpp
index 91fd22e..f945837 100644
--- a/dom/media/fmp4/MP4Decoder.cpp
+++ b/dom/media/fmp4/MP4Decoder.cpp
@@ -216,12 +216,6 @@ IsGonkMP4DecoderAvailable()
 }
 
 static bool
-IsGMPDecoderAvailable()
-{
-  return Preferences::GetBool("media.gmp.decoder.enabled", false);
-}
-
-static bool
 HavePlatformMPEGDecoders()
 {
 #ifdef XP_WIN
@@ -233,7 +227,6 @@ HavePlatformMPEGDecoders()
          IsFFmpegAvailable() ||
          IsAppleAvailable() ||
          IsGonkMP4DecoderAvailable() ||
-         IsGMPDecoderAvailable() ||
          // TODO: Other platforms...
          false;
 #endif
diff --git a/dom/media/gmp-plugin-openh264/Makefile.in b/dom/media/gmp-plugin-openh264/Makefile.in
deleted file mode 100644
index eece33e..0000000
--- a/dom/media/gmp-plugin-openh264/Makefile.in
+++ /dev/null
@@ -1,12 +0,0 @@
-#
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-INSTALL_TARGETS += FAKE_GMP_OPENH264_PLUGIN
-FAKE_GMP_OPENH264_PLUGIN_DEST = $(DEPTH)/dist/bin/gmp-fakeopenh264/1.0
-FAKE_GMP_OPENH264_PLUGIN_FILES = \
-  $(srcdir)/fakeopenh264.info \
-  $(srcdir)/fakeopenh264.voucher \
-  $(NULL)
-
diff --git a/dom/media/gmp-plugin-openh264/fakeopenh264.info b/dom/media/gmp-plugin-openh264/fakeopenh264.info
deleted file mode 100644
index 924b863..0000000
--- a/dom/media/gmp-plugin-openh264/fakeopenh264.info
+++ /dev/null
@@ -1,4 +0,0 @@
-Name: fakeopenh264
-Description: Fake GMP Plugin
-Version: 1.0
-APIs: encode-video[h264], decode-video[h264]
diff --git a/dom/media/gmp-plugin-openh264/fakeopenh264.voucher b/dom/media/gmp-plugin-openh264/fakeopenh264.voucher
deleted file mode 100644
index 2104d73..0000000
--- a/dom/media/gmp-plugin-openh264/fakeopenh264.voucher
+++ /dev/null
@@ -1 +0,0 @@
-gmp-fakeopenh264 placeholder voucher
diff --git a/dom/media/gmp-plugin-openh264/moz.build b/dom/media/gmp-plugin-openh264/moz.build
deleted file mode 100644
index 1d02fb1..0000000
--- a/dom/media/gmp-plugin-openh264/moz.build
+++ /dev/null
@@ -1,26 +0,0 @@
-# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-# largely a copy of dom/media/gmp-fake/moz.build
-
-FINAL_TARGET = 'dist/bin/gmp-fakeopenh264/1.0'
-SOURCES += [
-    '../gmp-plugin/gmp-fake.cpp',
-]
-
-SharedLibrary("fakeopenh264")
-
-if CONFIG['OS_ARCH'] == 'WINNT':
-    OS_LIBS += [
-        'ole32',
-    ]
-
-USE_STATIC_LIBS = True
-NO_VISIBILITY_FLAGS = True
-# Don't use STL wrappers; this isn't Goanna code
-DISABLE_STL_WRAPPING = True
-
-FAIL_ON_WARNINGS = True
diff --git a/dom/media/gmp-plugin/Makefile.in b/dom/media/gmp-plugin/Makefile.in
deleted file mode 100644
index 4ac0bc9..0000000
--- a/dom/media/gmp-plugin/Makefile.in
+++ /dev/null
@@ -1,13 +0,0 @@
-#
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-INSTALL_TARGETS += FAKE_GMP_PLUGIN
-FAKE_GMP_PLUGIN_DEST = $(DEPTH)/dist/bin/gmp-fake/1.0
-FAKE_GMP_PLUGIN_FILES = \
-  $(SHARED_LIBRARY) \
-  $(srcdir)/fake.info \
-  $(srcdir)/fake.voucher
-
-include $(topsrcdir)/config/rules.mk
diff --git a/dom/media/gmp-plugin/fake.info b/dom/media/gmp-plugin/fake.info
deleted file mode 100644
index a0d7eaa..0000000
--- a/dom/media/gmp-plugin/fake.info
+++ /dev/null
@@ -1,5 +0,0 @@
-Name: fake
-Description: Fake GMP Plugin
-Version: 1.0
-APIs: encode-video[h264], decode-video[h264], eme-decrypt-v7[fake]
-Libraries: dxva2.dll
diff --git a/dom/media/gmp-plugin/fake.voucher b/dom/media/gmp-plugin/fake.voucher
deleted file mode 100644
index bb13370..0000000
--- a/dom/media/gmp-plugin/fake.voucher
+++ /dev/null
@@ -1 +0,0 @@
-gmp-fake placeholder voucher
\ No newline at end of file
diff --git a/dom/media/gmp-plugin/gmp-fake.cpp b/dom/media/gmp-plugin/gmp-fake.cpp
deleted file mode 100644
index 7dbc852..0000000
--- a/dom/media/gmp-plugin/gmp-fake.cpp
+++ /dev/null
@@ -1,429 +0,0 @@
-/*!
- * \copy
- *     Copyright (c)  2009-2014, Cisco Systems
- *     Copyright (c)  2014, Mozilla
- *     All rights reserved.
- *
- *     Redistribution and use in source and binary forms, with or without
- *     modification, are permitted provided that the following conditions
- *     are met:
- *
- *        * Redistributions of source code must retain the above copyright
- *          notice, this list of conditions and the following disclaimer.
- *
- *        * Redistributions in binary form must reproduce the above copyright
- *          notice, this list of conditions and the following disclaimer in
- *          the documentation and/or other materials provided with the
- *          distribution.
- *
- *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *     FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *     COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *     INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *     BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *     CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *     LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *     ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *     POSSIBILITY OF SUCH DAMAGE.
- *
- *
- *************************************************************************************
- */
-
-#include <stdint.h>
-#include <time.h>
-#include <cstdio>
-#include <cstring>
-#include <iostream>
-#include <string>
-#include <memory>
-#include <assert.h>
-#include <limits.h>
-
-#include "gmp-platform.h"
-#include "gmp-video-host.h"
-#include "gmp-video-encode.h"
-#include "gmp-video-decode.h"
-#include "gmp-video-frame-i420.h"
-#include "gmp-video-frame-encoded.h"
-
-#if defined(GMP_FAKE_SUPPORT_DECRYPT)
-#include "gmp-decryption.h"
-#include "gmp-test-decryptor.h"
-#include "gmp-test-storage.h"
-#endif
-
-#if defined(_MSC_VER)
-#define PUBLIC_FUNC __declspec(dllexport)
-#else
-#define PUBLIC_FUNC
-#endif
-
-#define BIG_FRAME 10000
-
-static int g_log_level = 0;
-
-#define GMPLOG(l, x) do { \
-        if (l <= g_log_level) { \
-        const char *log_string = "unknown"; \
-        if ((l >= 0) && (l <= 3)) {               \
-        log_string = kLogStrings[l];            \
-        } \
-        std::cerr << log_string << ": " << x << std::endl; \
-        } \
-    } while(0)
-
-#define GL_CRIT 0
-#define GL_ERROR 1
-#define GL_INFO  2
-#define GL_DEBUG 3
-
-const char* kLogStrings[] = {
-  "Critical",
-  "Error",
-  "Info",
-  "Debug"
-};
-
-
-GMPPlatformAPI* g_platform_api = NULL;
-
-class FakeVideoEncoder;
-class FakeVideoDecoder;
-
-struct EncodedFrame {
-  uint32_t length_;
-  uint8_t h264_compat_;
-  uint32_t magic_;
-  uint32_t width_;
-  uint32_t height_;
-  uint8_t y_;
-  uint8_t u_;
-  uint8_t v_;
-  uint32_t timestamp_;
-};
-
-#define ENCODED_FRAME_MAGIC 0x4652414d
-
-class FakeEncoderTask : public GMPTask {
- public:
-  FakeEncoderTask(FakeVideoEncoder* encoder,
-                  GMPVideoi420Frame* frame,
-                  GMPVideoFrameType type)
-      : encoder_(encoder), frame_(frame), type_(type) {}
-
-  virtual void Run();
-  virtual void Destroy() { delete this; }
-
-  FakeVideoEncoder* encoder_;
-  GMPVideoi420Frame* frame_;
-  GMPVideoFrameType type_;
-};
-
-class FakeVideoEncoder : public GMPVideoEncoder {
- public:
-  explicit FakeVideoEncoder (GMPVideoHost* hostAPI) :
-    host_ (hostAPI),
-    callback_ (NULL) {}
-
-  virtual void InitEncode (const GMPVideoCodec& codecSettings,
-                             const uint8_t* aCodecSpecific,
-                             uint32_t aCodecSpecificSize,
-                             GMPVideoEncoderCallback* callback,
-                             int32_t numberOfCores,
-                             uint32_t maxPayloadSize) {
-    callback_ = callback;
-
-    GMPLOG (GL_INFO, "Initialized encoder");
-  }
-
-  virtual void Encode (GMPVideoi420Frame* inputImage,
-                         const uint8_t* aCodecSpecificInfo,
-                         uint32_t aCodecSpecificInfoLength,
-                         const GMPVideoFrameType* aFrameTypes,
-                         uint32_t aFrameTypesLength) {
-    GMPLOG (GL_DEBUG,
-            __FUNCTION__
-            << " size="
-            << inputImage->Width() << "x" << inputImage->Height());
-
-    assert (aFrameTypesLength != 0);
-
-    g_platform_api->runonmainthread(new FakeEncoderTask(this,
-                                                        inputImage,
-                                                        aFrameTypes[0]));
-  }
-
-  void Encode_m (GMPVideoi420Frame* inputImage,
-                 GMPVideoFrameType frame_type) {
-    if (frame_type  == kGMPKeyFrame) {
-      if (!inputImage)
-        return;
-    }
-    if (!inputImage) {
-      GMPLOG (GL_ERROR, "no input image");
-      return;
-    }
-
-    // Now return the encoded data back to the parent.
-    GMPVideoFrame* ftmp;
-    GMPErr err = host_->CreateFrame(kGMPEncodedVideoFrame, &ftmp);
-    if (err != GMPNoErr) {
-      GMPLOG (GL_ERROR, "Error creating encoded frame");
-      return;
-    }
-
-    GMPVideoEncodedFrame* f = static_cast<GMPVideoEncodedFrame*> (ftmp);
-
-    // Encode this in a frame that looks a little bit like H.264.
-    // Note that we don't do PPS or SPS.
-    // Copy the data. This really should convert this to network byte order.
-    EncodedFrame eframe;
-    eframe.length_ = sizeof(eframe) - sizeof(uint32_t);
-    eframe.h264_compat_ = 5; // Emulate a H.264 IDR NAL.
-    eframe.magic_ = ENCODED_FRAME_MAGIC;
-    eframe.width_ = inputImage->Width();
-    eframe.height_ = inputImage->Height();
-    eframe.y_ = AveragePlane(inputImage->Buffer(kGMPYPlane),
-                             inputImage->AllocatedSize(kGMPYPlane));
-    eframe.u_ = AveragePlane(inputImage->Buffer(kGMPUPlane),
-                             inputImage->AllocatedSize(kGMPUPlane));
-    eframe.v_ = AveragePlane(inputImage->Buffer(kGMPVPlane),
-                             inputImage->AllocatedSize(kGMPVPlane));
-
-    eframe.timestamp_ = inputImage->Timestamp();
-
-    err = f->CreateEmptyFrame (sizeof(eframe) +
-                               (frame_type  == kGMPKeyFrame ? sizeof(uint32_t) + BIG_FRAME : 0));
-    if (err != GMPNoErr) {
-      GMPLOG (GL_ERROR, "Error allocating frame data");
-      f->Destroy();
-      return;
-    }
-    memcpy(f->Buffer(), &eframe, sizeof(eframe));
-    if (frame_type  == kGMPKeyFrame) {
-      *((uint32_t*) f->Buffer() + sizeof(eframe)) = BIG_FRAME;
-    }
-
-    f->SetEncodedWidth (inputImage->Width());
-    f->SetEncodedHeight (inputImage->Height());
-    f->SetTimeStamp (inputImage->Timestamp());
-    f->SetFrameType (frame_type);
-    f->SetCompleteFrame (true);
-    f->SetBufferType(GMP_BufferLength32);
-
-    GMPLOG (GL_DEBUG, "Encoding complete. type= "
-            << f->FrameType()
-            << " length="
-            << f->Size()
-            << " timestamp="
-            << f->TimeStamp());
-
-    // Return the encoded frame.
-    GMPCodecSpecificInfo info;
-    memset (&info, 0, sizeof (info));
-    info.mCodecType = kGMPVideoCodecH264;
-    info.mBufferType = GMP_BufferLength32;
-    info.mCodecSpecific.mH264.mSimulcastIdx = 0;
-    GMPLOG (GL_DEBUG, "Calling callback");
-    callback_->Encoded (f, reinterpret_cast<uint8_t*> (&info), sizeof(info));
-    GMPLOG (GL_DEBUG, "Callback called");
-  }
-
-  virtual void SetChannelParameters (uint32_t aPacketLoss, uint32_t aRTT) {
-  }
-
-  virtual void SetRates (uint32_t aNewBitRate, uint32_t aFrameRate) {
-  }
-
-  virtual void SetPeriodicKeyFrames (bool aEnable) {
-  }
-
-  virtual void EncodingComplete() {
-    delete this;
-  }
-
- private:
-  uint8_t AveragePlane(uint8_t* ptr, size_t len) {
-    uint64_t val = 0;
-
-    for (size_t i=0; i<len; ++i) {
-      val += ptr[i];
-    }
-
-    return (val / len) % 0xff;
-  }
-
-  GMPVideoHost* host_;
-  GMPVideoEncoderCallback* callback_;
-};
-
-void FakeEncoderTask::Run() {
-  encoder_->Encode_m(frame_, type_);
-  frame_->Destroy();
-}
-
-class FakeDecoderTask : public GMPTask {
- public:
-  FakeDecoderTask(FakeVideoDecoder* decoder,
-                  GMPVideoEncodedFrame* frame,
-                  int64_t time)
-      : decoder_(decoder), frame_(frame), time_(time) {}
-
-  virtual void Run();
-  virtual void Destroy() { delete this; }
-
-  FakeVideoDecoder* decoder_;
-  GMPVideoEncodedFrame* frame_;
-  int64_t time_;
-};
-
-class FakeVideoDecoder : public GMPVideoDecoder {
- public:
-  explicit FakeVideoDecoder (GMPVideoHost* hostAPI) :
-    host_ (hostAPI),
-    callback_ (NULL) {}
-
-  virtual ~FakeVideoDecoder() {
-  }
-
-  virtual void InitDecode (const GMPVideoCodec& codecSettings,
-                             const uint8_t* aCodecSpecific,
-                             uint32_t aCodecSpecificSize,
-                             GMPVideoDecoderCallback* callback,
-                             int32_t coreCount) {
-    GMPLOG (GL_INFO, "InitDecode");
-
-    callback_ = callback;
-  }
-
-  virtual void Decode (GMPVideoEncodedFrame* inputFrame,
-                         bool missingFrames,
-                         const uint8_t* aCodecSpecificInfo,
-                         uint32_t aCodecSpecificInfoLength,
-                         int64_t renderTimeMs = -1) {
-    GMPLOG (GL_DEBUG, __FUNCTION__
-            << "Decoding frame size=" << inputFrame->Size()
-            << " timestamp=" << inputFrame->TimeStamp());
-    g_platform_api->runonmainthread(new FakeDecoderTask(this, inputFrame, renderTimeMs));
-  }
-
-  virtual void Reset() {
-  }
-
-  virtual void Drain() {
-  }
-
-  virtual void DecodingComplete() {
-    delete this;
-  }
-
-  // Return the decoded data back to the parent.
-  void Decode_m (GMPVideoEncodedFrame* inputFrame,
-                 int64_t renderTimeMs) {
-    EncodedFrame *eframe;
-    if (inputFrame->Size() != (sizeof(*eframe))) {
-      GMPLOG (GL_ERROR, "Couldn't decode frame. Size=" << inputFrame->Size());
-      return;
-    }
-    eframe = reinterpret_cast<EncodedFrame*>(inputFrame->Buffer());
-
-    if (eframe->magic_ != ENCODED_FRAME_MAGIC) {
-      GMPLOG (GL_ERROR, "Couldn't decode frame. Magic=" << eframe->magic_);
-      return;
-    }
-
-    int width = eframe->width_;
-    int height = eframe->height_;
-    int ystride = eframe->width_;
-    int uvstride = eframe->width_/2;
-
-    GMPLOG (GL_DEBUG, "Video frame ready for display "
-            << width
-            << "x"
-            << height
-            << " timestamp="
-            << inputFrame->TimeStamp());
-
-    GMPVideoFrame* ftmp = NULL;
-
-    // Translate the image.
-    GMPErr err = host_->CreateFrame (kGMPI420VideoFrame, &ftmp);
-    if (err != GMPNoErr) {
-      GMPLOG (GL_ERROR, "Couldn't allocate empty I420 frame");
-      return;
-    }
-
-    GMPVideoi420Frame* frame = static_cast<GMPVideoi420Frame*> (ftmp);
-    err = frame->CreateEmptyFrame (
-        width, height,
-        ystride, uvstride, uvstride);
-    if (err != GMPNoErr) {
-      GMPLOG (GL_ERROR, "Couldn't make decoded frame");
-      return;
-    }
-
-    memset(frame->Buffer(kGMPYPlane),
-           eframe->y_,
-           frame->AllocatedSize(kGMPYPlane));
-    memset(frame->Buffer(kGMPUPlane),
-           eframe->u_,
-           frame->AllocatedSize(kGMPUPlane));
-    memset(frame->Buffer(kGMPVPlane),
-           eframe->v_,
-           frame->AllocatedSize(kGMPVPlane));
-
-    GMPLOG (GL_DEBUG, "Allocated size = "
-            << frame->AllocatedSize (kGMPYPlane));
-    frame->SetTimestamp (inputFrame->TimeStamp());
-    frame->SetDuration (inputFrame->Duration());
-    callback_->Decoded (frame);
-
-  }
-
-  GMPVideoHost* host_;
-  GMPVideoDecoderCallback* callback_;
-};
-
-void FakeDecoderTask::Run() {
-  decoder_->Decode_m(frame_, time_);
-  frame_->Destroy();
-}
-
-extern "C" {
-
-  PUBLIC_FUNC GMPErr
-  GMPInit (GMPPlatformAPI* aPlatformAPI) {
-    g_platform_api = aPlatformAPI;
-    return GMPNoErr;
-  }
-
-  PUBLIC_FUNC GMPErr
-  GMPGetAPI (const char* aApiName, void* aHostAPI, void** aPluginApi) {
-    if (!strcmp (aApiName, GMP_API_VIDEO_DECODER)) {
-      *aPluginApi = new FakeVideoDecoder (static_cast<GMPVideoHost*> (aHostAPI));
-      return GMPNoErr;
-    } else if (!strcmp (aApiName, GMP_API_VIDEO_ENCODER)) {
-      *aPluginApi = new FakeVideoEncoder (static_cast<GMPVideoHost*> (aHostAPI));
-      return GMPNoErr;
-#if defined(GMP_FAKE_SUPPORT_DECRYPT)
-    } else if (!strcmp (aApiName, GMP_API_DECRYPTOR)) {
-      *aPluginApi = new FakeDecryptor(static_cast<GMPDecryptorHost*> (aHostAPI));
-      return GMPNoErr;
-    } else if (!strcmp (aApiName, GMP_API_ASYNC_SHUTDOWN)) {
-      *aPluginApi = new TestAsyncShutdown(static_cast<GMPAsyncShutdownHost*> (aHostAPI));
-      return GMPNoErr;
-#endif
-    }
-    return GMPGenericErr;
-  }
-
-  PUBLIC_FUNC void
-  GMPShutdown (void) {
-    g_platform_api = NULL;
-  }
-
-} // extern "C"
diff --git a/dom/media/gmp-plugin/gmp-test-decryptor.cpp b/dom/media/gmp-plugin/gmp-test-decryptor.cpp
deleted file mode 100644
index 38894a8..0000000
--- a/dom/media/gmp-plugin/gmp-test-decryptor.cpp
+++ /dev/null
@@ -1,604 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "gmp-test-decryptor.h"
-#include "gmp-test-storage.h"
-#include "gmp-test-output-protection.h"
-
-#include <string>
-#include <vector>
-#include <iostream>
-#include <istream>
-#include <iterator>
-#include <sstream>
-#include <set>
-
-#include "mozilla/Assertions.h"
-#include "mozilla/Attributes.h"
-
-using namespace std;
-
-FakeDecryptor* FakeDecryptor::sInstance = nullptr;
-extern GMPPlatformAPI* g_platform_api; // Defined in gmp-fake.cpp
-
-class GMPMutexAutoLock
-{
-public:
-  explicit GMPMutexAutoLock(GMPMutex* aMutex) : mMutex(aMutex) {
-    mMutex->Acquire();
-  }
-  ~GMPMutexAutoLock() {
-    mMutex->Release();
-  }
-private:
-  GMPMutex* const mMutex;
-};
-
-class TestManager {
-public:
-  TestManager() : mMutex(CreateMutex()) {}
-
-  // Register a test with the test manager.
-  void BeginTest(const string& aTestID) {
-    GMPMutexAutoLock lock(mMutex);
-    auto found = mTestIDs.find(aTestID);
-    if (found == mTestIDs.end()) {
-      mTestIDs.insert(aTestID);
-    } else {
-      Error("FAIL BeginTest test already existed: " + aTestID);
-    }
-  }
-
-  // Notify the test manager that the test is finished. If all tests are done,
-  // test manager will send "test-storage complete" to notify the parent that
-  // all tests are finished and also delete itself.
-  void EndTest(const string& aTestID) {
-    bool isEmpty = false;
-    {
-      GMPMutexAutoLock lock(mMutex);
-      auto found = mTestIDs.find(aTestID);
-      if (found != mTestIDs.end()) {
-        mTestIDs.erase(aTestID);
-        isEmpty = mTestIDs.empty();
-      } else {
-        Error("FAIL EndTest test not existed: " + aTestID);
-        return;
-      }
-    }
-    if (isEmpty) {
-      Finish();
-      delete this;
-    }
-  }
-
-private:
-  ~TestManager() {
-    mMutex->Destroy();
-  }
-
-  static void Error(const string& msg) {
-    FakeDecryptor::Message(msg);
-  }
-
-  static void Finish() {
-    FakeDecryptor::Message("test-storage complete");
-  }
-
-  static GMPMutex* CreateMutex() {
-    GMPMutex* mutex = nullptr;
-    g_platform_api->createmutex(&mutex);
-    return mutex;
-  }
-
-  GMPMutex* const mMutex;
-  set<string> mTestIDs;
-};
-
-FakeDecryptor::FakeDecryptor(GMPDecryptorHost* aHost)
-  : mCallback(nullptr)
-  , mHost(aHost)
-{
-  MOZ_ASSERT(!sInstance);
-  sInstance = this;
-}
-
-void FakeDecryptor::DecryptingComplete()
-{
-  sInstance = nullptr;
-  delete this;
-}
-
-void
-FakeDecryptor::Message(const std::string& aMessage)
-{
-  MOZ_ASSERT(sInstance);
-  const static std::string sid("fake-session-id");
-  sInstance->mCallback->SessionMessage(sid.c_str(), sid.size(),
-                                       kGMPLicenseRequest,
-                                       (const uint8_t*)aMessage.c_str(), aMessage.size());
-}
-
-std::vector<std::string>
-Tokenize(const std::string& aString)
-{
-  std::stringstream strstr(aString);
-  std::istream_iterator<std::string> it(strstr), end;
-  return std::vector<std::string>(it, end);
-}
-
-static const string TruncateRecordId = "truncate-record-id";
-static const string TruncateRecordData = "I will soon be truncated";
-
-class ReadThenTask : public GMPTask {
-public:
-  ReadThenTask(string aId, ReadContinuation* aThen)
-    : mId(aId)
-    , mThen(aThen)
-  {}
-  void Run() override {
-    ReadRecord(mId, mThen);
-  }
-  void Destroy() override {
-    delete this;
-  }
-  string mId;
-  ReadContinuation* mThen;
-};
-
-class SendMessageTask : public GMPTask {
-public:
-  explicit SendMessageTask(const string& aMessage,
-                           TestManager* aTestManager = nullptr,
-                           const string& aTestID = "")
-    : mMessage(aMessage), mTestmanager(aTestManager), mTestID(aTestID) {}
-
-  void Run() override {
-    FakeDecryptor::Message(mMessage);
-    if (mTestmanager) {
-      mTestmanager->EndTest(mTestID);
-    }
-  }
-
-  void Destroy() override {
-    delete this;
-  }
-
-private:
-  string mMessage;
-  TestManager* const mTestmanager;
-  const string mTestID;
-};
-
-class TestEmptyContinuation : public ReadContinuation {
-public:
-  TestEmptyContinuation(TestManager* aTestManager, const string& aTestID)
-    : mTestmanager(aTestManager), mTestID(aTestID) {}
-
-  void ReadComplete(GMPErr aErr, const std::string& aData) override {
-    if (aData != "") {
-      FakeDecryptor::Message("FAIL TestEmptyContinuation record was not truncated");
-    }
-    mTestmanager->EndTest(mTestID);
-    delete this;
-  }
-
-private:
-  TestManager* const mTestmanager;
-  const string mTestID;
-};
-
-class TruncateContinuation : public ReadContinuation {
-public:
-  TruncateContinuation(const string& aID,
-                       TestManager* aTestManager,
-                       const string& aTestID)
-    : mID(aID), mTestmanager(aTestManager), mTestID(aTestID) {}
-
-  void ReadComplete(GMPErr aErr, const std::string& aData) override {
-    if (aData != TruncateRecordData) {
-      FakeDecryptor::Message("FAIL TruncateContinuation read data doesn't match written data");
-    }
-    auto cont = new TestEmptyContinuation(mTestmanager, mTestID);
-    auto msg = "FAIL in TruncateContinuation write.";
-    auto failTask = new SendMessageTask(msg, mTestmanager, mTestID);
-    WriteRecord(mID, nullptr, 0, new ReadThenTask(mID, cont), failTask);
-    delete this;
-  }
-
-private:
-  const string mID;
-  TestManager* const mTestmanager;
-  const string mTestID;
-};
-
-class VerifyAndFinishContinuation : public ReadContinuation {
-public:
-  explicit VerifyAndFinishContinuation(string aValue,
-                                       TestManager* aTestManager,
-                                       const string& aTestID)
-  : mValue(aValue), mTestmanager(aTestManager), mTestID(aTestID) {}
-
-  void ReadComplete(GMPErr aErr, const std::string& aData) override {
-    if (aData != mValue) {
-      FakeDecryptor::Message("FAIL VerifyAndFinishContinuation read data doesn't match expected data");
-    }
-    mTestmanager->EndTest(mTestID);
-    delete this;
-  }
-
-private:
-  string mValue;
-  TestManager* const mTestmanager;
-  const string mTestID;
-};
-
-class VerifyAndOverwriteContinuation : public ReadContinuation {
-public:
-  VerifyAndOverwriteContinuation(string aId, string aValue, string aOverwrite,
-                                 TestManager* aTestManager, const string& aTestID)
-    : mId(aId)
-    , mValue(aValue)
-    , mOverwrite(aOverwrite)
-    , mTestmanager(aTestManager)
-    , mTestID(aTestID)
-  {}
-
-  void ReadComplete(GMPErr aErr, const std::string& aData) override {
-    if (aData != mValue) {
-      FakeDecryptor::Message("FAIL VerifyAndOverwriteContinuation read data doesn't match expected data");
-    }
-    auto cont = new VerifyAndFinishContinuation(mOverwrite, mTestmanager, mTestID);
-    auto msg = "FAIL in VerifyAndOverwriteContinuation write.";
-    auto failTask = new SendMessageTask(msg, mTestmanager, mTestID);
-    WriteRecord(mId, mOverwrite, new ReadThenTask(mId, cont), failTask);
-    delete this;
-  }
-
-private:
-  string mId;
-  string mValue;
-  string mOverwrite;
-  TestManager* const mTestmanager;
-  const string mTestID;
-};
-
-static const string OpenAgainRecordId = "open-again-record-id";
-
-class OpenedSecondTimeContinuation : public OpenContinuation {
-public:
-  explicit OpenedSecondTimeContinuation(GMPRecord* aRecord,
-                                        TestManager* aTestManager,
-                                        const string& aTestID)
-    : mRecord(aRecord), mTestmanager(aTestManager), mTestID(aTestID) {
-    MOZ_ASSERT(aRecord);
-  }
-
-  virtual void OpenComplete(GMPErr aStatus, GMPRecord* aRecord) override {
-    if (GMP_SUCCEEDED(aStatus)) {
-      FakeDecryptor::Message("FAIL OpenSecondTimeContinuation should not be able to re-open record.");
-    }
-    if (aRecord) {
-      aRecord->Close();
-    }
-    // Succeeded, open should have failed.
-    mTestmanager->EndTest(mTestID);
-    mRecord->Close();
-  }
-
-private:
-  GMPRecord* mRecord;
-  TestManager* const mTestmanager;
-  const string mTestID;
-};
-
-class OpenedFirstTimeContinuation : public OpenContinuation {
-public:
-  OpenedFirstTimeContinuation(const string& aID,
-                              TestManager* aTestManager,
-                              const string& aTestID)
-    : mID(aID), mTestmanager(aTestManager), mTestID(aTestID) {}
-
-  virtual void OpenComplete(GMPErr aStatus, GMPRecord* aRecord) override {
-    if (GMP_FAILED(aStatus)) {
-      FakeDecryptor::Message("FAIL OpenAgainContinuation to open record initially.");
-      mTestmanager->EndTest(mTestID);
-      if (aRecord) {
-        aRecord->Close();
-      }
-      return;
-    }
-
-    auto cont = new OpenedSecondTimeContinuation(aRecord, mTestmanager, mTestID);
-    GMPOpenRecord(mID, cont);
-  }
-
-private:
-  const string mID;
-  TestManager* const mTestmanager;
-  const string mTestID;
-};
-
-static void
-DoTestStorage(const string& aPrefix, TestManager* aTestManager)
-{
-  // Basic I/O tests. We run three cases concurrently. The tests, like
-  // GMPStorage run asynchronously. When they've all passed, we send
-  // a message back to the parent process, or a failure message if not.
-
-  // Test 1: Basic I/O test, and test that writing 0 bytes in a record
-  // deletes record.
-  //
-  // Write data to truncate record, then
-  // read data, verify that we read what we wrote, then
-  // write 0 bytes to truncate record, then
-  // read data, verify that 0 bytes was read
-  const string id1 = aPrefix + TruncateRecordId;
-  const string testID1 = aPrefix + "write-test-1";
-  aTestManager->BeginTest(testID1);
-  auto cont1 = new TruncateContinuation(id1, aTestManager, testID1);
-  auto msg1 = "FAIL in TestStorage writing TruncateRecord.";
-  auto failTask1 = new SendMessageTask(msg1, aTestManager, testID1);
-  WriteRecord(id1, TruncateRecordData,
-              new ReadThenTask(id1, cont1), failTask1);
-
-  // Test 2: Test that overwriting a record with a shorter record truncates
-  // the record to the shorter record.
-  //
-  // Write record, then
-  // read and verify record, then
-  // write a shorter record to same record.
-  // read and verify
-  string id2 = aPrefix + "record1";
-  string record1 = "This is the first write to a record.";
-  string overwrite = "A shorter record";
-  const string testID2 = aPrefix + "write-test-2";
-  aTestManager->BeginTest(testID2);
-  auto task2 = new VerifyAndOverwriteContinuation(id2, record1, overwrite,
-                                                  aTestManager, testID2);
-  auto msg2 = "FAIL in TestStorage writing record1.";
-  auto failTask2 = new SendMessageTask(msg2, aTestManager, testID2);
-  WriteRecord(id2, record1, new ReadThenTask(id2, task2), failTask2);
-
-  // Test 3: Test that opening a record while it's already open fails.
-  //
-  // Open record1, then
-  // open record1, should fail.
-  // close record1
-  const string id3 = aPrefix + OpenAgainRecordId;
-  const string testID3 = aPrefix + "open-test-1";
-  aTestManager->BeginTest(testID3);
-  auto task3 = new OpenedFirstTimeContinuation(id3, aTestManager, testID3);
-  GMPOpenRecord(id3, task3);
-}
-
-class TestStorageTask : public GMPTask {
-public:
-  TestStorageTask(const string& aPrefix, TestManager* aTestManager)
-    : mPrefix(aPrefix), mTestManager(aTestManager) {}
-  virtual void Destroy() { delete this; }
-  virtual void Run() {
-    DoTestStorage(mPrefix, mTestManager);
-  }
-private:
-  const string mPrefix;
-  TestManager* const mTestManager;
-};
-
-void
-FakeDecryptor::TestStorage()
-{
-  TestManager* testManager = new TestManager();
-  GMPThread* thread1 = nullptr;
-  GMPThread* thread2 = nullptr;
-
-  // Main thread tests.
-  DoTestStorage("mt1-", testManager);
-  DoTestStorage("mt2-", testManager);
-
-  // Off-main-thread tests.
-  if (GMP_SUCCEEDED(g_platform_api->createthread(&thread1))) {
-    thread1->Post(new TestStorageTask("thread1-", testManager));
-  } else {
-    FakeDecryptor::Message("FAIL to create thread1 for storage tests");
-  }
-
-  if (GMP_SUCCEEDED(g_platform_api->createthread(&thread2))) {
-    thread2->Post(new TestStorageTask("thread2-", testManager));
-  } else {
-    FakeDecryptor::Message("FAIL to create thread2 for storage tests");
-  }
-
-  if (thread1) {
-    thread1->Join();
-  }
-
-  if (thread2) {
-    thread2->Join();
-  }
-
-  // Note: Once all tests finish, TestManager will dispatch "test-pass" message,
-  // which ends the test for the parent.
-}
-
-class ReportWritten : public GMPTask {
-public:
-  ReportWritten(const string& aRecordId, const string& aValue)
-    : mRecordId(aRecordId)
-    , mValue(aValue)
-  {}
-  void Run() override {
-    FakeDecryptor::Message("stored " + mRecordId + " " + mValue);
-  }
-  void Destroy() override {
-    delete this;
-  }
-  const string mRecordId;
-  const string mValue;
-};
-
-class ReportReadStatusContinuation : public ReadContinuation {
-public:
-  explicit ReportReadStatusContinuation(const string& aRecordId)
-    : mRecordId(aRecordId)
-  {}
-  void ReadComplete(GMPErr aErr, const std::string& aData) override {
-    if (GMP_FAILED(aErr)) {
-      FakeDecryptor::Message("retrieve " + mRecordId + " failed");
-    } else {
-      stringstream ss;
-      ss << aData.size();
-      string len;
-      ss >> len;
-      FakeDecryptor::Message("retrieve " + mRecordId + " succeeded (length " +
-                             len + " bytes)");
-    }
-    delete this;
-  }
-  string mRecordId;
-};
-
-class ReportReadRecordContinuation : public ReadContinuation {
-public:
-  explicit ReportReadRecordContinuation(const string& aRecordId)
-    : mRecordId(aRecordId)
-  {}
-  void ReadComplete(GMPErr aErr, const std::string& aData) override {
-    if (GMP_FAILED(aErr)) {
-      FakeDecryptor::Message("retrieved " + mRecordId + " failed");
-    } else {
-      FakeDecryptor::Message("retrieved " + mRecordId + " " + aData);
-    }
-    delete this;
-  }
-  string mRecordId;
-};
-
-static void
-RecvGMPRecordIterator(GMPRecordIterator* aRecordIterator,
-                      void* aUserArg,
-                      GMPErr aStatus)
-{
-  FakeDecryptor* decryptor = reinterpret_cast<FakeDecryptor*>(aUserArg);
-  decryptor->ProcessRecordNames(aRecordIterator, aStatus);
-}
-
-void
-FakeDecryptor::ProcessRecordNames(GMPRecordIterator* aRecordIterator,
-                                  GMPErr aStatus)
-{
-  if (sInstance != this) {
-    FakeDecryptor::Message("Error aUserArg was not passed through GetRecordIterator");
-    return;
-  }
-  if (GMP_FAILED(aStatus)) {
-    FakeDecryptor::Message("Error GetRecordIterator failed");
-    return;
-  }
-  std::string response("record-names ");
-  bool first = true;
-  const char* name = nullptr;
-  uint32_t len = 0;
-  while (GMP_SUCCEEDED(aRecordIterator->GetName(&name, &len))) {
-    std::string s(name, name+len);
-    if (!first) {
-      response += ",";
-    } else {
-      first = false;
-    }
-    response += s;
-    aRecordIterator->NextRecord();
-  }
-  aRecordIterator->Close();
-  FakeDecryptor::Message(response);
-}
-
-enum ShutdownMode {
-  ShutdownNormal,
-  ShutdownTimeout,
-  ShutdownStoreToken
-};
-
-static ShutdownMode sShutdownMode = ShutdownNormal;
-static string sShutdownToken = "";
-
-void
-FakeDecryptor::UpdateSession(uint32_t aPromiseId,
-                             const char* aSessionId,
-                             uint32_t aSessionIdLength,
-                             const uint8_t* aResponse,
-                             uint32_t aResponseSize)
-{
-  std::string response((const char*)aResponse, (const char*)(aResponse)+aResponseSize);
-  std::vector<std::string> tokens = Tokenize(response);
-  const string& task = tokens[0];
-  if (task == "test-storage") {
-    TestStorage();
-  } else if (task == "store") {
-      // send "stored record" message on complete.
-    const string& id = tokens[1];
-    const string& value = tokens[2];
-    WriteRecord(id,
-                value,
-                new ReportWritten(id, value),
-                new SendMessageTask("FAIL in writing record."));
-  } else if (task == "retrieve") {
-    const string& id = tokens[1];
-    ReadRecord(id, new ReportReadStatusContinuation(id));
-  } else if (task == "shutdown-mode") {
-    const string& mode = tokens[1];
-    if (mode == "timeout") {
-      sShutdownMode = ShutdownTimeout;
-    } else if (mode == "token") {
-      sShutdownMode = ShutdownStoreToken;
-      sShutdownToken = tokens[2];
-      Message("shutdown-token received " + sShutdownToken);
-    }
-  } else if (task == "retrieve-shutdown-token") {
-    ReadRecord("shutdown-token", new ReportReadRecordContinuation("shutdown-token"));
-  } else if (task == "test-op-apis") {
-    mozilla::gmptest::TestOuputProtectionAPIs();
-  } else if (task == "retrieve-plugin-voucher") {
-    const uint8_t* rawVoucher = nullptr;
-    uint32_t length = 0;
-    mHost->GetPluginVoucher(&rawVoucher, &length);
-    std::string voucher((const char*)rawVoucher, (const char*)(rawVoucher + length));
-    Message("retrieved plugin-voucher: " + voucher);
-  } else if (task == "retrieve-record-names") {
-    GMPEnumRecordNames(&RecvGMPRecordIterator, this);
-  }
-}
-
-class CompleteShutdownTask : public GMPTask {
-public:
-  explicit CompleteShutdownTask(GMPAsyncShutdownHost* aHost)
-    : mHost(aHost)
-  {
-  }
-  virtual void Run() {
-    mHost->ShutdownComplete();
-  }
-  virtual void Destroy() { delete this; }
-  GMPAsyncShutdownHost* mHost;
-};
-
-void
-TestAsyncShutdown::BeginShutdown() {
-  switch (sShutdownMode) {
-    case ShutdownNormal:
-      mHost->ShutdownComplete();
-      break;
-    case ShutdownTimeout:
-      // Don't do anything; wait for timeout, Goanna should kill
-      // the plugin and recover.
-      break;
-    case ShutdownStoreToken:
-      // Store message, then shutdown.
-      WriteRecord("shutdown-token",
-                  sShutdownToken,
-                  new CompleteShutdownTask(mHost),
-                  new SendMessageTask("FAIL writing shutdown-token."));
-      break;
-  }
-}
diff --git a/dom/media/gmp-plugin/gmp-test-decryptor.h b/dom/media/gmp-plugin/gmp-test-decryptor.h
deleted file mode 100644
index e530273..0000000
--- a/dom/media/gmp-plugin/gmp-test-decryptor.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef FAKE_DECRYPTOR_H__
-#define FAKE_DECRYPTOR_H__
-
-#include "gmp-decryption.h"
-#include "gmp-async-shutdown.h"
-#include <string>
-#include "mozilla/Attributes.h"
-
-class FakeDecryptor : public GMPDecryptor {
-public:
-
-  explicit FakeDecryptor(GMPDecryptorHost* aHost);
-
-  virtual void Init(GMPDecryptorCallback* aCallback) override {
-    mCallback = aCallback;
-  }
-
-  virtual void CreateSession(uint32_t aCreateSessionToken,
-                             uint32_t aPromiseId,
-                             const char* aInitDataType,
-                             uint32_t aInitDataTypeSize,
-                             const uint8_t* aInitData,
-                             uint32_t aInitDataSize,
-                             GMPSessionType aSessionType) override
-  {
-  }
-
-  virtual void LoadSession(uint32_t aPromiseId,
-                           const char* aSessionId,
-                           uint32_t aSessionIdLength) override
-  {
-  }
-
-  virtual void UpdateSession(uint32_t aPromiseId,
-                             const char* aSessionId,
-                             uint32_t aSessionIdLength,
-                             const uint8_t* aResponse,
-                             uint32_t aResponseSize) override;
-
-  virtual void CloseSession(uint32_t aPromiseId,
-                            const char* aSessionId,
-                            uint32_t aSessionIdLength) override
-  {
-  }
-
-  virtual void RemoveSession(uint32_t aPromiseId,
-                             const char* aSessionId,
-                             uint32_t aSessionIdLength) override
-  {
-  }
-
-  virtual void SetServerCertificate(uint32_t aPromiseId,
-                                    const uint8_t* aServerCert,
-                                    uint32_t aServerCertSize) override
-  {
-  }
-
-  virtual void Decrypt(GMPBuffer* aBuffer,
-                       GMPEncryptedBufferMetadata* aMetadata) override
-  {
-  }
-
-  virtual void DecryptingComplete() override;
-
-  static void Message(const std::string& aMessage);
-
-  void ProcessRecordNames(GMPRecordIterator* aRecordIterator,
-                          GMPErr aStatus);
-
-private:
-
-  virtual ~FakeDecryptor() {}
-  static FakeDecryptor* sInstance;
-
-  void TestStorage();
-
-  GMPDecryptorCallback* mCallback;
-  GMPDecryptorHost* mHost;
-};
-
-class TestAsyncShutdown : public GMPAsyncShutdown {
-public:
-  explicit TestAsyncShutdown(GMPAsyncShutdownHost* aHost)
-    : mHost(aHost)
-  {
-  }
-  virtual void BeginShutdown() override;
-private:
-  GMPAsyncShutdownHost* mHost;
-};
-
-#endif
diff --git a/dom/media/gmp-plugin/gmp-test-output-protection.h b/dom/media/gmp-plugin/gmp-test-output-protection.h
deleted file mode 100644
index 85e9bfc..0000000
--- a/dom/media/gmp-plugin/gmp-test-output-protection.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#if defined(XP_WIN)
-#include <d3d9.h> // needed to prevent re-definition of enums
-#include <stdio.h>
-#include <string>
-#include <vector>
-#include <windows.h>
-
-#include "opmapi.h"
-#endif
-
-namespace mozilla {
-namespace gmptest {
-
-#if defined(XP_WIN)
-typedef HRESULT(STDAPICALLTYPE * OPMGetVideoOutputsFromHMONITORProc)
-          (HMONITOR, OPM_VIDEO_OUTPUT_SEMANTICS, ULONG*, IOPMVideoOutput***);
-
-static OPMGetVideoOutputsFromHMONITORProc sOPMGetVideoOutputsFromHMONITORProc = nullptr;
-
-static BOOL CALLBACK EnumDisplayMonitorsCallback(HMONITOR hMonitor, HDC hdc,
-                                                 LPRECT lprc, LPARAM pData)
-{
-  std::vector<std::string>* failureMsgs = (std::vector<std::string>*)pData;
-
-  MONITORINFOEXA miex;
-  ZeroMemory(&miex, sizeof(miex));
-  miex.cbSize = sizeof(miex);
-  if (!GetMonitorInfoA(hMonitor, &miex)) {
-    failureMsgs->push_back("FAIL GetMonitorInfoA call failed");
-  }
-
-  DISPLAY_DEVICEA dd;
-  ZeroMemory(&dd, sizeof(dd));
-  dd.cb = sizeof(dd);
-  if (!EnumDisplayDevicesA(miex.szDevice, 0, &dd, 1)) {
-    failureMsgs->push_back("FAIL EnumDisplayDevicesA call failed");
-  }
-
-  ULONG numVideoOutputs = 0;
-  IOPMVideoOutput** opmVideoOutputArray = nullptr;
-  HRESULT hr = sOPMGetVideoOutputsFromHMONITORProc(hMonitor,
-                                                   OPM_VOS_OPM_SEMANTICS,
-                                                   &numVideoOutputs,
-                                                   &opmVideoOutputArray);
-  if (S_OK != hr) {
-    if (0x8007001f != hr && 0x80070032 != hr) {
-      char msg[100];
-      sprintf(msg, "FAIL OPMGetVideoOutputsFromHMONITOR call failed: HRESULT=0x%08x", hr);
-      failureMsgs->push_back(msg);
-    }
-    return true;
-  }
-
-  for (ULONG i = 0; i < numVideoOutputs; ++i) {
-    OPM_RANDOM_NUMBER opmRandomNumber;
-    BYTE* certificate = nullptr;
-    ULONG certificateLength = 0;
-    hr = opmVideoOutputArray[i]->StartInitialization(&opmRandomNumber,
-                                                     &certificate,
-                                                     &certificateLength);
-    if (S_OK != hr) {
-      char msg[100];
-      sprintf(msg, "FAIL StartInitialization call failed: HRESULT=0x%08x", hr);
-      failureMsgs->push_back(msg);
-    }
-
-    if (certificate) {
-      CoTaskMemFree(certificate);
-    }
-
-    opmVideoOutputArray[i]->Release();
-  }
-
-  if (opmVideoOutputArray) {
-    CoTaskMemFree(opmVideoOutputArray);
-  }
-
-  return true;
-}
-#endif
-
-static void
-RunOutputProtectionAPITests()
-{
-#if defined(XP_WIN)
-  // Get hold of OPMGetVideoOutputsFromHMONITOR function.
-  HMODULE hDvax2DLL = GetModuleHandleW(L"dxva2.dll");
-  if (!hDvax2DLL) {
-    FakeDecryptor::Message("FAIL GetModuleHandleW call failed for dxva2.dll");
-    return;
-  }
-
-  sOPMGetVideoOutputsFromHMONITORProc = (OPMGetVideoOutputsFromHMONITORProc)
-    GetProcAddress(hDvax2DLL, "OPMGetVideoOutputsFromHMONITOR");
-  if (!sOPMGetVideoOutputsFromHMONITORProc) {
-    FakeDecryptor::Message("FAIL GetProcAddress call failed for OPMGetVideoOutputsFromHMONITOR");
-    return;
-  }
-
-  // Test EnumDisplayMonitors.
-  // Other APIs are tested in the callback function.
-  std::vector<std::string> failureMsgs;
-  if (!EnumDisplayMonitors(NULL, NULL, EnumDisplayMonitorsCallback,
-                           (LPARAM) &failureMsgs)) {
-    FakeDecryptor::Message("FAIL EnumDisplayMonitors call failed");
-  }
-
-  // Report any failures in the callback function.
-  for (size_t i = 0; i < failureMsgs.size(); i++) {
-    FakeDecryptor::Message(failureMsgs[i]);
-  }
-#endif
-}
-
-static void
-TestOuputProtectionAPIs()
-{
-  RunOutputProtectionAPITests();
-  FakeDecryptor::Message("OP tests completed");
-  return;
-}
-
-} // gmptest
-} // mozilla
diff --git a/dom/media/gmp-plugin/gmp-test-storage.cpp b/dom/media/gmp-plugin/gmp-test-storage.cpp
deleted file mode 100644
index f733aef..0000000
--- a/dom/media/gmp-plugin/gmp-test-storage.cpp
+++ /dev/null
@@ -1,233 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "gmp-test-storage.h"
-#include <vector>
-
-#include "mozilla/Assertions.h"
-#include "mozilla/Attributes.h"
-
-class WriteRecordClient : public GMPRecordClient {
-public:
-  GMPErr Init(GMPRecord* aRecord,
-              GMPTask* aOnSuccess,
-              GMPTask* aOnFailure,
-              const uint8_t* aData,
-              uint32_t aDataSize) {
-    mRecord = aRecord;
-    mOnSuccess = aOnSuccess;
-    mOnFailure = aOnFailure;
-    mData.insert(mData.end(), aData, aData + aDataSize);
-    return mRecord->Open();
-  }
-
-  virtual void OpenComplete(GMPErr aStatus) override {
-    if (GMP_SUCCEEDED(aStatus)) {
-      mRecord->Write(mData.size() ? &mData.front() : nullptr, mData.size());
-    } else {
-      GMPRunOnMainThread(mOnFailure);
-      mOnSuccess->Destroy();
-    }
-  }
-
-  virtual void ReadComplete(GMPErr aStatus,
-                            const uint8_t* aData,
-                            uint32_t aDataSize) override {}
-
-  virtual void WriteComplete(GMPErr aStatus) override {
-    // Note: Call Close() before running continuation, in case the
-    // continuation tries to open the same record; if we call Close()
-    // after running the continuation, the Close() call will arrive
-    // just after the Open() call succeeds, immediately closing the
-    // record we just opened.
-    mRecord->Close();
-    if (GMP_SUCCEEDED(aStatus)) {
-      GMPRunOnMainThread(mOnSuccess);
-      mOnFailure->Destroy();
-    } else {
-      GMPRunOnMainThread(mOnFailure);
-      mOnSuccess->Destroy();
-    }
-    delete this;
-  }
-
-private:
-  GMPRecord* mRecord;
-  GMPTask* mOnSuccess;
-  GMPTask* mOnFailure;
-  std::vector<uint8_t> mData;
-};
-
-GMPErr
-WriteRecord(const std::string& aRecordName,
-            const uint8_t* aData,
-            uint32_t aNumBytes,
-            GMPTask* aOnSuccess,
-            GMPTask* aOnFailure)
-{
-  GMPRecord* record;
-  WriteRecordClient* client = new WriteRecordClient();
-  auto err = GMPOpenRecord(aRecordName.c_str(),
-                           aRecordName.size(),
-                           &record,
-                           client);
-  if (GMP_FAILED(err)) {
-    GMPRunOnMainThread(aOnFailure);
-    aOnSuccess->Destroy();
-    return err;
-  }
-  return client->Init(record, aOnSuccess, aOnFailure, aData, aNumBytes);
-}
-
-GMPErr
-WriteRecord(const std::string& aRecordName,
-            const std::string& aData,
-            GMPTask* aOnSuccess,
-            GMPTask* aOnFailure)
-{
-  return WriteRecord(aRecordName,
-                     (const uint8_t*)aData.c_str(),
-                     aData.size(),
-                     aOnSuccess,
-                     aOnFailure);
-}
-
-class ReadRecordClient : public GMPRecordClient {
-public:
-  GMPErr Init(GMPRecord* aRecord,
-              ReadContinuation* aContinuation) {
-    mRecord = aRecord;
-    mContinuation = aContinuation;
-    return mRecord->Open();
-  }
-
-  virtual void OpenComplete(GMPErr aStatus) override {
-    auto err = mRecord->Read();
-    if (GMP_FAILED(err)) {
-      mContinuation->ReadComplete(err, "");
-      delete this;
-    }
-  }
-
-  virtual void ReadComplete(GMPErr aStatus,
-                            const uint8_t* aData,
-                            uint32_t aDataSize) override {
-    // Note: Call Close() before running continuation, in case the
-    // continuation tries to open the same record; if we call Close()
-    // after running the continuation, the Close() call will arrive
-    // just after the Open() call succeeds, immediately closing the
-    // record we just opened.
-    mRecord->Close();
-    std::string data((const char*)aData, aDataSize);
-    mContinuation->ReadComplete(GMPNoErr, data);
-    delete this;
-  }
-
-  virtual void WriteComplete(GMPErr aStatus) override {
-  }
-
-private:
-  GMPRecord* mRecord;
-  ReadContinuation* mContinuation;
-};
-
-GMPErr
-ReadRecord(const std::string& aRecordName,
-           ReadContinuation* aContinuation)
-{
-  MOZ_ASSERT(aContinuation);
-  GMPRecord* record;
-  ReadRecordClient* client = new ReadRecordClient();
-  auto err = GMPOpenRecord(aRecordName.c_str(),
-                           aRecordName.size(),
-                           &record,
-                           client);
-  if (GMP_FAILED(err)) {
-    return err;
-  }
-  return client->Init(record, aContinuation);
-}
-
-extern GMPPlatformAPI* g_platform_api; // Defined in gmp-fake.cpp
-
-GMPErr
-GMPOpenRecord(const char* aName,
-              uint32_t aNameLength,
-              GMPRecord** aOutRecord,
-              GMPRecordClient* aClient)
-{
-  MOZ_ASSERT(g_platform_api);
-  return g_platform_api->createrecord(aName, aNameLength, aOutRecord, aClient);
-}
-
-GMPErr
-GMPRunOnMainThread(GMPTask* aTask)
-{
-  MOZ_ASSERT(g_platform_api);
-  return g_platform_api->runonmainthread(aTask);
-}
-
-class OpenRecordClient : public GMPRecordClient {
-public:
-  /*
-   * This function will take the memory ownership of the parameters and
-   * delete them when done.
-   */
-  static void Open(const std::string& aRecordName,
-            OpenContinuation* aContinuation) {
-    MOZ_ASSERT(aContinuation);
-    (new OpenRecordClient(aContinuation))->Do(aRecordName);
-  }
-
-  virtual void OpenComplete(GMPErr aStatus) override {
-    Done(aStatus);
-  }
-
-  virtual void ReadComplete(GMPErr aStatus,
-                            const uint8_t* aData,
-                            uint32_t aDataSize) override {
-    MOZ_CRASH("Should not reach here.");
-  }
-
-  virtual void WriteComplete(GMPErr aStatus) override {
-    MOZ_CRASH("Should not reach here.");
-  }
-
-private:
-  explicit OpenRecordClient(OpenContinuation* aContinuation)
-    : mRecord(nullptr), mContinuation(aContinuation) {}
-
-  void Do(const std::string& aName) {
-    auto err = GMPOpenRecord(aName.c_str(), aName.size(), &mRecord, this);
-    if (GMP_FAILED(err) ||
-        GMP_FAILED(err = mRecord->Open())) {
-      Done(err);
-    }
-  }
-
-  void Done(GMPErr err) {
-    // mContinuation is responsible for closing mRecord.
-    mContinuation->OpenComplete(err, mRecord);
-    delete mContinuation;
-    delete this;
-  }
-
-  GMPRecord* mRecord;
-  OpenContinuation* mContinuation;
-};
-
-void
-GMPOpenRecord(const std::string& aRecordName,
-              OpenContinuation* aContinuation)
-{
-  OpenRecordClient::Open(aRecordName, aContinuation);
-}
-
-GMPErr
-GMPEnumRecordNames(RecvGMPRecordIteratorPtr aRecvIteratorFunc,
-                   void* aUserArg)
-{
-  return g_platform_api->getrecordenumerator(aRecvIteratorFunc, aUserArg);
-}
diff --git a/dom/media/gmp-plugin/gmp-test-storage.h b/dom/media/gmp-plugin/gmp-test-storage.h
deleted file mode 100644
index d77f8eb..0000000
--- a/dom/media/gmp-plugin/gmp-test-storage.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef TEST_GMP_STORAGE_H__
-#define TEST_GMP_STORAGE_H__
-
-#include "gmp-errors.h"
-#include "gmp-platform.h"
-#include <string>
-
-class ReadContinuation {
-public:
-  virtual ~ReadContinuation() {}
-  virtual void ReadComplete(GMPErr aErr, const std::string& aData) = 0;
-};
-
-// Reads a record to storage using GMPRecord.
-// Calls ReadContinuation with read data.
-GMPErr
-ReadRecord(const std::string& aRecordName,
-           ReadContinuation* aContinuation);
-
-// Writes a record to storage using GMPRecord.
-// Runs continuation when data is written.
-GMPErr
-WriteRecord(const std::string& aRecordName,
-            const std::string& aData,
-            GMPTask* aOnSuccess,
-            GMPTask* aOnFailure);
-
-GMPErr
-WriteRecord(const std::string& aRecordName,
-            const uint8_t* aData,
-            uint32_t aNumBytes,
-            GMPTask* aOnSuccess,
-            GMPTask* aOnFailure);
-
-GMPErr
-GMPOpenRecord(const char* aName,
-              uint32_t aNameLength,
-              GMPRecord** aOutRecord,
-              GMPRecordClient* aClient);
-
-GMPErr
-GMPRunOnMainThread(GMPTask* aTask);
-
-class OpenContinuation {
-public:
-  virtual ~OpenContinuation() {}
-  virtual void OpenComplete(GMPErr aStatus, GMPRecord* aRecord) = 0;
-};
-
-void
-GMPOpenRecord(const std::string& aRecordName,
-              OpenContinuation* aContinuation);
-
-GMPErr
-GMPEnumRecordNames(RecvGMPRecordIteratorPtr aRecvIteratorFunc,
-                   void* aUserArg);
-
-#endif // TEST_GMP_STORAGE_H__
diff --git a/dom/media/gmp-plugin/moz.build b/dom/media/gmp-plugin/moz.build
deleted file mode 100644
index 507469f..0000000
--- a/dom/media/gmp-plugin/moz.build
+++ /dev/null
@@ -1,28 +0,0 @@
-# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-NO_DIST_INSTALL = True
-SOURCES += [
-        'gmp-fake.cpp',
-        'gmp-test-decryptor.cpp',
-        'gmp-test-storage.cpp',
-]
-
-DEFINES['GMP_FAKE_SUPPORT_DECRYPT'] = True
-
-SharedLibrary("fake")
-
-if CONFIG['OS_ARCH'] == 'WINNT':
-    OS_LIBS += [
-        'ole32',
-    ]
-
-USE_STATIC_LIBS = True
-NO_VISIBILITY_FLAGS = True
-# Don't use STL wrappers; this isn't Goanna code
-DISABLE_STL_WRAPPING = True
-
-FAIL_ON_WARNINGS = True
diff --git a/dom/media/gmp/GMPAudioDecoderChild.cpp b/dom/media/gmp/GMPAudioDecoderChild.cpp
deleted file mode 100644
index 72ce071..0000000
--- a/dom/media/gmp/GMPAudioDecoderChild.cpp
+++ /dev/null
@@ -1,172 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPAudioDecoderChild.h"
-#include "GMPChild.h"
-#include "GMPAudioHost.h"
-#include "mozilla/unused.h"
-#include <stdio.h>
-
-namespace mozilla {
-namespace gmp {
-
-GMPAudioDecoderChild::GMPAudioDecoderChild(GMPChild* aPlugin)
-  : mPlugin(aPlugin)
-  , mAudioDecoder(nullptr)
-{
-  MOZ_ASSERT(mPlugin);
-}
-
-GMPAudioDecoderChild::~GMPAudioDecoderChild()
-{
-}
-
-void
-GMPAudioDecoderChild::Init(GMPAudioDecoder* aDecoder)
-{
-  MOZ_ASSERT(aDecoder, "Cannot initialize Audio decoder child without a Audio decoder!");
-  mAudioDecoder = aDecoder;
-}
-
-GMPAudioHostImpl&
-GMPAudioDecoderChild::Host()
-{
-  return mAudioHost;
-}
-
-void
-GMPAudioDecoderChild::Decoded(GMPAudioSamples* aDecodedSamples)
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  if (!aDecodedSamples) {
-    MOZ_CRASH("Not given decoded audio samples!");
-  }
-
-  GMPAudioDecodedSampleData samples;
-  samples.mData().AppendElements((int16_t*)aDecodedSamples->Buffer(),
-                                 aDecodedSamples->Size() / sizeof(int16_t));
-  samples.mTimeStamp() = aDecodedSamples->TimeStamp();
-  samples.mChannelCount() = aDecodedSamples->Channels();
-  samples.mSamplesPerSecond() = aDecodedSamples->Rate();
-
-  unused << SendDecoded(samples);
-
-  aDecodedSamples->Destroy();
-}
-
-void
-GMPAudioDecoderChild::InputDataExhausted()
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  unused << SendInputDataExhausted();
-}
-
-void
-GMPAudioDecoderChild::DrainComplete()
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  unused << SendDrainComplete();
-}
-
-void
-GMPAudioDecoderChild::ResetComplete()
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  unused << SendResetComplete();
-}
-
-void
-GMPAudioDecoderChild::Error(GMPErr aError)
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  unused << SendError(aError);
-}
-
-bool
-GMPAudioDecoderChild::RecvInitDecode(const GMPAudioCodecData& a)
-{
-  MOZ_ASSERT(mAudioDecoder);
-  if (!mAudioDecoder) {
-    return false;
-  }
-
-  GMPAudioCodec codec;
-  codec.mCodecType = a.mCodecType();
-  codec.mChannelCount = a.mChannelCount();
-  codec.mBitsPerChannel = a.mBitsPerChannel();
-  codec.mSamplesPerSecond = a.mSamplesPerSecond();
-  codec.mExtraData = a.mExtraData().Elements();
-  codec.mExtraDataLen = a.mExtraData().Length();
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mAudioDecoder->InitDecode(codec, this);
-
-  return true;
-}
-
-bool
-GMPAudioDecoderChild::RecvDecode(const GMPAudioEncodedSampleData& aEncodedSamples)
-{
-  if (!mAudioDecoder) {
-    return false;
-  }
-
-  GMPAudioSamples* samples = new GMPAudioSamplesImpl(aEncodedSamples);
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mAudioDecoder->Decode(samples);
-
-  return true;
-}
-
-bool
-GMPAudioDecoderChild::RecvReset()
-{
-  if (!mAudioDecoder) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mAudioDecoder->Reset();
-
-  return true;
-}
-
-bool
-GMPAudioDecoderChild::RecvDrain()
-{
-  if (!mAudioDecoder) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mAudioDecoder->Drain();
-
-  return true;
-}
-
-bool
-GMPAudioDecoderChild::RecvDecodingComplete()
-{
-  if (mAudioDecoder) {
-    // Ignore any return code. It is OK for this to fail without killing the process.
-    mAudioDecoder->DecodingComplete();
-    mAudioDecoder = nullptr;
-  }
-
-  mPlugin = nullptr;
-
-  unused << Send__delete__(this);
-
-  return true;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPAudioDecoderChild.h b/dom/media/gmp/GMPAudioDecoderChild.h
deleted file mode 100644
index b186925..0000000
--- a/dom/media/gmp/GMPAudioDecoderChild.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPAudioDecoderChild_h_
-#define GMPAudioDecoderChild_h_
-
-#include "mozilla/gmp/PGMPAudioDecoderChild.h"
-#include "gmp-audio-decode.h"
-#include "GMPAudioHost.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPChild;
-
-class GMPAudioDecoderChild : public PGMPAudioDecoderChild,
-                             public GMPAudioDecoderCallback
-{
-public:
-  explicit GMPAudioDecoderChild(GMPChild* aPlugin);
-  virtual ~GMPAudioDecoderChild();
-
-  void Init(GMPAudioDecoder* aDecoder);
-  GMPAudioHostImpl& Host();
-
-  // GMPAudioDecoderCallback
-  virtual void Decoded(GMPAudioSamples* aEncodedSamples) override;
-  virtual void InputDataExhausted() override;
-  virtual void DrainComplete() override;
-  virtual void ResetComplete() override;
-  virtual void Error(GMPErr aError) override;
-
-private:
-  // PGMPAudioDecoderChild
-  virtual bool RecvInitDecode(const GMPAudioCodecData& codecSettings) override;
-  virtual bool RecvDecode(const GMPAudioEncodedSampleData& input) override;
-  virtual bool RecvReset() override;
-  virtual bool RecvDrain() override;
-  virtual bool RecvDecodingComplete() override;
-
-  GMPChild* mPlugin;
-  GMPAudioDecoder* mAudioDecoder;
-  GMPAudioHostImpl mAudioHost;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPAudioDecoderChild_h_
diff --git a/dom/media/gmp/GMPAudioDecoderParent.cpp b/dom/media/gmp/GMPAudioDecoderParent.cpp
deleted file mode 100644
index f7d1312..0000000
--- a/dom/media/gmp/GMPAudioDecoderParent.cpp
+++ /dev/null
@@ -1,279 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPAudioDecoderParent.h"
-#include "GMPParent.h"
-#include <stdio.h>
-#include "mozilla/unused.h"
-#include "GMPMessageUtils.h"
-#include "nsThreadUtils.h"
-#include "prlog.h"
-
-namespace mozilla {
-
-#ifdef LOG
-#undef LOG
-#endif
-
-#ifdef PR_LOGGING
-extern PRLogModuleInfo* GetGMPLog();
-
-#define LOGD(msg) PR_LOG(GetGMPLog(), PR_LOG_DEBUG, msg)
-#define LOG(level, msg) PR_LOG(GetGMPLog(), (level), msg)
-#else
-#define LOGD(msg)
-#define LOG(level, msg)
-#endif
-
-namespace gmp {
-
-GMPAudioDecoderParent::GMPAudioDecoderParent(GMPParent* aPlugin)
-  : mIsOpen(false)
-  , mShuttingDown(false)
-  , mPlugin(aPlugin)
-  , mCallback(nullptr)
-{
-  MOZ_ASSERT(mPlugin);
-}
-
-GMPAudioDecoderParent::~GMPAudioDecoderParent()
-{
-}
-
-nsresult
-GMPAudioDecoderParent::InitDecode(GMPAudioCodecType aCodecType,
-                                  uint32_t aChannelCount,
-                                  uint32_t aBitsPerChannel,
-                                  uint32_t aSamplesPerSecond,
-                                  nsTArray<uint8_t>& aExtraData,
-                                  GMPAudioDecoderCallbackProxy* aCallback)
-{
-  if (mIsOpen) {
-    NS_WARNING("Trying to re-init an in-use GMP audio decoder!");
-    return NS_ERROR_FAILURE;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (!aCallback) {
-    return NS_ERROR_FAILURE;
-  }
-  mCallback = aCallback;
-
-  GMPAudioCodecData data;
-  data.mCodecType() = aCodecType;
-  data.mChannelCount() = aChannelCount;
-  data.mBitsPerChannel() = aBitsPerChannel;
-  data.mSamplesPerSecond() = aSamplesPerSecond;
-  data.mExtraData() = aExtraData;
-  if (!SendInitDecode(data)) {
-    return NS_ERROR_FAILURE;
-  }
-  mIsOpen = true;
-
-  // Async IPC, we don't have access to a return value.
-  return NS_OK;
-}
-
-nsresult
-GMPAudioDecoderParent::Decode(GMPAudioSamplesImpl& aEncodedSamples)
-{
-
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP Audio decoder!");
-    return NS_ERROR_FAILURE;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  GMPAudioEncodedSampleData samples;
-  aEncodedSamples.RelinquishData(samples);
-
-  if (!SendDecode(samples)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // Async IPC, we don't have access to a return value.
-  return NS_OK;
-}
-
-nsresult
-GMPAudioDecoderParent::Reset()
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP Audio decoder!");
-    return NS_ERROR_FAILURE;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (!SendReset()) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // Async IPC, we don't have access to a return value.
-  return NS_OK;
-}
-
-nsresult
-GMPAudioDecoderParent::Drain()
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP Audio decoder!");
-    return NS_ERROR_FAILURE;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (!SendDrain()) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // Async IPC, we don't have access to a return value.
-  return NS_OK;
-}
-
-// Note: Consider keeping ActorDestroy sync'd up when making changes here.
-nsresult
-GMPAudioDecoderParent::Close()
-{
-  LOGD(("%s: %p", __FUNCTION__, this));
-  MOZ_ASSERT(!mPlugin || mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  // Consumer is done with us; we can shut down.  No more callbacks should
-  // be made to mCallback.  Note: do this before Shutdown()!
-  mCallback = nullptr;
-  // Let Shutdown mark us as dead so it knows if we had been alive
-
-  // In case this is the last reference
-  nsRefPtr<GMPAudioDecoderParent> kungfudeathgrip(this);
-  Release();
-  Shutdown();
-
-  return NS_OK;
-}
-
-// Note: Consider keeping ActorDestroy sync'd up when making changes here.
-nsresult
-GMPAudioDecoderParent::Shutdown()
-{
-  LOGD(("%s: %p", __FUNCTION__, this));
-  MOZ_ASSERT(!mPlugin || mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (mShuttingDown) {
-    return NS_OK;
-  }
-  mShuttingDown = true;
-
-  // Notify client we're gone!  Won't occur after Close()
-  if (mCallback) {
-    mCallback->Terminated();
-    mCallback = nullptr;
-  }
-
-  mIsOpen = false;
-  unused << SendDecodingComplete();
-
-  return NS_OK;
-}
-
-// Note: Keep this sync'd up with DecodingComplete
-void
-GMPAudioDecoderParent::ActorDestroy(ActorDestroyReason aWhy)
-{
-  mIsOpen = false;
-  if (mCallback) {
-    // May call Close() (and Shutdown()) immediately or with a delay
-    mCallback->Terminated();
-    mCallback = nullptr;
-  }
-  if (mPlugin) {
-    // Ignore any return code. It is OK for this to fail without killing the process.
-    mPlugin->AudioDecoderDestroyed(this);
-    mPlugin = nullptr;
-  }
-}
-
-bool
-GMPAudioDecoderParent::RecvDecoded(const GMPAudioDecodedSampleData& aDecoded)
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  mCallback->Decoded(aDecoded.mData(),
-                     aDecoded.mTimeStamp(),
-                     aDecoded.mChannelCount(),
-                     aDecoded.mSamplesPerSecond());
-
-  return true;
-}
-
-bool
-GMPAudioDecoderParent::RecvInputDataExhausted()
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mCallback->InputDataExhausted();
-
-  return true;
-}
-
-bool
-GMPAudioDecoderParent::RecvDrainComplete()
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mCallback->DrainComplete();
-
-  return true;
-}
-
-bool
-GMPAudioDecoderParent::RecvResetComplete()
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mCallback->ResetComplete();
-
-  return true;
-}
-
-bool
-GMPAudioDecoderParent::RecvError(const GMPErr& aError)
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mCallback->Error(aError);
-
-  return true;
-}
-
-bool
-GMPAudioDecoderParent::Recv__delete__()
-{
-  if (mPlugin) {
-    // Ignore any return code. It is OK for this to fail without killing the process.
-    mPlugin->AudioDecoderDestroyed(this);
-    mPlugin = nullptr;
-  }
-
-  return true;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPAudioDecoderParent.h b/dom/media/gmp/GMPAudioDecoderParent.h
deleted file mode 100644
index 30dad91..0000000
--- a/dom/media/gmp/GMPAudioDecoderParent.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPAudioDecoderParent_h_
-#define GMPAudioDecoderParent_h_
-
-#include "mozilla/RefPtr.h"
-#include "gmp-audio-decode.h"
-#include "gmp-audio-codec.h"
-#include "mozilla/gmp/PGMPAudioDecoderParent.h"
-#include "GMPMessageUtils.h"
-#include "GMPAudioDecoderProxy.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPParent;
-
-class GMPAudioDecoderParent final : public GMPAudioDecoderProxy
-                                      , public PGMPAudioDecoderParent
-{
-public:
-  NS_INLINE_DECL_REFCOUNTING(GMPAudioDecoderParent)
-
-  explicit GMPAudioDecoderParent(GMPParent *aPlugin);
-
-  nsresult Shutdown();
-
-  // GMPAudioDecoderProxy
-  virtual nsresult InitDecode(GMPAudioCodecType aCodecType,
-                              uint32_t aChannelCount,
-                              uint32_t aBitsPerChannel,
-                              uint32_t aSamplesPerSecond,
-                              nsTArray<uint8_t>& aExtraData,
-                              GMPAudioDecoderCallbackProxy* aCallback) override;
-  virtual nsresult Decode(GMPAudioSamplesImpl& aInput) override;
-  virtual nsresult Reset() override;
-  virtual nsresult Drain() override;
-  virtual nsresult Close() override;
-
-private:
-  ~GMPAudioDecoderParent();
-
-  // PGMPAudioDecoderParent
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-  virtual bool RecvDecoded(const GMPAudioDecodedSampleData& aDecoded) override;
-  virtual bool RecvInputDataExhausted() override;
-  virtual bool RecvDrainComplete() override;
-  virtual bool RecvResetComplete() override;
-  virtual bool RecvError(const GMPErr& aError) override;
-  virtual bool Recv__delete__() override;
-
-  bool mIsOpen;
-  bool mShuttingDown;
-  nsRefPtr<GMPParent> mPlugin;
-  GMPAudioDecoderCallbackProxy* mCallback;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPAudioDecoderParent_h_
diff --git a/dom/media/gmp/GMPAudioDecoderProxy.h b/dom/media/gmp/GMPAudioDecoderProxy.h
deleted file mode 100644
index 6d71ba0..0000000
--- a/dom/media/gmp/GMPAudioDecoderProxy.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPAudioDecoderProxy_h_
-#define GMPAudioDecoderProxy_h_
-
-#include "GMPCallbackBase.h"
-#include "gmp-audio-codec.h"
-#include "GMPAudioHost.h"
-#include "nsTArray.h"
-#include "mozilla/gmp/GMPTypes.h"
-
-class GMPAudioDecoderCallbackProxy : public GMPCallbackBase {
-public:
-  virtual ~GMPAudioDecoderCallbackProxy() {}
-  // Note: aChannelCount and aSamplesPerSecond may not be consistent from
-  // one invocation to the next.
-  virtual void Decoded(const nsTArray<int16_t>& aPCM,
-                       uint64_t aTimeStamp,
-                       uint32_t aChannelCount,
-                       uint32_t aSamplesPerSecond) = 0;
-  virtual void InputDataExhausted() = 0;
-  virtual void DrainComplete() = 0;
-  virtual void ResetComplete() = 0;
-  virtual void Error(GMPErr aError) = 0;
-};
-
-class GMPAudioDecoderProxy {
-public:
-  virtual ~GMPAudioDecoderProxy() {}
-
-  virtual nsresult InitDecode(GMPAudioCodecType aCodecType,
-                              uint32_t aChannelCount,
-                              uint32_t aBitsPerChannel,
-                              uint32_t aSamplesPerSecond,
-                              nsTArray<uint8_t>& aExtraData,
-                              GMPAudioDecoderCallbackProxy* aCallback) = 0;
-  virtual nsresult Decode(mozilla::gmp::GMPAudioSamplesImpl& aSamples) = 0;
-  virtual nsresult Reset() = 0;
-  virtual nsresult Drain() = 0;
-  // Call to tell GMP/plugin the consumer will no longer use this
-  // interface/codec.
-  virtual nsresult Close() = 0;
-};
-
-#endif // GMPAudioDecoderProxy_h_
diff --git a/dom/media/gmp/GMPAudioHost.cpp b/dom/media/gmp/GMPAudioHost.cpp
deleted file mode 100644
index 4dd1253..0000000
--- a/dom/media/gmp/GMPAudioHost.cpp
+++ /dev/null
@@ -1,162 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPAudioHost.h"
-#include "gmp-audio-samples.h"
-#include "gmp-errors.h"
-#include "GMPEncryptedBufferDataImpl.h"
-#include "MediaData.h"
-
-namespace mozilla {
-namespace gmp {
-
-GMPAudioSamplesImpl::GMPAudioSamplesImpl(GMPAudioFormat aFormat)
-  : mFormat(aFormat)
-  , mTimeStamp(0)
-  , mChannels(0)
-  , mRate(0)
-{
-}
-
-GMPAudioSamplesImpl::GMPAudioSamplesImpl(const GMPAudioEncodedSampleData& aData)
-  : mFormat(kGMPAudioEncodedSamples)
-  , mBuffer(aData.mData())
-  , mTimeStamp(aData.mTimeStamp())
-  , mChannels(aData.mChannelCount())
-  , mRate(aData.mSamplesPerSecond())
-{
-  if (aData.mDecryptionData().mKeyId().Length() > 0) {
-    mCrypto = new GMPEncryptedBufferDataImpl(aData.mDecryptionData());
-  }
-}
-
-GMPAudioSamplesImpl::GMPAudioSamplesImpl(MediaRawData* aSample,
-                                         uint32_t aChannels,
-                                         uint32_t aRate)
- : mFormat(kGMPAudioEncodedSamples)
- , mTimeStamp(aSample->mTime)
- , mChannels(aChannels)
- , mRate(aRate)
-{
-  mBuffer.AppendElements(aSample->Data(), aSample->Size());
-  if (aSample->mCrypto.valid) {
-    mCrypto = new GMPEncryptedBufferDataImpl(aSample->mCrypto);
-  }
-}
-
-GMPAudioSamplesImpl::~GMPAudioSamplesImpl()
-{
-}
-
-GMPAudioFormat
-GMPAudioSamplesImpl::GetFormat()
-{
-  return mFormat;
-}
-
-void
-GMPAudioSamplesImpl::Destroy()
-{
-  delete this;
-}
-
-GMPErr
-GMPAudioSamplesImpl::SetBufferSize(uint32_t aSize)
-{
-  mBuffer.SetLength(aSize);
-  return GMPNoErr;
-}
-
-uint32_t
-GMPAudioSamplesImpl::Size()
-{
-  return mBuffer.Length();
-}
-
-void
-GMPAudioSamplesImpl::SetTimeStamp(uint64_t aTimeStamp)
-{
-  mTimeStamp = aTimeStamp;
-}
-
-uint64_t
-GMPAudioSamplesImpl::TimeStamp()
-{
-  return mTimeStamp;
-}
-
-const uint8_t*
-GMPAudioSamplesImpl::Buffer() const
-{
-  return mBuffer.Elements();
-}
-
-uint8_t*
-GMPAudioSamplesImpl::Buffer()
-{
-  return mBuffer.Elements();
-}
-
-const GMPEncryptedBufferMetadata*
-GMPAudioSamplesImpl::GetDecryptionData() const
-{
-  return mCrypto;
-}
-
-void
-GMPAudioSamplesImpl::InitCrypto(const CryptoSample& aCrypto)
-{
-  if (!aCrypto.valid) {
-    return;
-  }
-  mCrypto = new GMPEncryptedBufferDataImpl(aCrypto);
-}
-
-void
-GMPAudioSamplesImpl::RelinquishData(GMPAudioEncodedSampleData& aData)
-{
-  aData.mData() = Move(mBuffer);
-  aData.mTimeStamp() = TimeStamp();
-  if (mCrypto) {
-    mCrypto->RelinquishData(aData.mDecryptionData());
-  }
-}
-
-uint32_t
-GMPAudioSamplesImpl::Channels() const
-{
-  return mChannels;
-}
-
-void
-GMPAudioSamplesImpl::SetChannels(uint32_t aChannels)
-{
-  mChannels = aChannels;
-}
-
-uint32_t
-GMPAudioSamplesImpl::Rate() const
-{
-  return mRate;
-}
-
-void
-GMPAudioSamplesImpl::SetRate(uint32_t aRate)
-{
-  mRate = aRate;
-}
-
-
-GMPErr
-GMPAudioHostImpl::CreateSamples(GMPAudioFormat aFormat,
-                                GMPAudioSamples** aSamples)
-{
-
-  *aSamples = new GMPAudioSamplesImpl(aFormat);
-  return GMPNoErr;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPAudioHost.h b/dom/media/gmp/GMPAudioHost.h
deleted file mode 100644
index 6988044..0000000
--- a/dom/media/gmp/GMPAudioHost.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPAudioHost_h_
-#define GMPAudioHost_h_
-
-#include "gmp-audio-host.h"
-#include "gmp-audio-samples.h"
-#include "nsTArray.h"
-#include "gmp-decryption.h"
-#include "nsAutoPtr.h"
-#include "GMPEncryptedBufferDataImpl.h"
-#include "mozilla/gmp/GMPTypes.h"
-
-namespace mozilla {
-class CryptoSample;
-class MediaRawData;
-
-namespace gmp {
-
-class GMPAudioSamplesImpl : public GMPAudioSamples {
-public:
-  explicit GMPAudioSamplesImpl(GMPAudioFormat aFormat);
-  explicit GMPAudioSamplesImpl(const GMPAudioEncodedSampleData& aData);
-  GMPAudioSamplesImpl(MediaRawData* aSample,
-                      uint32_t aChannels,
-                      uint32_t aRate);
-  virtual ~GMPAudioSamplesImpl();
-
-  virtual GMPAudioFormat GetFormat() override;
-  virtual void Destroy() override;
-  virtual GMPErr SetBufferSize(uint32_t aSize) override;
-  virtual uint32_t Size() override;
-  virtual void SetTimeStamp(uint64_t aTimeStamp) override;
-  virtual uint64_t TimeStamp() override;
-  virtual const uint8_t* Buffer() const override;
-  virtual uint8_t* Buffer() override;
-  virtual const GMPEncryptedBufferMetadata* GetDecryptionData() const override;
-
-  void InitCrypto(const CryptoSample& aCrypto);
-
-  void RelinquishData(GMPAudioEncodedSampleData& aData);
-
-  virtual uint32_t Channels() const override;
-  virtual void SetChannels(uint32_t aChannels) override;
-  virtual uint32_t Rate() const override;
-  virtual void SetRate(uint32_t aRate) override;
-
-private:
-  GMPAudioFormat mFormat;
-  nsTArray<uint8_t> mBuffer;
-  int64_t mTimeStamp;
-  nsAutoPtr<GMPEncryptedBufferDataImpl> mCrypto;
-  uint32_t mChannels;
-  uint32_t mRate;
-};
-
-class GMPAudioHostImpl : public GMPAudioHost
-{
-public:
-  virtual GMPErr CreateSamples(GMPAudioFormat aFormat,
-                               GMPAudioSamples** aSamples) override;
-private:
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPAudioHost_h_
diff --git a/dom/media/gmp/GMPCallbackBase.h b/dom/media/gmp/GMPCallbackBase.h
deleted file mode 100644
index 3d96629..0000000
--- a/dom/media/gmp/GMPCallbackBase.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPCallbackBase_h_
-#define GMPCallbackBase_h_
-
-class GMPCallbackBase
-{
-public:
-  virtual ~GMPCallbackBase() {}
-
-  // The GMP code will call this if the codec crashes or shuts down.  It's
-  // expected that the consumer (destination of this callback) will respond
-  // by dropping their reference to the proxy, allowing the proxy/parent to
-  // be destroyed.
-  virtual void Terminated() = 0;
-};
-
-#endif
diff --git a/dom/media/gmp/GMPChild.cpp b/dom/media/gmp/GMPChild.cpp
deleted file mode 100644
index 1ec55d8..0000000
--- a/dom/media/gmp/GMPChild.cpp
+++ /dev/null
@@ -1,761 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPChild.h"
-#include "GMPProcessChild.h"
-#include "GMPLoader.h"
-#include "GMPVideoDecoderChild.h"
-#include "GMPVideoEncoderChild.h"
-#include "GMPAudioDecoderChild.h"
-#include "GMPDecryptorChild.h"
-#include "GMPVideoHost.h"
-#include "nsDebugImpl.h"
-#include "nsIFile.h"
-#include "nsXULAppAPI.h"
-#include "gmp-video-decode.h"
-#include "gmp-video-encode.h"
-#include "GMPPlatform.h"
-#ifdef XP_WIN
-#include "nsCRT.h"
-#endif
-#include <fstream>
-
-static const int MAX_VOUCHER_LENGTH = 500000;
-
-#ifdef XP_WIN
-#include <stdlib.h> // for _exit()
-#else
-#include <unistd.h> // for _exit()
-#endif
-
-#if defined(MOZ_GMP_SANDBOX)
-#if defined(XP_WIN)
-#define TARGET_SANDBOX_EXPORTS
-#include "mozilla/sandboxTarget.h"
-#elif defined(XP_MACOSX)
-#include "mozilla/Sandbox.h"
-#endif
-#endif
-
-namespace mozilla {
-namespace gmp {
-
-GMPChild::GMPChild()
-  : mAsyncShutdown(nullptr)
-  , mGMPMessageLoop(MessageLoop::current())
-  , mGMPLoader(nullptr)
-{
-  nsDebugImpl::SetMultiprocessMode("GMP");
-}
-
-GMPChild::~GMPChild()
-{
-}
-
-static bool
-GetFileBase(const std::string& aPluginPath,
-            nsCOMPtr<nsIFile>& aLibDirectory,
-            nsCOMPtr<nsIFile>& aFileBase,
-            nsAutoString& aBaseName)
-{
-  nsDependentCString pluginPath(aPluginPath.c_str());
-
-  nsresult rv = NS_NewLocalFile(NS_ConvertUTF8toUTF16(pluginPath),
-                                true, getter_AddRefs(aFileBase));
-  if (NS_FAILED(rv)) {
-    return false;
-  }
-
-  if (NS_FAILED(aFileBase->Clone(getter_AddRefs(aLibDirectory)))) {
-    return false;
-  }
-
-  nsCOMPtr<nsIFile> parent;
-  rv = aFileBase->GetParent(getter_AddRefs(parent));
-  if (NS_FAILED(rv)) {
-    return false;
-  }
-
-  nsAutoString parentLeafName;
-  rv = parent->GetLeafName(parentLeafName);
-  if (NS_FAILED(rv)) {
-    return false;
-  }
-
-  aBaseName = Substring(parentLeafName,
-                        4,
-                        parentLeafName.Length() - 1);
-  return true;
-}
-
-static bool
-GetFileBase(const std::string& aPluginPath,
-            nsCOMPtr<nsIFile>& aFileBase,
-            nsAutoString& aBaseName)
-{
-  nsCOMPtr<nsIFile> unusedLibDir;
-  return GetFileBase(aPluginPath, unusedLibDir, aFileBase, aBaseName);
-}
-
-static bool
-GetPluginFile(const std::string& aPluginPath,
-              nsCOMPtr<nsIFile>& aLibDirectory,
-              nsCOMPtr<nsIFile>& aLibFile)
-{
-  nsAutoString baseName;
-  GetFileBase(aPluginPath, aLibDirectory, aLibFile, baseName);
-
-#if defined(XP_MACOSX)
-  nsAutoString binaryName = NS_LITERAL_STRING("lib") + baseName + NS_LITERAL_STRING(".dylib");
-#elif defined(OS_POSIX)
-  nsAutoString binaryName = NS_LITERAL_STRING("lib") + baseName + NS_LITERAL_STRING(".so");
-#elif defined(XP_WIN)
-  nsAutoString binaryName =                            baseName + NS_LITERAL_STRING(".dll");
-#else
-#error not defined
-#endif
-  aLibFile->AppendRelativePath(binaryName);
-  return true;
-}
-
-static bool
-GetPluginFile(const std::string& aPluginPath,
-              nsCOMPtr<nsIFile>& aLibFile)
-{
-  nsCOMPtr<nsIFile> unusedlibDir;
-  return GetPluginFile(aPluginPath, unusedlibDir, aLibFile);
-}
-
-static bool
-GetInfoFile(const std::string& aPluginPath,
-            nsCOMPtr<nsIFile>& aInfoFile)
-{
-  nsAutoString baseName;
-  GetFileBase(aPluginPath, aInfoFile, baseName);
-  nsAutoString infoFileName = baseName + NS_LITERAL_STRING(".info");
-  aInfoFile->AppendRelativePath(infoFileName);
-  return true;
-}
-
-#if defined(XP_MACOSX) && defined(MOZ_GMP_SANDBOX)
-static nsCString
-GetNativeTarget(nsIFile* aFile)
-{
-  bool isLink;
-  nsCString path;
-  aFile->IsSymlink(&isLink);
-  if (isLink) {
-    aFile->GetNativeTarget(path);
-  } else {
-    aFile->GetNativePath(path);
-  }
-  return path;
-}
-
-static bool
-GetPluginPaths(const std::string& aPluginPath,
-               nsCString &aPluginDirectoryPath,
-               nsCString &aPluginFilePath)
-{
-  nsCOMPtr<nsIFile> libDirectory, libFile;
-  if (!GetPluginFile(aPluginPath, libDirectory, libFile)) {
-    return false;
-  }
-
-  // Mac sandbox rules expect paths to actual files and directories -- not
-  // soft links.
-  aPluginDirectoryPath = GetNativeTarget(libDirectory);
-  aPluginFilePath = GetNativeTarget(libFile);
-
-  return true;
-}
-
-static bool
-GetAppPaths(nsCString &aAppPath, nsCString &aAppBinaryPath)
-{
-  nsAutoCString appPath;
-  nsAutoCString appBinaryPath(
-    (CommandLine::ForCurrentProcess()->argv()[0]).c_str());
-
-  nsAutoCString::const_iterator start, end;
-  appBinaryPath.BeginReading(start);
-  appBinaryPath.EndReading(end);
-  if (RFindInReadable(NS_LITERAL_CSTRING(".app/Contents/MacOS/"), start, end)) {
-    end = start;
-    ++end; ++end; ++end; ++end;
-    appBinaryPath.BeginReading(start);
-    appPath.Assign(Substring(start, end));
-  } else {
-    return false;
-  }
-
-  nsCOMPtr<nsIFile> app, appBinary;
-  nsresult rv = NS_NewLocalFile(NS_ConvertUTF8toUTF16(appPath),
-                                true, getter_AddRefs(app));
-  if (NS_FAILED(rv)) {
-    return false;
-  }
-  rv = NS_NewLocalFile(NS_ConvertUTF8toUTF16(appBinaryPath),
-                       true, getter_AddRefs(appBinary));
-  if (NS_FAILED(rv)) {
-    return false;
-  }
-
-  // Mac sandbox rules expect paths to actual files and directories -- not
-  // soft links.
-  aAppPath = GetNativeTarget(app);
-  appBinaryPath = GetNativeTarget(appBinary);
-
-  return true;
-}
-
-void
-GMPChild::StartMacSandbox()
-{
-  nsAutoCString pluginDirectoryPath, pluginFilePath;
-  if (!GetPluginPaths(mPluginPath, pluginDirectoryPath, pluginFilePath)) {
-    MOZ_CRASH("Error scanning plugin path");
-  }
-  nsAutoCString appPath, appBinaryPath;
-  if (!GetAppPaths(appPath, appBinaryPath)) {
-    MOZ_CRASH("Error resolving child process path");
-  }
-
-  MacSandboxInfo info;
-  info.type = MacSandboxType_Plugin;
-  info.pluginInfo.type = MacSandboxPluginType_GMPlugin_Default;
-  info.pluginInfo.pluginPath.Assign(pluginDirectoryPath);
-  mPluginBinaryPath.Assign(pluginFilePath);
-  info.pluginInfo.pluginBinaryPath.Assign(pluginFilePath);
-  info.appPath.Assign(appPath);
-  info.appBinaryPath.Assign(appBinaryPath);
-
-  nsAutoCString err;
-  if (!mozilla::StartMacSandbox(info, err)) {
-    NS_WARNING(err.get());
-    MOZ_CRASH("sandbox_init() failed");
-  }
-}
-#endif // XP_MACOSX && MOZ_GMP_SANDBOX
-
-void
-GMPChild::CheckThread()
-{
-  MOZ_ASSERT(mGMPMessageLoop == MessageLoop::current());
-}
-
-bool
-GMPChild::Init(const std::string& aPluginPath,
-               const std::string& aVoucherPath,
-               base::ProcessHandle aParentProcessHandle,
-               MessageLoop* aIOLoop,
-               IPC::Channel* aChannel)
-{
-  if (!Open(aChannel, aParentProcessHandle, aIOLoop)) {
-    return false;
-  }
-
-  mPluginPath = aPluginPath;
-  mVoucherPath = aVoucherPath;
-  return true;
-}
-
-bool
-GMPChild::RecvSetNodeId(const nsCString& aNodeId)
-{
-  // Store the per origin salt for the node id. Note: we do this in a
-  // separate message than RecvStartPlugin() so that the string is not
-  // sitting in a string on the IPC code's call stack.
-  mNodeId = std::string(aNodeId.BeginReading(), aNodeId.EndReading());
-  return true;
-}
-
-GMPErr
-GMPChild::GetAPI(const char* aAPIName, void* aHostAPI, void** aPluginAPI)
-{
-  if (!mGMPLoader) {
-    return GMPGenericErr;
-  }
-  return mGMPLoader->GetAPI(aAPIName, aHostAPI, aPluginAPI);
-}
-
-#ifdef XP_WIN
-// Pre-load DLLs that need to be used by the EME plugin but that can't be
-// loaded after the sandbox has started
-bool
-GMPChild::PreLoadLibraries(const std::string& aPluginPath)
-{
-  // This must be in sorted order and lowercase!
-  static const char* whitelist[] =
-    {
-       "d3d9.dll", // Create an `IDirect3D9` to get adapter information
-       "dxva2.dll", // Get monitor information
-       "evr.dll", // MFGetStrideForBitmapInfoHeader
-       "mfh264dec.dll", // H.264 decoder (on Windows Vista)
-       "mfheaacdec.dll", // AAC decoder (on Windows Vista)
-       "mfplat.dll", // MFCreateSample, MFCreateAlignedMemoryBuffer, MFCreateMediaType
-       "msauddecmft.dll", // AAC decoder (on Windows 8)
-       "msmpeg2adec.dll", // AAC decoder (on Windows 7)
-       "msmpeg2vdec.dll", // H.264 decoder
-    };
-  static const int whitelistLen = sizeof(whitelist) / sizeof(whitelist[0]);
-
-  nsCOMPtr<nsIFile> infoFile;
-  GetInfoFile(aPluginPath, infoFile);
-
-  nsString path;
-  infoFile->GetPath(path);
-
-  std::ifstream stream;
-#ifdef _MSC_VER
-  stream.open(static_cast<const wchar_t*>(path.get()));
-#else
-  stream.open(NS_ConvertUTF16toUTF8(path).get());
-#endif
-  if (!stream.good()) {
-    NS_WARNING("Failure opening info file for required DLLs");
-    return false;
-  }
-
-  do {
-    std::string line;
-    getline(stream, line);
-    if (stream.fail()) {
-      NS_WARNING("Failure reading info file for required DLLs");
-      return false;
-    }
-    std::transform(line.begin(), line.end(), line.begin(), tolower);
-    static const char* prefix = "libraries:";
-    static const int prefixLen = strlen(prefix);
-    if (0 == line.compare(0, prefixLen, prefix)) {
-      char* lineCopy = strdup(line.c_str() + prefixLen);
-      char* start = lineCopy;
-      while (char* tok = nsCRT::strtok(start, ", ", &start)) {
-        for (int i = 0; i < whitelistLen; i++) {
-          if (0 == strcmp(whitelist[i], tok)) {
-            LoadLibraryA(tok);
-            break;
-          }
-        }
-      }
-      free(lineCopy);
-      break;
-    }
-  } while (!stream.eof());
-
-  return true;
-}
-#endif
-
-#if defined(MOZ_GMP_SANDBOX)
-
-#if defined(XP_MACOSX)
-class MacOSXSandboxStarter : public SandboxStarter {
-public:
-  explicit MacOSXSandboxStarter(GMPChild* aGMPChild)
-    : mGMPChild(aGMPChild)
-  {}
-  virtual void Start(const char* aLibPath) override {
-    mGMPChild->StartMacSandbox();
-  }
-private:
-  GMPChild* mGMPChild;
-};
-#endif
-
-#endif // MOZ_GMP_SANDBOX
-
-bool
-GMPChild::GetLibPath(nsACString& aOutLibPath)
-{
-#if defined(XP_MACOSX) && defined(MOZ_GMP_SANDBOX)
-  nsAutoCString pluginDirectoryPath, pluginFilePath;
-  if (!GetPluginPaths(mPluginPath, pluginDirectoryPath, pluginFilePath)) {
-    MOZ_CRASH("Error scanning plugin path");
-  }
-  aOutLibPath.Assign(pluginFilePath);
-  return true;
-#else
-  nsCOMPtr<nsIFile> libFile;
-  if (!GetPluginFile(mPluginPath, libFile)) {
-    return false;
-  }
-  return NS_SUCCEEDED(libFile->GetNativePath(aOutLibPath));
-#endif
-}
-
-bool
-GMPChild::RecvStartPlugin()
-{
-#if defined(XP_WIN)
-  PreLoadLibraries(mPluginPath);
-#endif
-  PreLoadPluginVoucher(mPluginPath);
-  PreLoadSandboxVoucher();
-
-  nsCString libPath;
-  if (!GetLibPath(libPath)) {
-    return false;
-  }
-
-  auto platformAPI = new GMPPlatformAPI();
-  InitPlatformAPI(*platformAPI, this);
-
-  mGMPLoader = GMPProcessChild::GetGMPLoader();
-  if (!mGMPLoader) {
-    NS_WARNING("Failed to get GMPLoader");
-    return false;
-  }
-
-#if defined(MOZ_GMP_SANDBOX) && defined(XP_MACOSX)
-  nsAutoPtr<SandboxStarter> starter(new MacOSXSandboxStarter(this));
-  mGMPLoader->SetStartSandboxStarter(starter);
-#endif
-
-  if (!mGMPLoader->Load(libPath.get(),
-                        libPath.Length(),
-                        &mNodeId[0],
-                        mNodeId.size(),
-                        platformAPI)) {
-    NS_WARNING("Failed to load GMP");
-    return false;
-  }
-
-  void* sh = nullptr;
-  GMPAsyncShutdownHost* host = static_cast<GMPAsyncShutdownHost*>(this);
-  GMPErr err = GetAPI(GMP_API_ASYNC_SHUTDOWN, host, &sh);
-  if (err == GMPNoErr && sh) {
-    mAsyncShutdown = reinterpret_cast<GMPAsyncShutdown*>(sh);
-    SendAsyncShutdownRequired();
-  }
-
-  return true;
-}
-
-MessageLoop*
-GMPChild::GMPMessageLoop()
-{
-  return mGMPMessageLoop;
-}
-
-void
-GMPChild::ActorDestroy(ActorDestroyReason aWhy)
-{
-  if (mGMPLoader) {
-    mGMPLoader->Shutdown();
-  }
-  if (AbnormalShutdown == aWhy) {
-    NS_WARNING("Abnormal shutdown of GMP process!");
-    _exit(0);
-  }
-
-  XRE_ShutdownChildProcess();
-}
-
-void
-GMPChild::ProcessingError(Result aCode, const char* aReason)
-{
-  switch (aCode) {
-    case MsgDropped:
-      _exit(0); // Don't trigger a crash report.
-    case MsgNotKnown:
-      MOZ_CRASH("aborting because of MsgNotKnown");
-    case MsgNotAllowed:
-      MOZ_CRASH("aborting because of MsgNotAllowed");
-    case MsgPayloadError:
-      MOZ_CRASH("aborting because of MsgPayloadError");
-    case MsgProcessingError:
-      MOZ_CRASH("aborting because of MsgProcessingError");
-    case MsgRouteError:
-      MOZ_CRASH("aborting because of MsgRouteError");
-    case MsgValueError:
-      MOZ_CRASH("aborting because of MsgValueError");
-    default:
-      MOZ_CRASH("not reached");
-  }
-}
-
-PGMPAudioDecoderChild*
-GMPChild::AllocPGMPAudioDecoderChild()
-{
-  return new GMPAudioDecoderChild(this);
-}
-
-bool
-GMPChild::DeallocPGMPAudioDecoderChild(PGMPAudioDecoderChild* aActor)
-{
-  delete aActor;
-  return true;
-}
-
-PGMPVideoDecoderChild*
-GMPChild::AllocPGMPVideoDecoderChild()
-{
-  return new GMPVideoDecoderChild(this);
-}
-
-bool
-GMPChild::DeallocPGMPVideoDecoderChild(PGMPVideoDecoderChild* aActor)
-{
-  delete aActor;
-  return true;
-}
-
-PGMPDecryptorChild*
-GMPChild::AllocPGMPDecryptorChild()
-{
-  GMPDecryptorChild* actor = new GMPDecryptorChild(this, mPluginVoucher, mSandboxVoucher);
-  actor->AddRef();
-  return actor;
-}
-
-bool
-GMPChild::DeallocPGMPDecryptorChild(PGMPDecryptorChild* aActor)
-{
-  static_cast<GMPDecryptorChild*>(aActor)->Release();
-  return true;
-}
-
-bool
-GMPChild::RecvPGMPAudioDecoderConstructor(PGMPAudioDecoderChild* aActor)
-{
-  auto vdc = static_cast<GMPAudioDecoderChild*>(aActor);
-
-  void* vd = nullptr;
-  GMPErr err = GetAPI(GMP_API_AUDIO_DECODER, &vdc->Host(), &vd);
-  if (err != GMPNoErr || !vd) {
-    return false;
-  }
-
-  vdc->Init(static_cast<GMPAudioDecoder*>(vd));
-
-  return true;
-}
-
-PGMPVideoEncoderChild*
-GMPChild::AllocPGMPVideoEncoderChild()
-{
-  return new GMPVideoEncoderChild(this);
-}
-
-bool
-GMPChild::DeallocPGMPVideoEncoderChild(PGMPVideoEncoderChild* aActor)
-{
-  delete aActor;
-  return true;
-}
-
-bool
-GMPChild::RecvPGMPVideoDecoderConstructor(PGMPVideoDecoderChild* aActor)
-{
-  auto vdc = static_cast<GMPVideoDecoderChild*>(aActor);
-
-  void* vd = nullptr;
-  GMPErr err = GetAPI(GMP_API_VIDEO_DECODER, &vdc->Host(), &vd);
-  if (err != GMPNoErr || !vd) {
-    NS_WARNING("GMPGetAPI call failed trying to construct decoder.");
-    return false;
-  }
-
-  vdc->Init(static_cast<GMPVideoDecoder*>(vd));
-
-  return true;
-}
-
-bool
-GMPChild::RecvPGMPVideoEncoderConstructor(PGMPVideoEncoderChild* aActor)
-{
-  auto vec = static_cast<GMPVideoEncoderChild*>(aActor);
-
-  void* ve = nullptr;
-  GMPErr err = GetAPI(GMP_API_VIDEO_ENCODER, &vec->Host(), &ve);
-  if (err != GMPNoErr || !ve) {
-    NS_WARNING("GMPGetAPI call failed trying to construct encoder.");
-    return false;
-  }
-
-  vec->Init(static_cast<GMPVideoEncoder*>(ve));
-
-  return true;
-}
-
-bool
-GMPChild::RecvPGMPDecryptorConstructor(PGMPDecryptorChild* aActor)
-{
-  GMPDecryptorChild* child = static_cast<GMPDecryptorChild*>(aActor);
-  GMPDecryptorHost* host = static_cast<GMPDecryptorHost*>(child);
-
-  void* session = nullptr;
-  GMPErr err = GetAPI(GMP_API_DECRYPTOR, host, &session);
-
-  if (err != GMPNoErr && !session) {
-    // XXX to remove in bug 1147692
-    err = GetAPI(GMP_API_DECRYPTOR_COMPAT, host, &session);
-  }
-
-  if (err != GMPNoErr || !session) {
-    return false;
-  }
-
-  child->Init(static_cast<GMPDecryptor*>(session));
-
-  return true;
-}
-
-PGMPTimerChild*
-GMPChild::AllocPGMPTimerChild()
-{
-  return new GMPTimerChild(this);
-}
-
-bool
-GMPChild::DeallocPGMPTimerChild(PGMPTimerChild* aActor)
-{
-  MOZ_ASSERT(mTimerChild == static_cast<GMPTimerChild*>(aActor));
-  mTimerChild = nullptr;
-  return true;
-}
-
-GMPTimerChild*
-GMPChild::GetGMPTimers()
-{
-  if (!mTimerChild) {
-    PGMPTimerChild* sc = SendPGMPTimerConstructor();
-    if (!sc) {
-      return nullptr;
-    }
-    mTimerChild = static_cast<GMPTimerChild*>(sc);
-  }
-  return mTimerChild;
-}
-
-PGMPStorageChild*
-GMPChild::AllocPGMPStorageChild()
-{
-  return new GMPStorageChild(this);
-}
-
-bool
-GMPChild::DeallocPGMPStorageChild(PGMPStorageChild* aActor)
-{
-  mStorage = nullptr;
-  return true;
-}
-
-GMPStorageChild*
-GMPChild::GetGMPStorage()
-{
-  if (!mStorage) {
-    PGMPStorageChild* sc = SendPGMPStorageConstructor();
-    if (!sc) {
-      return nullptr;
-    }
-    mStorage = static_cast<GMPStorageChild*>(sc);
-  }
-  return mStorage;
-}
-
-bool
-GMPChild::RecvCrashPluginNow()
-{
-  MOZ_CRASH();
-  return true;
-}
-
-bool
-GMPChild::RecvBeginAsyncShutdown()
-{
-  MOZ_ASSERT(mGMPMessageLoop == MessageLoop::current());
-  if (mAsyncShutdown) {
-    mAsyncShutdown->BeginShutdown();
-  } else {
-    ShutdownComplete();
-  }
-  return true;
-}
-
-void
-GMPChild::ShutdownComplete()
-{
-  MOZ_ASSERT(mGMPMessageLoop == MessageLoop::current());
-  SendAsyncShutdownComplete();
-}
-
-static bool
-GetPluginVoucherFile(const std::string& aPluginPath,
-                     nsCOMPtr<nsIFile>& aOutVoucherFile)
-{
-  nsAutoString baseName;
-  GetFileBase(aPluginPath, aOutVoucherFile, baseName);
-  nsAutoString infoFileName = baseName + NS_LITERAL_STRING(".voucher");
-  aOutVoucherFile->AppendRelativePath(infoFileName);
-  return true;
-}
-
-bool
-GMPChild::PreLoadPluginVoucher(const std::string& aPluginPath)
-{
-  nsCOMPtr<nsIFile> voucherFile;
-  GetPluginVoucherFile(aPluginPath, voucherFile);
-
-  nsString path;
-  voucherFile->GetPath(path);
-
-  std::ifstream stream;
-  stream.open(NS_ConvertUTF16toUTF8(path).get(), std::ios::binary);
-  if (!stream.good()) {
-    return false;
-  }
-
-  std::streampos start = stream.tellg();
-  stream.seekg (0, std::ios::end);
-  std::streampos end = stream.tellg();
-  stream.seekg (0, std::ios::beg);
-  auto length = end - start;
-  if (length > MAX_VOUCHER_LENGTH) {
-    NS_WARNING("Plugin voucher file too big!");
-    return false;
-  }
-
-  mPluginVoucher.SetLength(length);
-  stream.read((char*)mPluginVoucher.Elements(), length);
-  if (!stream) {
-    NS_WARNING("Failed to read plugin voucher file!");
-    return false;
-  }
-
-  return true;
-}
-
-void
-GMPChild::PreLoadSandboxVoucher()
-{
-  std::ifstream stream;
-  stream.open(mVoucherPath.c_str(), std::ios::binary);
-  if (!stream.good()) {
-    NS_WARNING("PreLoadSandboxVoucher can't find sandbox voucher file!");
-    return;
-  }
-
-  std::streampos start = stream.tellg();
-  stream.seekg (0, std::ios::end);
-  std::streampos end = stream.tellg();
-  stream.seekg (0, std::ios::beg);
-  auto length = end - start;
-  if (length > MAX_VOUCHER_LENGTH) {
-    NS_WARNING("PreLoadSandboxVoucher sandbox voucher file too big!");
-    return;
-  }
-
-  mSandboxVoucher.SetLength(length);
-  stream.read((char*)mSandboxVoucher.Elements(), length);
-  if (!stream) {
-    NS_WARNING("PreLoadSandboxVoucher failed to read plugin voucher file!");
-    return;
-  }
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPChild.h b/dom/media/gmp/GMPChild.h
deleted file mode 100644
index 5eb4656..0000000
--- a/dom/media/gmp/GMPChild.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPChild_h_
-#define GMPChild_h_
-
-#include "mozilla/gmp/PGMPChild.h"
-#include "GMPSharedMemManager.h"
-#include "GMPTimerChild.h"
-#include "GMPStorageChild.h"
-#include "GMPLoader.h"
-#include "gmp-async-shutdown.h"
-#include "gmp-entrypoints.h"
-#include "prlink.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPChild : public PGMPChild
-               , public GMPSharedMem
-               , public GMPAsyncShutdownHost
-{
-public:
-  GMPChild();
-  virtual ~GMPChild();
-
-  bool Init(const std::string& aPluginPath,
-            const std::string& aVoucherPath,
-            base::ProcessHandle aParentProcessHandle,
-            MessageLoop* aIOLoop,
-            IPC::Channel* aChannel);
-#ifdef XP_WIN
-  bool PreLoadLibraries(const std::string& aPluginPath);
-#endif
-  MessageLoop* GMPMessageLoop();
-
-  // Main thread only.
-  GMPTimerChild* GetGMPTimers();
-  GMPStorageChild* GetGMPStorage();
-
-  // GMPSharedMem
-  virtual void CheckThread() override;
-
-  // GMPAsyncShutdownHost
-  void ShutdownComplete() override;
-
-#if defined(XP_MACOSX) && defined(MOZ_GMP_SANDBOX)
-  void StartMacSandbox();
-#endif
-
-private:
-
-  bool PreLoadPluginVoucher(const std::string& aPluginPath);
-  void PreLoadSandboxVoucher();
-
-  bool GetLibPath(nsACString& aOutLibPath);
-
-  virtual bool RecvSetNodeId(const nsCString& aNodeId) override;
-  virtual bool RecvStartPlugin() override;
-
-  virtual PGMPVideoDecoderChild* AllocPGMPVideoDecoderChild() override;
-  virtual bool DeallocPGMPVideoDecoderChild(PGMPVideoDecoderChild* aActor) override;
-  virtual bool RecvPGMPVideoDecoderConstructor(PGMPVideoDecoderChild* aActor) override;
-
-  virtual PGMPVideoEncoderChild* AllocPGMPVideoEncoderChild() override;
-  virtual bool DeallocPGMPVideoEncoderChild(PGMPVideoEncoderChild* aActor) override;
-  virtual bool RecvPGMPVideoEncoderConstructor(PGMPVideoEncoderChild* aActor) override;
-
-  virtual PGMPDecryptorChild* AllocPGMPDecryptorChild() override;
-  virtual bool DeallocPGMPDecryptorChild(PGMPDecryptorChild* aActor) override;
-  virtual bool RecvPGMPDecryptorConstructor(PGMPDecryptorChild* aActor) override;
-
-  virtual PGMPAudioDecoderChild* AllocPGMPAudioDecoderChild() override;
-  virtual bool DeallocPGMPAudioDecoderChild(PGMPAudioDecoderChild* aActor) override;
-  virtual bool RecvPGMPAudioDecoderConstructor(PGMPAudioDecoderChild* aActor) override;
-
-  virtual PGMPTimerChild* AllocPGMPTimerChild() override;
-  virtual bool DeallocPGMPTimerChild(PGMPTimerChild* aActor) override;
-
-  virtual PGMPStorageChild* AllocPGMPStorageChild() override;
-  virtual bool DeallocPGMPStorageChild(PGMPStorageChild* aActor) override;
-
-  virtual bool RecvCrashPluginNow() override;
-  virtual bool RecvBeginAsyncShutdown() override;
-
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-  virtual void ProcessingError(Result aCode, const char* aReason) override;
-
-  GMPErr GetAPI(const char* aAPIName, void* aHostAPI, void** aPluginAPI);
-
-  GMPAsyncShutdown* mAsyncShutdown;
-  nsRefPtr<GMPTimerChild> mTimerChild;
-  nsRefPtr<GMPStorageChild> mStorage;
-
-  MessageLoop* mGMPMessageLoop;
-  std::string mPluginPath;
-  std::string mVoucherPath;
-#if defined(XP_MACOSX) && defined(MOZ_GMP_SANDBOX)
-  nsCString mPluginBinaryPath;
-#endif
-  std::string mNodeId;
-  GMPLoader* mGMPLoader;
-  nsTArray<uint8_t> mPluginVoucher;
-  nsTArray<uint8_t> mSandboxVoucher;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPChild_h_
diff --git a/dom/media/gmp/GMPDecryptorChild.cpp b/dom/media/gmp/GMPDecryptorChild.cpp
deleted file mode 100644
index 4c17065..0000000
--- a/dom/media/gmp/GMPDecryptorChild.cpp
+++ /dev/null
@@ -1,341 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPDecryptorChild.h"
-#include "GMPChild.h"
-#include "mozilla/TimeStamp.h"
-#include "mozilla/unused.h"
-#include "runnable_utils.h"
-#include <ctime>
-
-#define ON_GMP_THREAD() (mPlugin->GMPMessageLoop() == MessageLoop::current())
-
-#define CALL_ON_GMP_THREAD(_func, ...) \
-  do { \
-    if (ON_GMP_THREAD()) { \
-      _func(__VA_ARGS__); \
-    } else { \
-      mPlugin->GMPMessageLoop()->PostTask( \
-        FROM_HERE, NewRunnableMethod(this, &GMPDecryptorChild::_func, __VA_ARGS__) \
-      ); \
-    } \
-  } while(false)
-
-namespace mozilla {
-namespace gmp {
-
-GMPDecryptorChild::GMPDecryptorChild(GMPChild* aPlugin,
-                                     const nsTArray<uint8_t>& aPluginVoucher,
-                                     const nsTArray<uint8_t>& aSandboxVoucher)
-  : mSession(nullptr)
-  , mPlugin(aPlugin)
-  , mPluginVoucher(aPluginVoucher)
-  , mSandboxVoucher(aSandboxVoucher)
-{
-  MOZ_ASSERT(mPlugin);
-}
-
-GMPDecryptorChild::~GMPDecryptorChild()
-{
-}
-
-void
-GMPDecryptorChild::Init(GMPDecryptor* aSession)
-{
-  MOZ_ASSERT(aSession);
-  mSession = aSession;
-}
-
-void
-GMPDecryptorChild::SetSessionId(uint32_t aCreateSessionToken,
-                                const char* aSessionId,
-                                uint32_t aSessionIdLength)
-{
-  CALL_ON_GMP_THREAD(SendSetSessionId,
-                     aCreateSessionToken, nsAutoCString(aSessionId, aSessionIdLength));
-}
-
-void
-GMPDecryptorChild::ResolveLoadSessionPromise(uint32_t aPromiseId,
-                                             bool aSuccess)
-{
-  CALL_ON_GMP_THREAD(SendResolveLoadSessionPromise, aPromiseId, aSuccess);
-}
-
-void
-GMPDecryptorChild::ResolvePromise(uint32_t aPromiseId)
-{
-  CALL_ON_GMP_THREAD(SendResolvePromise, aPromiseId);
-}
-
-void
-GMPDecryptorChild::RejectPromise(uint32_t aPromiseId,
-                                 GMPDOMException aException,
-                                 const char* aMessage,
-                                 uint32_t aMessageLength)
-{
-  CALL_ON_GMP_THREAD(SendRejectPromise,
-                     aPromiseId, aException, nsAutoCString(aMessage, aMessageLength));
-}
-
-void
-GMPDecryptorChild::SessionMessage(const char* aSessionId,
-                                  uint32_t aSessionIdLength,
-                                  GMPSessionMessageType aMessageType,
-                                  const uint8_t* aMessage,
-                                  uint32_t aMessageLength)
-{
-  nsTArray<uint8_t> msg;
-  msg.AppendElements(aMessage, aMessageLength);
-  CALL_ON_GMP_THREAD(SendSessionMessage,
-                     nsAutoCString(aSessionId, aSessionIdLength),
-                     aMessageType, msg);
-}
-
-void
-GMPDecryptorChild::ExpirationChange(const char* aSessionId,
-                                    uint32_t aSessionIdLength,
-                                    GMPTimestamp aExpiryTime)
-{
-  CALL_ON_GMP_THREAD(SendExpirationChange,
-                     nsAutoCString(aSessionId, aSessionIdLength), aExpiryTime);
-}
-
-void
-GMPDecryptorChild::SessionClosed(const char* aSessionId,
-                                 uint32_t aSessionIdLength)
-{
-  CALL_ON_GMP_THREAD(SendSessionClosed,
-                     nsAutoCString(aSessionId, aSessionIdLength));
-}
-
-void
-GMPDecryptorChild::SessionError(const char* aSessionId,
-                                uint32_t aSessionIdLength,
-                                GMPDOMException aException,
-                                uint32_t aSystemCode,
-                                const char* aMessage,
-                                uint32_t aMessageLength)
-{
-  CALL_ON_GMP_THREAD(SendSessionError,
-                     nsAutoCString(aSessionId, aSessionIdLength),
-                     aException, aSystemCode,
-                     nsAutoCString(aMessage, aMessageLength));
-}
-
-void
-GMPDecryptorChild::KeyStatusChanged(const char* aSessionId,
-                                    uint32_t aSessionIdLength,
-                                    const uint8_t* aKeyId,
-                                    uint32_t aKeyIdLength,
-                                    GMPMediaKeyStatus aStatus)
-{
-  nsAutoTArray<uint8_t, 16> kid;
-  kid.AppendElements(aKeyId, aKeyIdLength);
-  CALL_ON_GMP_THREAD(SendKeyStatusChanged,
-                     nsAutoCString(aSessionId, aSessionIdLength), kid,
-                     aStatus);
-}
-
-void
-GMPDecryptorChild::Decrypted(GMPBuffer* aBuffer, GMPErr aResult)
-{
-  if (!ON_GMP_THREAD()) {
-    // We should run this whole method on the GMP thread since the buffer needs
-    // to be deleted after the SendDecrypted call.
-    CALL_ON_GMP_THREAD(Decrypted, aBuffer, aResult);
-    return;
-  }
-
-  if (!aBuffer) {
-    NS_WARNING("GMPDecryptorCallback passed bull GMPBuffer");
-    return;
-  }
-
-  auto buffer = static_cast<GMPBufferImpl*>(aBuffer);
-  SendDecrypted(buffer->mId, aResult, buffer->mData);
-  delete buffer;
-}
-
-void
-GMPDecryptorChild::SetCapabilities(uint64_t aCaps)
-{
-  CALL_ON_GMP_THREAD(SendSetCaps, aCaps);
-}
-
-void
-GMPDecryptorChild::GetSandboxVoucher(const uint8_t** aVoucher,
-                                     uint32_t* aVoucherLength)
-{
-  if (!aVoucher || !aVoucherLength) {
-    return;
-  }
-  *aVoucher = mSandboxVoucher.Elements();
-  *aVoucherLength = mSandboxVoucher.Length();
-}
-
-void
-GMPDecryptorChild::GetPluginVoucher(const uint8_t** aVoucher,
-                                    uint32_t* aVoucherLength)
-{
-  if (!aVoucher || !aVoucherLength) {
-    return;
-  }
-  *aVoucher = mPluginVoucher.Elements();
-  *aVoucherLength = mPluginVoucher.Length();
-}
-
-bool
-GMPDecryptorChild::RecvInit()
-{
-  if (!mSession) {
-    return false;
-  }
-  mSession->Init(this);
-  return true;
-}
-
-bool
-GMPDecryptorChild::RecvCreateSession(const uint32_t& aCreateSessionToken,
-                                     const uint32_t& aPromiseId,
-                                     const nsCString& aInitDataType,
-                                     InfallibleTArray<uint8_t>&& aInitData,
-                                     const GMPSessionType& aSessionType)
-{
-  if (!mSession) {
-    return false;
-  }
-
-  mSession->CreateSession(aCreateSessionToken,
-                          aPromiseId,
-                          aInitDataType.get(),
-                          aInitDataType.Length(),
-                          aInitData.Elements(),
-                          aInitData.Length(),
-                          aSessionType);
-
-  return true;
-}
-
-bool
-GMPDecryptorChild::RecvLoadSession(const uint32_t& aPromiseId,
-                                   const nsCString& aSessionId)
-{
-  if (!mSession) {
-    return false;
-  }
-
-  mSession->LoadSession(aPromiseId,
-                        aSessionId.get(),
-                        aSessionId.Length());
-
-  return true;
-}
-
-bool
-GMPDecryptorChild::RecvUpdateSession(const uint32_t& aPromiseId,
-                                     const nsCString& aSessionId,
-                                     InfallibleTArray<uint8_t>&& aResponse)
-{
-  if (!mSession) {
-    return false;
-  }
-
-  mSession->UpdateSession(aPromiseId,
-                          aSessionId.get(),
-                          aSessionId.Length(),
-                          aResponse.Elements(),
-                          aResponse.Length());
-
-  return true;
-}
-
-bool
-GMPDecryptorChild::RecvCloseSession(const uint32_t& aPromiseId,
-                                    const nsCString& aSessionId)
-{
-  if (!mSession) {
-    return false;
-  }
-
-  mSession->CloseSession(aPromiseId,
-                         aSessionId.get(),
-                         aSessionId.Length());
-
-  return true;
-}
-
-bool
-GMPDecryptorChild::RecvRemoveSession(const uint32_t& aPromiseId,
-                                     const nsCString& aSessionId)
-{
-  if (!mSession) {
-    return false;
-  }
-
-  mSession->RemoveSession(aPromiseId,
-                          aSessionId.get(),
-                          aSessionId.Length());
-
-  return true;
-}
-
-bool
-GMPDecryptorChild::RecvSetServerCertificate(const uint32_t& aPromiseId,
-                                            InfallibleTArray<uint8_t>&& aServerCert)
-{
-  if (!mSession) {
-    return false;
-  }
-
-  mSession->SetServerCertificate(aPromiseId,
-                                 aServerCert.Elements(),
-                                 aServerCert.Length());
-
-  return true;
-}
-
-bool
-GMPDecryptorChild::RecvDecrypt(const uint32_t& aId,
-                               InfallibleTArray<uint8_t>&& aBuffer,
-                               const GMPDecryptionData& aMetadata)
-{
-  if (!mSession) {
-    return false;
-  }
-
-  // Note: the GMPBufferImpl created here is deleted when the GMP passes
-  // it back in the Decrypted() callback above.
-  GMPBufferImpl* buffer = new GMPBufferImpl(aId, aBuffer);
-
-  // |metadata| lifetime is managed by |buffer|.
-  GMPEncryptedBufferDataImpl* metadata = new GMPEncryptedBufferDataImpl(aMetadata);
-  buffer->SetMetadata(metadata);
-
-  mSession->Decrypt(buffer, metadata);
-  return true;
-}
-
-bool
-GMPDecryptorChild::RecvDecryptingComplete()
-{
-  if (!mSession) {
-    return false;
-  }
-
-  mSession->DecryptingComplete();
-  mSession = nullptr;
-
-  unused << Send__delete__(this);
-
-  return true;
-}
-
-} // namespace gmp
-} // namespace mozilla
-
-// avoid redefined macro in unified build
-#undef ON_GMP_THREAD
-#undef CALL_ON_GMP_THREAD
diff --git a/dom/media/gmp/GMPDecryptorChild.h b/dom/media/gmp/GMPDecryptorChild.h
deleted file mode 100644
index b0f9848..0000000
--- a/dom/media/gmp/GMPDecryptorChild.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPDecryptorChild_h_
-#define GMPDecryptorChild_h_
-
-#include "mozilla/gmp/PGMPDecryptorChild.h"
-#include "gmp-decryption.h"
-#include "mozilla/gmp/GMPTypes.h"
-#include "GMPEncryptedBufferDataImpl.h"
-#include <string>
-
-namespace mozilla {
-namespace gmp {
-
-class GMPChild;
-
-class GMPDecryptorChild : public GMPDecryptorCallback
-                        , public GMPDecryptorHost
-                        , public PGMPDecryptorChild
-{
-public:
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(GMPDecryptorChild);
-
-  explicit GMPDecryptorChild(GMPChild* aPlugin,
-                             const nsTArray<uint8_t>& aPluginVoucher,
-                             const nsTArray<uint8_t>& aSandboxVoucher);
-
-  void Init(GMPDecryptor* aSession);
-
-  // GMPDecryptorCallback
-  virtual void SetSessionId(uint32_t aCreateSessionToken,
-                            const char* aSessionId,
-                            uint32_t aSessionIdLength) override;
-  virtual void ResolveLoadSessionPromise(uint32_t aPromiseId,
-                                         bool aSuccess) override;
-  virtual void ResolvePromise(uint32_t aPromiseId) override;
-
-  virtual void RejectPromise(uint32_t aPromiseId,
-                             GMPDOMException aException,
-                             const char* aMessage,
-                             uint32_t aMessageLength) override;
-
-  virtual void SessionMessage(const char* aSessionId,
-                              uint32_t aSessionIdLength,
-                              GMPSessionMessageType aMessageType,
-                              const uint8_t* aMessage,
-                              uint32_t aMessageLength) override;
-
-  virtual void ExpirationChange(const char* aSessionId,
-                                 uint32_t aSessionIdLength,
-                                 GMPTimestamp aExpiryTime) override;
-
-   virtual void SessionClosed(const char* aSessionId,
-                             uint32_t aSessionIdLength) override;
-
-  virtual void SessionError(const char* aSessionId,
-                            uint32_t aSessionIdLength,
-                            GMPDOMException aException,
-                            uint32_t aSystemCode,
-                            const char* aMessage,
-                            uint32_t aMessageLength) override;
-
-  virtual void KeyStatusChanged(const char* aSessionId,
-                                uint32_t aSessionIdLength,
-                                const uint8_t* aKeyId,
-                                uint32_t aKeyIdLength,
-                                GMPMediaKeyStatus aStatus) override;
-
-  virtual void SetCapabilities(uint64_t aCaps) override;
-
-  virtual void Decrypted(GMPBuffer* aBuffer, GMPErr aResult) override;
-
-  // GMPDecryptorHost
-  virtual void GetSandboxVoucher(const uint8_t** aVoucher,
-                                 uint32_t* aVoucherLength) override;
-
-  virtual void GetPluginVoucher(const uint8_t** aVoucher,
-                                uint32_t* aVoucherLength) override;
-private:
-  ~GMPDecryptorChild();
-
-  // GMPDecryptorChild
-  virtual bool RecvInit() override;
-
-  virtual bool RecvCreateSession(const uint32_t& aCreateSessionToken,
-                                 const uint32_t& aPromiseId,
-                                 const nsCString& aInitDataType,
-                                 InfallibleTArray<uint8_t>&& aInitData,
-                                 const GMPSessionType& aSessionType) override;
-
-  virtual bool RecvLoadSession(const uint32_t& aPromiseId,
-                               const nsCString& aSessionId) override;
-
-  virtual bool RecvUpdateSession(const uint32_t& aPromiseId,
-                                 const nsCString& aSessionId,
-                                 InfallibleTArray<uint8_t>&& aResponse) override;
-
-  virtual bool RecvCloseSession(const uint32_t& aPromiseId,
-                                const nsCString& aSessionId) override;
-
-  virtual bool RecvRemoveSession(const uint32_t& aPromiseId,
-                                 const nsCString& aSessionId) override;
-
-  virtual bool RecvDecrypt(const uint32_t& aId,
-                           InfallibleTArray<uint8_t>&& aBuffer,
-                           const GMPDecryptionData& aMetadata) override;
-
-  // Resolve/reject promise on completion.
-  virtual bool RecvSetServerCertificate(const uint32_t& aPromiseId,
-                                        InfallibleTArray<uint8_t>&& aServerCert) override;
-
-  virtual bool RecvDecryptingComplete() override;
-
-  // GMP's GMPDecryptor implementation.
-  // Only call into this on the (GMP process) main thread.
-  GMPDecryptor* mSession;
-  GMPChild* mPlugin;
-
-  // Reference to the vouchers owned by the GMPChild.
-  const nsTArray<uint8_t>& mPluginVoucher;
-  const nsTArray<uint8_t>& mSandboxVoucher;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPDecryptorChild_h_
diff --git a/dom/media/gmp/GMPDecryptorParent.cpp b/dom/media/gmp/GMPDecryptorParent.cpp
deleted file mode 100644
index 165c978..0000000
--- a/dom/media/gmp/GMPDecryptorParent.cpp
+++ /dev/null
@@ -1,373 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPDecryptorParent.h"
-#include "GMPParent.h"
-#include "MediaData.h"
-#include "mozilla/unused.h"
-
-namespace mozilla {
-namespace gmp {
-
-GMPDecryptorParent::GMPDecryptorParent(GMPParent* aPlugin)
-  : mIsOpen(false)
-  , mShuttingDown(false)
-  , mPlugin(aPlugin)
-  , mCallback(nullptr)
-#ifdef DEBUG
-  , mGMPThread(aPlugin->GMPThread())
-#endif
-{
-  MOZ_ASSERT(mPlugin && mGMPThread);
-  mPluginId = aPlugin->GetPluginId();
-}
-
-GMPDecryptorParent::~GMPDecryptorParent()
-{
-}
-
-const nsACString&
-GMPDecryptorParent::GetPluginId() const
-{
-  return mPluginId;
-}
-
-nsresult
-GMPDecryptorParent::Init(GMPDecryptorProxyCallback* aCallback)
-{
-  if (mIsOpen) {
-    NS_WARNING("Trying to re-use an in-use GMP decrypter!");
-    return NS_ERROR_FAILURE;
-  }
-  mCallback = aCallback;
-  if (!SendInit()) {
-    return NS_ERROR_FAILURE;
-  }
-  mIsOpen = true;
-  return NS_OK;
-}
-
-void
-GMPDecryptorParent::CreateSession(uint32_t aCreateSessionToken,
-                                  uint32_t aPromiseId,
-                                  const nsCString& aInitDataType,
-                                  const nsTArray<uint8_t>& aInitData,
-                                  GMPSessionType aSessionType)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return;
-  }
-  // Caller should ensure parameters passed in from JS are valid.
-  MOZ_ASSERT(!aInitDataType.IsEmpty() && !aInitData.IsEmpty());
-  unused << SendCreateSession(aCreateSessionToken, aPromiseId, aInitDataType, aInitData, aSessionType);
-}
-
-void
-GMPDecryptorParent::LoadSession(uint32_t aPromiseId,
-                                const nsCString& aSessionId)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return;
-  }
-  // Caller should ensure parameters passed in from JS are valid.
-  MOZ_ASSERT(!aSessionId.IsEmpty());
-  unused << SendLoadSession(aPromiseId, aSessionId);
-}
-
-void
-GMPDecryptorParent::UpdateSession(uint32_t aPromiseId,
-                                  const nsCString& aSessionId,
-                                  const nsTArray<uint8_t>& aResponse)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return;
-  }
-  // Caller should ensure parameters passed in from JS are valid.
-  MOZ_ASSERT(!aSessionId.IsEmpty() && !aResponse.IsEmpty());
-  unused << SendUpdateSession(aPromiseId, aSessionId, aResponse);
-}
-
-void
-GMPDecryptorParent::CloseSession(uint32_t aPromiseId,
-                                 const nsCString& aSessionId)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return;
-  }
-  // Caller should ensure parameters passed in from JS are valid.
-  MOZ_ASSERT(!aSessionId.IsEmpty());
-  unused << SendCloseSession(aPromiseId, aSessionId);
-}
-
-void
-GMPDecryptorParent::RemoveSession(uint32_t aPromiseId,
-                                  const nsCString& aSessionId)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return;
-  }
-  // Caller should ensure parameters passed in from JS are valid.
-  MOZ_ASSERT(!aSessionId.IsEmpty());
-  unused << SendRemoveSession(aPromiseId, aSessionId);
-}
-
-void
-GMPDecryptorParent::SetServerCertificate(uint32_t aPromiseId,
-                                         const nsTArray<uint8_t>& aServerCert)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return;
-  }
-  // Caller should ensure parameters passed in from JS are valid.
-  MOZ_ASSERT(!aServerCert.IsEmpty());
-  unused << SendSetServerCertificate(aPromiseId, aServerCert);
-}
-
-void
-GMPDecryptorParent::Decrypt(uint32_t aId,
-                            const CryptoSample& aCrypto,
-                            const nsTArray<uint8_t>& aBuffer)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return;
-  }
-
-  // Caller should ensure parameters passed in are valid.
-  MOZ_ASSERT(!aBuffer.IsEmpty() && aCrypto.valid);
-
-  GMPDecryptionData data(aCrypto.key,
-                         aCrypto.iv,
-                         aCrypto.plain_sizes,
-                         aCrypto.encrypted_sizes,
-                         aCrypto.session_ids);
-
-  unused << SendDecrypt(aId, aBuffer, data);
-}
-
-bool
-GMPDecryptorParent::RecvSetSessionId(const uint32_t& aCreateSessionId,
-                                     const nsCString& aSessionId)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return false;
-  }
-  mCallback->SetSessionId(aCreateSessionId, aSessionId);
-  return true;
-}
-
-bool
-GMPDecryptorParent::RecvResolveLoadSessionPromise(const uint32_t& aPromiseId,
-                                                  const bool& aSuccess)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return false;
-  }
-  mCallback->ResolveLoadSessionPromise(aPromiseId, aSuccess);
-  return true;
-}
-
-bool
-GMPDecryptorParent::RecvResolvePromise(const uint32_t& aPromiseId)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return false;
-  }
-  mCallback->ResolvePromise(aPromiseId);
-  return true;
-}
-
-nsresult
-GMPExToNsresult(GMPDOMException aDomException) {
-  switch (aDomException) {
-    case kGMPNoModificationAllowedError: return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
-    case kGMPNotFoundError: return NS_ERROR_DOM_NOT_FOUND_ERR;
-    case kGMPNotSupportedError: return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
-    case kGMPInvalidStateError: return NS_ERROR_DOM_INVALID_STATE_ERR;
-    case kGMPSyntaxError: return NS_ERROR_DOM_SYNTAX_ERR;
-    case kGMPInvalidModificationError: return NS_ERROR_DOM_INVALID_MODIFICATION_ERR;
-    case kGMPInvalidAccessError: return NS_ERROR_DOM_INVALID_ACCESS_ERR;
-    case kGMPSecurityError: return NS_ERROR_DOM_SECURITY_ERR;
-    case kGMPAbortError: return NS_ERROR_DOM_ABORT_ERR;
-    case kGMPQuotaExceededError: return NS_ERROR_DOM_QUOTA_EXCEEDED_ERR;
-    case kGMPTimeoutError: return NS_ERROR_DOM_TIMEOUT_ERR;
-    default: return NS_ERROR_DOM_UNKNOWN_ERR;
-  }
-}
-
-bool
-GMPDecryptorParent::RecvRejectPromise(const uint32_t& aPromiseId,
-                                      const GMPDOMException& aException,
-                                      const nsCString& aMessage)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return false;
-  }
-  mCallback->RejectPromise(aPromiseId, GMPExToNsresult(aException), aMessage);
-  return true;
-}
-
-bool
-GMPDecryptorParent::RecvSessionMessage(const nsCString& aSessionId,
-                                       const GMPSessionMessageType& aMessageType,
-                                       nsTArray<uint8_t>&& aMessage)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return false;
-  }
-  mCallback->SessionMessage(aSessionId, aMessageType, aMessage);
-  return true;
-}
-
-bool
-GMPDecryptorParent::RecvExpirationChange(const nsCString& aSessionId,
-                                         const double& aExpiryTime)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return false;
-  }
-  mCallback->ExpirationChange(aSessionId, aExpiryTime);
-  return true;
-}
-
-bool
-GMPDecryptorParent::RecvSessionClosed(const nsCString& aSessionId)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return false;
-  }
-  mCallback->SessionClosed(aSessionId);
-  return true;
-}
-
-bool
-GMPDecryptorParent::RecvSessionError(const nsCString& aSessionId,
-                                     const GMPDOMException& aException,
-                                     const uint32_t& aSystemCode,
-                                     const nsCString& aMessage)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return false;
-  }
-  mCallback->SessionError(aSessionId,
-                          GMPExToNsresult(aException),
-                          aSystemCode,
-                          aMessage);
-  return true;
-}
-
-bool
-GMPDecryptorParent::RecvKeyStatusChanged(const nsCString& aSessionId,
-                                         InfallibleTArray<uint8_t>&& aKeyId,
-                                         const GMPMediaKeyStatus& aStatus)
-{
-  if (mIsOpen) {
-    mCallback->KeyStatusChanged(aSessionId, aKeyId, aStatus);
-  }
-  return true;
-}
-
-bool
-GMPDecryptorParent::RecvSetCaps(const uint64_t& aCaps)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return false;
-  }
-  mCallback->SetCaps(aCaps);
-  return true;
-}
-
-bool
-GMPDecryptorParent::RecvDecrypted(const uint32_t& aId,
-                                  const GMPErr& aErr,
-                                  InfallibleTArray<uint8_t>&& aBuffer)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use a dead GMP decrypter!");
-    return false;
-  }
-  mCallback->Decrypted(aId, aErr, aBuffer);
-  return true;
-}
-
-// Note: may be called via Terminated()
-void
-GMPDecryptorParent::Close()
-{
-  MOZ_ASSERT(mGMPThread == NS_GetCurrentThread());
-  // Consumer is done with us; we can shut down.  No more callbacks should
-  // be made to mCallback. Note: do this before Shutdown()!
-  mCallback = nullptr;
-  // Let Shutdown mark us as dead so it knows if we had been alive
-
-  // In case this is the last reference
-  nsRefPtr<GMPDecryptorParent> kungfudeathgrip(this);
-  this->Release();
-  Shutdown();
-}
-
-void
-GMPDecryptorParent::Shutdown()
-{
-  MOZ_ASSERT(mGMPThread == NS_GetCurrentThread());
-
-  if (mShuttingDown) {
-    return;
-  }
-  mShuttingDown = true;
-
-  // Notify client we're gone!  Won't occur after Close()
-  if (mCallback) {
-    mCallback->Terminated();
-    mCallback = nullptr;
-  }
-
-  mIsOpen = false;
-  unused << SendDecryptingComplete();
-}
-
-// Note: Keep this sync'd up with Shutdown
-void
-GMPDecryptorParent::ActorDestroy(ActorDestroyReason aWhy)
-{
-  mIsOpen = false;
-  if (mCallback) {
-    // May call Close() (and Shutdown()) immediately or with a delay
-    mCallback->Terminated();
-    mCallback = nullptr;
-  }
-  if (mPlugin) {
-    mPlugin->DecryptorDestroyed(this);
-    mPlugin = nullptr;
-  }
-}
-
-bool
-GMPDecryptorParent::Recv__delete__()
-{
-  if (mPlugin) {
-    mPlugin->DecryptorDestroyed(this);
-    mPlugin = nullptr;
-  }
-  return true;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPDecryptorParent.h b/dom/media/gmp/GMPDecryptorParent.h
deleted file mode 100644
index 4d2a291..0000000
--- a/dom/media/gmp/GMPDecryptorParent.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPDecryptorParent_h_
-#define GMPDecryptorParent_h_
-
-#include "mozilla/gmp/PGMPDecryptorParent.h"
-#include "mozilla/RefPtr.h"
-#include "gmp-decryption.h"
-#include "GMPDecryptorProxy.h"
-
-namespace mozilla {
-
-class CryptoSample;
-
-namespace gmp {
-
-class GMPParent;
-
-class GMPDecryptorParent final : public GMPDecryptorProxy
-                                   , public PGMPDecryptorParent
-{
-public:
-  NS_INLINE_DECL_REFCOUNTING(GMPDecryptorParent)
-
-  explicit GMPDecryptorParent(GMPParent *aPlugin);
-
-  // GMPDecryptorProxy
-  virtual const nsACString& GetPluginId() const override;
-
-  virtual nsresult Init(GMPDecryptorProxyCallback* aCallback) override;
-
-  virtual void CreateSession(uint32_t aCreateSessionToken,
-                             uint32_t aPromiseId,
-                             const nsCString& aInitDataType,
-                             const nsTArray<uint8_t>& aInitData,
-                             GMPSessionType aSessionType) override;
-
-  virtual void LoadSession(uint32_t aPromiseId,
-                           const nsCString& aSessionId) override;
-
-  virtual void UpdateSession(uint32_t aPromiseId,
-                             const nsCString& aSessionId,
-                             const nsTArray<uint8_t>& aResponse) override;
-
-  virtual void CloseSession(uint32_t aPromiseId,
-                            const nsCString& aSessionId) override;
-
-  virtual void RemoveSession(uint32_t aPromiseId,
-                             const nsCString& aSessionId) override;
-
-  virtual void SetServerCertificate(uint32_t aPromiseId,
-                                    const nsTArray<uint8_t>& aServerCert) override;
-
-  virtual void Decrypt(uint32_t aId,
-                       const CryptoSample& aCrypto,
-                       const nsTArray<uint8_t>& aBuffer) override;
-
-  virtual void Close() override;
-
-  void Shutdown();
-
-private:
-  ~GMPDecryptorParent();
-
-  // PGMPDecryptorParent
-
-  virtual bool RecvSetSessionId(const uint32_t& aCreateSessionToken,
-                                const nsCString& aSessionId) override;
-
-  virtual bool RecvResolveLoadSessionPromise(const uint32_t& aPromiseId,
-                                             const bool& aSuccess) override;
-
-  virtual bool RecvResolvePromise(const uint32_t& aPromiseId) override;
-
-  virtual bool RecvRejectPromise(const uint32_t& aPromiseId,
-                                 const GMPDOMException& aException,
-                                 const nsCString& aMessage) override;
-
-  virtual bool RecvSessionMessage(const nsCString& aSessionId,
-                                  const GMPSessionMessageType& aMessageType,
-                                  nsTArray<uint8_t>&& aMessage) override;
-
-  virtual bool RecvExpirationChange(const nsCString& aSessionId,
-                                    const double& aExpiryTime) override;
-
-  virtual bool RecvSessionClosed(const nsCString& aSessionId) override;
-
-  virtual bool RecvSessionError(const nsCString& aSessionId,
-                                const GMPDOMException& aException,
-                                const uint32_t& aSystemCode,
-                                const nsCString& aMessage) override;
-
-  virtual bool RecvKeyStatusChanged(const nsCString& aSessionId,
-                                    InfallibleTArray<uint8_t>&& aKeyId,
-                                    const GMPMediaKeyStatus& aStatus) override;
-
-  virtual bool RecvDecrypted(const uint32_t& aId,
-                             const GMPErr& aErr,
-                             InfallibleTArray<uint8_t>&& aBuffer) override;
-
-  virtual bool RecvSetCaps(const uint64_t& aCaps) override;
-
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-  virtual bool Recv__delete__() override;
-
-  bool mIsOpen;
-  bool mShuttingDown;
-  nsRefPtr<GMPParent> mPlugin;
-  nsCString mPluginId;
-  GMPDecryptorProxyCallback* mCallback;
-#ifdef DEBUG
-  nsIThread* const mGMPThread;
-#endif
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPDecryptorChild_h_
diff --git a/dom/media/gmp/GMPDecryptorProxy.h b/dom/media/gmp/GMPDecryptorProxy.h
deleted file mode 100644
index bcc9fb2..0000000
--- a/dom/media/gmp/GMPDecryptorProxy.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPDecryptorProxy_h_
-#define GMPDecryptorProxy_h_
-
-#include "GMPCallbackBase.h"
-#include "gmp-decryption.h"
-#include "nsString.h"
-
-namespace mozilla {
-class CryptoSample;
-}
-
-class GMPDecryptorProxyCallback : public GMPCallbackBase {
-public:
-  ~GMPDecryptorProxyCallback() {}
-
-  virtual void SetSessionId(uint32_t aCreateSessionId,
-                            const nsCString& aSessionId) = 0;
-
-  virtual void ResolveLoadSessionPromise(uint32_t aPromiseId,
-                                         bool aSuccess) = 0;
-
-  virtual void ResolvePromise(uint32_t aPromiseId) = 0;
-
-  virtual void RejectPromise(uint32_t aPromiseId,
-                             nsresult aException,
-                             const nsCString& aSessionId) = 0;
-
-  virtual void SessionMessage(const nsCString& aSessionId,
-                              GMPSessionMessageType aMessageType,
-                              const nsTArray<uint8_t>& aMessage) = 0;
-
-  virtual void ExpirationChange(const nsCString& aSessionId,
-                                GMPTimestamp aExpiryTime) = 0;
-
-  virtual void SessionClosed(const nsCString& aSessionId) = 0;
-
-  virtual void SessionError(const nsCString& aSessionId,
-                            nsresult aException,
-                            uint32_t aSystemCode,
-                            const nsCString& aMessage) = 0;
-
-  virtual void KeyStatusChanged(const nsCString& aSessionId,
-                                const nsTArray<uint8_t>& aKeyId,
-                                GMPMediaKeyStatus aStatus) = 0;
-
-  virtual void SetCaps(uint64_t aCaps) = 0;
-
-  virtual void Decrypted(uint32_t aId,
-                         GMPErr aResult,
-                         const nsTArray<uint8_t>& aDecryptedData) = 0;
-};
-
-class GMPDecryptorProxy {
-public:
-  ~GMPDecryptorProxy() {}
-
-  virtual const nsACString& GetPluginId() const = 0;
-
-  virtual nsresult Init(GMPDecryptorProxyCallback* aCallback) = 0;
-
-  virtual void CreateSession(uint32_t aCreateSessionToken,
-                             uint32_t aPromiseId,
-                             const nsCString& aInitDataType,
-                             const nsTArray<uint8_t>& aInitData,
-                             GMPSessionType aSessionType) = 0;
-
-  virtual void LoadSession(uint32_t aPromiseId,
-                           const nsCString& aSessionId) = 0;
-
-  virtual void UpdateSession(uint32_t aPromiseId,
-                             const nsCString& aSessionId,
-                             const nsTArray<uint8_t>& aResponse) = 0;
-
-  virtual void CloseSession(uint32_t aPromiseId,
-                            const nsCString& aSessionId) = 0;
-
-  virtual void RemoveSession(uint32_t aPromiseId,
-                             const nsCString& aSessionId) = 0;
-
-  virtual void SetServerCertificate(uint32_t aPromiseId,
-                                    const nsTArray<uint8_t>& aServerCert) = 0;
-
-  virtual void Decrypt(uint32_t aId,
-                       const mozilla::CryptoSample& aCrypto,
-                       const nsTArray<uint8_t>& aBuffer) = 0;
-
-  virtual void Close() = 0;
-};
-
-#endif // GMPDecryptorProxy_h_
diff --git a/dom/media/gmp/GMPEncryptedBufferDataImpl.cpp b/dom/media/gmp/GMPEncryptedBufferDataImpl.cpp
deleted file mode 100644
index 4c0bbb1..0000000
--- a/dom/media/gmp/GMPEncryptedBufferDataImpl.cpp
+++ /dev/null
@@ -1,132 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPEncryptedBufferDataImpl.h"
-#include "mozilla/gmp/GMPTypes.h"
-#include "MediaData.h"
-
-namespace mozilla {
-namespace gmp {
-
-GMPEncryptedBufferDataImpl::GMPEncryptedBufferDataImpl(const CryptoSample& aCrypto)
-  : mKeyId(aCrypto.key)
-  , mIV(aCrypto.iv)
-  , mClearBytes(aCrypto.plain_sizes)
-  , mCipherBytes(aCrypto.encrypted_sizes)
-  , mSessionIdList(aCrypto.session_ids)
-{
-}
-
-GMPEncryptedBufferDataImpl::GMPEncryptedBufferDataImpl(const GMPDecryptionData& aData)
-  : mKeyId(aData.mKeyId())
-  , mIV(aData.mIV())
-  , mClearBytes(aData.mClearBytes())
-  , mCipherBytes(aData.mCipherBytes())
-  , mSessionIdList(aData.mSessionIds())
-{
-  MOZ_ASSERT(mClearBytes.Length() == mCipherBytes.Length());
-}
-
-GMPEncryptedBufferDataImpl::~GMPEncryptedBufferDataImpl()
-{
-}
-
-void
-GMPEncryptedBufferDataImpl::RelinquishData(GMPDecryptionData& aData)
-{
-  aData.mKeyId() = Move(mKeyId);
-  aData.mIV() = Move(mIV);
-  aData.mClearBytes() = Move(mClearBytes);
-  aData.mCipherBytes() = Move(mCipherBytes);
-  mSessionIdList.RelinquishData(aData.mSessionIds());
-}
-
-const uint8_t*
-GMPEncryptedBufferDataImpl::KeyId() const
-{
-  return mKeyId.Elements();
-}
-
-uint32_t
-GMPEncryptedBufferDataImpl::KeyIdSize() const
-{
-  return mKeyId.Length();
-}
-
-const uint8_t*
-GMPEncryptedBufferDataImpl::IV() const
-{
-  return mIV.Elements();
-}
-
-uint32_t
-GMPEncryptedBufferDataImpl::IVSize() const
-{
-  return mIV.Length();
-}
-
-const uint16_t*
-GMPEncryptedBufferDataImpl::ClearBytes() const
-{
-  return mClearBytes.Elements();
-}
-
-const uint32_t*
-GMPEncryptedBufferDataImpl::CipherBytes() const
-{
-  return mCipherBytes.Elements();
-}
-
-const GMPStringList*
-GMPEncryptedBufferDataImpl::SessionIds() const
-{
-  return &mSessionIdList;
-}
-
-uint32_t
-GMPEncryptedBufferDataImpl::NumSubsamples() const
-{
-  MOZ_ASSERT(mClearBytes.Length() == mCipherBytes.Length());
-  // Return the min of the two, to ensure there's not chance of array index
-  // out-of-bounds shenanigans.
-  return std::min<uint32_t>(mClearBytes.Length(), mCipherBytes.Length());
-}
-
-GMPStringListImpl::GMPStringListImpl(const nsTArray<nsCString>& aStrings)
-  : mStrings(aStrings)
-{
-}
-
-const uint32_t
-GMPStringListImpl::Size() const
-{
-  return mStrings.Length();
-}
-
-void
-GMPStringListImpl::StringAt(uint32_t aIndex,
-                            const char** aOutString,
-                            uint32_t *aOutLength) const
-{
-  if (NS_WARN_IF(aIndex >= Size())) {
-    return;
-  }
-
-  *aOutString = mStrings[aIndex].BeginReading();
-  *aOutLength = mStrings[aIndex].Length();
-}
-
-void
-GMPStringListImpl::RelinquishData(nsTArray<nsCString>& aStrings)
-{
-  aStrings = Move(mStrings);
-}
-
-GMPStringListImpl::~GMPStringListImpl()
-{
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPEncryptedBufferDataImpl.h b/dom/media/gmp/GMPEncryptedBufferDataImpl.h
deleted file mode 100644
index c79fcde..0000000
--- a/dom/media/gmp/GMPEncryptedBufferDataImpl.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPEncryptedBufferDataImpl_h_
-#define GMPEncryptedBufferDataImpl_h_
-
-#include "gmp-decryption.h"
-#include "nsTArray.h"
-#include "mozilla/gmp/GMPTypes.h"
-
-namespace mozilla {
-class CryptoSample;
-
-namespace gmp {
-
-class GMPStringListImpl : public GMPStringList
-{
-public:
-  explicit GMPStringListImpl(const nsTArray<nsCString>& aStrings);
-  virtual const uint32_t Size() const override;
-  virtual void StringAt(uint32_t aIndex,
-                        const char** aOutString, uint32_t *aOutLength) const override;
-  virtual ~GMPStringListImpl() override;
-  void RelinquishData(nsTArray<nsCString>& aStrings);
-
-private:
-  nsTArray<nsCString> mStrings;
-};
-
-class GMPEncryptedBufferDataImpl : public GMPEncryptedBufferMetadata {
-public:
-  explicit GMPEncryptedBufferDataImpl(const CryptoSample& aCrypto);
-  explicit GMPEncryptedBufferDataImpl(const GMPDecryptionData& aData);
-  virtual ~GMPEncryptedBufferDataImpl();
-
-  void RelinquishData(GMPDecryptionData& aData);
-
-  virtual const uint8_t* KeyId() const override;
-  virtual uint32_t KeyIdSize() const override;
-  virtual const uint8_t* IV() const override;
-  virtual uint32_t IVSize() const override;
-  virtual uint32_t NumSubsamples() const override;
-  virtual const uint16_t* ClearBytes() const override;
-  virtual const uint32_t* CipherBytes() const override;
-  virtual const GMPStringList* SessionIds() const override;
-
-private:
-  nsTArray<uint8_t> mKeyId;
-  nsTArray<uint8_t> mIV;
-  nsTArray<uint16_t> mClearBytes;
-  nsTArray<uint32_t> mCipherBytes;
-
-  GMPStringListImpl mSessionIdList;
-};
-
-class GMPBufferImpl : public GMPBuffer {
-public:
-  GMPBufferImpl(uint32_t aId, const nsTArray<uint8_t>& aData)
-    : mId(aId)
-    , mData(aData)
-  {
-  }
-  virtual uint32_t Id() const {
-    return mId;
-  }
-  virtual uint8_t* Data() {
-    return mData.Elements();
-  }
-  virtual uint32_t Size() const {
-    return mData.Length();
-  }
-  virtual void Resize(uint32_t aSize) {
-    mData.SetLength(aSize);
-  }
-
-  // Set metadata object to be freed when this buffer is destroyed.
-  void SetMetadata(GMPEncryptedBufferDataImpl* aMetadata) {
-    mMetadata = aMetadata;
-  }
-
-  uint32_t mId;
-  nsTArray<uint8_t> mData;
-  nsAutoPtr<GMPEncryptedBufferDataImpl> mMetadata;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPEncryptedBufferDataImpl_h_
diff --git a/dom/media/gmp/GMPLoader.cpp b/dom/media/gmp/GMPLoader.cpp
deleted file mode 100644
index 9209c3a..0000000
--- a/dom/media/gmp/GMPLoader.cpp
+++ /dev/null
@@ -1,283 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- * vim: sw=4 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPLoader.h"
-#include <stdio.h>
-#include "mozilla/Attributes.h"
-#include "gmp-entrypoints.h"
-#include "prlink.h"
-
-#include <string>
-
-#if defined(XP_WIN) && defined(MOZ_SANDBOX)
-#include "mozilla/sandboxTarget.h"
-#include "mozilla/Scoped.h"
-#include "windows.h"
-#include <intrin.h>
-#include <assert.h>
-#endif
-
-#if defined(HASH_NODE_ID_WITH_DEVICE_ID)
-// In order to provide EME plugins with a "device binding" capability,
-// in the parent we generate and store some random bytes as salt for every
-// (origin, urlBarOrigin) pair that uses EME. We store these bytes so
-// that every time we revisit the same origin we get the same salt.
-// We send this salt to the child on startup. The child collects some
-// device specific data and munges that with the salt to create the
-// "node id" that we expose to EME plugins. It then overwrites the device
-// specific data, and activates the sandbox.
-#include "rlz/lib/machine_id.h"
-#include "rlz/lib/string_utils.h"
-#include "sha256.h"
-#endif
-
-#if defined(XP_WIN) && defined(MOZ_SANDBOX)
-namespace {
-
-// Scoped type used by Load
-struct ScopedActCtxHandleTraits
-{
-  typedef HANDLE type;
-
-  static type empty()
-  {
-    return INVALID_HANDLE_VALUE;
-  }
-
-  static void release(type aActCtxHandle)
-  {
-    if (aActCtxHandle != INVALID_HANDLE_VALUE) {
-      ReleaseActCtx(aActCtxHandle);
-    }
-  }
-};
-typedef mozilla::Scoped<ScopedActCtxHandleTraits> ScopedActCtxHandle;
-
-} // anonymous namespace
-#endif
-
-namespace mozilla {
-namespace gmp {
-
-class GMPLoaderImpl : public GMPLoader {
-public:
-  explicit GMPLoaderImpl(SandboxStarter* aStarter)
-    : mSandboxStarter(aStarter)
-  {}
-  virtual ~GMPLoaderImpl() {}
-
-  virtual bool Load(const char* aLibPath,
-                    uint32_t aLibPathLen,
-                    char* aOriginSalt,
-                    uint32_t aOriginSaltLen,
-                    const GMPPlatformAPI* aPlatformAPI) override;
-
-  virtual GMPErr GetAPI(const char* aAPIName,
-                        void* aHostAPI,
-                        void** aPluginAPI) override;
-
-  virtual void Shutdown() override;
-
-#ifdef SANDBOX_NOT_STATICALLY_LINKED_INTO_PLUGIN_CONTAINER
-  virtual void SetStartSandboxStarter(SandboxStarter* aStarter) override {
-    mSandboxStarter = aStarter;
-  }
-#endif
-
-private:
-  PRLibrary* mLib;
-  GMPGetAPIFunc mGetAPIFunc;
-  SandboxStarter* mSandboxStarter;
-};
-
-GMPLoader* CreateGMPLoader(SandboxStarter* aStarter) {
-  return static_cast<GMPLoader*>(new GMPLoaderImpl(aStarter));
-}
-
-#if defined(XP_WIN) && defined(HASH_NODE_ID_WITH_DEVICE_ID)
-MOZ_NEVER_INLINE
-static bool
-GetStackAfterCurrentFrame(uint8_t** aOutTop, uint8_t** aOutBottom)
-{
-  // "Top" of the free space on the stack is directly after the memory
-  // holding our return address.
-  uint8_t* top = (uint8_t*)_AddressOfReturnAddress();
-
-  // Look down the stack until we find the guard page...
-  MEMORY_BASIC_INFORMATION memInfo = {0};
-  uint8_t* bottom = top;
-  while (1) {
-    if (!VirtualQuery(bottom, &memInfo, sizeof(memInfo))) {
-      return false;
-    }
-    if ((memInfo.Protect & PAGE_GUARD) == PAGE_GUARD) {
-      bottom = (uint8_t*)memInfo.BaseAddress + memInfo.RegionSize;
-#ifdef DEBUG
-      if (!VirtualQuery(bottom, &memInfo, sizeof(memInfo))) {
-        return false;
-      }
-      assert(!(memInfo.Protect & PAGE_GUARD)); // Should have found boundary.
-#endif
-      break;
-    } else if (memInfo.State != MEM_COMMIT ||
-               (memInfo.AllocationProtect & PAGE_READWRITE) != PAGE_READWRITE) {
-      return false;
-    }
-    bottom = (uint8_t*)memInfo.BaseAddress - 1;
-  }
-  *aOutTop = top;
-  *aOutBottom = bottom;
-  return true;
-}
-#endif
-
-bool
-GMPLoaderImpl::Load(const char* aLibPath,
-                    uint32_t aLibPathLen,
-                    char* aOriginSalt,
-                    uint32_t aOriginSaltLen,
-                    const GMPPlatformAPI* aPlatformAPI)
-{
-  std::string nodeId;
-#ifdef HASH_NODE_ID_WITH_DEVICE_ID
-  if (aOriginSaltLen > 0) {
-    string16 deviceId;
-    int volumeId;
-    if (!rlz_lib::GetRawMachineId(&deviceId, &volumeId)) {
-      return false;
-    }
-
-    SHA256Context ctx;
-    SHA256_Begin(&ctx);
-    SHA256_Update(&ctx, (const uint8_t*)aOriginSalt, aOriginSaltLen);
-    SHA256_Update(&ctx, (const uint8_t*)deviceId.c_str(), deviceId.size() * sizeof(string16::value_type));
-    SHA256_Update(&ctx, (const uint8_t*)&volumeId, sizeof(int));
-    uint8_t digest[SHA256_LENGTH] = {0};
-    unsigned int digestLen = 0;
-    SHA256_End(&ctx, digest, &digestLen, SHA256_LENGTH);
-
-    // Overwrite all data involved in calculation as it could potentially
-    // identify the user, so there's no chance a GMP can read it and use
-    // it for identity tracking.
-    memset(&ctx, 0, sizeof(ctx));
-    memset(aOriginSalt, 0, aOriginSaltLen);
-    volumeId = 0;
-    memset(&deviceId[0], '*', sizeof(string16::value_type) * deviceId.size());
-    deviceId = L"";
-
-    if (!rlz_lib::BytesToString(digest, SHA256_LENGTH, &nodeId)) {
-      return false;
-    }
-    // We've successfully bound the origin salt to node id.
-    // rlz_lib::GetRawMachineId and/or the system functions it
-    // called could have left user identifiable data on the stack,
-    // so carefully zero the stack down to the guard page.
-    uint8_t* top;
-    uint8_t* bottom;
-    if (!GetStackAfterCurrentFrame(&top, &bottom)) {
-      return false;
-    }
-    assert(top >= bottom);
-    // Inline instructions equivalent to RtlSecureZeroMemory().
-    // We can't just use RtlSecureZeroMemory here directly, as in debug
-    // builds, RtlSecureZeroMemory() can't be inlined, and the stack
-    // memory it uses would get wiped by itself running, causing crashes.
-    for (volatile uint8_t* p = (volatile uint8_t*)bottom; p < top; p++) {
-      *p = 0;
-    }
-  } else
-#endif
-  {
-    nodeId = std::string(aOriginSalt, aOriginSalt + aOriginSaltLen);
-  }
-
-#if defined(XP_WIN) && defined(MOZ_SANDBOX)
-  // If the GMP DLL is a side-by-side assembly with static imports then the DLL
-  // loader will attempt to create an activation context which will fail because
-  // of the sandbox. If we create an activation context before we start the
-  // sandbox then this one will get picked up by the DLL loader.
-  int pathLen = MultiByteToWideChar(CP_ACP, 0, aLibPath, -1, nullptr, 0);
-  if (pathLen == 0) {
-    return false;
-  }
-
-  wchar_t* widePath = new wchar_t[pathLen];
-  if (MultiByteToWideChar(CP_ACP, 0, aLibPath, -1, widePath, pathLen) == 0) {
-    delete[] widePath;
-    return false;
-  }
-
-  ACTCTX actCtx = { sizeof(actCtx) };
-  actCtx.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
-  actCtx.lpSource = widePath;
-  actCtx.lpResourceName = ISOLATIONAWARE_MANIFEST_RESOURCE_ID;
-  ScopedActCtxHandle actCtxHandle(CreateActCtx(&actCtx));
-  delete[] widePath;
-#endif
-
-  // Start the sandbox now that we've generated the device bound node id.
-  // This must happen after the node id is bound to the device id, as
-  // generating the device id requires privileges.
-  if (mSandboxStarter) {
-    mSandboxStarter->Start(aLibPath);
-  }
-
-  // Load the GMP.
-  PRLibSpec libSpec;
-  libSpec.value.pathname = aLibPath;
-  libSpec.type = PR_LibSpec_Pathname;
-  mLib = PR_LoadLibraryWithFlags(libSpec, 0);
-  if (!mLib) {
-    return false;
-  }
-
-  GMPInitFunc initFunc = reinterpret_cast<GMPInitFunc>(PR_FindFunctionSymbol(mLib, "GMPInit"));
-  if (!initFunc) {
-    return false;
-  }
-
-  if (initFunc(aPlatformAPI) != GMPNoErr) {
-    return false;
-  }
-
-  GMPSetNodeIdFunc setNodeIdFunc = reinterpret_cast<GMPSetNodeIdFunc>(PR_FindFunctionSymbol(mLib, "GMPSetNodeId"));
-  if (setNodeIdFunc) {
-    setNodeIdFunc(nodeId.c_str(), nodeId.size());
-  }
-
-  mGetAPIFunc = reinterpret_cast<GMPGetAPIFunc>(PR_FindFunctionSymbol(mLib, "GMPGetAPI"));
-  if (!mGetAPIFunc) {
-    return false;
-  }
-
-  return true;
-}
-
-GMPErr
-GMPLoaderImpl::GetAPI(const char* aAPIName,
-                      void* aHostAPI,
-                      void** aPluginAPI)
-{
-  return mGetAPIFunc ? mGetAPIFunc(aAPIName, aHostAPI, aPluginAPI)
-                     : GMPGenericErr;
-}
-
-void
-GMPLoaderImpl::Shutdown()
-{
-  if (mLib) {
-    GMPShutdownFunc shutdownFunc = reinterpret_cast<GMPShutdownFunc>(PR_FindFunctionSymbol(mLib, "GMPShutdown"));
-    if (shutdownFunc) {
-      shutdownFunc();
-    }
-    PR_UnloadLibrary(mLib);
-    mLib = nullptr;
-  }
-}
-
-} // namespace gmp
-} // namespace mozilla
-
diff --git a/dom/media/gmp/GMPLoader.h b/dom/media/gmp/GMPLoader.h
deleted file mode 100644
index fb51e75..0000000
--- a/dom/media/gmp/GMPLoader.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- * vim: sw=4 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMP_LOADER_H__
-#define GMP_LOADER_H__
-
-#include <stdint.h>
-#include "gmp-entrypoints.h"
-
-namespace mozilla {
-namespace gmp {
-
-class SandboxStarter {
-public:
-  virtual ~SandboxStarter() {}
-  virtual void Start(const char* aLibPath) = 0;
-};
-
-#if defined(XP_MACOSX)
-#define SANDBOX_NOT_STATICALLY_LINKED_INTO_PLUGIN_CONTAINER 1
-#endif
-
-// Encapsulates generating the device-bound node id, activating the sandbox,
-// loading the GMP, and passing the node id to the GMP (in that order).
-//
-// In Desktop Goanna, the implementation of this lives in plugin-container,
-// and is passed into XUL code from on startup. The GMP IPC child protocol actor
-// uses this interface to load and retrieve interfaces from the GMPs.
-//
-// In Desktop Goanna the implementation lives in the plugin-container so that
-// it can be covered by DRM vendor's voucher.
-//
-// On Android the GMPLoader implementation lives in libxul (because for the time
-// being GMPLoader relies upon NSPR, which we can't use in plugin-container
-// on Android).
-//
-// There is exactly one GMPLoader per GMP child process, and only one GMP
-// per child process (so the GMPLoader only loads one GMP).
-class GMPLoader {
-public:
-  virtual ~GMPLoader() {}
-
-  // Calculates the device-bound node id, then activates the sandbox,
-  // then loads the GMP library and (if applicable) passes the bound node id
-  // to the GMP.
-  virtual bool Load(const char* aLibPath,
-                    uint32_t aLibPathLen,
-                    char* aOriginSalt,
-                    uint32_t aOriginSaltLen,
-                    const GMPPlatformAPI* aPlatformAPI) = 0;
-
-  // Retrieves an interface pointer from the GMP.
-  virtual GMPErr GetAPI(const char* aAPIName, void* aHostAPI, void** aPluginAPI) = 0;
-
-  // Calls the GMPShutdown function exported by the GMP lib, and unloads the
-  // plugin library.
-  virtual void Shutdown() = 0;
-
-#ifdef SANDBOX_NOT_STATICALLY_LINKED_INTO_PLUGIN_CONTAINER
-  // Encapsulates starting the sandbox on Linux and MacOSX.
-  // TODO: Remove this, and put sandbox in plugin-container on all platforms.
-  virtual void SetStartSandboxStarter(SandboxStarter* aStarter) = 0;
-#endif
-};
-
-// On Desktop, this function resides in plugin-container.
-// On Mobile, this function resides in XUL.
-GMPLoader* CreateGMPLoader(SandboxStarter* aStarter);
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMP_LOADER_H__
diff --git a/dom/media/gmp/GMPMessageUtils.h b/dom/media/gmp/GMPMessageUtils.h
deleted file mode 100644
index 471f928..0000000
--- a/dom/media/gmp/GMPMessageUtils.h
+++ /dev/null
@@ -1,252 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPMessageUtils_h_
-#define GMPMessageUtils_h_
-
-#include "gmp-video-codec.h"
-#include "gmp-video-frame-encoded.h"
-#include "gmp-audio-codec.h"
-#include "gmp-decryption.h"
-
-namespace IPC {
-
-template <>
-struct ParamTraits<GMPErr>
-: public ContiguousEnumSerializer<GMPErr,
-                                  GMPNoErr,
-                                  GMPLastErr>
-{};
-
-struct GMPDomExceptionValidator {
-  static bool IsLegalValue(GMPDOMException aValue) {
-    switch (aValue) {
-      case kGMPNoModificationAllowedError:
-      case kGMPNotFoundError:
-      case kGMPNotSupportedError:
-      case kGMPInvalidStateError:
-      case kGMPSyntaxError:
-      case kGMPInvalidModificationError:
-      case kGMPInvalidAccessError:
-      case kGMPSecurityError:
-      case kGMPAbortError:
-      case kGMPQuotaExceededError:
-      case kGMPTimeoutError:
-        return true;
-      default:
-        return false;
-    }
-  }
-};
-
-template <>
-struct ParamTraits<GMPVideoFrameType>
-: public ContiguousEnumSerializer<GMPVideoFrameType,
-                                  kGMPKeyFrame,
-                                  kGMPVideoFrameInvalid>
-{};
-
-template<>
-struct ParamTraits<GMPDOMException>
-: public EnumSerializer<GMPDOMException, GMPDomExceptionValidator>
-{};
-
-template <>
-struct ParamTraits<GMPSessionMessageType>
-: public ContiguousEnumSerializer<GMPSessionMessageType,
-                                  kGMPLicenseRequest,
-                                  kGMPMessageInvalid>
-{};
-
-template <>
-struct ParamTraits<GMPMediaKeyStatus>
-: public ContiguousEnumSerializer<GMPMediaKeyStatus,
-                                  kGMPUsable,
-                                  kGMPMediaKeyStatusInvalid>
-{};
-
-template <>
-struct ParamTraits<GMPSessionType>
-: public ContiguousEnumSerializer<GMPSessionType,
-                                  kGMPTemporySession,
-                                  kGMPSessionInvalid>
-{};
-
-template <>
-struct ParamTraits<GMPAudioCodecType>
-: public ContiguousEnumSerializer<GMPAudioCodecType,
-                                  kGMPAudioCodecAAC,
-                                  kGMPAudioCodecInvalid>
-{};
-
-template <>
-struct ParamTraits<GMPVideoCodecComplexity>
-: public ContiguousEnumSerializer<GMPVideoCodecComplexity,
-                                  kGMPComplexityNormal,
-                                  kGMPComplexityInvalid>
-{};
-
-template <>
-struct ParamTraits<GMPVP8ResilienceMode>
-: public ContiguousEnumSerializer<GMPVP8ResilienceMode,
-                                  kResilienceOff,
-                                  kResilienceInvalid>
-{};
-
-template <>
-struct ParamTraits<GMPVideoCodecType>
-: public ContiguousEnumSerializer<GMPVideoCodecType,
-                                  kGMPVideoCodecVP8,
-                                  kGMPVideoCodecInvalid>
-{};
-
-template <>
-struct ParamTraits<GMPVideoCodecMode>
-: public ContiguousEnumSerializer<GMPVideoCodecMode,
-                                  kGMPRealtimeVideo,
-                                  kGMPCodecModeInvalid>
-{};
-
-template <>
-struct ParamTraits<GMPBufferType>
-: public ContiguousEnumSerializer<GMPBufferType,
-                                  GMP_BufferSingle,
-                                  GMP_BufferInvalid>
-{};
-
-template <>
-struct ParamTraits<GMPSimulcastStream>
-{
-  typedef GMPSimulcastStream paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam)
-  {
-    WriteParam(aMsg, aParam.mWidth);
-    WriteParam(aMsg, aParam.mHeight);
-    WriteParam(aMsg, aParam.mNumberOfTemporalLayers);
-    WriteParam(aMsg, aParam.mMaxBitrate);
-    WriteParam(aMsg, aParam.mTargetBitrate);
-    WriteParam(aMsg, aParam.mMinBitrate);
-    WriteParam(aMsg, aParam.mQPMax);
-  }
-
-  static bool Read(const Message* aMsg, void** aIter, paramType* aResult)
-  {
-    if (ReadParam(aMsg, aIter, &(aResult->mWidth)) &&
-        ReadParam(aMsg, aIter, &(aResult->mHeight)) &&
-        ReadParam(aMsg, aIter, &(aResult->mNumberOfTemporalLayers)) &&
-        ReadParam(aMsg, aIter, &(aResult->mMaxBitrate)) &&
-        ReadParam(aMsg, aIter, &(aResult->mTargetBitrate)) &&
-        ReadParam(aMsg, aIter, &(aResult->mMinBitrate)) &&
-        ReadParam(aMsg, aIter, &(aResult->mQPMax))) {
-      return true;
-    }
-    return false;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog)
-  {
-    aLog->append(StringPrintf(L"[%u, %u, %u, %u, %u, %u, %u]", aParam.mWidth, aParam.mHeight,
-                              aParam.mNumberOfTemporalLayers, aParam.mMaxBitrate,
-                              aParam.mTargetBitrate, aParam.mMinBitrate, aParam.mQPMax));
-  }
-};
-
-template <>
-struct ParamTraits<GMPVideoCodec>
-{
-  typedef GMPVideoCodec paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam)
-  {
-    WriteParam(aMsg, aParam.mGMPApiVersion);
-    WriteParam(aMsg, aParam.mCodecType);
-    WriteParam(aMsg, nsAutoCString(aParam.mPLName));
-    WriteParam(aMsg, aParam.mPLType);
-    WriteParam(aMsg, aParam.mWidth);
-    WriteParam(aMsg, aParam.mHeight);
-    WriteParam(aMsg, aParam.mStartBitrate);
-    WriteParam(aMsg, aParam.mMaxBitrate);
-    WriteParam(aMsg, aParam.mMinBitrate);
-    WriteParam(aMsg, aParam.mMaxFramerate);
-    WriteParam(aMsg, aParam.mFrameDroppingOn);
-    WriteParam(aMsg, aParam.mKeyFrameInterval);
-    WriteParam(aMsg, aParam.mQPMax);
-    WriteParam(aMsg, aParam.mNumberOfSimulcastStreams);
-    for (uint32_t i = 0; i < aParam.mNumberOfSimulcastStreams; i++) {
-      WriteParam(aMsg, aParam.mSimulcastStream[i]);
-    }
-    WriteParam(aMsg, aParam.mMode);
-  }
-
-  static bool Read(const Message* aMsg, void** aIter, paramType* aResult)
-  {
-    // NOTE: make sure this matches any versions supported
-    if (!ReadParam(aMsg, aIter, &(aResult->mGMPApiVersion)) ||
-      aResult->mGMPApiVersion != kGMPVersion33) {
-        return false;
-    }
-    if (!ReadParam(aMsg, aIter, &(aResult->mCodecType))) {
-      return false;
-    }
-
-    nsAutoCString plName;
-    if (!ReadParam(aMsg, aIter, &plName) ||
-        plName.Length() > kGMPPayloadNameSize - 1) {
-      return false;
-    }
-    memcpy(aResult->mPLName, plName.get(), plName.Length());
-    memset(aResult->mPLName + plName.Length(), 0, kGMPPayloadNameSize - plName.Length());
-
-    if (!ReadParam(aMsg, aIter, &(aResult->mPLType)) ||
-        !ReadParam(aMsg, aIter, &(aResult->mWidth)) ||
-        !ReadParam(aMsg, aIter, &(aResult->mHeight)) ||
-        !ReadParam(aMsg, aIter, &(aResult->mStartBitrate)) ||
-        !ReadParam(aMsg, aIter, &(aResult->mMaxBitrate)) ||
-        !ReadParam(aMsg, aIter, &(aResult->mMinBitrate)) ||
-        !ReadParam(aMsg, aIter, &(aResult->mMaxFramerate)) ||
-        !ReadParam(aMsg, aIter, &(aResult->mFrameDroppingOn)) ||
-        !ReadParam(aMsg, aIter, &(aResult->mKeyFrameInterval))) {
-      return false;
-    }
-
-    if (!ReadParam(aMsg, aIter, &(aResult->mQPMax)) ||
-        !ReadParam(aMsg, aIter, &(aResult->mNumberOfSimulcastStreams))) {
-      return false;
-    }
-
-    if (aResult->mNumberOfSimulcastStreams > kGMPMaxSimulcastStreams) {
-      return false;
-    }
-
-    for (uint32_t i = 0; i < aResult->mNumberOfSimulcastStreams; i++) {
-      if (!ReadParam(aMsg, aIter, &(aResult->mSimulcastStream[i]))) {
-        return false;
-      }
-    }
-
-    if (!ReadParam(aMsg, aIter, &(aResult->mMode))) {
-      return false;
-    }
-
-    return true;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog)
-  {
-    const char* codecName = nullptr;
-    if (aParam.mCodecType == kGMPVideoCodecVP8) {
-      codecName = "VP8";
-    }
-    aLog->append(StringPrintf(L"[%s, %u, %u]",
-                              codecName,
-                              aParam.mWidth,
-                              aParam.mHeight));
-  }
-};
-
-} // namespace IPC
-
-#endif // GMPMessageUtils_h_
diff --git a/dom/media/gmp/GMPParent.cpp b/dom/media/gmp/GMPParent.cpp
deleted file mode 100644
index a64500e..0000000
--- a/dom/media/gmp/GMPParent.cpp
+++ /dev/null
@@ -1,995 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPParent.h"
-#include "prlog.h"
-#include "nsComponentManagerUtils.h"
-#include "nsComponentManagerUtils.h"
-#include "nsIInputStream.h"
-#include "nsILineInputStream.h"
-#include "nsNetUtil.h"
-#include "nsCharSeparatedTokenizer.h"
-#include "nsThreadUtils.h"
-#include "nsIRunnable.h"
-#include "mozIGoannaMediaPluginService.h"
-#include "mozilla/unused.h"
-#include "nsIObserverService.h"
-#include "GMPTimerParent.h"
-#include "runnable_utils.h"
-#if defined(XP_LINUX) && defined(MOZ_GMP_SANDBOX)
-#include "mozilla/SandboxInfo.h"
-#endif
-
-#include "mozilla/Telemetry.h"
-
-namespace mozilla {
-
-#ifdef LOG
-#undef LOG
-#endif
-
-#ifdef PR_LOGGING
-extern PRLogModuleInfo* GetGMPLog();
-
-#define LOGD(msg) PR_LOG(GetGMPLog(), PR_LOG_DEBUG, msg)
-#define LOG(level, msg) PR_LOG(GetGMPLog(), (level), msg)
-#else
-#define LOGD(msg)
-#define LOG(level, msg)
-#endif
-
-#ifdef __CLASS__
-#undef __CLASS__
-#endif
-#define __CLASS__ "GMPParent"
-
-namespace gmp {
-
-GMPParent::GMPParent()
-  : mState(GMPStateNotLoaded)
-  , mProcess(nullptr)
-  , mDeleteProcessOnlyOnUnload(false)
-  , mAbnormalShutdownInProgress(false)
-  , mIsBlockingDeletion(false)
-  , mCanDecrypt(false)
-  , mAsyncShutdownRequired(false)
-  , mAsyncShutdownInProgress(false)
-{
-  // Use the parent address to identify it.
-  // We could use any unique-to-the-parent value.
-  mPluginId.AppendInt(reinterpret_cast<uint64_t>(this));
-}
-
-GMPParent::~GMPParent()
-{
-  // Can't Close or Destroy the process here, since destruction is MainThread only
-  MOZ_ASSERT(NS_IsMainThread());
-}
-
-void
-GMPParent::CheckThread()
-{
-  MOZ_ASSERT(mGMPThread == NS_GetCurrentThread());
-}
-
-nsresult
-GMPParent::CloneFrom(const GMPParent* aOther)
-{
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-  MOZ_ASSERT(aOther->mDirectory && aOther->mService, "null plugin directory");
-  return Init(aOther->mService, aOther->mDirectory);
-}
-
-nsresult
-GMPParent::Init(GoannaMediaPluginService *aService, nsIFile* aPluginDir)
-{
-  MOZ_ASSERT(aPluginDir);
-  MOZ_ASSERT(aService);
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-
-  mService = aService;
-  mDirectory = aPluginDir;
-
-  // aPluginDir is <profile-dir>/<gmp-plugin-id>/<version>
-  // where <gmp-plugin-id> should be gmp-gmpopenh264
-  nsCOMPtr<nsIFile> parent;
-  nsresult rv = aPluginDir->GetParent(getter_AddRefs(parent));
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-  nsAutoString parentLeafName;
-  rv = parent->GetLeafName(parentLeafName);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-  LOGD(("%s::%s: %p for %s", __CLASS__, __FUNCTION__, this,
-       NS_LossyConvertUTF16toASCII(parentLeafName).get()));
-
-  MOZ_ASSERT(parentLeafName.Length() > 4);
-  mName = Substring(parentLeafName, 4);
-
-  return ReadGMPMetaData();
-}
-
-void
-GMPParent::Crash()
-{
-  if (mState != GMPStateNotLoaded) {
-    unused << SendCrashPluginNow();
-  }
-}
-
-nsresult
-GMPParent::LoadProcess()
-{
-  MOZ_ASSERT(mDirectory, "Plugin directory cannot be NULL!");
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-  MOZ_ASSERT(mState == GMPStateNotLoaded);
-
-  nsAutoString path;
-  if (NS_FAILED(mDirectory->GetPath(path))) {
-    return NS_ERROR_FAILURE;
-  }
-  LOGD(("%s::%s: %p for %s", __CLASS__, __FUNCTION__, this, path.get()));
-
-  if (!mProcess) {
-    mProcess = new GMPProcessParent(NS_ConvertUTF16toUTF8(path).get());
-    if (!mProcess->Launch(30 * 1000)) {
-      mProcess->Delete();
-      mProcess = nullptr;
-      return NS_ERROR_FAILURE;
-    }
-
-    bool opened = Open(mProcess->GetChannel(), mProcess->GetChildProcessHandle());
-    if (!opened) {
-      LOGD(("%s::%s: Failed to create new child process %p", __CLASS__, __FUNCTION__, (void *)mProcess));
-      mProcess->Delete();
-      mProcess = nullptr;
-      return NS_ERROR_FAILURE;
-    }
-    LOGD(("%s::%s: Created new child process %p", __CLASS__, __FUNCTION__, (void *)mProcess));
-
-    bool ok = SendSetNodeId(mNodeId);
-    if (!ok) {
-      LOGD(("%s::%s: Failed to send node id to child process %p", __CLASS__, __FUNCTION__, (void *)mProcess));
-      mProcess->Delete();
-      mProcess = nullptr;
-      return NS_ERROR_FAILURE;
-    }
-    LOGD(("%s::%s: Sent node id to child process %p", __CLASS__, __FUNCTION__, (void *)mProcess));
-
-    ok = SendStartPlugin();
-    if (!ok) {
-      LOGD(("%s::%s: Failed to send start to child process %p", __CLASS__, __FUNCTION__, (void *)mProcess));
-      mProcess->Delete();
-      mProcess = nullptr;
-      return NS_ERROR_FAILURE;
-    }
-    LOGD(("%s::%s: Sent StartPlugin to child process %p", __CLASS__, __FUNCTION__, (void *)mProcess));
-  }
-
-  mState = GMPStateLoaded;
-
-  return NS_OK;
-}
-
-void
-AbortWaitingForGMPAsyncShutdown(nsITimer* aTimer, void* aClosure)
-{
-  NS_WARNING("Timed out waiting for GMP async shutdown!");
-  GMPParent* parent = reinterpret_cast<GMPParent*>(aClosure);
-  nsRefPtr<GoannaMediaPluginService> service =
-    GoannaMediaPluginService::GetGoannaMediaPluginService();
-  if (service) {
-    service->AsyncShutdownComplete(parent);
-  }
-}
-
-nsresult
-GMPParent::EnsureAsyncShutdownTimeoutSet()
-{
-  if (mAsyncShutdownTimeout) {
-    return NS_OK;
-  }
-
-  nsresult rv;
-  mAsyncShutdownTimeout = do_CreateInstance(NS_TIMER_CONTRACTID, &rv);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  // Set timer to abort waiting for plugin to shutdown if it takes
-  // too long.
-  rv = mAsyncShutdownTimeout->SetTarget(mGMPThread);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-   return rv;
-  }
-
-  int32_t timeout = GMP_DEFAULT_ASYNC_SHUTDONW_TIMEOUT;
-  nsRefPtr<GoannaMediaPluginService> service =
-    GoannaMediaPluginService::GetGoannaMediaPluginService();
-  if (service) {
-    timeout = service->AsyncShutdownTimeoutMs();
-  }
-  return mAsyncShutdownTimeout->InitWithFuncCallback(
-    &AbortWaitingForGMPAsyncShutdown, this, timeout,
-    nsITimer::TYPE_ONE_SHOT);
-}
-
-void
-GMPParent::CloseIfUnused()
-{
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-  LOGD(("%s::%s: %p mAsyncShutdownRequired=%d", __CLASS__, __FUNCTION__, this,
-        mAsyncShutdownRequired));
-
-  if ((mDeleteProcessOnlyOnUnload ||
-       mState == GMPStateLoaded ||
-       mState == GMPStateUnloading) &&
-      mVideoDecoders.IsEmpty() &&
-      mVideoEncoders.IsEmpty() &&
-      mDecryptors.IsEmpty() &&
-      mAudioDecoders.IsEmpty()) {
-
-    // Ensure all timers are killed.
-    for (uint32_t i = mTimers.Length(); i > 0; i--) {
-      mTimers[i - 1]->Shutdown();
-    }
-
-    if (mAsyncShutdownRequired) {
-      if (!mAsyncShutdownInProgress) {
-        LOGD(("%s::%s: %p sending async shutdown notification", __CLASS__,
-              __FUNCTION__, this));
-        mAsyncShutdownInProgress = true;
-        if (!SendBeginAsyncShutdown() ||
-            NS_FAILED(EnsureAsyncShutdownTimeoutSet())) {
-          AbortAsyncShutdown();
-        }
-      }
-    } else {
-      // Any async shutdown must be complete. Shutdown GMPStorage.
-      for (size_t i = mStorage.Length(); i > 0; i--) {
-        mStorage[i - 1]->Shutdown();
-      }
-      Shutdown();
-    }
-  }
-}
-
-void
-GMPParent::AbortAsyncShutdown()
-{
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-  LOGD(("%s::%s: %p", __CLASS__, __FUNCTION__, this));
-
-  if (mAsyncShutdownTimeout) {
-    mAsyncShutdownTimeout->Cancel();
-    mAsyncShutdownTimeout = nullptr;
-  }
-
-  if (!mAsyncShutdownRequired || !mAsyncShutdownInProgress) {
-    return;
-  }
-
-  nsRefPtr<GMPParent> kungFuDeathGrip(this);
-  mService->AsyncShutdownComplete(this);
-  mAsyncShutdownRequired = false;
-  mAsyncShutdownInProgress = false;
-  CloseIfUnused();
-}
-
-void
-GMPParent::AudioDecoderDestroyed(GMPAudioDecoderParent* aDecoder)
-{
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-
-  MOZ_ALWAYS_TRUE(mAudioDecoders.RemoveElement(aDecoder));
-
-  // Recv__delete__ is on the stack, don't potentially destroy the top-level actor
-  // until after this has completed.
-  nsCOMPtr<nsIRunnable> event = NS_NewRunnableMethod(this, &GMPParent::CloseIfUnused);
-  NS_DispatchToCurrentThread(event);
-}
-
-void
-GMPParent::CloseActive(bool aDieWhenUnloaded)
-{
-  LOGD(("%s::%s: %p state %d", __CLASS__, __FUNCTION__, this, mState));
-  if (aDieWhenUnloaded) {
-    mDeleteProcessOnlyOnUnload = true; // don't allow this to go back...
-  }
-  if (mState == GMPStateLoaded) {
-    mState = GMPStateUnloading;
-  }
-
-  // Invalidate and remove any remaining API objects.
-  for (uint32_t i = mVideoDecoders.Length(); i > 0; i--) {
-    mVideoDecoders[i - 1]->Shutdown();
-  }
-
-  for (uint32_t i = mVideoEncoders.Length(); i > 0; i--) {
-    mVideoEncoders[i - 1]->Shutdown();
-  }
-
-  for (uint32_t i = mDecryptors.Length(); i > 0; i--) {
-    mDecryptors[i - 1]->Shutdown();
-  }
-
-  for (uint32_t i = mAudioDecoders.Length(); i > 0; i--) {
-    mAudioDecoders[i - 1]->Shutdown();
-  }
-
-  // Note: we don't shutdown timers here, we do that in CloseIfUnused(),
-  // as there are multiple entry points to CloseIfUnused().
-
-  // Note: We don't shutdown storage API objects here, as they need to
-  // work during async shutdown of GMPs.
-
-  // Note: the shutdown of the codecs is async!  don't kill
-  // the plugin-container until they're all safely shut down via
-  // CloseIfUnused();
-  CloseIfUnused();
-}
-
-void
-GMPParent::MarkForDeletion()
-{
-  mDeleteProcessOnlyOnUnload = true;
-  mIsBlockingDeletion = true;
-}
-
-bool
-GMPParent::IsMarkedForDeletion()
-{
-  return mIsBlockingDeletion;
-}
-
-void
-GMPParent::Shutdown()
-{
-  LOGD(("%s::%s: %p", __CLASS__, __FUNCTION__, this));
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-
-  MOZ_ASSERT(!mAsyncShutdownTimeout, "Should have canceled shutdown timeout");
-
-  if (mAbnormalShutdownInProgress) {
-    return;
-  }
-  MOZ_ASSERT(mVideoDecoders.IsEmpty() && mVideoEncoders.IsEmpty());
-  if (mState == GMPStateNotLoaded || mState == GMPStateClosing) {
-    return;
-  }
-
-  DeleteProcess();
-  // XXX Get rid of mDeleteProcessOnlyOnUnload and this code when
-  // Bug 1043671 is fixed
-  if (!mDeleteProcessOnlyOnUnload) {
-    // Destroy ourselves and rise from the fire to save memory
-    nsRefPtr<GMPParent> self(this);
-    mService->ReAddOnGMPThread(self);
-  } // else we've been asked to die and stay dead
-  MOZ_ASSERT(mState == GMPStateNotLoaded);
-}
-
-class NotifyGMPShutdownTask : public nsRunnable {
-public:
-  explicit NotifyGMPShutdownTask(const nsAString& aNodeId)
-    : mNodeId(aNodeId)
-  {
-  }
-  NS_IMETHOD Run() {
-    MOZ_ASSERT(NS_IsMainThread());
-    nsCOMPtr<nsIObserverService> obsService = mozilla::services::GetObserverService();
-    MOZ_ASSERT(obsService);
-    if (obsService) {
-      obsService->NotifyObservers(nullptr, "gmp-shutdown", mNodeId.get());
-    }
-    return NS_OK;
-  }
-  nsString mNodeId;
-};
-
-void
-GMPParent::ChildTerminated()
-{
-  nsRefPtr<GMPParent> self(this);
-  GMPThread()->Dispatch(NS_NewRunnableMethodWithArg<nsRefPtr<GMPParent>>(
-                          mService,
-                          &GoannaMediaPluginService::PluginTerminated,
-                          self),
-                        NS_DISPATCH_NORMAL);
-}
-
-void
-GMPParent::DeleteProcess()
-{
-  LOGD(("%s::%s: %p", __CLASS__, __FUNCTION__, this));
-
-  if (mState != GMPStateClosing) {
-    // Don't Close() twice!
-    // Probably remove when bug 1043671 is resolved
-    mState = GMPStateClosing;
-    Close();
-  }
-  mProcess->Delete(NS_NewRunnableMethod(this, &GMPParent::ChildTerminated));
-  LOGD(("%s::%s: Shut down process %p", __CLASS__, __FUNCTION__, (void *) mProcess));
-  mProcess = nullptr;
-  mState = GMPStateNotLoaded;
-
-  NS_DispatchToMainThread(
-    new NotifyGMPShutdownTask(NS_ConvertUTF8toUTF16(mNodeId)),
-    NS_DISPATCH_NORMAL);
-
-}
-
-void
-GMPParent::VideoDecoderDestroyed(GMPVideoDecoderParent* aDecoder)
-{
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-
-  // If the constructor fails, we'll get called before it's added
-  unused << NS_WARN_IF(!mVideoDecoders.RemoveElement(aDecoder));
-
-  if (mVideoDecoders.IsEmpty() &&
-      mVideoEncoders.IsEmpty()) {
-    // Recv__delete__ is on the stack, don't potentially destroy the top-level actor
-    // until after this has completed.
-    nsCOMPtr<nsIRunnable> event = NS_NewRunnableMethod(this, &GMPParent::CloseIfUnused);
-    NS_DispatchToCurrentThread(event);
-  }
-}
-
-void
-GMPParent::VideoEncoderDestroyed(GMPVideoEncoderParent* aEncoder)
-{
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-
-  // If the constructor fails, we'll get called before it's added
-  unused << NS_WARN_IF(!mVideoEncoders.RemoveElement(aEncoder));
-
-  if (mVideoDecoders.IsEmpty() &&
-      mVideoEncoders.IsEmpty()) {
-    // Recv__delete__ is on the stack, don't potentially destroy the top-level actor
-    // until after this has completed.
-    nsCOMPtr<nsIRunnable> event = NS_NewRunnableMethod(this, &GMPParent::CloseIfUnused);
-    NS_DispatchToCurrentThread(event);
-  }
-}
-
-void
-GMPParent::DecryptorDestroyed(GMPDecryptorParent* aSession)
-{
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-
-  MOZ_ALWAYS_TRUE(mDecryptors.RemoveElement(aSession));
-
-  // Recv__delete__ is on the stack, don't potentially destroy the top-level actor
-  // until after this has completed.
-  if (mDecryptors.IsEmpty()) {
-    nsCOMPtr<nsIRunnable> event = NS_NewRunnableMethod(this, &GMPParent::CloseIfUnused);
-    NS_DispatchToCurrentThread(event);
-  }
-}
-
-nsresult
-GMPParent::GetGMPDecryptor(GMPDecryptorParent** aGMPDP)
-{
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-
-  if (!EnsureProcessLoaded()) {
-    return NS_ERROR_FAILURE;
-  }
-
-  PGMPDecryptorParent* pdp = SendPGMPDecryptorConstructor();
-  if (!pdp) {
-    return NS_ERROR_FAILURE;
-  }
-  GMPDecryptorParent* dp = static_cast<GMPDecryptorParent*>(pdp);
-  // This addref corresponds to the Proxy pointer the consumer is returned.
-  // It's dropped by calling Close() on the interface.
-  NS_ADDREF(dp);
-  mDecryptors.AppendElement(dp);
-  *aGMPDP = dp;
-
-  return NS_OK;
-}
-
-GMPState
-GMPParent::State() const
-{
-  return mState;
-}
-
-// Not changing to use mService since we'll be removing it
-nsIThread*
-GMPParent::GMPThread()
-{
-  if (!mGMPThread) {
-    nsCOMPtr<mozIGoannaMediaPluginService> mps = do_GetService("@mozilla.org/goanna-media-plugin-service;1");
-    MOZ_ASSERT(mps);
-    if (!mps) {
-      return nullptr;
-    }
-    // Not really safe if we just grab to the mGMPThread, as we don't know
-    // what thread we're running on and other threads may be trying to
-    // access this without locks!  However, debug only, and primary failure
-    // mode outside of compiler-helped TSAN is a leak.  But better would be
-    // to use swap() under a lock.
-    mps->GetThread(getter_AddRefs(mGMPThread));
-    MOZ_ASSERT(mGMPThread);
-  }
-
-  return mGMPThread;
-}
-
-bool
-GMPParent::SupportsAPI(const nsCString& aAPI, const nsCString& aTag)
-{
-  for (uint32_t i = 0; i < mCapabilities.Length(); i++) {
-    if (!mCapabilities[i]->mAPIName.Equals(aAPI)) {
-      continue;
-    }
-    nsTArray<nsCString>& tags = mCapabilities[i]->mAPITags;
-    for (uint32_t j = 0; j < tags.Length(); j++) {
-      if (tags[j].Equals(aTag)) {
-        return true;
-      }
-    }
-  }
-  return false;
-}
-
-bool
-GMPParent::EnsureProcessLoaded()
-{
-  if (mState == GMPStateLoaded) {
-    return true;
-  }
-  if (mState == GMPStateClosing ||
-      mState == GMPStateUnloading) {
-    return false;
-  }
-
-  nsresult rv = LoadProcess();
-
-  return NS_SUCCEEDED(rv);
-}
-
-nsresult
-GMPParent::GetGMPAudioDecoder(GMPAudioDecoderParent** aGMPAD)
-{
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-
-  if (!EnsureProcessLoaded()) {
-    return NS_ERROR_FAILURE;
-  }
-
-  PGMPAudioDecoderParent* pvap = SendPGMPAudioDecoderConstructor();
-  if (!pvap) {
-    return NS_ERROR_FAILURE;
-  }
-  GMPAudioDecoderParent* vap = static_cast<GMPAudioDecoderParent*>(pvap);
-  // This addref corresponds to the Proxy pointer the consumer is returned.
-  // It's dropped by calling Close() on the interface.
-  NS_ADDREF(vap);
-  *aGMPAD = vap;
-  mAudioDecoders.AppendElement(vap);
-
-  return NS_OK;
-}
-
-nsresult
-GMPParent::GetGMPVideoDecoder(GMPVideoDecoderParent** aGMPVD)
-{
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-
-  if (!EnsureProcessLoaded()) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // returned with one anonymous AddRef that locks it until Destroy
-  PGMPVideoDecoderParent* pvdp = SendPGMPVideoDecoderConstructor();
-  if (!pvdp) {
-    return NS_ERROR_FAILURE;
-  }
-  GMPVideoDecoderParent *vdp = static_cast<GMPVideoDecoderParent*>(pvdp);
-  // This addref corresponds to the Proxy pointer the consumer is returned.
-  // It's dropped by calling Close() on the interface.
-  NS_ADDREF(vdp);
-  *aGMPVD = vdp;
-  mVideoDecoders.AppendElement(vdp);
-
-  return NS_OK;
-}
-
-nsresult
-GMPParent::GetGMPVideoEncoder(GMPVideoEncoderParent** aGMPVE)
-{
-  MOZ_ASSERT(GMPThread() == NS_GetCurrentThread());
-
-  if (!EnsureProcessLoaded()) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // returned with one anonymous AddRef that locks it until Destroy
-  PGMPVideoEncoderParent* pvep = SendPGMPVideoEncoderConstructor();
-  if (!pvep) {
-    return NS_ERROR_FAILURE;
-  }
-  GMPVideoEncoderParent *vep = static_cast<GMPVideoEncoderParent*>(pvep);
-  // This addref corresponds to the Proxy pointer the consumer is returned.
-  // It's dropped by calling Close() on the interface.
-  NS_ADDREF(vep);
-  *aGMPVE = vep;
-  mVideoEncoders.AppendElement(vep);
-
-  return NS_OK;
-}
-
-void
-GMPParent::ActorDestroy(ActorDestroyReason aWhy)
-{
-  LOGD(("%s::%s: %p (%d)", __CLASS__, __FUNCTION__, this, (int) aWhy));
-  // warn us off trying to close again
-  mState = GMPStateClosing;
-  mAbnormalShutdownInProgress = true;
-  CloseActive(false);
-
-  // Normal Shutdown() will delete the process on unwind.
-  if (AbnormalShutdown == aWhy) {
-    nsRefPtr<GMPParent> self(this);
-    if (mAsyncShutdownRequired) {
-      mService->AsyncShutdownComplete(this);
-      mAsyncShutdownRequired = false;
-    }
-    // Must not call Close() again in DeleteProcess(), as we'll recurse
-    // infinitely if we do.
-    MOZ_ASSERT(mState == GMPStateClosing);
-    DeleteProcess();
-    // Note: final destruction will be Dispatched to ourself
-    mService->ReAddOnGMPThread(self);
-  }
-}
-
-PGMPVideoDecoderParent*
-GMPParent::AllocPGMPVideoDecoderParent()
-{
-  GMPVideoDecoderParent* vdp = new GMPVideoDecoderParent(this);
-  NS_ADDREF(vdp);
-  return vdp;
-}
-
-bool
-GMPParent::DeallocPGMPVideoDecoderParent(PGMPVideoDecoderParent* aActor)
-{
-  GMPVideoDecoderParent* vdp = static_cast<GMPVideoDecoderParent*>(aActor);
-  NS_RELEASE(vdp);
-  return true;
-}
-
-PGMPVideoEncoderParent*
-GMPParent::AllocPGMPVideoEncoderParent()
-{
-  GMPVideoEncoderParent* vep = new GMPVideoEncoderParent(this);
-  NS_ADDREF(vep);
-  return vep;
-}
-
-bool
-GMPParent::DeallocPGMPVideoEncoderParent(PGMPVideoEncoderParent* aActor)
-{
-  GMPVideoEncoderParent* vep = static_cast<GMPVideoEncoderParent*>(aActor);
-  NS_RELEASE(vep);
-  return true;
-}
-
-PGMPDecryptorParent*
-GMPParent::AllocPGMPDecryptorParent()
-{
-  GMPDecryptorParent* ksp = new GMPDecryptorParent(this);
-  NS_ADDREF(ksp);
-  return ksp;
-}
-
-bool
-GMPParent::DeallocPGMPDecryptorParent(PGMPDecryptorParent* aActor)
-{
-  GMPDecryptorParent* ksp = static_cast<GMPDecryptorParent*>(aActor);
-  NS_RELEASE(ksp);
-  return true;
-}
-
-PGMPAudioDecoderParent*
-GMPParent::AllocPGMPAudioDecoderParent()
-{
-  GMPAudioDecoderParent* vdp = new GMPAudioDecoderParent(this);
-  NS_ADDREF(vdp);
-  return vdp;
-}
-
-bool
-GMPParent::DeallocPGMPAudioDecoderParent(PGMPAudioDecoderParent* aActor)
-{
-  GMPAudioDecoderParent* vdp = static_cast<GMPAudioDecoderParent*>(aActor);
-  NS_RELEASE(vdp);
-  return true;
-}
-
-PGMPStorageParent*
-GMPParent::AllocPGMPStorageParent()
-{
-  GMPStorageParent* p = new GMPStorageParent(mNodeId, this);
-  mStorage.AppendElement(p); // Addrefs, released in DeallocPGMPStorageParent.
-  return p;
-}
-
-bool
-GMPParent::DeallocPGMPStorageParent(PGMPStorageParent* aActor)
-{
-  GMPStorageParent* p = static_cast<GMPStorageParent*>(aActor);
-  p->Shutdown();
-  mStorage.RemoveElement(p);
-  return true;
-}
-
-bool
-GMPParent::RecvPGMPStorageConstructor(PGMPStorageParent* aActor)
-{
-  GMPStorageParent* p  = (GMPStorageParent*)aActor;
-  if (NS_WARN_IF(NS_FAILED(p->Init()))) {
-    return false;
-  }
-  return true;
-}
-
-bool
-GMPParent::RecvPGMPTimerConstructor(PGMPTimerParent* actor)
-{
-  return true;
-}
-
-PGMPTimerParent*
-GMPParent::AllocPGMPTimerParent()
-{
-  GMPTimerParent* p = new GMPTimerParent(GMPThread());
-  mTimers.AppendElement(p); // Released in DeallocPGMPTimerParent, or on shutdown.
-  return p;
-}
-
-bool
-GMPParent::DeallocPGMPTimerParent(PGMPTimerParent* aActor)
-{
-  GMPTimerParent* p = static_cast<GMPTimerParent*>(aActor);
-  p->Shutdown();
-  mTimers.RemoveElement(p);
-  return true;
-}
-
-nsresult
-ParseNextRecord(nsILineInputStream* aLineInputStream,
-                const nsCString& aPrefix,
-                nsCString& aResult,
-                bool& aMoreLines)
-{
-  nsAutoCString record;
-  nsresult rv = aLineInputStream->ReadLine(record, &aMoreLines);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  if (record.Length() <= aPrefix.Length() ||
-      !Substring(record, 0, aPrefix.Length()).Equals(aPrefix)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  aResult = Substring(record, aPrefix.Length());
-  aResult.Trim("\b\t\r\n ");
-
-  return NS_OK;
-}
-
-nsresult
-GMPParent::ReadGMPMetaData()
-{
-  MOZ_ASSERT(mDirectory, "Plugin directory cannot be NULL!");
-  MOZ_ASSERT(!mName.IsEmpty(), "Plugin mName cannot be empty!");
-
-  nsCOMPtr<nsIFile> infoFile;
-  nsresult rv = mDirectory->Clone(getter_AddRefs(infoFile));
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-  infoFile->AppendRelativePath(mName + NS_LITERAL_STRING(".info"));
-
-  nsCOMPtr<nsIInputStream> inputStream;
-  rv = NS_NewLocalFileInputStream(getter_AddRefs(inputStream), infoFile);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  nsCOMPtr<nsILineInputStream> lineInputStream = do_QueryInterface(inputStream, &rv);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  nsCString value;
-  bool moreLines = false;
-
-  // 'Name:' record
-  nsCString prefix = NS_LITERAL_CSTRING("Name:");
-  rv = ParseNextRecord(lineInputStream, prefix, value, moreLines);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-  if (value.IsEmpty()) {
-    // Not OK for name to be empty. Must have one non-whitespace character.
-    return NS_ERROR_FAILURE;
-  }
-  mDisplayName = value;
-
-  // 'Description:' record
-  if (!moreLines) {
-    return NS_ERROR_FAILURE;
-  }
-  prefix = NS_LITERAL_CSTRING("Description:");
-  rv = ParseNextRecord(lineInputStream, prefix, value, moreLines);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-  mDescription = value;
-
-  // 'Version:' record
-  if (!moreLines) {
-    return NS_ERROR_FAILURE;
-  }
-  prefix = NS_LITERAL_CSTRING("Version:");
-  rv = ParseNextRecord(lineInputStream, prefix, value, moreLines);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-  mVersion = value;
-
-  // 'Capability:' record
-  if (!moreLines) {
-    return NS_ERROR_FAILURE;
-  }
-  prefix = NS_LITERAL_CSTRING("APIs:");
-  rv = ParseNextRecord(lineInputStream, prefix, value, moreLines);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-  nsCCharSeparatedTokenizer apiTokens(value, ',');
-  while (apiTokens.hasMoreTokens()) {
-    nsAutoCString api(apiTokens.nextToken());
-    api.StripWhitespace();
-    if (api.IsEmpty()) {
-      continue;
-    }
-
-    int32_t tagsStart = api.FindChar('[');
-    if (tagsStart == 0) {
-      // Not allowed to be the first character.
-      // API name must be at least one character.
-      continue;
-    }
-
-    auto cap = new GMPCapability();
-    if (tagsStart == -1) {
-      // No tags.
-      cap->mAPIName.Assign(api);
-    } else {
-      auto tagsEnd = api.FindChar(']');
-      if (tagsEnd == -1 || tagsEnd < tagsStart) {
-        // Invalid syntax, skip whole capability.
-        delete cap;
-        continue;
-      }
-
-      cap->mAPIName.Assign(Substring(api, 0, tagsStart));
-
-      if ((tagsEnd - tagsStart) > 1) {
-        const nsDependentCSubstring ts(Substring(api, tagsStart + 1, tagsEnd - tagsStart - 1));
-        nsCCharSeparatedTokenizer tagTokens(ts, ':');
-        while (tagTokens.hasMoreTokens()) {
-          const nsDependentCSubstring tag(tagTokens.nextToken());
-          cap->mAPITags.AppendElement(tag);
-        }
-      }
-    }
-
-    if (cap->mAPIName.EqualsLiteral(GMP_API_DECRYPTOR) ||
-        cap->mAPIName.EqualsLiteral(GMP_API_DECRYPTOR_COMPAT)) {
-      mCanDecrypt = true;
-
-#if defined(XP_LINUX) && defined(MOZ_GMP_SANDBOX)
-      if (!mozilla::SandboxInfo::Get().CanSandboxMedia()) {
-        printf_stderr("GMPParent::ReadGMPMetaData: Plugin \"%s\" is an EME CDM"
-                      " but this system can't sandbox it; not loading.\n",
-                      mDisplayName.get());
-        delete cap;
-        return NS_ERROR_FAILURE;
-      }
-#endif
-    }
-
-    mCapabilities.AppendElement(cap);
-  }
-
-  if (mCapabilities.IsEmpty()) {
-    return NS_ERROR_FAILURE;
-  }
-
-  return NS_OK;
-}
-
-bool
-GMPParent::CanBeSharedCrossNodeIds() const
-{
-  return mNodeId.IsEmpty() &&
-    // XXX bug 1159300 hack -- maybe remove after openh264 1.4
-    // We don't want to use CDM decoders for non-encrypted playback
-    // just yet; especially not for WebRTC. Don't allow CDMs to be used
-    // without a node ID.
-    !mCanDecrypt;
-}
-
-bool
-GMPParent::CanBeUsedFrom(const nsACString& aNodeId) const
-{
-  return (mNodeId.IsEmpty() && State() == GMPStateNotLoaded) ||
-         mNodeId == aNodeId;
-}
-
-void
-GMPParent::SetNodeId(const nsACString& aNodeId)
-{
-  MOZ_ASSERT(!aNodeId.IsEmpty());
-  MOZ_ASSERT(CanBeUsedFrom(aNodeId));
-  mNodeId = aNodeId;
-}
-
-const nsCString&
-GMPParent::GetDisplayName() const
-{
-  return mDisplayName;
-}
-
-const nsCString&
-GMPParent::GetVersion() const
-{
-  return mVersion;
-}
-
-const nsACString&
-GMPParent::GetPluginId() const
-{
-  return mPluginId;
-}
-
-bool
-GMPParent::RecvAsyncShutdownRequired()
-{
-  LOGD(("%s::%s: %p", __CLASS__, __FUNCTION__, this));
-  if (mAsyncShutdownRequired) {
-    NS_WARNING("Received AsyncShutdownRequired message more than once!");
-    return true;
-  }
-  mAsyncShutdownRequired = true;
-  mService->AsyncShutdownNeeded(this);
-  return true;
-}
-
-bool
-GMPParent::RecvAsyncShutdownComplete()
-{
-  LOGD(("%s::%s: %p", __CLASS__, __FUNCTION__, this));
-
-  MOZ_ASSERT(mAsyncShutdownRequired);
-  AbortAsyncShutdown();
-  return true;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPParent.h b/dom/media/gmp/GMPParent.h
deleted file mode 100644
index 184b0a8..0000000
--- a/dom/media/gmp/GMPParent.h
+++ /dev/null
@@ -1,201 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPParent_h_
-#define GMPParent_h_
-
-#include "GMPProcessParent.h"
-#include "GMPService.h"
-#include "GMPAudioDecoderParent.h"
-#include "GMPDecryptorParent.h"
-#include "GMPVideoDecoderParent.h"
-#include "GMPVideoEncoderParent.h"
-#include "GMPTimerParent.h"
-#include "GMPStorageParent.h"
-#include "mozilla/gmp/PGMPParent.h"
-#include "nsCOMPtr.h"
-#include "nscore.h"
-#include "nsISupports.h"
-#include "nsString.h"
-#include "nsTArray.h"
-#include "nsIFile.h"
-#include "ThreadSafeRefcountingWithMainThreadDestruction.h"
-
-class nsILineInputStream;
-class nsIThread;
-
-namespace mozilla {
-namespace gmp {
-
-class GMPCapability
-{
-public:
-  nsCString mAPIName;
-  nsTArray<nsCString> mAPITags;
-};
-
-enum GMPState {
-  GMPStateNotLoaded,
-  GMPStateLoaded,
-  GMPStateUnloading,
-  GMPStateClosing
-};
-
-class GMPParent final : public PGMPParent,
-                            public GMPSharedMem
-{
-public:
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING_WITH_MAIN_THREAD_DESTRUCTION(GMPParent)
-
-  GMPParent();
-
-  nsresult Init(GoannaMediaPluginService *aService, nsIFile* aPluginDir);
-  nsresult CloneFrom(const GMPParent* aOther);
-
-  void Crash();
-
-  nsresult LoadProcess();
-
-  // Called internally to close this if we don't need it
-  void CloseIfUnused();
-
-  // Notify all active de/encoders that we are closing, either because of
-  // normal shutdown or unexpected shutdown/crash.
-  void CloseActive(bool aDieWhenUnloaded);
-
-  // Tell the plugin to die after shutdown.
-  void MarkForDeletion();
-  bool IsMarkedForDeletion();
-
-  // Called by the GMPService to forcibly close active de/encoders at shutdown
-  void Shutdown();
-
-  // This must not be called while we're in the middle of abnormal ActorDestroy
-  void DeleteProcess();
-
-  bool SupportsAPI(const nsCString& aAPI, const nsCString& aTag);
-
-  nsresult GetGMPVideoDecoder(GMPVideoDecoderParent** aGMPVD);
-  void VideoDecoderDestroyed(GMPVideoDecoderParent* aDecoder);
-
-  nsresult GetGMPVideoEncoder(GMPVideoEncoderParent** aGMPVE);
-  void VideoEncoderDestroyed(GMPVideoEncoderParent* aEncoder);
-
-  nsresult GetGMPDecryptor(GMPDecryptorParent** aGMPKS);
-  void DecryptorDestroyed(GMPDecryptorParent* aSession);
-
-  nsresult GetGMPAudioDecoder(GMPAudioDecoderParent** aGMPAD);
-  void AudioDecoderDestroyed(GMPAudioDecoderParent* aDecoder);
-
-  GMPState State() const;
-  nsIThread* GMPThread();
-
-  // A GMP can either be a single instance shared across all NodeIds (like
-  // in the OpenH264 case), or we can require a new plugin instance for every
-  // NodeIds running the plugin (as in the EME plugin case).
-  //
-  // A NodeId is a hash of the ($urlBarOrigin, $ownerDocOrigin) pair.
-  //
-  // Plugins are associated with an NodeIds by calling SetNodeId() before
-  // loading.
-  //
-  // If a plugin has no NodeId specified and it is loaded, it is assumed to
-  // be shared across NodeIds.
-
-  // Specifies that a GMP can only work with the specified NodeIds.
-  void SetNodeId(const nsACString& aNodeId);
-  const nsACString& GetNodeId() const { return mNodeId; }
-
-  const nsCString& GetDisplayName() const;
-  const nsCString& GetVersion() const;
-  const nsACString& GetPluginId() const;
-
-  // Returns true if a plugin can be or is being used across multiple NodeIds.
-  bool CanBeSharedCrossNodeIds() const;
-
-  // A GMP can be used from a NodeId if it's already been set to work with
-  // that NodeId, or if it's not been set to work with any NodeId and has
-  // not yet been loaded (i.e. it's not shared across NodeIds).
-  bool CanBeUsedFrom(const nsACString& aNodeId) const;
-
-  already_AddRefed<nsIFile> GetDirectory() {
-    return nsCOMPtr<nsIFile>(mDirectory).forget();
-  }
-
-  // GMPSharedMem
-  virtual void CheckThread() override;
-
-  void AbortAsyncShutdown();
-
-  // Called when the child process has died.
-  void ChildTerminated();
-
-private:
-  ~GMPParent();
-  nsRefPtr<GoannaMediaPluginService> mService;
-  bool EnsureProcessLoaded();
-  nsresult ReadGMPMetaData();
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-
-  virtual PGMPVideoDecoderParent* AllocPGMPVideoDecoderParent() override;
-  virtual bool DeallocPGMPVideoDecoderParent(PGMPVideoDecoderParent* aActor) override;
-
-  virtual PGMPVideoEncoderParent* AllocPGMPVideoEncoderParent() override;
-  virtual bool DeallocPGMPVideoEncoderParent(PGMPVideoEncoderParent* aActor) override;
-
-  virtual PGMPDecryptorParent* AllocPGMPDecryptorParent() override;
-  virtual bool DeallocPGMPDecryptorParent(PGMPDecryptorParent* aActor) override;
-
-  virtual PGMPAudioDecoderParent* AllocPGMPAudioDecoderParent() override;
-  virtual bool DeallocPGMPAudioDecoderParent(PGMPAudioDecoderParent* aActor) override;
-
-  virtual bool RecvPGMPStorageConstructor(PGMPStorageParent* actor) override;
-  virtual PGMPStorageParent* AllocPGMPStorageParent() override;
-  virtual bool DeallocPGMPStorageParent(PGMPStorageParent* aActor) override;
-
-  virtual bool RecvPGMPTimerConstructor(PGMPTimerParent* actor) override;
-  virtual PGMPTimerParent* AllocPGMPTimerParent() override;
-  virtual bool DeallocPGMPTimerParent(PGMPTimerParent* aActor) override;
-
-  virtual bool RecvAsyncShutdownComplete() override;
-  virtual bool RecvAsyncShutdownRequired() override;
-
-  nsresult EnsureAsyncShutdownTimeoutSet();
-
-  GMPState mState;
-  nsCOMPtr<nsIFile> mDirectory; // plugin directory on disk
-  nsString mName; // base name of plugin on disk, UTF-16 because used for paths
-  nsCString mDisplayName; // name of plugin displayed to users
-  nsCString mDescription; // description of plugin for display to users
-  nsCString mVersion;
-  nsCString mPluginId;
-  nsTArray<nsAutoPtr<GMPCapability>> mCapabilities;
-  GMPProcessParent* mProcess;
-  bool mDeleteProcessOnlyOnUnload;
-  bool mAbnormalShutdownInProgress;
-  bool mIsBlockingDeletion;
-
-  bool mCanDecrypt;
-
-  nsTArray<nsRefPtr<GMPVideoDecoderParent>> mVideoDecoders;
-  nsTArray<nsRefPtr<GMPVideoEncoderParent>> mVideoEncoders;
-  nsTArray<nsRefPtr<GMPDecryptorParent>> mDecryptors;
-  nsTArray<nsRefPtr<GMPAudioDecoderParent>> mAudioDecoders;
-  nsTArray<nsRefPtr<GMPTimerParent>> mTimers;
-  nsTArray<nsRefPtr<GMPStorageParent>> mStorage;
-  nsCOMPtr<nsIThread> mGMPThread;
-  nsCOMPtr<nsITimer> mAsyncShutdownTimeout; // GMP Thread only.
-  // NodeId the plugin is assigned to, or empty if the the plugin is not
-  // assigned to a NodeId.
-  nsAutoCString mNodeId;
-
-  bool mAsyncShutdownRequired;
-  bool mAsyncShutdownInProgress;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPParent_h_
diff --git a/dom/media/gmp/GMPPlatform.cpp b/dom/media/gmp/GMPPlatform.cpp
deleted file mode 100644
index 8579ef3..0000000
--- a/dom/media/gmp/GMPPlatform.cpp
+++ /dev/null
@@ -1,301 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPPlatform.h"
-#include "GMPStorageChild.h"
-#include "GMPTimerChild.h"
-#include "mozilla/Monitor.h"
-#include "nsAutoPtr.h"
-#include "GMPChild.h"
-#include <ctime>
-
-namespace mozilla {
-namespace gmp {
-
-static MessageLoop* sMainLoop = nullptr;
-static GMPChild* sChild = nullptr;
-
-static bool
-IsOnChildMainThread()
-{
-  return sMainLoop && sMainLoop == MessageLoop::current();
-}
-
-// We just need a refcounted wrapper for GMPTask objects.
-class Runnable final
-{
-public:
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(Runnable)
-
-  explicit Runnable(GMPTask* aTask)
-  : mTask(aTask)
-  {
-    MOZ_ASSERT(mTask);
-  }
-
-  void Run()
-  {
-    mTask->Run();
-    mTask->Destroy();
-    mTask = nullptr;
-  }
-
-private:
-  ~Runnable()
-  {
-  }
-
-  GMPTask* mTask;
-};
-
-class SyncRunnable final
-{
-public:
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(SyncRunnable)
-
-  SyncRunnable(GMPTask* aTask, MessageLoop* aMessageLoop)
-  : mDone(false)
-  , mTask(aTask)
-  , mMessageLoop(aMessageLoop)
-  , mMonitor("GMPSyncRunnable")
-  {
-    MOZ_ASSERT(mTask);
-    MOZ_ASSERT(mMessageLoop);
-  }
-
-  void Post()
-  {
-    // We assert here for two reasons.
-    // 1) Nobody should be blocking the main thread.
-    // 2) This prevents deadlocks when doing sync calls to main which if the
-    //    main thread tries to do a sync call back to the calling thread.
-    MOZ_ASSERT(!IsOnChildMainThread());
-
-    mMessageLoop->PostTask(FROM_HERE, NewRunnableMethod(this, &SyncRunnable::Run));
-    MonitorAutoLock lock(mMonitor);
-    while (!mDone) {
-      lock.Wait();
-    }
-  }
-
-  void Run()
-  {
-    mTask->Run();
-    mTask->Destroy();
-    mTask = nullptr;
-    MonitorAutoLock lock(mMonitor);
-    mDone = true;
-    lock.Notify();
-  }
-
-private:
-  ~SyncRunnable()
-  {
-  }
-
-  bool mDone;
-  GMPTask* mTask;
-  MessageLoop* mMessageLoop;
-  Monitor mMonitor;
-};
-
-GMPErr
-CreateThread(GMPThread** aThread)
-{
-  if (!aThread) {
-    return GMPGenericErr;
-  }
-
-  *aThread = new GMPThreadImpl();
-
-  return GMPNoErr;
-}
-
-GMPErr
-RunOnMainThread(GMPTask* aTask)
-{
-  if (!aTask || !sMainLoop) {
-    return GMPGenericErr;
-  }
-
-  nsRefPtr<Runnable> r = new Runnable(aTask);
-  sMainLoop->PostTask(FROM_HERE, NewRunnableMethod(r.get(), &Runnable::Run));
-
-  return GMPNoErr;
-}
-
-GMPErr
-SyncRunOnMainThread(GMPTask* aTask)
-{
-  if (!aTask || !sMainLoop || IsOnChildMainThread()) {
-    return GMPGenericErr;
-  }
-
-  nsRefPtr<SyncRunnable> r = new SyncRunnable(aTask, sMainLoop);
-
-  r->Post();
-
-  return GMPNoErr;
-}
-
-GMPErr
-CreateMutex(GMPMutex** aMutex)
-{
-  if (!aMutex) {
-    return GMPGenericErr;
-  }
-
-  *aMutex = new GMPMutexImpl();
-
-  return GMPNoErr;
-}
-
-GMPErr
-CreateRecord(const char* aRecordName,
-             uint32_t aRecordNameSize,
-             GMPRecord** aOutRecord,
-             GMPRecordClient* aClient)
-{
-  if (aRecordNameSize > GMP_MAX_RECORD_NAME_SIZE) {
-    NS_WARNING("GMP tried to CreateRecord with too long record name");
-    return GMPGenericErr;
-  }
-  GMPStorageChild* storage = sChild->GetGMPStorage();
-  if (!storage) {
-    return GMPGenericErr;
-  }
-  MOZ_ASSERT(storage);
-  return storage->CreateRecord(nsDependentCString(aRecordName, aRecordNameSize),
-                               aOutRecord,
-                               aClient);
-}
-
-GMPErr
-SetTimerOnMainThread(GMPTask* aTask, int64_t aTimeoutMS)
-{
-  if (!aTask || !sMainLoop || !IsOnChildMainThread()) {
-    return GMPGenericErr;
-  }
-  GMPTimerChild* timers = sChild->GetGMPTimers();
-  NS_ENSURE_TRUE(timers, GMPGenericErr);
-  return timers->SetTimer(aTask, aTimeoutMS);
-}
-
-GMPErr
-GetClock(GMPTimestamp* aOutTime)
-{
-  *aOutTime = time(0) * 1000;
-  return GMPNoErr;
-}
-
-GMPErr
-CreateRecordIterator(RecvGMPRecordIteratorPtr aRecvIteratorFunc,
-                     void* aUserArg)
-{
-  if (!aRecvIteratorFunc) {
-    return GMPInvalidArgErr;
-  }
-  GMPStorageChild* storage = sChild->GetGMPStorage();
-  if (!storage) {
-    return GMPGenericErr;
-  }
-  MOZ_ASSERT(storage);
-  return storage->EnumerateRecords(aRecvIteratorFunc, aUserArg);
-}
-
-void
-InitPlatformAPI(GMPPlatformAPI& aPlatformAPI, GMPChild* aChild)
-{
-  if (!sMainLoop) {
-    sMainLoop = MessageLoop::current();
-  }
-  if (!sChild) {
-    sChild = aChild;
-  }
-
-  aPlatformAPI.version = 0;
-  aPlatformAPI.createthread = &CreateThread;
-  aPlatformAPI.runonmainthread = &RunOnMainThread;
-  aPlatformAPI.syncrunonmainthread = &SyncRunOnMainThread;
-  aPlatformAPI.createmutex = &CreateMutex;
-  aPlatformAPI.createrecord = &CreateRecord;
-  aPlatformAPI.settimer = &SetTimerOnMainThread;
-  aPlatformAPI.getcurrenttime = &GetClock;
-  aPlatformAPI.getrecordenumerator = &CreateRecordIterator;
-}
-
-GMPThreadImpl::GMPThreadImpl()
-: mMutex("GMPThreadImpl"),
-  mThread("GMPThread")
-{
-  MOZ_COUNT_CTOR(GMPThread);
-}
-
-GMPThreadImpl::~GMPThreadImpl()
-{
-  MOZ_COUNT_DTOR(GMPThread);
-}
-
-void
-GMPThreadImpl::Post(GMPTask* aTask)
-{
-  MutexAutoLock lock(mMutex);
-
-  if (!mThread.IsRunning()) {
-    bool started = mThread.Start();
-    if (!started) {
-      NS_WARNING("Unable to start GMPThread!");
-      return;
-    }
-  }
-
-  nsRefPtr<Runnable> r = new Runnable(aTask);
-
-  mThread.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(r.get(), &Runnable::Run));
-}
-
-void
-GMPThreadImpl::Join()
-{
-  {
-    MutexAutoLock lock(mMutex);
-    if (mThread.IsRunning()) {
-      mThread.Stop();
-    }
-  }
-  delete this;
-}
-
-GMPMutexImpl::GMPMutexImpl()
-: mMonitor("gmp-mutex")
-{
-  MOZ_COUNT_CTOR(GMPMutexImpl);
-}
-
-GMPMutexImpl::~GMPMutexImpl()
-{
-  MOZ_COUNT_DTOR(GMPMutexImpl);
-}
-
-void
-GMPMutexImpl::Destroy()
-{
-  delete this;
-}
-
-void
-GMPMutexImpl::Acquire()
-{
-  mMonitor.Enter();
-}
-
-void
-GMPMutexImpl::Release()
-{
-  mMonitor.Exit();
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPPlatform.h b/dom/media/gmp/GMPPlatform.h
deleted file mode 100644
index e13e94a..0000000
--- a/dom/media/gmp/GMPPlatform.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPPlatform_h_
-#define GMPPlatform_h_
-
-#include "mozilla/Mutex.h"
-#include "gmp-platform.h"
-#include "base/thread.h"
-#include "mozilla/ReentrantMonitor.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPChild;
-
-void InitPlatformAPI(GMPPlatformAPI& aPlatformAPI, GMPChild* aChild);
-
-GMPErr RunOnMainThread(GMPTask* aTask);
-
-class GMPThreadImpl : public GMPThread
-{
-public:
-  GMPThreadImpl();
-  virtual ~GMPThreadImpl();
-
-  // GMPThread
-  virtual void Post(GMPTask* aTask) override;
-  virtual void Join() override;
-
-private:
-  Mutex mMutex;
-  base::Thread mThread;
-};
-
-class GMPMutexImpl : public GMPMutex
-{
-public:
-  GMPMutexImpl();
-  virtual ~GMPMutexImpl();
-
-  // GMPMutex
-  virtual void Acquire() override;
-  virtual void Release() override;
-  virtual void Destroy() override;
-
-private:
-  ReentrantMonitor mMonitor;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPPlatform_h_
diff --git a/dom/media/gmp/GMPProcessChild.cpp b/dom/media/gmp/GMPProcessChild.cpp
deleted file mode 100644
index 803d9c2..0000000
--- a/dom/media/gmp/GMPProcessChild.cpp
+++ /dev/null
@@ -1,83 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPProcessChild.h"
-
-#include "base/command_line.h"
-#include "base/string_util.h"
-#include "chrome/common/chrome_switches.h"
-#include "mozilla/ipc/IOThreadChild.h"
-#include "mozilla/BackgroundHangMonitor.h"
-
-using mozilla::ipc::IOThreadChild;
-
-namespace mozilla {
-namespace gmp {
-
-GMPProcessChild::GMPProcessChild(ProcessHandle parentHandle)
-: ProcessChild(parentHandle)
-{
-}
-
-GMPProcessChild::~GMPProcessChild()
-{
-}
-
-bool
-GMPProcessChild::Init()
-{
-  std::string pluginFilename;
-  std::string voucherFilename;
-
-#if defined(OS_POSIX)
-  // NB: need to be very careful in ensuring that the first arg
-  // (after the binary name) here is indeed the plugin module path.
-  // Keep in sync with dom/plugins/PluginModuleParent.
-  std::vector<std::string> values = CommandLine::ForCurrentProcess()->argv();
-  MOZ_ASSERT(values.size() >= 3, "not enough args");
-  pluginFilename = values[1];
-  voucherFilename = values[2];
-#elif defined(OS_WIN)
-  std::vector<std::wstring> values = CommandLine::ForCurrentProcess()->GetLooseValues();
-  MOZ_ASSERT(values.size() >= 2, "not enough loose args");
-  pluginFilename = WideToUTF8(values[0]);
-  voucherFilename = WideToUTF8(values[1]);
-#else
-#error Not implemented
-#endif
-
-  BackgroundHangMonitor::Startup();
-
-  return mPlugin.Init(pluginFilename,
-                      voucherFilename,
-                      ParentHandle(),
-                      IOThreadChild::message_loop(),
-                      IOThreadChild::channel());
-}
-
-void
-GMPProcessChild::CleanUp()
-{
-  BackgroundHangMonitor::Shutdown();
-}
-
-GMPLoader* GMPProcessChild::mLoader = nullptr;
-
-/* static */
-void
-GMPProcessChild::SetGMPLoader(GMPLoader* aLoader)
-{
-  mLoader = aLoader;
-}
-
-/* static */
-GMPLoader*
-GMPProcessChild::GetGMPLoader()
-{
-  return mLoader;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPProcessChild.h b/dom/media/gmp/GMPProcessChild.h
deleted file mode 100644
index 1331892..0000000
--- a/dom/media/gmp/GMPProcessChild.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPProcessChild_h_
-#define GMPProcessChild_h_
-
-#include "mozilla/ipc/ProcessChild.h"
-#include "GMPChild.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPLoader;
-
-class GMPProcessChild final : public mozilla::ipc::ProcessChild {
-protected:
-  typedef mozilla::ipc::ProcessChild ProcessChild;
-
-public:
-  explicit GMPProcessChild(ProcessHandle parentHandle);
-  ~GMPProcessChild();
-
-  virtual bool Init() override;
-  virtual void CleanUp() override;
-
-  // Set/get the GMPLoader singleton for this child process.
-  // Note: The GMPLoader is not deleted by this object, the caller of
-  // SetGMPLoader() must manage the GMPLoader's lifecycle.
-  static void SetGMPLoader(GMPLoader* aHost);
-  static GMPLoader* GetGMPLoader();
-
-private:
-  GMPChild mPlugin;
-  static GMPLoader* mLoader;
-  DISALLOW_COPY_AND_ASSIGN(GMPProcessChild);
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPProcessChild_h_
diff --git a/dom/media/gmp/GMPProcessParent.cpp b/dom/media/gmp/GMPProcessParent.cpp
deleted file mode 100644
index 79c63c9..0000000
--- a/dom/media/gmp/GMPProcessParent.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=2 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPProcessParent.h"
-#include "GMPUtils.h"
-
-#include "base/string_util.h"
-#include "base/process_util.h"
-
-#include <string>
-
-using std::vector;
-using std::string;
-
-using mozilla::gmp::GMPProcessParent;
-using mozilla::ipc::GoannaChildProcessHost;
-using base::ProcessArchitecture;
-
-template<>
-struct RunnableMethodTraits<GMPProcessParent>
-{
-  static void RetainCallee(GMPProcessParent* obj) { }
-  static void ReleaseCallee(GMPProcessParent* obj) { }
-};
-
-namespace mozilla {
-namespace gmp {
-
-GMPProcessParent::GMPProcessParent(const std::string& aGMPPath)
-: GoannaChildProcessHost(GoannaProcessType_GMPlugin),
-  mGMPPath(aGMPPath)
-{
-  MOZ_COUNT_CTOR(GMPProcessParent);
-}
-
-GMPProcessParent::~GMPProcessParent()
-{
-  MOZ_COUNT_DTOR(GMPProcessParent);
-}
-
-bool
-GMPProcessParent::Launch(int32_t aTimeoutMs)
-{
-  nsCOMPtr<nsIFile> path;
-  if (!GetEMEVoucherPath(getter_AddRefs(path))) {
-    NS_WARNING("GMPProcessParent can't get EME voucher path!");
-    return false;
-  }
-  nsAutoCString voucherPath;
-  path->GetNativePath(voucherPath);
-
-  vector<string> args;
-  args.push_back(mGMPPath);
-  args.push_back(string(voucherPath.BeginReading(), voucherPath.EndReading()));
-
-#if defined(XP_WIN) && defined(MOZ_SANDBOX)
-  std::wstring wGMPPath = UTF8ToWide(mGMPPath.c_str());
-  mAllowedFilesRead.push_back(wGMPPath + L"\\*");
-#endif
-
-  return SyncLaunch(args, aTimeoutMs, base::GetCurrentProcessArchitecture());
-}
-
-void
-GMPProcessParent::Delete(nsCOMPtr<nsIRunnable> aCallback)
-{
-  mDeletedCallback = aCallback;
-  XRE_GetIOMessageLoop()->PostTask(FROM_HERE, NewRunnableMethod(this, &GMPProcessParent::DoDelete));
-}
-
-void
-GMPProcessParent::DoDelete()
-{
-  MOZ_ASSERT(MessageLoop::current() == XRE_GetIOMessageLoop());
-  Join();
-
-  if (mDeletedCallback) {
-    mDeletedCallback->Run();
-  }
-
-  delete this;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPProcessParent.h b/dom/media/gmp/GMPProcessParent.h
deleted file mode 100644
index e4639f1..0000000
--- a/dom/media/gmp/GMPProcessParent.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- * vim: sw=4 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPProcessParent_h
-#define GMPProcessParent_h 1
-
-#include "mozilla/Attributes.h"
-#include "base/basictypes.h"
-#include "base/file_path.h"
-#include "base/thread.h"
-#include "base/waitable_event.h"
-#include "chrome/common/child_process_host.h"
-#include "mozilla/ipc/GoannaChildProcessHost.h"
-
-class nsIRunnable;
-
-namespace mozilla {
-namespace gmp {
-
-class GMPProcessParent final : public mozilla::ipc::GoannaChildProcessHost
-{
-public:
-  explicit GMPProcessParent(const std::string& aGMPPath);
-  ~GMPProcessParent();
-
-  // Synchronously launch the plugin process. If the process fails to launch
-  // after timeoutMs, this method will return false.
-  bool Launch(int32_t aTimeoutMs);
-
-  void Delete(nsCOMPtr<nsIRunnable> aCallback = nullptr);
-
-  virtual bool CanShutdown() override { return true; }
-  const std::string& GetPluginFilePath() { return mGMPPath; }
-
-  using mozilla::ipc::GoannaChildProcessHost::GetShutDownEvent;
-  using mozilla::ipc::GoannaChildProcessHost::GetChannel;
-  using mozilla::ipc::GoannaChildProcessHost::GetChildProcessHandle;
-
-private:
-  void DoDelete();
-
-  std::string mGMPPath;
-  nsCOMPtr<nsIRunnable> mDeletedCallback;
-
-  DISALLOW_COPY_AND_ASSIGN(GMPProcessParent);
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // ifndef GMPProcessParent_h
diff --git a/dom/media/gmp/GMPService.cpp b/dom/media/gmp/GMPService.cpp
deleted file mode 100644
index d92bc02..0000000
--- a/dom/media/gmp/GMPService.cpp
+++ /dev/null
@@ -1,1707 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPService.h"
-#include "prio.h"
-#include "prlog.h"
-#include "GMPParent.h"
-#include "GMPVideoDecoderParent.h"
-#include "nsIObserverService.h"
-#include "GoannaChildProcessHost.h"
-#include "mozilla/Preferences.h"
-#include "mozilla/ClearOnShutdown.h"
-#include "mozilla/SyncRunnable.h"
-#include "nsXPCOMPrivate.h"
-#include "mozilla/Services.h"
-#include "nsNativeCharsetUtils.h"
-#include "nsIConsoleService.h"
-#include "mozilla/unused.h"
-#include "GMPDecryptorParent.h"
-#include "GMPAudioDecoderParent.h"
-#include "nsComponentManagerUtils.h"
-#include "mozilla/Preferences.h"
-#include "runnable_utils.h"
-#include "VideoUtils.h"
-#if defined(XP_LINUX) && defined(MOZ_GMP_SANDBOX)
-#include "mozilla/SandboxInfo.h"
-#endif
-#include "nsAppDirectoryServiceDefs.h"
-#include "nsDirectoryServiceUtils.h"
-#include "nsDirectoryServiceDefs.h"
-#include "nsHashKeys.h"
-#include "nsIFile.h"
-#include "nsISimpleEnumerator.h"
-
-namespace mozilla {
-
-#ifdef LOG
-#undef LOG
-#endif
-
-#ifdef PR_LOGGING
-PRLogModuleInfo*
-GetGMPLog()
-{
-  static PRLogModuleInfo *sLog;
-  if (!sLog)
-    sLog = PR_NewLogModule("GMP");
-  return sLog;
-}
-
-#define LOGD(msg) PR_LOG(GetGMPLog(), PR_LOG_DEBUG, msg)
-#define LOG(level, msg) PR_LOG(GetGMPLog(), (level), msg)
-#else
-#define LOGD(msg)
-#define LOG(leve1, msg)
-#endif
-
-#ifdef __CLASS__
-#undef __CLASS__
-#endif
-#define __CLASS__ "GMPService"
-
-namespace gmp {
-
-static const uint32_t NodeIdSaltLength = 32;
-static StaticRefPtr<GoannaMediaPluginService> sSingletonService;
-
-class GMPServiceCreateHelper final : public nsRunnable
-{
-  nsRefPtr<GoannaMediaPluginService> mService;
-
-public:
-  static already_AddRefed<GoannaMediaPluginService>
-  GetOrCreate()
-  {
-    nsRefPtr<GoannaMediaPluginService> service;
-
-    if (NS_IsMainThread()) {
-      service = GetOrCreateOnMainThread();
-    } else {
-      nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
-      MOZ_ASSERT(mainThread);
-
-      nsRefPtr<GMPServiceCreateHelper> createHelper = new GMPServiceCreateHelper();
-
-      mozilla::SyncRunnable::DispatchToThread(mainThread, createHelper, true);
-
-      service = createHelper->mService.forget();
-    }
-
-    return service.forget();
-  }
-
-private:
-  GMPServiceCreateHelper()
-  {
-  }
-
-  ~GMPServiceCreateHelper()
-  {
-    MOZ_ASSERT(!mService);
-  }
-
-  static already_AddRefed<GoannaMediaPluginService>
-  GetOrCreateOnMainThread()
-  {
-    MOZ_ASSERT(NS_IsMainThread());
-
-    nsRefPtr<GoannaMediaPluginService> service = sSingletonService.get();
-    if (!service) {
-      service = new GoannaMediaPluginService();
-      service->Init();
-
-      sSingletonService = service;
-      ClearOnShutdown(&sSingletonService);
-    }
-
-    return service.forget();
-  }
-
-  NS_IMETHOD
-  Run()
-  {
-    MOZ_ASSERT(NS_IsMainThread());
-
-    mService = GetOrCreateOnMainThread();
-    return NS_OK;
-  }
-};
-
-already_AddRefed<GoannaMediaPluginService>
-GoannaMediaPluginService::GetGoannaMediaPluginService()
-{
-  return GMPServiceCreateHelper::GetOrCreate();
-}
-
-NS_IMPL_ISUPPORTS(GoannaMediaPluginService, mozIGoannaMediaPluginService, nsIObserver)
-
-static int32_t sMaxAsyncShutdownWaitMs = 0;
-static bool sHaveSetTimeoutPrefCache = false;
-
-GoannaMediaPluginService::GoannaMediaPluginService()
-  : mMutex("GoannaMediaPluginService::mMutex")
-  , mShuttingDown(false)
-  , mShuttingDownOnGMPThread(false)
-  , mScannedPluginOnDisk(false)
-  , mWaitingForPluginsAsyncShutdown(false)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  if (!sHaveSetTimeoutPrefCache) {
-    sHaveSetTimeoutPrefCache = true;
-    Preferences::AddIntVarCache(&sMaxAsyncShutdownWaitMs,
-                                "media.gmp.async-shutdown-timeout",
-                                GMP_DEFAULT_ASYNC_SHUTDONW_TIMEOUT);
-  }
-}
-
-GoannaMediaPluginService::~GoannaMediaPluginService()
-{
-  MOZ_ASSERT(mPlugins.IsEmpty());
-  MOZ_ASSERT(mAsyncShutdownPlugins.IsEmpty());
-}
-
-int32_t
-GoannaMediaPluginService::AsyncShutdownTimeoutMs()
-{
-  MOZ_ASSERT(sHaveSetTimeoutPrefCache);
-  return sMaxAsyncShutdownWaitMs;
-}
-
-void
-GoannaMediaPluginService::RemoveObsoletePluginCrashCallbacks()
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  for (size_t i = mPluginCrashCallbacks.Length(); i != 0; --i) {
-    nsRefPtr<PluginCrashCallback>& callback = mPluginCrashCallbacks[i - 1];
-    if (!callback->IsStillValid()) {
-      LOGD(("%s::%s - Removing obsolete callback for pluginId %s",
-            __CLASS__, __FUNCTION__,
-            PromiseFlatCString(callback->PluginId()).get()));
-      mPluginCrashCallbacks.RemoveElementAt(i - 1);
-    }
-  }
-}
-
-void
-GoannaMediaPluginService::AddPluginCrashCallback(
-  nsRefPtr<PluginCrashCallback> aPluginCrashCallback)
-{
-  RemoveObsoletePluginCrashCallbacks();
-  mPluginCrashCallbacks.AppendElement(aPluginCrashCallback);
-}
-
-void
-GoannaMediaPluginService::RemovePluginCrashCallbacks(const nsACString& aPluginId)
-{
-  RemoveObsoletePluginCrashCallbacks();
-  for (size_t i = mPluginCrashCallbacks.Length(); i != 0; --i) {
-    nsRefPtr<PluginCrashCallback>& callback = mPluginCrashCallbacks[i - 1];
-    if (callback->PluginId() == aPluginId) {
-      mPluginCrashCallbacks.RemoveElementAt(i - 1);
-    }
-  }
-}
-
-void
-GoannaMediaPluginService::RunPluginCrashCallbacks(const nsACString& aPluginId,
-                                                 const nsACString& aPluginName,
-                                                 const nsAString& aPluginDumpId)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  LOGD(("%s::%s(%s)", __CLASS__, __FUNCTION__, aPluginId.Data()));
-  for (size_t i = mPluginCrashCallbacks.Length(); i != 0; --i) {
-    nsRefPtr<PluginCrashCallback>& callback = mPluginCrashCallbacks[i - 1];
-    const nsACString& callbackPluginId = callback->PluginId();
-    if (!callback->IsStillValid()) {
-      LOGD(("%s::%s(%s) - Removing obsolete callback for pluginId %s",
-            __CLASS__, __FUNCTION__, aPluginId.Data(),
-            PromiseFlatCString(callback->PluginId()).get()));
-      mPluginCrashCallbacks.RemoveElementAt(i - 1);
-    } else if (callbackPluginId == aPluginId) {
-      LOGD(("%s::%s(%s) - Running #%u",
-          __CLASS__, __FUNCTION__, aPluginId.Data(), i - 1));
-      callback->Run(aPluginName, aPluginDumpId);
-      mPluginCrashCallbacks.RemoveElementAt(i - 1);
-    }
-  }
-}
-
-nsresult
-GoannaMediaPluginService::Init()
-{
-  MOZ_ASSERT(NS_IsMainThread());
-
-  nsCOMPtr<nsIObserverService> obsService = mozilla::services::GetObserverService();
-  MOZ_ASSERT(obsService);
-  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(obsService->AddObserver(this, "profile-change-teardown", false)));
-  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(obsService->AddObserver(this, NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID, false)));
-  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(obsService->AddObserver(this, "last-pb-context-exited", false)));
-  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(obsService->AddObserver(this, "browser:purge-session-history", false)));
-
-#ifdef DEBUG
-  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(obsService->AddObserver(this, "mediakeys-request", false)));
-#endif
-
-  nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
-  if (prefs) {
-    prefs->AddObserver("media.gmp.plugin.crash", this, false);
-  }
-
-#ifndef MOZ_WIDGET_GONK
-  // Directory service is main thread only, so cache the profile dir here
-  // so that we can use it off main thread.
-  // We only do this on non-B2G, as this fails in multi-process Goanna.
-  // TODO: Make this work in multi-process Goanna.
-  nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR, getter_AddRefs(mStorageBaseDir));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  rv = mStorageBaseDir->AppendNative(NS_LITERAL_CSTRING("gmp"));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  rv = mStorageBaseDir->Create(nsIFile::DIRECTORY_TYPE, 0700);
-  if (NS_WARN_IF(NS_FAILED(rv) && rv != NS_ERROR_FILE_ALREADY_EXISTS)) {
-    return rv;
-  }
-#endif
-
-  // Kick off scanning for plugins
-  nsCOMPtr<nsIThread> thread;
-  return GetThread(getter_AddRefs(thread));
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::Observe(nsISupports* aSubject,
-                                 const char* aTopic,
-                                 const char16_t* aSomeData)
-{
-  LOGD(("%s::%s topic='%s' data='%s'", __CLASS__, __FUNCTION__,
-       aTopic, NS_ConvertUTF16toUTF8(aSomeData).get()));
-  if (!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {
-    nsCOMPtr<nsIPrefBranch> branch( do_QueryInterface(aSubject) );
-    if (branch) {
-      bool crashNow = false;
-      if (NS_LITERAL_STRING("media.gmp.plugin.crash").Equals(aSomeData)) {
-        branch->GetBoolPref("media.gmp.plugin.crash",  &crashNow);
-      }
-      if (crashNow) {
-        nsCOMPtr<nsIThread> gmpThread;
-        {
-          MutexAutoLock lock(mMutex);
-          gmpThread = mGMPThread;
-        }
-        if (gmpThread) {
-          gmpThread->Dispatch(WrapRunnable(this, &GoannaMediaPluginService::CrashPlugins),
-                              NS_DISPATCH_NORMAL);
-        }
-      }
-    }
-  } else if (!strcmp("profile-change-teardown", aTopic)) {
-
-    // How shutdown works:
-    //
-    // Some GMPs require time to do bookkeeping upon shutdown. These GMPs
-    // need to be given time to access storage during shutdown. To signal
-    // that time to shutdown is required, those GMPs implement the
-    // GMPAsyncShutdown interface.
-    //
-    // When we startup the child process, we query the GMP for the
-    // GMPAsyncShutdown interface, and if it's present, we send a message
-    // back to the GMPParent, which then registers the GMPParent by calling
-    // GMPService::AsyncShutdownNeeded().
-    //
-    // On shutdown, we set mWaitingForPluginsAsyncShutdown to true, and then
-    // call UnloadPlugins on the GMPThread, and process events on the main
-    // thread until an event sets mWaitingForPluginsAsyncShutdown=false on
-    // the main thread.
-    //
-    // UnloadPlugins() sends close messages for all plugins' API objects to
-    // the GMP interfaces in the child process, and then sends the async
-    // shutdown notifications to child GMPs. When a GMP has completed its
-    // shutdown, it calls GMPAsyncShutdownHost::ShutdownComplete(), which
-    // sends a message back to the parent, which calls
-    // GMPService::AsyncShutdownComplete(). If all plugins requiring async
-    // shutdown have called AsyncShutdownComplete() we stick an event on the
-    // main thread to set mWaitingForPluginsAsyncShutdown=false. We must use
-    // an event to do this, as we must ensure the main thread processes an
-    // event to run its loop. This will unblock the main thread, and shutdown
-    // of other components will proceed.
-    //
-    // We set a timer in UnloadPlugins(), and abort waiting for async
-    // shutdown if the GMPs are taking too long to shutdown.
-    //
-    // We shutdown in "profile-change-teardown", as the profile dir is
-    // still writable then, and it's required for GMPStorage. We block the
-    // shutdown process by spinning the main thread event loop until all GMPs
-    // have shutdown, or timeout has occurred.
-    //
-    // GMPStorage needs to work up until the shutdown-complete notification
-    // arrives from the GMP process.
-
-    mWaitingForPluginsAsyncShutdown = true;
-
-    nsCOMPtr<nsIThread> gmpThread;
-    {
-      MutexAutoLock lock(mMutex);
-      MOZ_ASSERT(!mShuttingDown);
-      mShuttingDown = true;
-      gmpThread = mGMPThread;
-    }
-
-    if (gmpThread) {
-      gmpThread->Dispatch(
-        NS_NewRunnableMethod(this, &GoannaMediaPluginService::UnloadPlugins),
-        NS_DISPATCH_NORMAL);
-    } else {
-      MOZ_ASSERT(mPlugins.IsEmpty());
-    }
-
-    // Wait for plugins to do async shutdown...
-    while (mWaitingForPluginsAsyncShutdown) {
-      NS_ProcessNextEvent(NS_GetCurrentThread(), true);
-    }
-
-  } else if (!strcmp(NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID, aTopic)) {
-    nsCOMPtr<nsIThread> gmpThread;
-    {
-      MutexAutoLock lock(mMutex);
-      // XXX The content process never gets profile-change-teardown, so mShuttingDown
-      // will always be false here. GMPService needs to be proxied to the parent.
-      // See bug 1057908.
-      MOZ_ASSERT(XRE_GetProcessType() != GoannaProcessType_Default || mShuttingDown);
-      mGMPThread.swap(gmpThread);
-    }
-
-    if (gmpThread) {
-      gmpThread->Shutdown();
-    }
-  } else if (!strcmp("last-pb-context-exited", aTopic)) {
-    // When Private Browsing mode exits, all we need to do is clear
-    // mTempNodeIds. This drops all the node ids we've cached in memory
-    // for PB origin-pairs. If we try to open an origin-pair for non-PB
-    // mode, we'll get the NodeId salt stored on-disk, and if we try to
-    // open a PB mode origin-pair, we'll re-generate new salt.
-    mTempNodeIds.Clear();
-  } else if (!strcmp("browser:purge-session-history", aTopic)) {
-    // Clear everything!
-    if (!aSomeData || nsDependentString(aSomeData).IsEmpty()) {
-      return GMPDispatch(NS_NewRunnableMethod(
-          this, &GoannaMediaPluginService::ClearStorage));
-    }
-
-    // Clear nodeIds/records modified after |t|.
-    nsresult rv;
-    PRTime t = nsDependentString(aSomeData).ToInteger64(&rv, 10);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-    return GMPDispatch(NS_NewRunnableMethodWithArg<PRTime>(
-        this, &GoannaMediaPluginService::ClearRecentHistoryOnGMPThread, t));
-  }
-
-  return NS_OK;
-}
-
-nsresult
-GoannaMediaPluginService::GMPDispatch(nsIRunnable* event, uint32_t flags)
-{
-  nsCOMPtr<nsIRunnable> r(event);
-  nsCOMPtr<nsIThread> thread;
-  nsresult rv = GetThread(getter_AddRefs(thread));
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-  return thread->Dispatch(r, flags);
-}
-
-// always call with getter_AddRefs, because it does
-NS_IMETHODIMP
-GoannaMediaPluginService::GetThread(nsIThread** aThread)
-{
-  MOZ_ASSERT(aThread);
-
-  // This can be called from any thread.
-  MutexAutoLock lock(mMutex);
-
-  if (!mGMPThread) {
-    // Don't allow the thread to be created after shutdown has started.
-    if (mShuttingDown) {
-      return NS_ERROR_FAILURE;
-    }
-
-    nsresult rv = NS_NewNamedThread("GMPThread", getter_AddRefs(mGMPThread));
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-
-    // Tell the thread to initialize plugins
-    mGMPThread->Dispatch(NS_NewRunnableMethod(this, &GoannaMediaPluginService::LoadFromEnvironment), NS_DISPATCH_NORMAL);
-  }
-
-  NS_ADDREF(mGMPThread);
-  *aThread = mGMPThread;
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::GetGMPAudioDecoder(nsTArray<nsCString>* aTags,
-                                            const nsACString& aNodeId,
-                                            GMPAudioDecoderProxy** aGMPAD)
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-  NS_ENSURE_ARG(aTags && aTags->Length() > 0);
-  NS_ENSURE_ARG(aGMPAD);
-
-  if (mShuttingDownOnGMPThread) {
-    return NS_ERROR_FAILURE;
-  }
-
-  nsRefPtr<GMPParent> gmp = SelectPluginForAPI(aNodeId,
-                                               NS_LITERAL_CSTRING(GMP_API_AUDIO_DECODER),
-                                               *aTags);
-  if (!gmp) {
-    return NS_ERROR_FAILURE;
-  }
-
-  GMPAudioDecoderParent* gmpADP;
-  nsresult rv = gmp->GetGMPAudioDecoder(&gmpADP);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  *aGMPAD = gmpADP;
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::GetGMPVideoDecoder(nsTArray<nsCString>* aTags,
-                                            const nsACString& aNodeId,
-                                            GMPVideoHost** aOutVideoHost,
-                                            GMPVideoDecoderProxy** aGMPVD)
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-  NS_ENSURE_ARG(aTags && aTags->Length() > 0);
-  NS_ENSURE_ARG(aOutVideoHost);
-  NS_ENSURE_ARG(aGMPVD);
-
-  if (mShuttingDownOnGMPThread) {
-    return NS_ERROR_FAILURE;
-  }
-
-  nsRefPtr<GMPParent> gmp = SelectPluginForAPI(aNodeId,
-                                               NS_LITERAL_CSTRING(GMP_API_VIDEO_DECODER),
-                                               *aTags);
-#ifdef PR_LOGGING
-  nsCString api = (*aTags)[0];
-  LOGD(("%s: %p returning %p for api %s", __FUNCTION__, (void *)this, (void *)gmp, api.get()));
-#endif
-  if (!gmp) {
-    return NS_ERROR_FAILURE;
-  }
-
-
-  GMPVideoDecoderParent* gmpVDP;
-  nsresult rv = gmp->GetGMPVideoDecoder(&gmpVDP);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  *aGMPVD = gmpVDP;
-  *aOutVideoHost = &gmpVDP->Host();
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::GetGMPVideoEncoder(nsTArray<nsCString>* aTags,
-                                            const nsACString& aNodeId,
-                                            GMPVideoHost** aOutVideoHost,
-                                            GMPVideoEncoderProxy** aGMPVE)
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-  NS_ENSURE_ARG(aTags && aTags->Length() > 0);
-  NS_ENSURE_ARG(aOutVideoHost);
-  NS_ENSURE_ARG(aGMPVE);
-
-  if (mShuttingDownOnGMPThread) {
-    return NS_ERROR_FAILURE;
-  }
-
-  nsRefPtr<GMPParent> gmp = SelectPluginForAPI(aNodeId,
-                                               NS_LITERAL_CSTRING(GMP_API_VIDEO_ENCODER),
-                                               *aTags);
-#ifdef PR_LOGGING
-  nsCString api = (*aTags)[0];
-  LOGD(("%s: %p returning %p for api %s", __FUNCTION__, (void *)this, (void *)gmp, api.get()));
-#endif
-  if (!gmp) {
-    return NS_ERROR_FAILURE;
-  }
-
-  GMPVideoEncoderParent* gmpVEP;
-  nsresult rv = gmp->GetGMPVideoEncoder(&gmpVEP);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  *aGMPVE = gmpVEP;
-  *aOutVideoHost = &gmpVEP->Host();
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::GetGMPDecryptor(nsTArray<nsCString>* aTags,
-                                         const nsACString& aNodeId,
-                                         GMPDecryptorProxy** aDecryptor)
-{
-#if defined(XP_LINUX) && defined(MOZ_GMP_SANDBOX)
-  if (!SandboxInfo::Get().CanSandboxMedia()) {
-    NS_WARNING("GoannaMediaPluginService::GetGMPDecryptor: "
-               "EME decryption not available without sandboxing support.");
-    return NS_ERROR_NOT_AVAILABLE;
-  }
-#endif
-
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-  NS_ENSURE_ARG(aTags && aTags->Length() > 0);
-  NS_ENSURE_ARG(aDecryptor);
-
-  if (mShuttingDownOnGMPThread) {
-    return NS_ERROR_FAILURE;
-  }
-
-  nsRefPtr<GMPParent> gmp = SelectPluginForAPI(aNodeId,
-                                               NS_LITERAL_CSTRING(GMP_API_DECRYPTOR),
-                                               *aTags);
-
-  if (!gmp) {
-    // XXX to remove in bug 1147692
-    gmp = SelectPluginForAPI(aNodeId,
-                             NS_LITERAL_CSTRING(GMP_API_DECRYPTOR_COMPAT),
-                             *aTags);
-  }
-
-  if (!gmp) {
-    return NS_ERROR_FAILURE;
-  }
-
-  GMPDecryptorParent* ksp;
-  nsresult rv = gmp->GetGMPDecryptor(&ksp);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  *aDecryptor = static_cast<GMPDecryptorProxy*>(ksp);
-
-  return NS_OK;
-}
-
-void
-GoannaMediaPluginService::AsyncShutdownNeeded(GMPParent* aParent)
-{
-  LOGD(("%s::%s %p", __CLASS__, __FUNCTION__, aParent));
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-
-  MOZ_ASSERT(!mAsyncShutdownPlugins.Contains(aParent));
-  mAsyncShutdownPlugins.AppendElement(aParent);
-}
-
-void
-GoannaMediaPluginService::AsyncShutdownComplete(GMPParent* aParent)
-{
-  LOGD(("%s::%s %p", __CLASS__, __FUNCTION__, aParent));
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-
-  mAsyncShutdownPlugins.RemoveElement(aParent);
-  if (mAsyncShutdownPlugins.IsEmpty() && mShuttingDownOnGMPThread) {
-    // The main thread may be waiting for async shutdown of plugins,
-    // which has completed. Break the main thread out of its waiting loop.
-    nsRefPtr<nsIRunnable> task(NS_NewRunnableMethod(
-      this, &GoannaMediaPluginService::SetAsyncShutdownComplete));
-    NS_DispatchToMainThread(task);
-  }
-}
-
-void
-GoannaMediaPluginService::SetAsyncShutdownComplete()
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  mWaitingForPluginsAsyncShutdown = false;
-}
-
-void
-GoannaMediaPluginService::UnloadPlugins()
-{
-  LOGD(("%s::%s async_shutdown=%d", __CLASS__, __FUNCTION__,
-        mAsyncShutdownPlugins.Length()));
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-
-  MOZ_ASSERT(!mShuttingDownOnGMPThread);
-  mShuttingDownOnGMPThread = true;
-
-  {
-    MutexAutoLock lock(mMutex);
-    // Note: CloseActive is async; it will actually finish
-    // shutting down when all the plugins have unloaded.
-    for (size_t i = 0; i < mPlugins.Length(); i++) {
-      mPlugins[i]->CloseActive(true);
-    }
-    mPlugins.Clear();
-  }
-
-  if (mAsyncShutdownPlugins.IsEmpty()) {
-    nsRefPtr<nsIRunnable> task(NS_NewRunnableMethod(
-      this, &GoannaMediaPluginService::SetAsyncShutdownComplete));
-    NS_DispatchToMainThread(task);
-  }
-}
-
-void
-GoannaMediaPluginService::CrashPlugins()
-{
-  LOGD(("%s::%s", __CLASS__, __FUNCTION__));
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-
-  MutexAutoLock lock(mMutex);
-  for (size_t i = 0; i < mPlugins.Length(); i++) {
-    mPlugins[i]->Crash();
-  }
-}
-
-void
-GoannaMediaPluginService::LoadFromEnvironment()
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-
-  const char* env = PR_GetEnv("MOZ_GMP_PATH");
-  if (!env || !*env) {
-    return;
-  }
-
-  nsString allpaths;
-  if (NS_WARN_IF(NS_FAILED(NS_CopyNativeToUnicode(nsDependentCString(env), allpaths)))) {
-    return;
-  }
-
-  uint32_t pos = 0;
-  while (pos < allpaths.Length()) {
-    // Loop over multiple path entries separated by colons (*nix) or
-    // semicolons (Windows)
-    int32_t next = allpaths.FindChar(XPCOM_ENV_PATH_SEPARATOR[0], pos);
-    if (next == -1) {
-      AddOnGMPThread(nsDependentSubstring(allpaths, pos));
-      break;
-    } else {
-      AddOnGMPThread(nsDependentSubstring(allpaths, pos, next - pos));
-      pos = next + 1;
-    }
-  }
-
-  mScannedPluginOnDisk = true;
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::PathRunnable::Run()
-{
-  if (mOperation == ADD) {
-    mService->AddOnGMPThread(mPath);
-  } else {
-    mService->RemoveOnGMPThread(mPath,
-                                mOperation == REMOVE_AND_DELETE_FROM_DISK,
-                                mDefer);
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::AddPluginDirectory(const nsAString& aDirectory)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  return GMPDispatch(new PathRunnable(this, aDirectory,
-                                      PathRunnable::EOperation::ADD));
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::RemovePluginDirectory(const nsAString& aDirectory)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  return GMPDispatch(new PathRunnable(this, aDirectory,
-                                      PathRunnable::EOperation::REMOVE));
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::RemoveAndDeletePluginDirectory(
-  const nsAString& aDirectory, const bool aDefer)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  return GMPDispatch(
-    new PathRunnable(this, aDirectory,
-                     PathRunnable::EOperation::REMOVE_AND_DELETE_FROM_DISK,
-                     aDefer));
-}
-
-class DummyRunnable : public nsRunnable {
-public:
-  NS_IMETHOD Run() { return NS_OK; }
-};
-
-NS_IMETHODIMP
-GoannaMediaPluginService::GetPluginVersionForAPI(const nsACString& aAPI,
-                                                nsTArray<nsCString>* aTags,
-                                                nsACString& aOutVersion)
-{
-  NS_ENSURE_ARG(aTags && aTags->Length() > 0);
-  NS_ENSURE_ARG(aOutVersion.IsEmpty());
-
-  nsresult rv = EnsurePluginsOnDiskScanned();
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Failed to load GMPs from disk.");
-    return rv;
-  }
-
-  {
-    MutexAutoLock lock(mMutex);
-    nsCString api(aAPI);
-    size_t index = 0;
-
-    // We must parse the version number into a float for comparison. Yuck.
-    double maxParsedVersion = -1.;
-
-    while (GMPParent* gmp = FindPluginForAPIFrom(index, api, *aTags, &index)) {
-      double parsedVersion = atof(gmp->GetVersion().get());
-      if (maxParsedVersion < 0 || parsedVersion > maxParsedVersion) {
-        maxParsedVersion = parsedVersion;
-        aOutVersion = gmp->GetVersion();
-      }
-      index++;
-    }
-
-    if (maxParsedVersion < 0) {
-      return NS_ERROR_FAILURE;
-    }
-  }
-
-  return NS_OK;
-}
-
-nsresult
-GoannaMediaPluginService::EnsurePluginsOnDiskScanned()
-{
-  const char* env = nullptr;
-  if (!mScannedPluginOnDisk && (env = PR_GetEnv("MOZ_GMP_PATH")) && *env) {
-    // We have a MOZ_GMP_PATH environment variable which may specify the
-    // location of plugins to load, and we haven't yet scanned the disk to
-    // see if there are plugins there. Get the GMP thread, which will
-    // cause an event to be dispatched to which scans for plugins. We
-    // dispatch a sync event to the GMP thread here in order to wait until
-    // after the GMP thread has scanned any paths in MOZ_GMP_PATH.
-    nsresult rv = GMPDispatch(new DummyRunnable(), NS_DISPATCH_SYNC);
-    NS_ENSURE_SUCCESS(rv, rv);
-    MOZ_ASSERT(mScannedPluginOnDisk, "Should have scanned MOZ_GMP_PATH by now");
-  }
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::HasPluginForAPI(const nsACString& aAPI,
-                                         nsTArray<nsCString>* aTags,
-                                         bool* aOutHavePlugin)
-{
-  NS_ENSURE_ARG(aTags && aTags->Length() > 0);
-  NS_ENSURE_ARG(aOutHavePlugin);
-
-  nsresult rv = EnsurePluginsOnDiskScanned();
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Failed to load GMPs from disk.");
-    return rv;
-  }
-
-  {
-    MutexAutoLock lock(mMutex);
-    nsCString api(aAPI);
-    GMPParent* gmp = FindPluginForAPIFrom(0, api, *aTags, nullptr);
-    *aOutHavePlugin = (gmp != nullptr);
-  }
-
-  return NS_OK;
-}
-
-GMPParent*
-GoannaMediaPluginService::FindPluginForAPIFrom(size_t aSearchStartIndex,
-                                              const nsCString& aAPI,
-                                              const nsTArray<nsCString>& aTags,
-                                              size_t* aOutPluginIndex)
-{
-  mMutex.AssertCurrentThreadOwns();
-  for (size_t i = aSearchStartIndex; i < mPlugins.Length(); i++) {
-    GMPParent* gmp = mPlugins[i];
-    bool supportsAllTags = true;
-    for (size_t t = 0; t < aTags.Length(); t++) {
-      const nsCString& tag = aTags.ElementAt(t);
-      if (!gmp->SupportsAPI(aAPI, tag)) {
-        supportsAllTags = false;
-        break;
-      }
-    }
-    if (!supportsAllTags) {
-      continue;
-    }
-    if (aOutPluginIndex) {
-      *aOutPluginIndex = i;
-    }
-    return gmp;
-  }
-  return nullptr;
-}
-
-GMPParent*
-GoannaMediaPluginService::SelectPluginForAPI(const nsACString& aNodeId,
-                                            const nsCString& aAPI,
-                                            const nsTArray<nsCString>& aTags)
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread,
-             "Can't clone GMP plugins on non-GMP threads.");
-
-  GMPParent* gmpToClone = nullptr;
-  {
-    MutexAutoLock lock(mMutex);
-    size_t index = 0;
-    GMPParent* gmp = nullptr;
-    while ((gmp = FindPluginForAPIFrom(index, aAPI, aTags, &index))) {
-      if (aNodeId.IsEmpty()) {
-        if (gmp->CanBeSharedCrossNodeIds()) {
-          return gmp;
-        }
-      } else if (gmp->CanBeUsedFrom(aNodeId)) {
-        MOZ_ASSERT(!aNodeId.IsEmpty());
-        gmp->SetNodeId(aNodeId);
-        return gmp;
-      }
-
-      if (!gmpToClone ||
-          (gmpToClone->IsMarkedForDeletion() && !gmp->IsMarkedForDeletion())) {
-        // This GMP has the correct type but has the wrong nodeId; hold on to it
-        // in case we need to clone it.
-        // Prefer GMPs in-use for the case where an upgraded plugin version is
-        // waiting for the old one to die. If the old plugin is in use, we
-        // should continue using it so that any persistent state remains
-        // consistent. Otherwise, just check that the plugin isn't scheduled
-        // for deletion.
-        gmpToClone = gmp;
-      }
-      // Loop around and try the next plugin; it may be usable from aNodeId.
-      index++;
-    }
-  }
-
-  // Plugin exists, but we can't use it due to cross-origin separation. Create a
-  // new one.
-  if (gmpToClone) {
-    GMPParent* clone = ClonePlugin(gmpToClone);
-    if (!aNodeId.IsEmpty()) {
-      clone->SetNodeId(aNodeId);
-    }
-    return clone;
-  }
-
-  return nullptr;
-}
-
-class CreateGMPParentTask : public nsRunnable {
-public:
-  NS_IMETHOD Run() {
-    MOZ_ASSERT(NS_IsMainThread());
-#if defined(XP_LINUX) && defined(MOZ_GMP_SANDBOX)
-    if (!SandboxInfo::Get().CanSandboxMedia()) {
-      if (!Preferences::GetBool("media.gmp.insecure.allow")) {
-        NS_WARNING("Denying media plugin load due to lack of sandboxing.");
-        return NS_ERROR_NOT_AVAILABLE;
-      }
-      NS_WARNING("Loading media plugin despite lack of sandboxing.");
-    }
-#endif
-    mParent = new GMPParent();
-    return NS_OK;
-  }
-  already_AddRefed<GMPParent> GetParent() {
-    return mParent.forget();
-  }
-private:
-  nsRefPtr<GMPParent> mParent;
-};
-
-GMPParent*
-GoannaMediaPluginService::ClonePlugin(const GMPParent* aOriginal)
-{
-  MOZ_ASSERT(aOriginal);
-
-  // The GMPParent inherits from IToplevelProtocol, which must be created
-  // on the main thread to be threadsafe. See Bug 1035653.
-  nsRefPtr<CreateGMPParentTask> task(new CreateGMPParentTask());
-  if (!NS_IsMainThread()) {
-    nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
-    MOZ_ASSERT(mainThread);
-    mozilla::SyncRunnable::DispatchToThread(mainThread, task);
-  }
-
-  nsRefPtr<GMPParent> gmp = task->GetParent();
-  nsresult rv = gmp->CloneFrom(aOriginal);
-
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Can't Create GMPParent");
-    return nullptr;
-  }
-
-  MutexAutoLock lock(mMutex);
-  mPlugins.AppendElement(gmp);
-
-  return gmp.get();
-}
-
-class NotifyObserversTask final : public nsRunnable {
-public:
-  explicit NotifyObserversTask(const char* aTopic)
-    : mTopic(aTopic)
-  {}
-  NS_IMETHOD Run() override {
-    MOZ_ASSERT(NS_IsMainThread());
-    nsCOMPtr<nsIObserverService> obsService = mozilla::services::GetObserverService();
-    MOZ_ASSERT(obsService);
-    if (obsService) {
-      obsService->NotifyObservers(nullptr, mTopic, nullptr);
-    }
-    return NS_OK;
-  }
-private:
-  ~NotifyObserversTask() {}
-  const char* mTopic;
-};
-
-void
-GoannaMediaPluginService::AddOnGMPThread(const nsAString& aDirectory)
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-  LOGD(("%s::%s: %s", __CLASS__, __FUNCTION__, NS_LossyConvertUTF16toASCII(aDirectory).get()));
-
-  nsCOMPtr<nsIFile> directory;
-  nsresult rv = NS_NewLocalFile(aDirectory, false, getter_AddRefs(directory));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return;
-  }
-
-  // The GMPParent inherits from IToplevelProtocol, which must be created
-  // on the main thread to be threadsafe. See Bug 1035653.
-  nsRefPtr<CreateGMPParentTask> task(new CreateGMPParentTask());
-  nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
-  MOZ_ASSERT(mainThread);
-  mozilla::SyncRunnable::DispatchToThread(mainThread, task);
-  nsRefPtr<GMPParent> gmp = task->GetParent();
-  rv = gmp ? gmp->Init(this, directory) : NS_ERROR_NOT_AVAILABLE;
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Can't Create GMPParent");
-    return;
-  }
-
-  {
-    MutexAutoLock lock(mMutex);
-    mPlugins.AppendElement(gmp);
-  }
-
-  NS_DispatchToMainThread(new NotifyObserversTask("gmp-path-added"), NS_DISPATCH_NORMAL);
-}
-
-void
-GoannaMediaPluginService::RemoveOnGMPThread(const nsAString& aDirectory,
-                                           const bool aDeleteFromDisk,
-                                           const bool aCanDefer)
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-  LOGD(("%s::%s: %s", __CLASS__, __FUNCTION__, NS_LossyConvertUTF16toASCII(aDirectory).get()));
-
-  nsCOMPtr<nsIFile> directory;
-  nsresult rv = NS_NewLocalFile(aDirectory, false, getter_AddRefs(directory));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return;
-  }
-
-  MutexAutoLock lock(mMutex);
-  for (size_t i = mPlugins.Length() - 1; i < mPlugins.Length(); i--) {
-    nsCOMPtr<nsIFile> pluginpath = mPlugins[i]->GetDirectory();
-    bool equals;
-    if (NS_FAILED(directory->Equals(pluginpath, &equals)) || !equals) {
-      continue;
-    }
-
-    nsRefPtr<GMPParent> gmp = mPlugins[i];
-    if (aDeleteFromDisk && gmp->State() != GMPStateNotLoaded) {
-      // We have to wait for the child process to release its lib handle
-      // before we can delete the GMP.
-      gmp->MarkForDeletion();
-
-      if (!mPluginsWaitingForDeletion.Contains(aDirectory)) {
-        mPluginsWaitingForDeletion.AppendElement(aDirectory);
-      }
-    }
-
-    if (gmp->State() == GMPStateNotLoaded || !aCanDefer) {
-      // GMP not in use or shutdown is being forced; can shut it down now.
-      gmp->AbortAsyncShutdown();
-      gmp->CloseActive(true);
-      mPlugins.RemoveElementAt(i);
-    }
-  }
-
-  if (aDeleteFromDisk) {
-    if (NS_SUCCEEDED(directory->Remove(true))) {
-      mPluginsWaitingForDeletion.RemoveElement(aDirectory);
-    }
-  }
-}
-
-// May remove when Bug 1043671 is fixed
-static void Dummy(nsRefPtr<GMPParent>& aOnDeathsDoor)
-{
-  // exists solely to do nothing and let the Runnable kill the GMPParent
-  // when done.
-}
-
-void
-GoannaMediaPluginService::PluginTerminated(const nsRefPtr<GMPParent>& aPlugin)
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-
-  if (aPlugin->IsMarkedForDeletion()) {
-    nsCString path8;
-    nsRefPtr<nsIFile> dir = aPlugin->GetDirectory();
-    nsresult rv = dir->GetNativePath(path8);
-    NS_ENSURE_SUCCESS_VOID(rv);
-
-    nsString path = NS_ConvertUTF8toUTF16(path8);
-    if (mPluginsWaitingForDeletion.Contains(path)) {
-      RemoveOnGMPThread(path, true /* delete */, true /* can defer */);
-    }
-  }
-}
-
-void
-GoannaMediaPluginService::ReAddOnGMPThread(const nsRefPtr<GMPParent>& aOld)
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-  LOGD(("%s::%s: %p", __CLASS__, __FUNCTION__, (void*) aOld));
-
-  nsRefPtr<GMPParent> gmp;
-  if (!mShuttingDownOnGMPThread) {
-    // Don't re-add plugin if we're shutting down. Let the old plugin die.
-    gmp = ClonePlugin(aOld);
-  }
-  // Note: both are now in the list
-  // Until we give up the GMPThread, we're safe even if we unlock temporarily
-  // since off-main-thread users just test for existance; they don't modify the list.
-  MutexAutoLock lock(mMutex);
-  mPlugins.RemoveElement(aOld);
-
-  // Schedule aOld to be destroyed.  We can't destroy it from here since we
-  // may be inside ActorDestroyed() for it.
-  NS_DispatchToCurrentThread(WrapRunnableNM(&Dummy, aOld));
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::GetStorageDir(nsIFile** aOutFile)
-{
-#ifndef MOZ_WIDGET_GONK
-  if (NS_WARN_IF(!mStorageBaseDir)) {
-    return NS_ERROR_FAILURE;
-  }
-  return mStorageBaseDir->Clone(aOutFile);
-#else
-  return NS_ERROR_NOT_IMPLEMENTED;
-#endif
-}
-
-static nsresult
-WriteToFile(nsIFile* aPath,
-            const nsCString& aFileName,
-            const nsCString& aData)
-{
-  nsCOMPtr<nsIFile> path;
-  nsresult rv = aPath->Clone(getter_AddRefs(path));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  rv = path->AppendNative(aFileName);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  PRFileDesc* f = nullptr;
-  rv = path->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE, PR_IRWXU, &f);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  int32_t len = PR_Write(f, aData.get(), aData.Length());
-  PR_Close(f);
-  if (NS_WARN_IF(len < 0 || (size_t)len != aData.Length())) {
-    return NS_ERROR_FAILURE;
-  }
-
-  return NS_OK;
-}
-
-static nsresult
-ReadFromFile(nsIFile* aPath,
-             const nsACString& aFileName,
-             nsACString& aOutData,
-             int32_t aMaxLength)
-{
-  nsCOMPtr<nsIFile> path;
-  nsresult rv = aPath->Clone(getter_AddRefs(path));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  rv = path->AppendNative(aFileName);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  PRFileDesc* f = nullptr;
-  rv = path->OpenNSPRFileDesc(PR_RDONLY | PR_CREATE_FILE, PR_IRWXU, &f);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  auto size = PR_Seek(f, 0, PR_SEEK_END);
-  PR_Seek(f, 0, PR_SEEK_SET);
-
-  if (size > aMaxLength) {
-    return NS_ERROR_FAILURE;
-  }
-  aOutData.SetLength(size);
-
-  auto len = PR_Read(f, aOutData.BeginWriting(), size);
-  PR_Close(f);
-  if (NS_WARN_IF(len != size)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  return NS_OK;
-}
-
-nsresult
-ReadSalt(nsIFile* aPath, nsACString& aOutData)
-{
-  return ReadFromFile(aPath, NS_LITERAL_CSTRING("salt"),
-                      aOutData, NodeIdSaltLength);
-
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::IsPersistentStorageAllowed(const nsACString& aNodeId,
-                                                    bool* aOutAllowed)
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-  NS_ENSURE_ARG(aOutAllowed);
-  *aOutAllowed = mPersistentStorageAllowed.Get(aNodeId);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::GetNodeId(const nsAString& aOrigin,
-                                   const nsAString& aTopLevelOrigin,
-                                   bool aInPrivateBrowsing,
-                                   nsACString& aOutId)
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-  LOGD(("%s::%s: (%s, %s), %s", __CLASS__, __FUNCTION__,
-       NS_ConvertUTF16toUTF8(aOrigin).get(),
-       NS_ConvertUTF16toUTF8(aTopLevelOrigin).get(),
-       (aInPrivateBrowsing ? "PrivateBrowsing" : "NonPrivateBrowsing")));
-
-#ifdef MOZ_WIDGET_GONK
-  NS_WARNING("GoannaMediaPluginService::GetNodeId Not implemented on B2G");
-  return NS_ERROR_NOT_IMPLEMENTED;
-#endif
-
-  nsresult rv;
-
-  if (aOrigin.EqualsLiteral("null") ||
-      aOrigin.IsEmpty() ||
-      aTopLevelOrigin.EqualsLiteral("null") ||
-      aTopLevelOrigin.IsEmpty()) {
-    // At least one of the (origin, topLevelOrigin) is null or empty;
-    // probably a local file. Generate a random node id, and don't store
-    // it so that the GMP's storage is temporary and not shared.
-    nsAutoCString salt;
-    rv = GenerateRandomPathName(salt, NodeIdSaltLength);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
-    }
-    aOutId = salt;
-    mPersistentStorageAllowed.Put(salt, false);
-    return NS_OK;
-  }
-
-  const uint32_t hash = AddToHash(HashString(aOrigin),
-                                  HashString(aTopLevelOrigin));
-
-  if (aInPrivateBrowsing) {
-    // For PB mode, we store the node id, indexed by the origin pair,
-    // so that if the same origin pair is opened in this session, it gets
-    // the same node id.
-    nsCString* salt = nullptr;
-    if (!(salt = mTempNodeIds.Get(hash))) {
-      // No salt stored, generate and temporarily store some for this id.
-      nsAutoCString newSalt;
-      rv = GenerateRandomPathName(newSalt, NodeIdSaltLength);
-      if (NS_WARN_IF(NS_FAILED(rv))) {
-        return rv;
-      }
-      salt = new nsCString(newSalt);
-      mTempNodeIds.Put(hash, salt);
-      mPersistentStorageAllowed.Put(*salt, false);
-    }
-    aOutId = *salt;
-    return NS_OK;
-  }
-
-  // Otherwise, try to see if we've previously generated and stored salt
-  // for this origin pair.
-  nsCOMPtr<nsIFile> path; // $profileDir/gmp/
-  rv = GetStorageDir(getter_AddRefs(path));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  rv = path->AppendNative(NS_LITERAL_CSTRING("id"));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  // $profileDir/gmp/id/
-  rv = path->Create(nsIFile::DIRECTORY_TYPE, 0700);
-  if (rv != NS_ERROR_FILE_ALREADY_EXISTS && NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  nsAutoCString hashStr;
-  hashStr.AppendInt((int64_t)hash);
-
-  // $profileDir/gmp/id/$hash
-  rv = path->AppendNative(hashStr);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  rv = path->Create(nsIFile::DIRECTORY_TYPE, 0700);
-  if (rv != NS_ERROR_FILE_ALREADY_EXISTS && NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  nsCOMPtr<nsIFile> saltFile;
-  rv = path->Clone(getter_AddRefs(saltFile));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  rv = saltFile->AppendNative(NS_LITERAL_CSTRING("salt"));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  nsAutoCString salt;
-  bool exists = false;
-  rv = saltFile->Exists(&exists);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-  if (!exists) {
-    // No stored salt for this origin. Generate salt, and store it and
-    // the origin on disk.
-    nsresult rv = GenerateRandomPathName(salt, NodeIdSaltLength);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
-    }
-    MOZ_ASSERT(salt.Length() == NodeIdSaltLength);
-
-    // $profileDir/gmp/id/$hash/salt
-    rv = WriteToFile(path, NS_LITERAL_CSTRING("salt"), salt);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
-    }
-
-    // $profileDir/gmp/id/$hash/origin
-    rv = WriteToFile(path,
-                     NS_LITERAL_CSTRING("origin"),
-                     NS_ConvertUTF16toUTF8(aOrigin));
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
-    }
-
-    // $profileDir/gmp/id/$hash/topLevelOrigin
-    rv = WriteToFile(path,
-                     NS_LITERAL_CSTRING("topLevelOrigin"),
-                     NS_ConvertUTF16toUTF8(aTopLevelOrigin));
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
-    }
-
-  } else {
-    rv = ReadSalt(path, salt);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
-    }
-  }
-
-  aOutId = salt;
-  mPersistentStorageAllowed.Put(salt, true);
-
-  return NS_OK;
-}
-
-static bool
-ExtractHostName(const nsACString& aOrigin, nsACString& aOutData)
-{
-  nsCString str;
-  str.Assign(aOrigin);
-  int begin = str.Find("://");
-  // The scheme is missing!
-  if (begin == -1) {
-    return false;
-  }
-
-  int end = str.RFind(":");
-  // Remove the port number
-  if (end != begin) {
-    str.SetLength(end);
-  }
-
-  nsDependentCSubstring host(str, begin + 3);
-  aOutData.Assign(host);
-  return true;
-}
-
-bool
-MatchOrigin(nsIFile* aPath, const nsACString& aSite)
-{
-  // http://en.wikipedia.org/wiki/Domain_Name_System#Domain_name_syntax
-  static const uint32_t MaxDomainLength = 253;
-
-  nsresult rv;
-  nsCString str;
-  rv = ReadFromFile(aPath, NS_LITERAL_CSTRING("origin"), str, MaxDomainLength);
-  if (NS_SUCCEEDED(rv) && ExtractHostName(str, str) && str.Equals(aSite)) {
-    return true;
-  }
-  rv = ReadFromFile(aPath, NS_LITERAL_CSTRING("topLevelOrigin"), str, MaxDomainLength);
-  if (NS_SUCCEEDED(rv) && ExtractHostName(str, str) && str.Equals(aSite)) {
-    return true;
-  }
-  return false;
-}
-
-template<typename T> static void
-KillPlugins(const nsTArray<nsRefPtr<GMPParent>>& aPlugins,
-            Mutex& aMutex, T&& aFilter)
-{
-  // Shutdown the plugins when |aFilter| evaluates to true.
-  // After we clear storage data, node IDs will become invalid and shouldn't be
-  // used anymore. We need to kill plugins with such nodeIDs.
-  // Note: we can't shut them down while holding the lock,
-  // as the lock is not re-entrant and shutdown requires taking the lock.
-  // The plugin list is only edited on the GMP thread, so this should be OK.
-  nsTArray<nsRefPtr<GMPParent>> pluginsToKill;
-  {
-    MutexAutoLock lock(aMutex);
-    for (size_t i = 0; i < aPlugins.Length(); i++) {
-      nsRefPtr<GMPParent> parent(aPlugins[i]);
-      if (aFilter(parent)) {
-        pluginsToKill.AppendElement(parent);
-      }
-    }
-  }
-
-  for (size_t i = 0; i < pluginsToKill.Length(); i++) {
-    pluginsToKill[i]->CloseActive(false);
-    // Abort async shutdown because we're going to wipe the plugin's storage,
-    // so we don't want it writing more data in its async shutdown path.
-    pluginsToKill[i]->AbortAsyncShutdown();
-  }
-}
-
-static nsresult
-DeleteDir(nsIFile* aPath)
-{
-  bool exists = false;
-  nsresult rv = aPath->Exists(&exists);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-  if (exists) {
-    return aPath->Remove(true);
-  }
-  return NS_OK;
-}
-
-struct NodeFilter {
-  explicit NodeFilter(const nsTArray<nsCString>& nodeIDs) : mNodeIDs(nodeIDs) {}
-  bool operator()(GMPParent* aParent) {
-    return mNodeIDs.Contains(aParent->GetNodeId());
-  }
-private:
-  const nsTArray<nsCString>& mNodeIDs;
-};
-
-void
-GoannaMediaPluginService::ClearNodeIdAndPlugin(DirectoryFilter& aFilter)
-{
-  nsresult rv;
-  nsCOMPtr<nsIFile> path;
-
-  // $profileDir/gmp/
-  rv = GetStorageDir(getter_AddRefs(path));
-  if (NS_FAILED(rv)) {
-    return;
-  }
-
-  // $profileDir/gmp/id/
-  rv = path->AppendNative(NS_LITERAL_CSTRING("id"));
-  if (NS_FAILED(rv)) {
-    return;
-  }
-
-  // Iterate all sub-folders of $profileDir/gmp/id/
-  nsCOMPtr<nsISimpleEnumerator> iter;
-  rv = path->GetDirectoryEntries(getter_AddRefs(iter));
-  if (NS_FAILED(rv)) {
-    return;
-  }
-
-  bool hasMore = false;
-  nsTArray<nsCString> nodeIDsToClear;
-  while (NS_SUCCEEDED(iter->HasMoreElements(&hasMore)) && hasMore) {
-    nsCOMPtr<nsISupports> supports;
-    rv = iter->GetNext(getter_AddRefs(supports));
-    if (NS_FAILED(rv)) {
-      continue;
-    }
-
-    // $profileDir/gmp/id/$hash
-    nsCOMPtr<nsIFile> dirEntry(do_QueryInterface(supports, &rv));
-    if (NS_FAILED(rv)) {
-      continue;
-    }
-
-    // Skip non-directory files.
-    bool isDirectory = false;
-    rv = dirEntry->IsDirectory(&isDirectory);
-    if (NS_FAILED(rv) || !isDirectory) {
-      continue;
-    }
-
-    if (!aFilter(dirEntry)) {
-      continue;
-    }
-
-    nsAutoCString salt;
-    if (NS_SUCCEEDED(ReadSalt(dirEntry, salt))) {
-      // Keep node IDs to clear data/plugins associated with them later.
-      nodeIDsToClear.AppendElement(salt);
-      // Also remove node IDs from the table.
-      mPersistentStorageAllowed.Remove(salt);
-    }
-    // Now we can remove the directory for the origin pair.
-    if (NS_FAILED(dirEntry->Remove(true))) {
-      NS_WARNING("Failed to delete the directory for the origin pair");
-    }
-  }
-
-  // Kill plugins that have node IDs to be cleared.
-  KillPlugins(mPlugins, mMutex, NodeFilter(nodeIDsToClear));
-
-  // Clear all matching $profileDir/gmp/storage/$nodeId/
-  rv = GetStorageDir(getter_AddRefs(path));
-  if (NS_FAILED(rv)) {
-    return;
-  }
-
-  rv = path->AppendNative(NS_LITERAL_CSTRING("storage"));
-  if (NS_FAILED(rv)) {
-    return;
-  }
-
-  for (size_t i = 0; i < nodeIDsToClear.Length(); i++) {
-    nsCOMPtr<nsIFile> dirEntry;
-    rv = path->Clone(getter_AddRefs(dirEntry));
-    if (NS_FAILED(rv)) {
-      continue;
-    }
-
-    rv = dirEntry->AppendNative(nodeIDsToClear[i]);
-    if (NS_FAILED(rv)) {
-      continue;
-    }
-
-    if (NS_FAILED(DeleteDir(dirEntry))) {
-      NS_WARNING("Failed to delete GMP storage directory for the node");
-    }
-  }
-}
-
-void
-GoannaMediaPluginService::ForgetThisSiteOnGMPThread(const nsACString& aSite)
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-  LOGD(("%s::%s: origin=%s", __CLASS__, __FUNCTION__, aSite.Data()));
-
-  struct OriginFilter : public DirectoryFilter {
-    explicit OriginFilter(const nsACString& aSite) : mSite(aSite) {}
-    virtual bool operator()(nsIFile* aPath) {
-      return MatchOrigin(aPath, mSite);
-    }
-  private:
-    const nsACString& mSite;
-  } filter(aSite);
-
-  ClearNodeIdAndPlugin(filter);
-}
-
-void
-GoannaMediaPluginService::ClearRecentHistoryOnGMPThread(PRTime aSince)
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-  LOGD(("%s::%s: since=%lld", __CLASS__, __FUNCTION__, (int64_t)aSince));
-
-  nsCOMPtr<nsIFile> storagePath;
-  nsCOMPtr<nsIFile> temp;
-  if (NS_SUCCEEDED(GetStorageDir(getter_AddRefs(temp))) &&
-      NS_SUCCEEDED(temp->AppendNative(NS_LITERAL_CSTRING("storage")))) {
-    storagePath = temp.forget();
-  }
-
-  struct MTimeFilter : public DirectoryFilter {
-    explicit MTimeFilter(PRTime aSince, already_AddRefed<nsIFile> aPath)
-      : mSince(aSince), mStoragePath(aPath) {}
-
-    // Return true if any files under aPath is modified after |mSince|.
-    bool IsModifiedAfter(nsIFile* aPath) {
-      PRTime lastModified;
-      nsresult rv = aPath->GetLastModifiedTime(&lastModified);
-      if (NS_SUCCEEDED(rv) && lastModified >= mSince) {
-        return true;
-      }
-      // Check sub-directories recursively
-      nsCOMPtr<nsISimpleEnumerator> iter;
-      rv = aPath->GetDirectoryEntries(getter_AddRefs(iter));
-      if (NS_FAILED(rv)) {
-        return false;
-      }
-
-      bool hasMore = false;
-      while (NS_SUCCEEDED(iter->HasMoreElements(&hasMore)) && hasMore) {
-        nsCOMPtr<nsISupports> supports;
-        rv = iter->GetNext(getter_AddRefs(supports));
-        if (NS_FAILED(rv)) {
-          continue;
-        }
-
-        nsCOMPtr<nsIFile> path(do_QueryInterface(supports, &rv));
-        if (NS_FAILED(rv)) {
-          continue;
-        }
-
-        if (IsModifiedAfter(path)) {
-          return true;
-        }
-      }
-      return false;
-    }
-
-    // |aPath| is $profileDir/gmp/id/$hash
-    virtual bool operator()(nsIFile* aPath) {
-      if (IsModifiedAfter(aPath)) {
-        return true;
-      }
-
-      nsAutoCString salt;
-      nsresult rv = ReadSalt(aPath, salt);
-      if (NS_FAILED(rv)) {
-        return false;
-      }
-
-      // $profileDir/gmp/storage/
-      if (!mStoragePath) {
-        return false;
-      }
-      // $profileDir/gmp/storage/$nodeId/
-      nsCOMPtr<nsIFile> path;
-      rv = mStoragePath->Clone(getter_AddRefs(path));
-      if (NS_FAILED(rv)) {
-        return false;
-      }
-
-      rv = path->AppendNative(salt);
-      return NS_SUCCEEDED(rv) && IsModifiedAfter(path);
-    }
-  private:
-    const PRTime mSince;
-    const nsCOMPtr<nsIFile> mStoragePath;
-  } filter(aSince, storagePath.forget());
-
-  ClearNodeIdAndPlugin(filter);
-
-  NS_DispatchToMainThread(new NotifyObserversTask("gmp-clear-storage-complete"), NS_DISPATCH_NORMAL);
-}
-
-NS_IMETHODIMP
-GoannaMediaPluginService::ForgetThisSite(const nsAString& aSite)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  return GMPDispatch(NS_NewRunnableMethodWithArg<nsCString>(
-      this, &GoannaMediaPluginService::ForgetThisSiteOnGMPThread,
-      NS_ConvertUTF16toUTF8(aSite)));
-}
-
-static bool IsNodeIdValid(GMPParent* aParent) {
-  return !aParent->GetNodeId().IsEmpty();
-}
-
-void
-GoannaMediaPluginService::ClearStorage()
-{
-  MOZ_ASSERT(NS_GetCurrentThread() == mGMPThread);
-  LOGD(("%s::%s", __CLASS__, __FUNCTION__));
-
-#ifdef MOZ_WIDGET_GONK
-  NS_WARNING("GoannaMediaPluginService::ClearStorage not implemented on B2G");
-  return;
-#endif
-
-  // Kill plugins with valid nodeIDs.
-  KillPlugins(mPlugins, mMutex, &IsNodeIdValid);
-
-  nsCOMPtr<nsIFile> path; // $profileDir/gmp/
-  nsresult rv = GetStorageDir(getter_AddRefs(path));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return;
-  }
-
-  if (NS_FAILED(DeleteDir(path))) {
-    NS_WARNING("Failed to delete GMP storage directory");
-  }
-  NS_DispatchToMainThread(new NotifyObserversTask("gmp-clear-storage-complete"), NS_DISPATCH_NORMAL);
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPService.h b/dom/media/gmp/GMPService.h
deleted file mode 100644
index 05f7992..0000000
--- a/dom/media/gmp/GMPService.h
+++ /dev/null
@@ -1,204 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPService_h_
-#define GMPService_h_
-
-#include "nsString.h"
-#include "mozIGoannaMediaPluginService.h"
-#include "nsIObserver.h"
-#include "nsTArray.h"
-#include "mozilla/Attributes.h"
-#include "mozilla/Monitor.h"
-#include "nsString.h"
-#include "nsCOMPtr.h"
-#include "nsIThread.h"
-#include "nsThreadUtils.h"
-#include "nsITimer.h"
-#include "nsClassHashtable.h"
-#include "nsDataHashtable.h"
-#include "mozilla/Atomics.h"
-
-template <class> struct already_AddRefed;
-
-namespace mozilla {
-namespace gmp {
-
-class GMPParent;
-
-#define GMP_DEFAULT_ASYNC_SHUTDONW_TIMEOUT 3000
-
-class GoannaMediaPluginService final : public mozIGoannaMediaPluginService
-                                        , public nsIObserver
-{
-public:
-  static already_AddRefed<GoannaMediaPluginService> GetGoannaMediaPluginService();
-
-  GoannaMediaPluginService();
-  nsresult Init();
-
-  NS_DECL_THREADSAFE_ISUPPORTS
-  NS_DECL_MOZIGOANNAMEDIAPLUGINSERVICE
-  NS_DECL_NSIOBSERVER
-
-  void AsyncShutdownNeeded(GMPParent* aParent);
-  void AsyncShutdownComplete(GMPParent* aParent);
-  void AbortAsyncShutdown();
-
-  int32_t AsyncShutdownTimeoutMs();
-
-  class PluginCrashCallback
-  {
-  public:
-    NS_INLINE_DECL_REFCOUNTING(PluginCrashCallback)
-
-    PluginCrashCallback(const nsACString& aPluginId)
-      : mPluginId(aPluginId)
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-    }
-    const nsACString& PluginId() const { return mPluginId; }
-    virtual void Run(const nsACString& aPluginName, const nsAString& aPluginDumpId) = 0;
-    virtual bool IsStillValid() = 0; // False if callback has become useless.
-  protected:
-    virtual ~PluginCrashCallback()
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-    }
-  private:
-    const nsCString mPluginId;
-  };
-  void RemoveObsoletePluginCrashCallbacks(); // Called from add/remove/run.
-  void AddPluginCrashCallback(nsRefPtr<PluginCrashCallback> aPluginCrashCallback);
-  void RemovePluginCrashCallbacks(const nsACString& aPluginId);
-  void RunPluginCrashCallbacks(const nsACString& aPluginId,
-                               const nsACString& aPluginName,
-                               const nsAString& aPluginDumpId);
-
-private:
-  ~GoannaMediaPluginService();
-
-  nsresult GMPDispatch(nsIRunnable* event, uint32_t flags = NS_DISPATCH_NORMAL);
-
-  void ClearStorage();
-
-  GMPParent* SelectPluginForAPI(const nsACString& aNodeId,
-                                const nsCString& aAPI,
-                                const nsTArray<nsCString>& aTags);
-  GMPParent* FindPluginForAPIFrom(size_t aSearchStartIndex,
-                                  const nsCString& aAPI,
-                                  const nsTArray<nsCString>& aTags,
-                                  size_t* aOutPluginIndex);
-
-  void UnloadPlugins();
-  void CrashPlugins();
-  void SetAsyncShutdownComplete();
-
-  void LoadFromEnvironment();
-  void ProcessPossiblePlugin(nsIFile* aDir);
-
-  void AddOnGMPThread(const nsAString& aDirectory);
-  void RemoveOnGMPThread(const nsAString& aDirectory,
-                         const bool aDeleteFromDisk,
-                         const bool aCanDefer);
-
-  nsresult SetAsyncShutdownTimeout();
-
-  struct DirectoryFilter {
-    virtual bool operator()(nsIFile* aPath) = 0;
-    ~DirectoryFilter() {}
-  };
-  void ClearNodeIdAndPlugin(DirectoryFilter& aFilter);
-
-  void ForgetThisSiteOnGMPThread(const nsACString& aOrigin);
-  void ClearRecentHistoryOnGMPThread(PRTime aSince);
-
-protected:
-  friend class GMPParent;
-  void ReAddOnGMPThread(const nsRefPtr<GMPParent>& aOld);
-  void PluginTerminated(const nsRefPtr<GMPParent>& aOld);
-private:
-  GMPParent* ClonePlugin(const GMPParent* aOriginal);
-  nsresult EnsurePluginsOnDiskScanned();
-
-  class PathRunnable : public nsRunnable
-  {
-  public:
-    enum EOperation {
-      ADD,
-      REMOVE,
-      REMOVE_AND_DELETE_FROM_DISK,
-    };
-
-    PathRunnable(GoannaMediaPluginService* aService, const nsAString& aPath,
-                 EOperation aOperation, bool aDefer = false)
-      : mService(aService)
-      , mPath(aPath)
-      , mOperation(aOperation)
-      , mDefer(aDefer)
-    { }
-
-    NS_DECL_NSIRUNNABLE
-
-  private:
-    nsRefPtr<GoannaMediaPluginService> mService;
-    nsString mPath;
-    EOperation mOperation;
-    bool mDefer;
-  };
-
-  Mutex mMutex; // Protects mGMPThread and mShuttingDown and mPlugins
-  nsTArray<nsRefPtr<GMPParent>> mPlugins;
-  nsCOMPtr<nsIThread> mGMPThread;
-  bool mShuttingDown;
-  bool mShuttingDownOnGMPThread;
-
-  nsTArray<nsRefPtr<PluginCrashCallback>> mPluginCrashCallbacks;
-
-  // True if we've inspected MOZ_GMP_PATH on the GMP thread and loaded any
-  // plugins found there into mPlugins.
-  Atomic<bool> mScannedPluginOnDisk;
-
-  template<typename T>
-  class MainThreadOnly {
-  public:
-    MOZ_IMPLICIT MainThreadOnly(T aValue)
-      : mValue(aValue)
-    {}
-    operator T&() {
-      MOZ_ASSERT(NS_IsMainThread());
-      return mValue;
-    }
-
-  private:
-    T mValue;
-  };
-
-  MainThreadOnly<bool> mWaitingForPluginsAsyncShutdown;
-
-  nsTArray<nsRefPtr<GMPParent>> mAsyncShutdownPlugins; // GMP Thread only.
-
-  nsTArray<nsString> mPluginsWaitingForDeletion;
-
-#ifndef MOZ_WIDGET_GONK
-  nsCOMPtr<nsIFile> mStorageBaseDir;
-#endif
-
-  // Hashes of (origin,topLevelOrigin) to the node id for
-  // non-persistent sessions.
-  nsClassHashtable<nsUint32HashKey, nsCString> mTempNodeIds;
-
-  // Hashes node id to whether that node id is allowed to store data
-  // persistently on disk.
-  nsDataHashtable<nsCStringHashKey, bool> mPersistentStorageAllowed;
-};
-
-nsresult ReadSalt(nsIFile* aPath, nsACString& aOutData);
-bool MatchOrigin(nsIFile* aPath, const nsACString& aSite);
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPService_h_
diff --git a/dom/media/gmp/GMPSharedMemManager.cpp b/dom/media/gmp/GMPSharedMemManager.cpp
deleted file mode 100644
index d24a75f..0000000
--- a/dom/media/gmp/GMPSharedMemManager.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPSharedMemManager.h"
-#include "GMPMessageUtils.h"
-#include "mozilla/ipc/SharedMemory.h"
-#include "mozilla/StaticPtr.h"
-#include "mozilla/ClearOnShutdown.h"
-
-namespace mozilla {
-namespace gmp {
-
-// Really one set of pools on each side of the plugin API.
-
-// YUV buffers go from Encoder parent to child; pool there, and then return
-// with Decoded() frames to the Decoder parent and goes into the parent pool.
-// Compressed (encoded) data goes from the Decoder parent to the child;
-// pool there, and then return with Encoded() frames and goes into the parent
-// pool.
-bool
-GMPSharedMemManager::MgrAllocShmem(GMPSharedMem::GMPMemoryClasses aClass, size_t aSize,
-                                   ipc::Shmem::SharedMemory::SharedMemoryType aType,
-                                   ipc::Shmem* aMem)
-{
-  mData->CheckThread();
-
-  // first look to see if we have a free buffer large enough
-  for (uint32_t i = 0; i < GetGmpFreelist(aClass).Length(); i++) {
-    MOZ_ASSERT(GetGmpFreelist(aClass)[i].IsWritable());
-    if (aSize <= GetGmpFreelist(aClass)[i].Size<uint8_t>()) {
-      *aMem = GetGmpFreelist(aClass)[i];
-      GetGmpFreelist(aClass).RemoveElementAt(i);
-      return true;
-    }
-  }
-
-  // Didn't find a buffer free with enough space; allocate one
-  size_t pagesize = ipc::SharedMemory::SystemPageSize();
-  aSize = (aSize + (pagesize-1)) & ~(pagesize-1); // round up to page size
-  bool retval = Alloc(aSize, aType, aMem);
-  // The allocator (or NeedsShmem call) should never return less than we ask for...
-  MOZ_ASSERT(aMem->Size<uint8_t>() >= aSize);
-  if (retval) {
-    mData->mGmpAllocated[aClass]++;
-  }
-  return retval;
-}
-
-bool
-GMPSharedMemManager::MgrDeallocShmem(GMPSharedMem::GMPMemoryClasses aClass, ipc::Shmem& aMem)
-{
-  mData->CheckThread();
-
-  size_t size = aMem.Size<uint8_t>();
-  size_t total = 0;
-
-  // XXX Bug NNNNNNN Until we put better guards on ipc::shmem, verify we
-  // weren't fed an shmem we already had.
-  for (uint32_t i = 0; i < GetGmpFreelist(aClass).Length(); i++) {
-    if (NS_WARN_IF(aMem == GetGmpFreelist(aClass)[i])) {
-      // Safest to crash in this case; should never happen in normal
-      // operation.
-      MOZ_CRASH("Deallocating Shmem we already have in our cache!");
-      //return true;
-    }
-  }
-
-  // XXX This works; there are better pool algorithms.  We need to avoid
-  // "falling off a cliff" with too low a number
-  if (GetGmpFreelist(aClass).Length() > 10) {
-    Dealloc(GetGmpFreelist(aClass)[0]);
-    GetGmpFreelist(aClass).RemoveElementAt(0);
-    // The allocation numbers will be fubar on the Child!
-    mData->mGmpAllocated[aClass]--;
-  }
-  for (uint32_t i = 0; i < GetGmpFreelist(aClass).Length(); i++) {
-    MOZ_ASSERT(GetGmpFreelist(aClass)[i].IsWritable());
-    total += GetGmpFreelist(aClass)[i].Size<uint8_t>();
-    if (size < GetGmpFreelist(aClass)[i].Size<uint8_t>()) {
-      GetGmpFreelist(aClass).InsertElementAt(i, aMem);
-      return true;
-    }
-  }
-  GetGmpFreelist(aClass).AppendElement(aMem);
-
-  return true;
-}
-
-uint32_t
-GMPSharedMemManager::NumInUse(GMPSharedMem::GMPMemoryClasses aClass)
-{
-  return mData->mGmpAllocated[aClass] - GetGmpFreelist(aClass).Length();
-}
-
-}
-}
diff --git a/dom/media/gmp/GMPSharedMemManager.h b/dom/media/gmp/GMPSharedMemManager.h
deleted file mode 100644
index cc36f3f..0000000
--- a/dom/media/gmp/GMPSharedMemManager.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPSharedMemManager_h_
-#define GMPSharedMemManager_h_
-
-#include "mozilla/ipc/Shmem.h"
-#include "nsTArray.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPSharedMemManager;
-
-class GMPSharedMem
-{
-public:
-  typedef enum {
-    kGMPFrameData = 0,
-    kGMPEncodedData,
-    kGMPNumTypes
-  } GMPMemoryClasses;
-
-  // This is a heuristic - max of 10 free in the Child pool, plus those
-  // in-use for the encoder and decoder at the given moment and not yet
-  // returned to the parent pool (which is not included).  If more than
-  // this are needed, we presume the client has either crashed or hung
-  // (perhaps temporarily).
-  static const uint32_t kGMPBufLimit = 20;
-
-  GMPSharedMem()
-  {
-    for (size_t i = 0; i < sizeof(mGmpAllocated)/sizeof(mGmpAllocated[0]); i++) {
-      mGmpAllocated[i] = 0;
-    }
-  }
-  virtual ~GMPSharedMem() {}
-
-  // Parent and child impls will differ here
-  virtual void CheckThread() = 0;
-
-protected:
-  friend class GMPSharedMemManager;
-
-  nsTArray<ipc::Shmem> mGmpFreelist[GMPSharedMem::kGMPNumTypes];
-  uint32_t mGmpAllocated[GMPSharedMem::kGMPNumTypes];
-};
-
-class GMPSharedMemManager
-{
-public:
-  explicit GMPSharedMemManager(GMPSharedMem *aData) : mData(aData) {}
-  virtual ~GMPSharedMemManager() {}
-
-  virtual bool MgrAllocShmem(GMPSharedMem::GMPMemoryClasses aClass, size_t aSize,
-                             ipc::Shmem::SharedMemory::SharedMemoryType aType,
-                             ipc::Shmem* aMem);
-  virtual bool MgrDeallocShmem(GMPSharedMem::GMPMemoryClasses aClass, ipc::Shmem& aMem);
-
-  // So we can know if data is "piling up" for the plugin - I.e. it's hung or crashed
-  virtual uint32_t NumInUse(GMPSharedMem::GMPMemoryClasses aClass);
-
-  // These have to be implemented using the AllocShmem/etc provided by the IPDL-generated interfaces,
-  // so have the Parent/Child implement them.
-  virtual bool Alloc(size_t aSize, ipc::Shmem::SharedMemory::SharedMemoryType aType, ipc::Shmem* aMem) = 0;
-  virtual void Dealloc(ipc::Shmem& aMem) = 0;
-
-private:
-  nsTArray<ipc::Shmem>& GetGmpFreelist(GMPSharedMem::GMPMemoryClasses aTypes)
-  {
-    return mData->mGmpFreelist[aTypes];
-  }
-
-  GMPSharedMem *mData;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPSharedMemManager_h_
diff --git a/dom/media/gmp/GMPStorageChild.cpp b/dom/media/gmp/GMPStorageChild.cpp
deleted file mode 100644
index efd025d..0000000
--- a/dom/media/gmp/GMPStorageChild.cpp
+++ /dev/null
@@ -1,379 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPStorageChild.h"
-#include "GMPChild.h"
-#include "gmp-storage.h"
-
-#define ON_GMP_THREAD() (mPlugin->GMPMessageLoop() == MessageLoop::current())
-
-#define CALL_ON_GMP_THREAD(_func, ...) \
-  do { \
-    if (ON_GMP_THREAD()) { \
-      _func(__VA_ARGS__); \
-    } else { \
-      mPlugin->GMPMessageLoop()->PostTask( \
-        FROM_HERE, NewRunnableMethod(this, &GMPStorageChild::_func, ##__VA_ARGS__) \
-      ); \
-    } \
-  } while(false)
-
-static nsTArray<uint8_t>
-ToArray(const uint8_t* aData, uint32_t aDataSize)
-{
-  nsTArray<uint8_t> data;
-  data.AppendElements(aData, aDataSize);
-  return mozilla::Move(data);
-}
-
-namespace mozilla {
-namespace gmp {
-
-GMPRecordImpl::GMPRecordImpl(GMPStorageChild* aOwner,
-                             const nsCString& aName,
-                             GMPRecordClient* aClient)
-  : mName(aName)
-  , mClient(aClient)
-  , mOwner(aOwner)
-{
-}
-
-GMPErr
-GMPRecordImpl::Open()
-{
-  return mOwner->Open(this);
-}
-
-void
-GMPRecordImpl::OpenComplete(GMPErr aStatus)
-{
-  mClient->OpenComplete(aStatus);
-}
-
-GMPErr
-GMPRecordImpl::Read()
-{
-  return mOwner->Read(this);
-}
-
-void
-GMPRecordImpl::ReadComplete(GMPErr aStatus,
-                            const uint8_t* aBytes,
-                            uint32_t aLength)
-{
-  mClient->ReadComplete(aStatus, aBytes, aLength);
-}
-
-GMPErr
-GMPRecordImpl::Write(const uint8_t* aData, uint32_t aDataSize)
-{
-  return mOwner->Write(this, aData, aDataSize);
-}
-
-void
-GMPRecordImpl::WriteComplete(GMPErr aStatus)
-{
-  mClient->WriteComplete(aStatus);
-}
-
-GMPErr
-GMPRecordImpl::Close()
-{
-  nsRefPtr<GMPRecordImpl> kungfuDeathGrip(this);
-  // Delete our self reference.
-  Release();
-  mOwner->Close(this->Name());
-  return GMPNoErr;
-}
-
-GMPStorageChild::GMPStorageChild(GMPChild* aPlugin)
-  : mMonitor("GMPStorageChild")
-  , mPlugin(aPlugin)
-  , mShutdown(false)
-{
-  MOZ_ASSERT(ON_GMP_THREAD());
-}
-
-GMPErr
-GMPStorageChild::CreateRecord(const nsCString& aRecordName,
-                              GMPRecord** aOutRecord,
-                              GMPRecordClient* aClient)
-{
-  MonitorAutoLock lock(mMonitor);
-
-  if (mShutdown) {
-    NS_WARNING("GMPStorage used after it's been shutdown!");
-    return GMPClosedErr;
-  }
-
-  MOZ_ASSERT(aRecordName.Length() && aOutRecord);
-
-  if (HasRecord(aRecordName)) {
-    return GMPRecordInUse;
-  }
-
-  nsRefPtr<GMPRecordImpl> record(new GMPRecordImpl(this, aRecordName, aClient));
-  mRecords.Put(aRecordName, record); // Addrefs
-
-  // The GMPRecord holds a self reference until the GMP calls Close() on
-  // it. This means the object is always valid (even if neutered) while
-  // the GMP expects it to be.
-  record.forget(aOutRecord);
-
-  return GMPNoErr;
-}
-
-bool
-GMPStorageChild::HasRecord(const nsCString& aRecordName)
-{
-  mMonitor.AssertCurrentThreadOwns();
-  return mRecords.Contains(aRecordName);
-}
-
-already_AddRefed<GMPRecordImpl>
-GMPStorageChild::GetRecord(const nsCString& aRecordName)
-{
-  MonitorAutoLock lock(mMonitor);
-  nsRefPtr<GMPRecordImpl> record;
-  mRecords.Get(aRecordName, getter_AddRefs(record));
-  return record.forget();
-}
-
-GMPErr
-GMPStorageChild::Open(GMPRecordImpl* aRecord)
-{
-  MonitorAutoLock lock(mMonitor);
-
-  if (mShutdown) {
-    NS_WARNING("GMPStorage used after it's been shutdown!");
-    return GMPClosedErr;
-  }
-
-  if (!HasRecord(aRecord->Name())) {
-    // Trying to re-open a record that has already been closed.
-    return GMPClosedErr;
-  }
-
-  CALL_ON_GMP_THREAD(SendOpen, aRecord->Name());
-
-  return GMPNoErr;
-}
-
-GMPErr
-GMPStorageChild::Read(GMPRecordImpl* aRecord)
-{
-  MonitorAutoLock lock(mMonitor);
-
-  if (mShutdown) {
-    NS_WARNING("GMPStorage used after it's been shutdown!");
-    return GMPClosedErr;
-  }
-
-  if (!HasRecord(aRecord->Name())) {
-    // Record not opened.
-    return GMPClosedErr;
-  }
-
-  CALL_ON_GMP_THREAD(SendRead, aRecord->Name());
-
-  return GMPNoErr;
-}
-
-GMPErr
-GMPStorageChild::Write(GMPRecordImpl* aRecord,
-                       const uint8_t* aData,
-                       uint32_t aDataSize)
-{
-  if (aDataSize > GMP_MAX_RECORD_SIZE) {
-    return GMPQuotaExceededErr;
-  }
-
-  MonitorAutoLock lock(mMonitor);
-
-  if (mShutdown) {
-    NS_WARNING("GMPStorage used after it's been shutdown!");
-    return GMPClosedErr;
-  }
-
-  if (!HasRecord(aRecord->Name())) {
-    // Record not opened.
-    return GMPClosedErr;
-  }
-
-  CALL_ON_GMP_THREAD(SendWrite, aRecord->Name(), ToArray(aData, aDataSize));
-
-  return GMPNoErr;
-}
-
-GMPErr
-GMPStorageChild::Close(const nsCString& aRecordName)
-{
-  MonitorAutoLock lock(mMonitor);
-
-  if (!HasRecord(aRecordName)) {
-    // Already closed.
-    return GMPClosedErr;
-  }
-
-  mRecords.Remove(aRecordName);
-
-  if (!mShutdown) {
-    CALL_ON_GMP_THREAD(SendClose, aRecordName);
-  }
-
-  return GMPNoErr;
-}
-
-bool
-GMPStorageChild::RecvOpenComplete(const nsCString& aRecordName,
-                                  const GMPErr& aStatus)
-{
-  // We don't need a lock to read |mShutdown| since it is only changed in
-  // the GMP thread.
-  if (mShutdown) {
-    return true;
-  }
-  nsRefPtr<GMPRecordImpl> record = GetRecord(aRecordName);
-  if (!record) {
-    // Not fatal.
-    return true;
-  }
-  record->OpenComplete(aStatus);
-  return true;
-}
-
-bool
-GMPStorageChild::RecvReadComplete(const nsCString& aRecordName,
-                                  const GMPErr& aStatus,
-                                  InfallibleTArray<uint8_t>&& aBytes)
-{
-  if (mShutdown) {
-    return true;
-  }
-  nsRefPtr<GMPRecordImpl> record = GetRecord(aRecordName);
-  if (!record) {
-    // Not fatal.
-    return true;
-  }
-  record->ReadComplete(aStatus, aBytes.Elements(), aBytes.Length());
-  return true;
-}
-
-bool
-GMPStorageChild::RecvWriteComplete(const nsCString& aRecordName,
-                                   const GMPErr& aStatus)
-{
-  if (mShutdown) {
-    return true;
-  }
-  nsRefPtr<GMPRecordImpl> record = GetRecord(aRecordName);
-  if (!record) {
-    // Not fatal.
-    return true;
-  }
-  record->WriteComplete(aStatus);
-  return true;
-}
-
-GMPErr
-GMPStorageChild::EnumerateRecords(RecvGMPRecordIteratorPtr aRecvIteratorFunc,
-                                  void* aUserArg)
-{
-  MonitorAutoLock lock(mMonitor);
-
-  if (mShutdown) {
-    NS_WARNING("GMPStorage used after it's been shutdown!");
-    return GMPClosedErr;
-  }
-
-  MOZ_ASSERT(aRecvIteratorFunc);
-  mPendingRecordIterators.push(RecordIteratorContext(aRecvIteratorFunc, aUserArg));
-
-  CALL_ON_GMP_THREAD(SendGetRecordNames);
-
-  return GMPNoErr;
-}
-
-class GMPRecordIteratorImpl : public GMPRecordIterator {
-public:
-  explicit GMPRecordIteratorImpl(const InfallibleTArray<nsCString>& aRecordNames)
-    : mRecordNames(aRecordNames)
-    , mIndex(0)
-  {
-    mRecordNames.Sort();
-  }
-
-  virtual GMPErr GetName(const char** aOutName, uint32_t* aOutNameLength) override {
-    if (!aOutName || !aOutNameLength) {
-      return GMPInvalidArgErr;
-    }
-    if (mIndex == mRecordNames.Length()) {
-      return GMPEndOfEnumeration;
-    }
-    *aOutName = mRecordNames[mIndex].get();
-    *aOutNameLength = mRecordNames[mIndex].Length();
-    return GMPNoErr;
-  }
-
-  virtual GMPErr NextRecord() override {
-    if (mIndex < mRecordNames.Length()) {
-      mIndex++;
-    }
-    return (mIndex < mRecordNames.Length()) ? GMPNoErr
-                                            : GMPEndOfEnumeration;
-  }
-
-  virtual void Close() override {
-    delete this;
-  }
-
-private:
-  nsTArray<nsCString> mRecordNames;
-  size_t mIndex;
-};
-
-bool
-GMPStorageChild::RecvRecordNames(InfallibleTArray<nsCString>&& aRecordNames,
-                                 const GMPErr& aStatus)
-{
-  RecordIteratorContext ctx;
-  {
-    MonitorAutoLock lock(mMonitor);
-    if (mShutdown || mPendingRecordIterators.empty()) {
-      return true;
-    }
-    ctx = mPendingRecordIterators.front();
-    mPendingRecordIterators.pop();
-  }
-
-  if (GMP_FAILED(aStatus)) {
-    ctx.mFunc(nullptr, ctx.mUserArg, aStatus);
-  } else {
-    ctx.mFunc(new GMPRecordIteratorImpl(aRecordNames), ctx.mUserArg, GMPNoErr);
-  }
-
-  return true;
-}
-
-bool
-GMPStorageChild::RecvShutdown()
-{
-  // Block any new storage requests, and thus any messages back to the
-  // parent. We don't delete any objects here, as that may invalidate
-  // GMPRecord pointers held by the GMP.
-  MonitorAutoLock lock(mMonitor);
-  mShutdown = true;
-  while (!mPendingRecordIterators.empty()) {
-    mPendingRecordIterators.pop();
-  }
-  return true;
-}
-
-} // namespace gmp
-} // namespace mozilla
-
-// avoid redefined macro in unified build
-#undef ON_GMP_THREAD
-#undef CALL_ON_GMP_THREAD
diff --git a/dom/media/gmp/GMPStorageChild.h b/dom/media/gmp/GMPStorageChild.h
deleted file mode 100644
index 625f410..0000000
--- a/dom/media/gmp/GMPStorageChild.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPStorageChild_h_
-#define GMPStorageChild_h_
-
-#include "mozilla/gmp/PGMPStorageChild.h"
-#include "gmp-storage.h"
-#include "nsTHashtable.h"
-#include "nsRefPtrHashtable.h"
-#include "gmp-platform.h"
-
-#include <queue>
-
-namespace mozilla {
-namespace gmp {
-
-class GMPChild;
-class GMPStorageChild;
-
-class GMPRecordImpl : public GMPRecord
-{
-public:
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(GMPRecordImpl)
-
-  GMPRecordImpl(GMPStorageChild* aOwner,
-                const nsCString& aName,
-                GMPRecordClient* aClient);
-
-  // GMPRecord.
-  virtual GMPErr Open() override;
-  virtual GMPErr Read() override;
-  virtual GMPErr Write(const uint8_t* aData,
-                       uint32_t aDataSize) override;
-  virtual GMPErr Close() override;
-
-  const nsCString& Name() const { return mName; }
-
-  void OpenComplete(GMPErr aStatus);
-  void ReadComplete(GMPErr aStatus, const uint8_t* aBytes, uint32_t aLength);
-  void WriteComplete(GMPErr aStatus);
-
-private:
-  ~GMPRecordImpl() {}
-  const nsCString mName;
-  GMPRecordClient* const mClient;
-  GMPStorageChild* const mOwner;
-};
-
-class GMPStorageChild : public PGMPStorageChild
-{
-public:
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(GMPStorageChild)
-
-  explicit GMPStorageChild(GMPChild* aPlugin);
-
-  GMPErr CreateRecord(const nsCString& aRecordName,
-                      GMPRecord** aOutRecord,
-                      GMPRecordClient* aClient);
-
-  GMPErr Open(GMPRecordImpl* aRecord);
-
-  GMPErr Read(GMPRecordImpl* aRecord);
-
-  GMPErr Write(GMPRecordImpl* aRecord,
-               const uint8_t* aData,
-               uint32_t aDataSize);
-
-  GMPErr Close(const nsCString& aRecordName);
-
-  GMPErr EnumerateRecords(RecvGMPRecordIteratorPtr aRecvIteratorFunc,
-                          void* aUserArg);
-
-private:
-  bool HasRecord(const nsCString& aRecordName);
-  already_AddRefed<GMPRecordImpl> GetRecord(const nsCString& aRecordName);
-
-protected:
-  ~GMPStorageChild() {}
-
-  // PGMPStorageChild
-  virtual bool RecvOpenComplete(const nsCString& aRecordName,
-                                const GMPErr& aStatus) override;
-  virtual bool RecvReadComplete(const nsCString& aRecordName,
-                                const GMPErr& aStatus,
-                                InfallibleTArray<uint8_t>&& aBytes) override;
-  virtual bool RecvWriteComplete(const nsCString& aRecordName,
-                                 const GMPErr& aStatus) override;
-  virtual bool RecvRecordNames(InfallibleTArray<nsCString>&& aRecordNames,
-                               const GMPErr& aStatus) override;
-  virtual bool RecvShutdown() override;
-
-private:
-  Monitor mMonitor;
-  nsRefPtrHashtable<nsCStringHashKey, GMPRecordImpl> mRecords;
-  GMPChild* mPlugin;
-
-  struct RecordIteratorContext {
-    explicit RecordIteratorContext(RecvGMPRecordIteratorPtr aFunc,
-                                   void* aUserArg)
-      : mFunc(aFunc)
-      , mUserArg(aUserArg)
-    {}
-    RecordIteratorContext() {}
-    RecvGMPRecordIteratorPtr mFunc;
-    void* mUserArg;
-  };
-
-  std::queue<RecordIteratorContext> mPendingRecordIterators;
-  bool mShutdown;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPStorageChild_h_
diff --git a/dom/media/gmp/GMPStorageParent.cpp b/dom/media/gmp/GMPStorageParent.cpp
deleted file mode 100644
index e9bf852..0000000
--- a/dom/media/gmp/GMPStorageParent.cpp
+++ /dev/null
@@ -1,619 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPStorageParent.h"
-#include "mozilla/SyncRunnable.h"
-#include "plhash.h"
-#include "nsDirectoryServiceUtils.h"
-#include "nsDirectoryServiceDefs.h"
-#include "nsAppDirectoryServiceDefs.h"
-#include "GMPParent.h"
-#include "gmp-storage.h"
-#include "mozilla/unused.h"
-#include "nsTHashtable.h"
-#include "nsDataHashtable.h"
-#include "prio.h"
-#include "mozIGoannaMediaPluginService.h"
-#include "nsContentCID.h"
-#include "nsServiceManagerUtils.h"
-#include "nsISimpleEnumerator.h"
-
-namespace mozilla {
-
-#ifdef LOG
-#undef LOG
-#endif
-
-#ifdef PR_LOGGING
-extern PRLogModuleInfo* GetGMPLog();
-
-#define LOGD(msg) PR_LOG(GetGMPLog(), PR_LOG_DEBUG, msg)
-#define LOG(level, msg) PR_LOG(GetGMPLog(), (level), msg)
-#else
-#define LOGD(msg)
-#define LOG(level, msg)
-#endif
-
-#ifdef __CLASS__
-#undef __CLASS__
-#endif
-#define __CLASS__ "GMPParent"
-
-namespace gmp {
-
-// We store the records in files in the profile dir.
-// $profileDir/gmp/storage/$nodeId/
-static nsresult
-GetGMPStorageDir(nsIFile** aTempDir, const nsCString& aNodeId)
-{
-  if (NS_WARN_IF(!aTempDir)) {
-    return NS_ERROR_INVALID_ARG;
-  }
-
-  nsCOMPtr<mozIGoannaMediaPluginService> mps =
-    do_GetService("@mozilla.org/goanna-media-plugin-service;1");
-  if (NS_WARN_IF(!mps)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  nsCOMPtr<nsIFile> tmpFile;
-  nsresult rv = mps->GetStorageDir(getter_AddRefs(tmpFile));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  rv = tmpFile->AppendNative(NS_LITERAL_CSTRING("storage"));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  rv = tmpFile->Create(nsIFile::DIRECTORY_TYPE, 0700);
-  if (rv != NS_ERROR_FILE_ALREADY_EXISTS && NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  rv = tmpFile->AppendNative(aNodeId);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  rv = tmpFile->Create(nsIFile::DIRECTORY_TYPE, 0700);
-  if (rv != NS_ERROR_FILE_ALREADY_EXISTS && NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  tmpFile.forget(aTempDir);
-
-  return NS_OK;
-}
-
-enum OpenFileMode  { ReadWrite, Truncate };
-
-nsresult
-OpenStorageFile(const nsCString& aRecordName,
-                const nsCString& aNodeId,
-                const OpenFileMode aMode,
-                PRFileDesc** aOutFD)
-{
-  MOZ_ASSERT(aOutFD);
-
-  nsCOMPtr<nsIFile> f;
-  nsresult rv = GetGMPStorageDir(getter_AddRefs(f), aNodeId);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  nsAutoString recordNameHash;
-  recordNameHash.AppendInt(HashString(aRecordName.get()));
-  f->Append(recordNameHash);
-
-  auto mode = PR_RDWR | PR_CREATE_FILE;
-  if (aMode == Truncate) {
-    mode |= PR_TRUNCATE;
-  }
-
-  return f->OpenNSPRFileDesc(mode, PR_IRWXU, aOutFD);
-}
-
-PLDHashOperator
-CloseFile(const nsACString& key, PRFileDesc*& entry, void* cx)
-{
-  if (PR_Close(entry) != PR_SUCCESS) {
-    NS_WARNING("GMPDiskStorage Failed to clsose file.");
-  }
-  return PL_DHASH_REMOVE;
-}
-
-class GMPDiskStorage : public GMPStorage {
-public:
-  explicit GMPDiskStorage(const nsCString& aNodeId)
-    : mNodeId(aNodeId)
-  {
-  }
-  ~GMPDiskStorage() {
-    mFiles.Enumerate(CloseFile, nullptr);
-    MOZ_ASSERT(!mFiles.Count());
-  }
-
-  virtual GMPErr Open(const nsCString& aRecordName) override
-  {
-    MOZ_ASSERT(!IsOpen(aRecordName));
-    PRFileDesc* fd = nullptr;
-    if (NS_FAILED(OpenStorageFile(aRecordName, mNodeId, ReadWrite, &fd))) {
-      NS_WARNING("Failed to open storage file.");
-      return GMPGenericErr;
-    }
-    mFiles.Put(aRecordName, fd);
-    return GMPNoErr;
-  }
-
-  virtual bool IsOpen(const nsCString& aRecordName) override {
-    return mFiles.Contains(aRecordName);
-  }
-
-  GMPErr ReadRecordMetadata(PRFileDesc* aFd,
-                            int32_t& aOutFileLength,
-                            int32_t& aOutRecordLength,
-                            nsACString& aOutRecordName)
-  {
-    int32_t fileLength = PR_Seek(aFd, 0, PR_SEEK_END);
-    PR_Seek(aFd, 0, PR_SEEK_SET);
-
-    if (fileLength > GMP_MAX_RECORD_SIZE) {
-      // Refuse to read big records.
-      return GMPQuotaExceededErr;
-    }
-    aOutFileLength = fileLength;
-    aOutRecordLength = 0;
-
-    // At the start of the file the length of the record name is stored in a
-    // size_t (host byte order) followed by the record name at the start of
-    // the file. The record name is not null terminated. The remainder of the
-    // file is the record's data.
-
-    size_t recordNameLength = 0;
-    if (fileLength == 0 || sizeof(recordNameLength) >= (size_t)fileLength) {
-      // Record file is empty, or doesn't even have enough contents to
-      // store the record name length and/or record name. Report record
-      // as empty.
-      return GMPNoErr;
-    }
-
-    int32_t bytesRead = PR_Read(aFd, &recordNameLength, sizeof(recordNameLength));
-    if (sizeof(recordNameLength) != bytesRead ||
-        recordNameLength > fileLength - sizeof(recordNameLength)) {
-      // Record file has invalid contents. Report record as empty.
-      return GMPNoErr;
-    }
-
-    nsCString recordName;
-    recordName.SetLength(recordNameLength);
-    bytesRead = PR_Read(aFd, recordName.BeginWriting(), recordNameLength);
-    if (bytesRead != (int32_t)recordNameLength) {
-      // Record file has invalid contents. Report record as empty.
-      return GMPGenericErr;
-    }
-
-    MOZ_ASSERT(fileLength > 0 && (size_t)fileLength >= sizeof(recordNameLength) + recordNameLength);
-    int32_t recordLength = fileLength - (sizeof(recordNameLength) + recordNameLength);
-
-    aOutRecordLength = recordLength;
-    aOutRecordName = recordName;
-
-    return GMPNoErr;
-  }
-
-  virtual GMPErr Read(const nsCString& aRecordName,
-                      nsTArray<uint8_t>& aOutBytes) override
-  {
-    // Our error strategy is to report records with invalid contents as
-    // containing 0 bytes. Zero length records are considered "deleted" by
-    // the GMPStorage API.
-    aOutBytes.SetLength(0);
-
-    PRFileDesc* fd = mFiles.Get(aRecordName);
-    if (!fd) {
-      return GMPGenericErr;
-    }
-
-    int32_t fileLength = 0;
-    int32_t recordLength = 0;
-    nsCString recordName;
-    GMPErr err = ReadRecordMetadata(fd,
-                                    fileLength,
-                                    recordLength,
-                                    recordName);
-    if (NS_WARN_IF(GMP_FAILED(err))) {
-      return err;
-    }
-
-    if (recordLength == 0) {
-      // Record is empoty but not invalid, or it's invalid and we're going to
-      // just act like it's empty and let the client overwrite it.
-      return GMPNoErr;
-    }
-
-    if (!aRecordName.Equals(recordName)) {
-      NS_WARNING("Hash collision in GMPStorage");
-      return GMPGenericErr;
-    }
-
-    // After calling ReadRecordMetadata, we should be ready to read the
-    // record data.
-    MOZ_ASSERT(PR_Available(fd) == recordLength);
-
-    aOutBytes.SetLength(recordLength);
-    int32_t bytesRead = PR_Read(fd, aOutBytes.Elements(), recordLength);
-    return (bytesRead == recordLength) ? GMPNoErr : GMPGenericErr;
-  }
-
-  virtual GMPErr Write(const nsCString& aRecordName,
-                       const nsTArray<uint8_t>& aBytes) override
-  {
-    PRFileDesc* fd = mFiles.Get(aRecordName);
-    if (!fd) {
-      return GMPGenericErr;
-    }
-
-    // Write operations overwrite the entire record. So re-open the file
-    // in truncate mode, to clear its contents.
-    PR_Close(fd);
-    mFiles.Remove(aRecordName);
-    if (NS_FAILED(OpenStorageFile(aRecordName, mNodeId, Truncate, &fd))) {
-      return GMPGenericErr;
-    }
-    mFiles.Put(aRecordName, fd);
-
-    // Store the length of the record name followed by the record name
-    // at the start of the file.
-    int32_t bytesWritten = 0;
-    if (aBytes.Length() > 0) {
-      size_t recordNameLength = aRecordName.Length();
-      bytesWritten = PR_Write(fd, &recordNameLength, sizeof(recordNameLength));
-      if (NS_WARN_IF(bytesWritten != sizeof(recordNameLength))) {
-        return GMPGenericErr;
-      }
-      bytesWritten = PR_Write(fd, aRecordName.get(), recordNameLength);
-      if (NS_WARN_IF(bytesWritten != (int32_t)recordNameLength)) {
-        return GMPGenericErr;
-      }
-    }
-
-    bytesWritten = PR_Write(fd, aBytes.Elements(), aBytes.Length());
-    return (bytesWritten == (int32_t)aBytes.Length()) ? GMPNoErr : GMPGenericErr;
-  }
-
-  virtual GMPErr GetRecordNames(nsTArray<nsCString>& aOutRecordNames) override
-  {
-    nsCOMPtr<nsIFile> storageDir;
-    nsresult rv = GetGMPStorageDir(getter_AddRefs(storageDir), mNodeId);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return GMPGenericErr;
-    }
-
-    nsCOMPtr<nsISimpleEnumerator> iter;
-    rv = storageDir->GetDirectoryEntries(getter_AddRefs(iter));
-    if (NS_FAILED(rv)) {
-      return GMPGenericErr;
-    }
-
-    bool hasMore;
-    while (NS_SUCCEEDED(iter->HasMoreElements(&hasMore)) && hasMore) {
-      nsCOMPtr<nsISupports> supports;
-      rv = iter->GetNext(getter_AddRefs(supports));
-      if (NS_FAILED(rv)) {
-        continue;
-      }
-      nsCOMPtr<nsIFile> dirEntry(do_QueryInterface(supports, &rv));
-      if (NS_FAILED(rv)) {
-        continue;
-      }
-
-      nsAutoCString leafName;
-      rv = dirEntry->GetNativeLeafName(leafName);
-      if (NS_FAILED(rv)) {
-        continue;
-      }
-
-      PRFileDesc* fd = nullptr;
-      if (NS_FAILED(dirEntry->OpenNSPRFileDesc(PR_RDONLY, 0, &fd))) {
-        continue;
-      }
-      int32_t fileLength = 0;
-      int32_t recordLength = 0;
-      nsCString recordName;
-      GMPErr err = ReadRecordMetadata(fd,
-                                      fileLength,
-                                      recordLength,
-                                      recordName);
-      PR_Close(fd);
-      if (NS_WARN_IF(GMP_FAILED(err))) {
-        return err;
-      }
-
-      if (recordName.IsEmpty() || recordLength == 0) {
-        continue;
-      }
-
-      // Ensure the file name is the hash of the record name stored in the
-      // record file. Otherwise it's not a valid record.
-      nsAutoCString recordNameHash;
-      recordNameHash.AppendInt(HashString(recordName.get()));
-      if (!recordNameHash.Equals(leafName)) {
-        continue;
-      }
-
-      aOutRecordNames.AppendElement(recordName);
-    }
-
-    return GMPNoErr;
-  }
-
-  virtual void Close(const nsCString& aRecordName) override
-  {
-    PRFileDesc* fd = mFiles.Get(aRecordName);
-    if (fd) {
-      if (PR_Close(fd) == PR_SUCCESS) {
-        mFiles.Remove(aRecordName);
-      } else {
-        NS_WARNING("GMPDiskStorage Failed to clsose file.");
-      }
-    }
-  }
-
-private:
-  nsDataHashtable<nsCStringHashKey, PRFileDesc*> mFiles;
-  const nsAutoCString mNodeId;
-};
-
-class GMPMemoryStorage : public GMPStorage {
-public:
-  virtual GMPErr Open(const nsCString& aRecordName) override
-  {
-    MOZ_ASSERT(!IsOpen(aRecordName));
-
-    Record* record = nullptr;
-    if (!mRecords.Get(aRecordName, &record)) {
-      record = new Record();
-      mRecords.Put(aRecordName, record);
-    }
-    record->mIsOpen = true;
-    return GMPNoErr;
-  }
-
-  virtual bool IsOpen(const nsCString& aRecordName) override {
-    Record* record = nullptr;
-    if (!mRecords.Get(aRecordName, &record)) {
-      return false;
-    }
-    return record->mIsOpen;
-  }
-
-  virtual GMPErr Read(const nsCString& aRecordName,
-                      nsTArray<uint8_t>& aOutBytes) override
-  {
-    Record* record = nullptr;
-    if (!mRecords.Get(aRecordName, &record)) {
-      return GMPGenericErr;
-    }
-    aOutBytes = record->mData;
-    return GMPNoErr;
-  }
-
-  virtual GMPErr Write(const nsCString& aRecordName,
-                       const nsTArray<uint8_t>& aBytes) override
-  {
-    Record* record = nullptr;
-    if (!mRecords.Get(aRecordName, &record)) {
-      return GMPClosedErr;
-    }
-    record->mData = aBytes;
-    return GMPNoErr;
-  }
-
-  virtual GMPErr GetRecordNames(nsTArray<nsCString>& aOutRecordNames) override
-  {
-    mRecords.EnumerateRead(EnumRecordNames, &aOutRecordNames);
-    return GMPNoErr;
-  }
-
-  virtual void Close(const nsCString& aRecordName) override
-  {
-    Record* record = nullptr;
-    if (!mRecords.Get(aRecordName, &record)) {
-      return;
-    }
-    if (!record->mData.Length()) {
-      // Record is empty, delete.
-      mRecords.Remove(aRecordName);
-    } else {
-      record->mIsOpen = false;
-    }
-  }
-
-private:
-
-  struct Record {
-    Record() : mIsOpen(false) {}
-    nsTArray<uint8_t> mData;
-    bool mIsOpen;
-  };
-
-  static PLDHashOperator
-  EnumRecordNames(const nsACString& aKey,
-                  Record* aRecord,
-                  void* aUserArg)
-  {
-    nsTArray<nsCString>* names = reinterpret_cast<nsTArray<nsCString>*>(aUserArg);
-    names->AppendElement(aKey);
-    return PL_DHASH_NEXT;
-  }
-
-  nsClassHashtable<nsCStringHashKey, Record> mRecords;
-};
-
-GMPStorageParent::GMPStorageParent(const nsCString& aNodeId,
-                                   GMPParent* aPlugin)
-  : mNodeId(aNodeId)
-  , mPlugin(aPlugin)
-  , mShutdown(false)
-{
-}
-
-nsresult
-GMPStorageParent::Init()
-{
-  if (NS_WARN_IF(mNodeId.IsEmpty())) {
-    return NS_ERROR_FAILURE;
-  }
-  nsCOMPtr<mozIGoannaMediaPluginService> mps =
-    do_GetService("@mozilla.org/goanna-media-plugin-service;1");
-  if (NS_WARN_IF(!mps)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  bool persistent = false;
-  if (NS_WARN_IF(NS_FAILED(mps->IsPersistentStorageAllowed(mNodeId, &persistent)))) {
-    return NS_ERROR_FAILURE;
-  }
-  if (persistent) {
-    mStorage = MakeUnique<GMPDiskStorage>(mNodeId);
-  } else {
-    mStorage = MakeUnique<GMPMemoryStorage>();
-  }
-
-  return NS_OK;
-}
-
-bool
-GMPStorageParent::RecvOpen(const nsCString& aRecordName)
-{
-  if (mShutdown) {
-    return false;
-  }
-
-  if (mNodeId.EqualsLiteral("null")) {
-    // Refuse to open storage if the page is opened from local disk,
-    // or shared across origin.
-    NS_WARNING("Refusing to open storage for null NodeId");
-    unused << SendOpenComplete(aRecordName, GMPGenericErr);
-    return true;
-  }
-
-  if (aRecordName.IsEmpty()) {
-    unused << SendOpenComplete(aRecordName, GMPGenericErr);
-    return true;
-  }
-
-  if (mStorage->IsOpen(aRecordName)) {
-    unused << SendOpenComplete(aRecordName, GMPRecordInUse);
-    return true;
-  }
-
-  auto err = mStorage->Open(aRecordName);
-  MOZ_ASSERT(GMP_FAILED(err) || mStorage->IsOpen(aRecordName));
-  unused << SendOpenComplete(aRecordName, err);
-
-  return true;
-}
-
-bool
-GMPStorageParent::RecvRead(const nsCString& aRecordName)
-{
-  LOGD(("%s::%s: %p record=%s", __CLASS__, __FUNCTION__, this, aRecordName.get()));
-
-  if (mShutdown) {
-    return false;
-  }
-
-  nsTArray<uint8_t> data;
-  if (!mStorage->IsOpen(aRecordName)) {
-    unused << SendReadComplete(aRecordName, GMPClosedErr, data);
-  } else {
-    unused << SendReadComplete(aRecordName, mStorage->Read(aRecordName, data), data);
-  }
-
-  return true;
-}
-
-bool
-GMPStorageParent::RecvWrite(const nsCString& aRecordName,
-                            InfallibleTArray<uint8_t>&& aBytes)
-{
-  LOGD(("%s::%s: %p record=%s", __CLASS__, __FUNCTION__, this, aRecordName.get()));
-
-  if (mShutdown) {
-    return false;
-  }
-
-  if (!mStorage->IsOpen(aRecordName)) {
-    unused << SendWriteComplete(aRecordName, GMPClosedErr);
-    return true;
-  }
-
-  if (aBytes.Length() > GMP_MAX_RECORD_SIZE) {
-    unused << SendWriteComplete(aRecordName, GMPQuotaExceededErr);
-    return true;
-  }
-
-  unused << SendWriteComplete(aRecordName, mStorage->Write(aRecordName, aBytes));
-
-  return true;
-}
-
-bool
-GMPStorageParent::RecvGetRecordNames()
-{
-  LOGD(("%s::%s: %p", __CLASS__, __FUNCTION__, this));
-
-  if (mShutdown) {
-    return true;
-  }
-
-  nsTArray<nsCString> recordNames;
-  GMPErr status = mStorage->GetRecordNames(recordNames);
-  unused << SendRecordNames(recordNames, status);
-
-  return true;
-}
-
-bool
-GMPStorageParent::RecvClose(const nsCString& aRecordName)
-{
-  LOGD(("%s::%s: %p record=%s", __CLASS__, __FUNCTION__, this, aRecordName.get()));
-
-  if (mShutdown) {
-    return true;
-  }
-
-  mStorage->Close(aRecordName);
-
-  return true;
-}
-
-void
-GMPStorageParent::ActorDestroy(ActorDestroyReason aWhy)
-{
-  LOGD(("%s::%s: %p", __CLASS__, __FUNCTION__, this));
-  Shutdown();
-}
-
-void
-GMPStorageParent::Shutdown()
-{
-  LOGD(("%s::%s: %p", __CLASS__, __FUNCTION__, this));
-
-  if (mShutdown) {
-    return;
-  }
-  mShutdown = true;
-  unused << SendShutdown();
-
-  mStorage = nullptr;
-
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPStorageParent.h b/dom/media/gmp/GMPStorageParent.h
deleted file mode 100644
index d1f58c6..0000000
--- a/dom/media/gmp/GMPStorageParent.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPStorageParent_h_
-#define GMPStorageParent_h_
-
-#include "mozilla/gmp/PGMPStorageParent.h"
-#include "gmp-storage.h"
-#include "mozilla/UniquePtr.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPParent;
-
-class GMPStorage {
-public:
-  virtual ~GMPStorage() {}
-
-  virtual GMPErr Open(const nsCString& aRecordName) = 0;
-  virtual bool IsOpen(const nsCString& aRecordName) = 0;
-  virtual GMPErr Read(const nsCString& aRecordName,
-                      nsTArray<uint8_t>& aOutBytes) = 0;
-  virtual GMPErr Write(const nsCString& aRecordName,
-                       const nsTArray<uint8_t>& aBytes) = 0;
-  virtual GMPErr GetRecordNames(nsTArray<nsCString>& aOutRecordNames) = 0;
-  virtual void Close(const nsCString& aRecordName) = 0;
-};
-
-class GMPStorageParent : public PGMPStorageParent {
-public:
-  NS_INLINE_DECL_REFCOUNTING(GMPStorageParent)
-  GMPStorageParent(const nsCString& aNodeId,
-                   GMPParent* aPlugin);
-
-  nsresult Init();
-  void Shutdown();
-
-protected:
-  virtual bool RecvOpen(const nsCString& aRecordName) override;
-  virtual bool RecvRead(const nsCString& aRecordName) override;
-  virtual bool RecvWrite(const nsCString& aRecordName,
-                         InfallibleTArray<uint8_t>&& aBytes) override;
-  virtual bool RecvGetRecordNames() override;
-  virtual bool RecvClose(const nsCString& aRecordName) override;
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-
-private:
-  ~GMPStorageParent() {}
-
-  UniquePtr<GMPStorage> mStorage;
-
-  const nsCString mNodeId;
-  nsRefPtr<GMPParent> mPlugin;
-  bool mShutdown;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPStorageParent_h_
diff --git a/dom/media/gmp/GMPTimerChild.cpp b/dom/media/gmp/GMPTimerChild.cpp
deleted file mode 100644
index 0b2b55c..0000000
--- a/dom/media/gmp/GMPTimerChild.cpp
+++ /dev/null
@@ -1,67 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPTimerChild.h"
-#include "GMPPlatform.h"
-#include "GMPChild.h"
-
-#define MAX_NUM_TIMERS 1000
-
-namespace mozilla {
-namespace gmp {
-
-GMPTimerChild::GMPTimerChild(GMPChild* aPlugin)
-  : mTimerCount(1)
-  , mPlugin(aPlugin)
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-}
-
-GMPTimerChild::~GMPTimerChild()
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-}
-
-GMPErr
-GMPTimerChild::SetTimer(GMPTask* aTask, int64_t aTimeoutMS)
-{
-  if (!aTask) {
-    NS_WARNING("Tried to set timer with null task!");
-    return GMPGenericErr;
-  }
-
-  if (mPlugin->GMPMessageLoop() != MessageLoop::current()) {
-    NS_WARNING("Tried to set GMP timer on non-main thread.");
-    return GMPGenericErr;
-  }
-
-  if (mTimers.Count() > MAX_NUM_TIMERS) {
-    return GMPQuotaExceededErr;
-  }
-  uint32_t timerId = mTimerCount;
-  mTimers.Put(timerId, aTask);
-  mTimerCount++;
-
-  if (!SendSetTimer(timerId, aTimeoutMS)) {
-    return GMPGenericErr;
-  }
-  return GMPNoErr;
-}
-
-bool
-GMPTimerChild::RecvTimerExpired(const uint32_t& aTimerId)
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  GMPTask* task = mTimers.Get(aTimerId);
-  mTimers.Remove(aTimerId);
-  if (task) {
-    RunOnMainThread(task);
-  }
-  return true;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPTimerChild.h b/dom/media/gmp/GMPTimerChild.h
deleted file mode 100644
index acae37c..0000000
--- a/dom/media/gmp/GMPTimerChild.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPTimerChild_h_
-#define GMPTimerChild_h_
-
-#include "mozilla/gmp/PGMPTimerChild.h"
-#include "mozilla/Monitor.h"
-#include "nsDataHashtable.h"
-#include "nsHashKeys.h"
-#include "gmp-errors.h"
-#include "gmp-platform.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPChild;
-
-class GMPTimerChild : public PGMPTimerChild
-{
-public:
-  NS_INLINE_DECL_REFCOUNTING(GMPTimerChild)
-
-  explicit GMPTimerChild(GMPChild* aPlugin);
-
-  GMPErr SetTimer(GMPTask* aTask, int64_t aTimeoutMS);
-
-protected:
-  // GMPTimerChild
-  virtual bool RecvTimerExpired(const uint32_t& aTimerId) override;
-
-private:
-  ~GMPTimerChild();
-
-  nsDataHashtable<nsUint32HashKey, GMPTask*> mTimers;
-  uint32_t mTimerCount;
-
-  GMPChild* mPlugin;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPTimerChild_h_
diff --git a/dom/media/gmp/GMPTimerParent.cpp b/dom/media/gmp/GMPTimerParent.cpp
deleted file mode 100644
index ef38f6e..0000000
--- a/dom/media/gmp/GMPTimerParent.cpp
+++ /dev/null
@@ -1,131 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPTimerParent.h"
-#include "nsComponentManagerUtils.h"
-#include "mozilla/unused.h"
-
-namespace mozilla {
-
-#ifdef LOG
-#undef LOG
-#endif
-
-#ifdef PR_LOGGING
-extern PRLogModuleInfo* GetGMPLog();
-
-#define LOGD(msg) PR_LOG(GetGMPLog(), PR_LOG_DEBUG, msg)
-#define LOG(level, msg) PR_LOG(GetGMPLog(), (level), msg)
-#else
-#define LOGD(msg)
-#define LOG(level, msg)
-#endif
-
-#ifdef __CLASS__
-#undef __CLASS__
-#endif
-#define __CLASS__ "GMPParent"
-
-namespace gmp {
-
-GMPTimerParent::GMPTimerParent(nsIThread* aGMPThread)
-  : mGMPThread(aGMPThread)
-  , mIsOpen(true)
-{
-}
-
-bool
-GMPTimerParent::RecvSetTimer(const uint32_t& aTimerId,
-                             const uint32_t& aTimeoutMs)
-{
-  LOGD(("%s::%s: %p mIsOpen=%d", __CLASS__, __FUNCTION__, this, mIsOpen));
-
-  MOZ_ASSERT(mGMPThread == NS_GetCurrentThread());
-
-  if (!mIsOpen) {
-    return true;
-  }
-
-  nsresult rv;
-  nsAutoPtr<Context> ctx(new Context());
-  ctx->mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
-  NS_ENSURE_SUCCESS(rv, true);
-
-  ctx->mId = aTimerId;
-  rv = ctx->mTimer->SetTarget(mGMPThread);
-  NS_ENSURE_SUCCESS(rv, true);
-  ctx->mParent = this;
-
-  rv = ctx->mTimer->InitWithFuncCallback(&GMPTimerParent::GMPTimerExpired,
-                                          ctx,
-                                          aTimeoutMs,
-                                          nsITimer::TYPE_ONE_SHOT);
-  NS_ENSURE_SUCCESS(rv, true);
-
-  mTimers.PutEntry(ctx.forget());
-
-  return true;
-}
-
-void
-GMPTimerParent::Shutdown()
-{
-  LOGD(("%s::%s: %p mIsOpen=%d", __CLASS__, __FUNCTION__, this, mIsOpen));
-
-  MOZ_ASSERT(mGMPThread == NS_GetCurrentThread());
-  mTimers.EnumerateEntries(GMPTimerParent::CancelTimers, nullptr);
-  mTimers.Clear();
-  mIsOpen = false;
-}
-
-/*static */
-PLDHashOperator
-GMPTimerParent::CancelTimers(nsPtrHashKey<Context>* aContext, void* aClosure)
-{
-  auto context = aContext->GetKey();
-  context->mTimer->Cancel();
-  delete context;
-  return PL_DHASH_NEXT;
-}
-
-void
-GMPTimerParent::ActorDestroy(ActorDestroyReason aWhy)
-{
-  LOGD(("%s::%s: %p mIsOpen=%d", __CLASS__, __FUNCTION__, this, mIsOpen));
-
-  Shutdown();
-}
-
-/* static */
-void
-GMPTimerParent::GMPTimerExpired(nsITimer *aTimer, void *aClosure)
-{
-  MOZ_ASSERT(aClosure);
-  nsAutoPtr<Context> ctx(static_cast<Context*>(aClosure));
-  MOZ_ASSERT(ctx->mParent);
-  if (ctx->mParent) {
-    ctx->mParent->TimerExpired(ctx);
-  }
-}
-
-void
-GMPTimerParent::TimerExpired(Context* aContext)
-{
-  LOGD(("%s::%s: %p mIsOpen=%d", __CLASS__, __FUNCTION__, this, mIsOpen));
-  MOZ_ASSERT(mGMPThread == NS_GetCurrentThread());
-
-  if (!mIsOpen) {
-    return;
-  }
-
-  uint32_t id = aContext->mId;
-  mTimers.RemoveEntry(aContext);
-  if (id) {
-    unused << SendTimerExpired(id);
-  }
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPTimerParent.h b/dom/media/gmp/GMPTimerParent.h
deleted file mode 100644
index 48a6c5a..0000000
--- a/dom/media/gmp/GMPTimerParent.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPTimerParent_h_
-#define GMPTimerParent_h_
-
-#include "mozilla/gmp/PGMPTimerParent.h"
-#include "nsITimer.h"
-#include "nsCOMPtr.h"
-#include "nsClassHashtable.h"
-#include "nsHashKeys.h"
-#include "nsAutoPtr.h"
-#include "mozilla/Monitor.h"
-#include "nsIThread.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPTimerParent : public PGMPTimerParent {
-public:
-  NS_INLINE_DECL_REFCOUNTING(GMPTimerParent)
-  explicit GMPTimerParent(nsIThread* aGMPThread);
-
-  void Shutdown();
-
-protected:
-  virtual bool RecvSetTimer(const uint32_t& aTimerId,
-                            const uint32_t& aTimeoutMs) override;
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-
-private:
-  ~GMPTimerParent() {}
-
-  static void GMPTimerExpired(nsITimer *aTimer, void *aClosure);
-
-  struct Context {
-    Context() {
-      MOZ_COUNT_CTOR(Context);
-    }
-    ~Context() {
-      MOZ_COUNT_DTOR(Context);
-    }
-    nsCOMPtr<nsITimer> mTimer;
-    nsRefPtr<GMPTimerParent> mParent; // Note: live timers keep the GMPTimerParent alive.
-    uint32_t mId;
-  };
-
-  static PLDHashOperator
-  CancelTimers(nsPtrHashKey<Context>* aContext, void* aClosure);
-
-  void TimerExpired(Context* aContext);
-
-  nsTHashtable<nsPtrHashKey<Context>> mTimers;
-
-  nsCOMPtr<nsIThread> mGMPThread;
-
-  bool mIsOpen;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPTimerParent_h_
diff --git a/dom/media/gmp/GMPTypes.ipdlh b/dom/media/gmp/GMPTypes.ipdlh
deleted file mode 100644
index 7189c88..0000000
--- a/dom/media/gmp/GMPTypes.ipdlh
+++ /dev/null
@@ -1,80 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-using GMPBufferType from "gmp-video-codec.h";
-using GMPAudioCodecType from "gmp-audio-codec.h";
-
-namespace mozilla {
-namespace gmp {
-
-struct GMPDecryptionData {
-  uint8_t[] mKeyId;
-  uint8_t[] mIV;
-  uint16_t[] mClearBytes;
-  uint32_t[] mCipherBytes;
-  nsCString[] mSessionIds;
-};
-
-struct GMPVideoEncodedFrameData
-{
-  uint32_t mEncodedWidth;
-  uint32_t mEncodedHeight;
-  uint64_t mTimestamp; // microseconds
-  uint64_t mDuration; // microseconds
-  uint32_t mFrameType;
-  uint32_t mSize;
-  GMPBufferType mBufferType;
-  Shmem mBuffer;
-  bool mCompleteFrame;
-  GMPDecryptionData mDecryptionData;
-};
-
-struct GMPPlaneData
-{
-  int32_t mSize;
-  int32_t mStride;
-  Shmem mBuffer;
-};
-
-struct GMPVideoi420FrameData
-{
-  GMPPlaneData mYPlane;
-  GMPPlaneData mUPlane;
-  GMPPlaneData mVPlane;
-  int32_t mWidth;
-  int32_t mHeight;
-  uint64_t mTimestamp; // microseconds
-  uint64_t mDuration; // microseconds
-};
-
-struct GMPAudioCodecData
-{
-  GMPAudioCodecType mCodecType;
-  uint32_t mChannelCount;
-  uint32_t mBitsPerChannel;
-  uint32_t mSamplesPerSecond;
-
-  uint8_t[] mExtraData;
-};
-
-struct GMPAudioEncodedSampleData
-{
-  uint8_t[] mData;
-  uint64_t mTimeStamp; // microseconds.
-  GMPDecryptionData mDecryptionData;
-  uint32_t mChannelCount;
-  uint32_t mSamplesPerSecond;
-};
-
-struct GMPAudioDecodedSampleData
-{
-  int16_t[] mData;
-  uint64_t mTimeStamp; // microseconds.
-  uint32_t mChannelCount;
-  uint32_t mSamplesPerSecond;
-};
-
-}
-}
diff --git a/dom/media/gmp/GMPUtils.cpp b/dom/media/gmp/GMPUtils.cpp
deleted file mode 100644
index ccbf03e..0000000
--- a/dom/media/gmp/GMPUtils.cpp
+++ /dev/null
@@ -1,38 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPUtils.h"
-#include "nsDirectoryServiceDefs.h"
-#include "nsIFile.h"
-#include "nsCOMPtr.h"
-
-namespace mozilla {
-
-bool
-GetEMEVoucherPath(nsIFile** aPath)
-{
-  nsCOMPtr<nsIFile> path;
-  NS_GetSpecialDirectory(NS_GRE_DIR, getter_AddRefs(path));
-  if (!path) {
-    NS_WARNING("GetEMEVoucherPath can't get NS_GRE_DIR!");
-    return false;
-  }
-  path->AppendNative(NS_LITERAL_CSTRING("voucher.bin"));
-  path.forget(aPath);
-  return true;
-}
-
-bool
-EMEVoucherFileExists()
-{
-  nsCOMPtr<nsIFile> path;
-  bool exists;
-  return GetEMEVoucherPath(getter_AddRefs(path)) &&
-         NS_SUCCEEDED(path->Exists(&exists)) &&
-         exists;
-}
-
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPUtils.h b/dom/media/gmp/GMPUtils.h
deleted file mode 100644
index 04b3d13..0000000
--- a/dom/media/gmp/GMPUtils.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPUtils_h_
-#define GMPUtils_h_
-
-#include "mozilla/UniquePtr.h"
-
-namespace mozilla {
-
-template<typename T>
-struct GMPUniqueDestroyPolicy
-{
-  void operator()(T* aGMPObject) const {
-    aGMPObject->Destroy();
-  }
-};
-
-// Ideally, this would be a template alias, but GCC 4.6 doesn't support them.  See bug 1124021.
-template<typename T>
-struct GMPUnique {
-  typedef mozilla::UniquePtr<T, GMPUniqueDestroyPolicy<T>> Ptr;
-};
-
-bool GetEMEVoucherPath(nsIFile** aPath);
-
-bool EMEVoucherFileExists();
-
-} // namespace mozilla
-
-#endif
diff --git a/dom/media/gmp/GMPVideoDecoderChild.cpp b/dom/media/gmp/GMPVideoDecoderChild.cpp
deleted file mode 100644
index bed62b9..0000000
--- a/dom/media/gmp/GMPVideoDecoderChild.cpp
+++ /dev/null
@@ -1,203 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPVideoDecoderChild.h"
-#include "GMPVideoi420FrameImpl.h"
-#include "GMPChild.h"
-#include <stdio.h>
-#include "mozilla/unused.h"
-#include "GMPVideoEncodedFrameImpl.h"
-
-namespace mozilla {
-namespace gmp {
-
-GMPVideoDecoderChild::GMPVideoDecoderChild(GMPChild* aPlugin)
-: GMPSharedMemManager(aPlugin),
-  mPlugin(aPlugin),
-  mVideoDecoder(nullptr),
-  mVideoHost(this)
-{
-  MOZ_ASSERT(mPlugin);
-}
-
-GMPVideoDecoderChild::~GMPVideoDecoderChild()
-{
-}
-
-void
-GMPVideoDecoderChild::Init(GMPVideoDecoder* aDecoder)
-{
-  MOZ_ASSERT(aDecoder, "Cannot initialize video decoder child without a video decoder!");
-  mVideoDecoder = aDecoder;
-}
-
-GMPVideoHostImpl&
-GMPVideoDecoderChild::Host()
-{
-  return mVideoHost;
-}
-
-void
-GMPVideoDecoderChild::Decoded(GMPVideoi420Frame* aDecodedFrame)
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  if (!aDecodedFrame) {
-    MOZ_CRASH("Not given a decoded frame!");
-  }
-
-  auto df = static_cast<GMPVideoi420FrameImpl*>(aDecodedFrame);
-
-  GMPVideoi420FrameData frameData;
-  df->InitFrameData(frameData);
-  SendDecoded(frameData);
-
-  aDecodedFrame->Destroy();
-}
-
-void
-GMPVideoDecoderChild::ReceivedDecodedReferenceFrame(const uint64_t aPictureId)
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  SendReceivedDecodedReferenceFrame(aPictureId);
-}
-
-void
-GMPVideoDecoderChild::ReceivedDecodedFrame(const uint64_t aPictureId)
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  SendReceivedDecodedFrame(aPictureId);
-}
-
-void
-GMPVideoDecoderChild::InputDataExhausted()
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  SendInputDataExhausted();
-}
-
-void
-GMPVideoDecoderChild::DrainComplete()
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  SendDrainComplete();
-}
-
-void
-GMPVideoDecoderChild::ResetComplete()
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  SendResetComplete();
-}
-
-void
-GMPVideoDecoderChild::Error(GMPErr aError)
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  SendError(aError);
-}
-
-bool
-GMPVideoDecoderChild::RecvInitDecode(const GMPVideoCodec& aCodecSettings,
-                                     InfallibleTArray<uint8_t>&& aCodecSpecific,
-                                     const int32_t& aCoreCount)
-{
-  if (!mVideoDecoder) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mVideoDecoder->InitDecode(aCodecSettings,
-                            aCodecSpecific.Elements(),
-                            aCodecSpecific.Length(),
-                            this,
-                            aCoreCount);
-  return true;
-}
-
-bool
-GMPVideoDecoderChild::RecvDecode(const GMPVideoEncodedFrameData& aInputFrame,
-                                 const bool& aMissingFrames,
-                                 InfallibleTArray<uint8_t>&& aCodecSpecificInfo,
-                                 const int64_t& aRenderTimeMs)
-{
-  if (!mVideoDecoder) {
-    return false;
-  }
-
-  auto f = new GMPVideoEncodedFrameImpl(aInputFrame, &mVideoHost);
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mVideoDecoder->Decode(f,
-                        aMissingFrames,
-                        aCodecSpecificInfo.Elements(),
-                        aCodecSpecificInfo.Length(),
-                        aRenderTimeMs);
-
-  return true;
-}
-
-bool
-GMPVideoDecoderChild::RecvChildShmemForPool(Shmem&& aFrameBuffer)
-{
-  if (aFrameBuffer.IsWritable()) {
-    mVideoHost.SharedMemMgr()->MgrDeallocShmem(GMPSharedMem::kGMPFrameData,
-                                               aFrameBuffer);
-  }
-  return true;
-}
-
-bool
-GMPVideoDecoderChild::RecvReset()
-{
-  if (!mVideoDecoder) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mVideoDecoder->Reset();
-
-  return true;
-}
-
-bool
-GMPVideoDecoderChild::RecvDrain()
-{
-  if (!mVideoDecoder) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mVideoDecoder->Drain();
-
-  return true;
-}
-
-bool
-GMPVideoDecoderChild::RecvDecodingComplete()
-{
-  if (mVideoDecoder) {
-    // Ignore any return code. It is OK for this to fail without killing the process.
-    mVideoDecoder->DecodingComplete();
-    mVideoDecoder = nullptr;
-  }
-
-  mVideoHost.DoneWithAPI();
-
-  mPlugin = nullptr;
-
-  unused << Send__delete__(this);
-
-  return true;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPVideoDecoderChild.h b/dom/media/gmp/GMPVideoDecoderChild.h
deleted file mode 100644
index aa2ff84..0000000
--- a/dom/media/gmp/GMPVideoDecoderChild.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPVideoDecoderChild_h_
-#define GMPVideoDecoderChild_h_
-
-#include "nsString.h"
-#include "mozilla/gmp/PGMPVideoDecoderChild.h"
-#include "gmp-video-decode.h"
-#include "GMPSharedMemManager.h"
-#include "GMPVideoHost.h"
-#include "mozilla/gmp/GMPTypes.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPChild;
-
-class GMPVideoDecoderChild : public PGMPVideoDecoderChild,
-                             public GMPVideoDecoderCallback,
-                             public GMPSharedMemManager
-{
-public:
-  explicit GMPVideoDecoderChild(GMPChild* aPlugin);
-  virtual ~GMPVideoDecoderChild();
-
-  void Init(GMPVideoDecoder* aDecoder);
-  GMPVideoHostImpl& Host();
-
-  // GMPVideoDecoderCallback
-  virtual void Decoded(GMPVideoi420Frame* decodedFrame) override;
-  virtual void ReceivedDecodedReferenceFrame(const uint64_t pictureId) override;
-  virtual void ReceivedDecodedFrame(const uint64_t pictureId) override;
-  virtual void InputDataExhausted() override;
-  virtual void DrainComplete() override;
-  virtual void ResetComplete() override;
-  virtual void Error(GMPErr aError) override;
-
-  // GMPSharedMemManager
-  virtual bool Alloc(size_t aSize, Shmem::SharedMemory::SharedMemoryType aType, Shmem* aMem) override
-  {
-#ifndef SHMEM_ALLOC_IN_CHILD
-    return CallNeedShmem(aSize, aMem);
-#else
-#ifdef GMP_SAFE_SHMEM
-    return AllocShmem(aSize, aType, aMem);
-#else
-    return AllocUnsafeShmem(aSize, aType, aMem);
-#endif
-#endif
-  }
-  virtual void Dealloc(Shmem& aMem) override
-  {
-#ifndef SHMEM_ALLOC_IN_CHILD
-    SendParentShmemForPool(aMem);
-#else
-    DeallocShmem(aMem);
-#endif
-  }
-
-private:
-  // PGMPVideoDecoderChild
-  virtual bool RecvInitDecode(const GMPVideoCodec& aCodecSettings,
-                              InfallibleTArray<uint8_t>&& aCodecSpecific,
-                              const int32_t& aCoreCount) override;
-  virtual bool RecvDecode(const GMPVideoEncodedFrameData& aInputFrame,
-                          const bool& aMissingFrames,
-                          InfallibleTArray<uint8_t>&& aCodecSpecificInfo,
-                          const int64_t& aRenderTimeMs) override;
-  virtual bool RecvChildShmemForPool(Shmem&& aFrameBuffer) override;
-  virtual bool RecvReset() override;
-  virtual bool RecvDrain() override;
-  virtual bool RecvDecodingComplete() override;
-
-  GMPChild* mPlugin;
-  GMPVideoDecoder* mVideoDecoder;
-  GMPVideoHostImpl mVideoHost;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPVideoDecoderChild_h_
diff --git a/dom/media/gmp/GMPVideoDecoderParent.cpp b/dom/media/gmp/GMPVideoDecoderParent.cpp
deleted file mode 100644
index d5d157e..0000000
--- a/dom/media/gmp/GMPVideoDecoderParent.cpp
+++ /dev/null
@@ -1,380 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPVideoDecoderParent.h"
-#include "prlog.h"
-#include "mozilla/unused.h"
-#include "nsAutoRef.h"
-#include "nsThreadUtils.h"
-#include "GMPUtils.h"
-#include "GMPVideoEncodedFrameImpl.h"
-#include "GMPVideoi420FrameImpl.h"
-#include "GMPParent.h"
-#include "GMPMessageUtils.h"
-#include "mozilla/gmp/GMPTypes.h"
-
-namespace mozilla {
-
-#ifdef LOG
-#undef LOG
-#endif
-
-#ifdef PR_LOGGING
-extern PRLogModuleInfo* GetGMPLog();
-
-#define LOGD(msg) PR_LOG(GetGMPLog(), PR_LOG_DEBUG, msg)
-#define LOG(level, msg) PR_LOG(GetGMPLog(), (level), msg)
-#else
-#define LOGD(msg)
-#define LOG(level, msg)
-#endif
-
-namespace gmp {
-
-// States:
-// Initial: mIsOpen == false
-//    on InitDecode success -> Open
-//    on Shutdown -> Dead
-// Open: mIsOpen == true
-//    on Close -> Dead
-//    on ActorDestroy -> Dead
-//    on Shutdown -> Dead
-// Dead: mIsOpen == false
-
-GMPVideoDecoderParent::GMPVideoDecoderParent(GMPParent* aPlugin)
-  : GMPSharedMemManager(aPlugin)
-  , mIsOpen(false)
-  , mShuttingDown(false)
-  , mPlugin(aPlugin)
-  , mCallback(nullptr)
-  , mVideoHost(this)
-{
-  MOZ_ASSERT(mPlugin);
-}
-
-GMPVideoDecoderParent::~GMPVideoDecoderParent()
-{
-}
-
-GMPVideoHostImpl&
-GMPVideoDecoderParent::Host()
-{
-  return mVideoHost;
-}
-
-// Note: may be called via Terminated()
-void
-GMPVideoDecoderParent::Close()
-{
-  LOGD(("%s: %p", __FUNCTION__, this));
-  MOZ_ASSERT(!mPlugin || mPlugin->GMPThread() == NS_GetCurrentThread());
-  // Consumer is done with us; we can shut down.  No more callbacks should
-  // be made to mCallback.  Note: do this before Shutdown()!
-  mCallback = nullptr;
-  // Let Shutdown mark us as dead so it knows if we had been alive
-
-  // In case this is the last reference
-  nsRefPtr<GMPVideoDecoderParent> kungfudeathgrip(this);
-  Release();
-  Shutdown();
-}
-
-nsresult
-GMPVideoDecoderParent::InitDecode(const GMPVideoCodec& aCodecSettings,
-                                  const nsTArray<uint8_t>& aCodecSpecific,
-                                  GMPVideoDecoderCallbackProxy* aCallback,
-                                  int32_t aCoreCount)
-{
-  if (mIsOpen) {
-    NS_WARNING("Trying to re-init an in-use GMP video decoder!");
-    return NS_ERROR_FAILURE;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (!aCallback) {
-    return NS_ERROR_FAILURE;
-  }
-  mCallback = aCallback;
-
-  if (!SendInitDecode(aCodecSettings, aCodecSpecific, aCoreCount)) {
-    return NS_ERROR_FAILURE;
-  }
-  mIsOpen = true;
-
-  // Async IPC, we don't have access to a return value.
-  return NS_OK;
-}
-
-nsresult
-GMPVideoDecoderParent::Decode(GMPUnique<GMPVideoEncodedFrame>::Ptr aInputFrame,
-                              bool aMissingFrames,
-                              const nsTArray<uint8_t>& aCodecSpecificInfo,
-                              int64_t aRenderTimeMs)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use an dead GMP video decoder");
-    return NS_ERROR_FAILURE;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  GMPUnique<GMPVideoEncodedFrameImpl>::Ptr inputFrameImpl(
-    static_cast<GMPVideoEncodedFrameImpl*>(aInputFrame.release()));
-
-  // Very rough kill-switch if the plugin stops processing.  If it's merely
-  // hung and continues, we'll come back to life eventually.
-  // 3* is because we're using 3 buffers per frame for i420 data for now.
-  if ((NumInUse(GMPSharedMem::kGMPFrameData) > 3*GMPSharedMem::kGMPBufLimit) ||
-      (NumInUse(GMPSharedMem::kGMPEncodedData) > GMPSharedMem::kGMPBufLimit)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  GMPVideoEncodedFrameData frameData;
-  inputFrameImpl->RelinquishFrameData(frameData);
-
-  if (!SendDecode(frameData,
-                  aMissingFrames,
-                  aCodecSpecificInfo,
-                  aRenderTimeMs)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // Async IPC, we don't have access to a return value.
-  return NS_OK;
-}
-
-nsresult
-GMPVideoDecoderParent::Reset()
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use an dead GMP video decoder");
-    return NS_ERROR_FAILURE;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (!SendReset()) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // Async IPC, we don't have access to a return value.
-  return NS_OK;
-}
-
-nsresult
-GMPVideoDecoderParent::Drain()
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use an dead GMP video decoder");
-    return NS_ERROR_FAILURE;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (!SendDrain()) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // Async IPC, we don't have access to a return value.
-  return NS_OK;
-}
-
-const nsCString&
-GMPVideoDecoderParent::GetDisplayName() const
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use an dead GMP video decoder");
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  return mPlugin->GetDisplayName();
-}
-
-// Note: Consider keeping ActorDestroy sync'd up when making changes here.
-nsresult
-GMPVideoDecoderParent::Shutdown()
-{
-  LOGD(("%s: %p", __FUNCTION__, this));
-  MOZ_ASSERT(!mPlugin || mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (mShuttingDown) {
-    return NS_OK;
-  }
-  mShuttingDown = true;
-
-  // Notify client we're gone!  Won't occur after Close()
-  if (mCallback) {
-    mCallback->Terminated();
-    mCallback = nullptr;
-  }
-
-  mIsOpen = false;
-  unused << SendDecodingComplete();
-
-  return NS_OK;
-}
-
-// Note: Keep this sync'd up with Shutdown
-void
-GMPVideoDecoderParent::ActorDestroy(ActorDestroyReason aWhy)
-{
-  mIsOpen = false;
-  mVideoHost.DoneWithAPI();
-
-  if (mCallback) {
-    // May call Close() (and Shutdown()) immediately or with a delay
-    mCallback->Terminated();
-    mCallback = nullptr;
-  }
-  if (mPlugin) {
-    // Ignore any return code. It is OK for this to fail without killing the process.
-    mPlugin->VideoDecoderDestroyed(this);
-    mPlugin = nullptr;
-  }
-  mVideoHost.ActorDestroyed();
-}
-
-bool
-GMPVideoDecoderParent::RecvDecoded(const GMPVideoi420FrameData& aDecodedFrame)
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  if (!GMPVideoi420FrameImpl::CheckFrameData(aDecodedFrame)) {
-    LOG(PR_LOG_ERROR, ("%s: Decoded frame corrupt, ignoring", __FUNCTION__));
-    return false;
-  }
-  auto f = new GMPVideoi420FrameImpl(aDecodedFrame, &mVideoHost);
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mCallback->Decoded(f);
-
-  return true;
-}
-
-bool
-GMPVideoDecoderParent::RecvReceivedDecodedReferenceFrame(const uint64_t& aPictureId)
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mCallback->ReceivedDecodedReferenceFrame(aPictureId);
-
-  return true;
-}
-
-bool
-GMPVideoDecoderParent::RecvReceivedDecodedFrame(const uint64_t& aPictureId)
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mCallback->ReceivedDecodedFrame(aPictureId);
-
-  return true;
-}
-
-bool
-GMPVideoDecoderParent::RecvInputDataExhausted()
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mCallback->InputDataExhausted();
-
-  return true;
-}
-
-bool
-GMPVideoDecoderParent::RecvDrainComplete()
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mCallback->DrainComplete();
-
-  return true;
-}
-
-bool
-GMPVideoDecoderParent::RecvResetComplete()
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mCallback->ResetComplete();
-
-  return true;
-}
-
-bool
-GMPVideoDecoderParent::RecvError(const GMPErr& aError)
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mCallback->Error(aError);
-
-  return true;
-}
-
-bool
-GMPVideoDecoderParent::RecvParentShmemForPool(Shmem&& aEncodedBuffer)
-{
-  if (aEncodedBuffer.IsWritable()) {
-    mVideoHost.SharedMemMgr()->MgrDeallocShmem(GMPSharedMem::kGMPEncodedData,
-                                               aEncodedBuffer);
-  }
-  return true;
-}
-
-bool
-GMPVideoDecoderParent::AnswerNeedShmem(const uint32_t& aFrameBufferSize,
-                                       Shmem* aMem)
-{
-  ipc::Shmem mem;
-
-  if (!mVideoHost.SharedMemMgr()->MgrAllocShmem(GMPSharedMem::kGMPFrameData,
-                                                aFrameBufferSize,
-                                                ipc::SharedMemory::TYPE_BASIC, &mem))
-  {
-    LOG(PR_LOG_ERROR, ("%s: Failed to get a shared mem buffer for Child! size %u",
-                       __FUNCTION__, aFrameBufferSize));
-    return false;
-  }
-  *aMem = mem;
-  mem = ipc::Shmem();
-  return true;
-}
-
-bool
-GMPVideoDecoderParent::Recv__delete__()
-{
-  if (mPlugin) {
-    // Ignore any return code. It is OK for this to fail without killing the process.
-    mPlugin->VideoDecoderDestroyed(this);
-    mPlugin = nullptr;
-  }
-
-  return true;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPVideoDecoderParent.h b/dom/media/gmp/GMPVideoDecoderParent.h
deleted file mode 100644
index 23c4d70..0000000
--- a/dom/media/gmp/GMPVideoDecoderParent.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPVideoDecoderParent_h_
-#define GMPVideoDecoderParent_h_
-
-#include "mozilla/RefPtr.h"
-#include "gmp-video-decode.h"
-#include "mozilla/gmp/PGMPVideoDecoderParent.h"
-#include "GMPMessageUtils.h"
-#include "GMPSharedMemManager.h"
-#include "GMPUtils.h"
-#include "GMPVideoHost.h"
-#include "GMPVideoDecoderProxy.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPParent;
-
-class GMPVideoDecoderParent final : public PGMPVideoDecoderParent
-                                      , public GMPVideoDecoderProxy
-                                      , public GMPSharedMemManager
-{
-public:
-  NS_INLINE_DECL_REFCOUNTING(GMPVideoDecoderParent)
-
-  explicit GMPVideoDecoderParent(GMPParent *aPlugin);
-
-  GMPVideoHostImpl& Host();
-  nsresult Shutdown();
-
-  // GMPVideoDecoder
-  virtual void Close() override;
-  virtual nsresult InitDecode(const GMPVideoCodec& aCodecSettings,
-                              const nsTArray<uint8_t>& aCodecSpecific,
-                              GMPVideoDecoderCallbackProxy* aCallback,
-                              int32_t aCoreCount) override;
-  virtual nsresult Decode(GMPUnique<GMPVideoEncodedFrame>::Ptr aInputFrame,
-                          bool aMissingFrames,
-                          const nsTArray<uint8_t>& aCodecSpecificInfo,
-                          int64_t aRenderTimeMs = -1) override;
-  virtual nsresult Reset() override;
-  virtual nsresult Drain() override;
-  virtual const uint64_t ParentID() override { return reinterpret_cast<uint64_t>(mPlugin.get()); }
-  virtual const nsCString& GetDisplayName() const override;
-
-  // GMPSharedMemManager
-  virtual bool Alloc(size_t aSize, Shmem::SharedMemory::SharedMemoryType aType, Shmem* aMem) override
-  {
-#ifdef GMP_SAFE_SHMEM
-    return AllocShmem(aSize, aType, aMem);
-#else
-    return AllocUnsafeShmem(aSize, aType, aMem);
-#endif
-  }
-  virtual void Dealloc(Shmem& aMem) override
-  {
-    DeallocShmem(aMem);
-  }
-
-private:
-  ~GMPVideoDecoderParent();
-
-  // PGMPVideoDecoderParent
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-  virtual bool RecvDecoded(const GMPVideoi420FrameData& aDecodedFrame) override;
-  virtual bool RecvReceivedDecodedReferenceFrame(const uint64_t& aPictureId) override;
-  virtual bool RecvReceivedDecodedFrame(const uint64_t& aPictureId) override;
-  virtual bool RecvInputDataExhausted() override;
-  virtual bool RecvDrainComplete() override;
-  virtual bool RecvResetComplete() override;
-  virtual bool RecvError(const GMPErr& aError) override;
-  virtual bool RecvParentShmemForPool(Shmem&& aEncodedBuffer) override;
-  virtual bool AnswerNeedShmem(const uint32_t& aFrameBufferSize,
-                               Shmem* aMem) override;
-  virtual bool Recv__delete__() override;
-
-  bool mIsOpen;
-  bool mShuttingDown;
-  nsRefPtr<GMPParent> mPlugin;
-  GMPVideoDecoderCallbackProxy* mCallback;
-  GMPVideoHostImpl mVideoHost;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPVideoDecoderParent_h_
diff --git a/dom/media/gmp/GMPVideoDecoderProxy.h b/dom/media/gmp/GMPVideoDecoderProxy.h
deleted file mode 100644
index 6a90f9d..0000000
--- a/dom/media/gmp/GMPVideoDecoderProxy.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPVideoDecoderProxy_h_
-#define GMPVideoDecoderProxy_h_
-
-#include "nsTArray.h"
-#include "gmp-video-decode.h"
-#include "gmp-video-frame-i420.h"
-#include "gmp-video-frame-encoded.h"
-
-#include "GMPCallbackBase.h"
-#include "GMPUtils.h"
-
-class nsCString;
-
-class GMPVideoDecoderCallbackProxy : public GMPCallbackBase,
-                                     public GMPVideoDecoderCallback
-{
-public:
-  virtual ~GMPVideoDecoderCallbackProxy() {}
-};
-
-// A proxy to GMPVideoDecoder in the child process.
-// GMPVideoDecoderParent exposes this to users the GMP.
-// This enables Goanna to pass nsTArrays to the child GMP and avoid
-// an extra copy when doing so.
-
-// The consumer must call Close() when done with the codec, or when
-// Terminated() is called by the GMP plugin indicating an abnormal shutdown
-// of the underlying plugin.  After calling Close(), the consumer must
-// not access this again.
-
-// This interface is not thread-safe and must only be used from GMPThread.
-class GMPVideoDecoderProxy {
-public:
-  virtual nsresult InitDecode(const GMPVideoCodec& aCodecSettings,
-                              const nsTArray<uint8_t>& aCodecSpecific,
-                              GMPVideoDecoderCallbackProxy* aCallback,
-                              int32_t aCoreCount) = 0;
-  virtual nsresult Decode(mozilla::GMPUnique<GMPVideoEncodedFrame>::Ptr aInputFrame,
-                          bool aMissingFrames,
-                          const nsTArray<uint8_t>& aCodecSpecificInfo,
-                          int64_t aRenderTimeMs = -1) = 0;
-  virtual nsresult Reset() = 0;
-  virtual nsresult Drain() = 0;
-  virtual const uint64_t ParentID() = 0;
-
-  // Call to tell GMP/plugin the consumer will no longer use this
-  // interface/codec.
-  virtual void Close() = 0;
-
-  virtual const nsCString& GetDisplayName() const = 0;
-};
-
-#endif
diff --git a/dom/media/gmp/GMPVideoEncodedFrameImpl.cpp b/dom/media/gmp/GMPVideoEncodedFrameImpl.cpp
deleted file mode 100644
index 7725c55..0000000
--- a/dom/media/gmp/GMPVideoEncodedFrameImpl.cpp
+++ /dev/null
@@ -1,324 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPVideoEncodedFrameImpl.h"
-#include "GMPVideoHost.h"
-#include "mozilla/gmp/GMPTypes.h"
-#include "GMPSharedMemManager.h"
-#include "GMPEncryptedBufferDataImpl.h"
-
-namespace mozilla {
-namespace gmp {
-
-GMPVideoEncodedFrameImpl::GMPVideoEncodedFrameImpl(GMPVideoHostImpl* aHost)
-: mEncodedWidth(0),
-  mEncodedHeight(0),
-  mTimeStamp(0ll),
-  mDuration(0ll),
-  mFrameType(kGMPDeltaFrame),
-  mSize(0),
-  mCompleteFrame(false),
-  mHost(aHost),
-  mBufferType(GMP_BufferSingle)
-{
-  MOZ_ASSERT(aHost);
-  aHost->EncodedFrameCreated(this);
-}
-
-GMPVideoEncodedFrameImpl::GMPVideoEncodedFrameImpl(const GMPVideoEncodedFrameData& aFrameData,
-                                                   GMPVideoHostImpl* aHost)
-: mEncodedWidth(aFrameData.mEncodedWidth()),
-  mEncodedHeight(aFrameData.mEncodedHeight()),
-  mTimeStamp(aFrameData.mTimestamp()),
-  mDuration(aFrameData.mDuration()),
-  mFrameType(static_cast<GMPVideoFrameType>(aFrameData.mFrameType())),
-  mSize(aFrameData.mSize()),
-  mCompleteFrame(aFrameData.mCompleteFrame()),
-  mHost(aHost),
-  mBuffer(aFrameData.mBuffer()),
-  mBufferType(aFrameData.mBufferType())
-{
-  MOZ_ASSERT(aHost);
-  if (aFrameData.mDecryptionData().mKeyId().Length() > 0) {
-    mCrypto = new GMPEncryptedBufferDataImpl(aFrameData.mDecryptionData());
-  }
-  aHost->EncodedFrameCreated(this);
-}
-
-GMPVideoEncodedFrameImpl::~GMPVideoEncodedFrameImpl()
-{
-  DestroyBuffer();
-  if (mHost) {
-    mHost->EncodedFrameDestroyed(this);
-  }
-}
-
-void
-GMPVideoEncodedFrameImpl::InitCrypto(const CryptoSample& aCrypto)
-{
-  mCrypto = new GMPEncryptedBufferDataImpl(aCrypto);
-}
-
-const GMPEncryptedBufferMetadata*
-GMPVideoEncodedFrameImpl::GetDecryptionData() const
-{
-  return mCrypto;
-}
-
-GMPVideoFrameFormat
-GMPVideoEncodedFrameImpl::GetFrameFormat()
-{
-  return kGMPEncodedVideoFrame;
-}
-
-void
-GMPVideoEncodedFrameImpl::DoneWithAPI()
-{
-  DestroyBuffer();
-
-  // Do this after destroying the buffer because destruction
-  // involves deallocation, which requires a host.
-  mHost = nullptr;
-}
-
-void
-GMPVideoEncodedFrameImpl::ActorDestroyed()
-{
-  // Simply clear out Shmem reference, do not attempt to
-  // properly free it. It has already been freed.
-  mBuffer = ipc::Shmem();
-  // No more host.
-  mHost = nullptr;
-}
-
-bool
-GMPVideoEncodedFrameImpl::RelinquishFrameData(GMPVideoEncodedFrameData& aFrameData)
-{
-  aFrameData.mEncodedWidth() = mEncodedWidth;
-  aFrameData.mEncodedHeight() = mEncodedHeight;
-  aFrameData.mTimestamp() = mTimeStamp;
-  aFrameData.mDuration() = mDuration;
-  aFrameData.mFrameType() = mFrameType;
-  aFrameData.mSize() = mSize;
-  aFrameData.mCompleteFrame() = mCompleteFrame;
-  aFrameData.mBuffer() = mBuffer;
-  aFrameData.mBufferType() = mBufferType;
-  if (mCrypto) {
-    mCrypto->RelinquishData(aFrameData.mDecryptionData());
-  }
-
-  // This method is called right before Shmem is sent to another process.
-  // We need to effectively zero out our member copy so that we don't
-  // try to delete Shmem we don't own later.
-  mBuffer = ipc::Shmem();
-
-  return true;
-}
-
-void
-GMPVideoEncodedFrameImpl::DestroyBuffer()
-{
-  if (mHost && mBuffer.IsWritable()) {
-    mHost->SharedMemMgr()->MgrDeallocShmem(GMPSharedMem::kGMPEncodedData, mBuffer);
-  }
-  mBuffer = ipc::Shmem();
-}
-
-GMPErr
-GMPVideoEncodedFrameImpl::CreateEmptyFrame(uint32_t aSize)
-{
-  if (aSize == 0) {
-    DestroyBuffer();
-  } else if (aSize > AllocatedSize()) {
-    DestroyBuffer();
-    if (!mHost->SharedMemMgr()->MgrAllocShmem(GMPSharedMem::kGMPEncodedData, aSize,
-                                              ipc::SharedMemory::TYPE_BASIC, &mBuffer) ||
-        !Buffer()) {
-      return GMPAllocErr;
-    }
-  }
-  mSize = aSize;
-
-  return GMPNoErr;
-}
-
-GMPErr
-GMPVideoEncodedFrameImpl::CopyFrame(const GMPVideoEncodedFrame& aFrame)
-{
-  auto& f = static_cast<const GMPVideoEncodedFrameImpl&>(aFrame);
-
-  if (f.mSize != 0) {
-    GMPErr err = CreateEmptyFrame(f.mSize);
-    if (err != GMPNoErr) {
-      return err;
-    }
-    memcpy(Buffer(), f.Buffer(), f.mSize);
-  }
-  mEncodedWidth = f.mEncodedWidth;
-  mEncodedHeight = f.mEncodedHeight;
-  mTimeStamp = f.mTimeStamp;
-  mDuration = f.mDuration;
-  mFrameType = f.mFrameType;
-  mSize = f.mSize; // already set...
-  mCompleteFrame = f.mCompleteFrame;
-  mBufferType = f.mBufferType;
-  mCrypto = new GMPEncryptedBufferDataImpl(*(f.mCrypto));
-  // Don't copy host, that should have been set properly on object creation via host.
-
-  return GMPNoErr;
-}
-
-void
-GMPVideoEncodedFrameImpl::SetEncodedWidth(uint32_t aEncodedWidth)
-{
-  mEncodedWidth = aEncodedWidth;
-}
-
-uint32_t
-GMPVideoEncodedFrameImpl::EncodedWidth()
-{
-  return mEncodedWidth;
-}
-
-void
-GMPVideoEncodedFrameImpl::SetEncodedHeight(uint32_t aEncodedHeight)
-{
-  mEncodedHeight = aEncodedHeight;
-}
-
-uint32_t
-GMPVideoEncodedFrameImpl::EncodedHeight()
-{
-  return mEncodedHeight;
-}
-
-void
-GMPVideoEncodedFrameImpl::SetTimeStamp(uint64_t aTimeStamp)
-{
-  mTimeStamp = aTimeStamp;
-}
-
-uint64_t
-GMPVideoEncodedFrameImpl::TimeStamp()
-{
-  return mTimeStamp;
-}
-
-void
-GMPVideoEncodedFrameImpl::SetDuration(uint64_t aDuration)
-{
-  mDuration = aDuration;
-}
-
-uint64_t
-GMPVideoEncodedFrameImpl::Duration() const
-{
-  return mDuration;
-}
-
-void
-GMPVideoEncodedFrameImpl::SetFrameType(GMPVideoFrameType aFrameType)
-{
-  mFrameType = aFrameType;
-}
-
-GMPVideoFrameType
-GMPVideoEncodedFrameImpl::FrameType()
-{
-  return mFrameType;
-}
-
-void
-GMPVideoEncodedFrameImpl::SetAllocatedSize(uint32_t aNewSize)
-{
-  if (aNewSize <= AllocatedSize()) {
-    return;
-  }
-
-  if (!mHost) {
-    return;
-  }
-
-  ipc::Shmem new_mem;
-  if (!mHost->SharedMemMgr()->MgrAllocShmem(GMPSharedMem::kGMPEncodedData, aNewSize,
-                                            ipc::SharedMemory::TYPE_BASIC, &new_mem) ||
-      !new_mem.get<uint8_t>()) {
-    return;
-  }
-
-  if (mBuffer.IsReadable()) {
-    memcpy(new_mem.get<uint8_t>(), Buffer(), mSize);
-  }
-
-  DestroyBuffer();
-
-  mBuffer = new_mem;
-}
-
-uint32_t
-GMPVideoEncodedFrameImpl::AllocatedSize()
-{
-  if (mBuffer.IsWritable()) {
-    return mBuffer.Size<uint8_t>();
-  }
-  return 0;
-}
-
-void
-GMPVideoEncodedFrameImpl::SetSize(uint32_t aSize)
-{
-  mSize = aSize;
-}
-
-uint32_t
-GMPVideoEncodedFrameImpl::Size()
-{
-  return mSize;
-}
-
-void
-GMPVideoEncodedFrameImpl::SetCompleteFrame(bool aCompleteFrame)
-{
-  mCompleteFrame = aCompleteFrame;
-}
-
-bool
-GMPVideoEncodedFrameImpl::CompleteFrame()
-{
-  return mCompleteFrame;
-}
-
-const uint8_t*
-GMPVideoEncodedFrameImpl::Buffer() const
-{
-  return mBuffer.get<uint8_t>();
-}
-
-uint8_t*
-GMPVideoEncodedFrameImpl::Buffer()
-{
-  return mBuffer.get<uint8_t>();
-}
-
-void
-GMPVideoEncodedFrameImpl::Destroy()
-{
-  delete this;
-}
-
-GMPBufferType
-GMPVideoEncodedFrameImpl::BufferType() const
-{
-  return mBufferType;
-}
-
-void
-GMPVideoEncodedFrameImpl::SetBufferType(GMPBufferType aBufferType)
-{
-  mBufferType = aBufferType;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPVideoEncodedFrameImpl.h b/dom/media/gmp/GMPVideoEncodedFrameImpl.h
deleted file mode 100644
index 8383934..0000000
--- a/dom/media/gmp/GMPVideoEncodedFrameImpl.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* Copyright (c) 2014, Mozilla Corporation
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above
- *    copyright notice, this list of conditions and the following
- *    disclaimer in the documentation and/or other materials provided
- *    with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GMPVideoEncodedFrameImpl_h_
-#define GMPVideoEncodedFrameImpl_h_
-
-#include "gmp-errors.h"
-#include "gmp-video-frame.h"
-#include "gmp-video-frame-encoded.h"
-#include "gmp-decryption.h"
-#include "mozilla/ipc/Shmem.h"
-
-namespace mozilla {
-class CryptoSample;
-
-namespace gmp {
-
-class GMPVideoHostImpl;
-class GMPVideoEncodedFrameData;
-class GMPEncryptedBufferDataImpl;
-
-class GMPVideoEncodedFrameImpl: public GMPVideoEncodedFrame
-{
-  friend struct IPC::ParamTraits<mozilla::gmp::GMPVideoEncodedFrameImpl>;
-public:
-  explicit GMPVideoEncodedFrameImpl(GMPVideoHostImpl* aHost);
-  GMPVideoEncodedFrameImpl(const GMPVideoEncodedFrameData& aFrameData, GMPVideoHostImpl* aHost);
-  virtual ~GMPVideoEncodedFrameImpl();
-
-  void InitCrypto(const CryptoSample& aCrypto);
-
-  // This is called during a normal destroy sequence, which is
-  // when a consumer is finished or during XPCOM shutdown.
-  void DoneWithAPI();
-  // Does not attempt to release Shmem, as the Shmem has already been released.
-  void ActorDestroyed();
-
-  bool RelinquishFrameData(GMPVideoEncodedFrameData& aFrameData);
-
-  // GMPVideoFrame
-  virtual GMPVideoFrameFormat GetFrameFormat() override;
-  virtual void Destroy() override;
-
-  // GMPVideoEncodedFrame
-  virtual GMPErr   CreateEmptyFrame(uint32_t aSize) override;
-  virtual GMPErr   CopyFrame(const GMPVideoEncodedFrame& aFrame) override;
-  virtual void     SetEncodedWidth(uint32_t aEncodedWidth) override;
-  virtual uint32_t EncodedWidth() override;
-  virtual void     SetEncodedHeight(uint32_t aEncodedHeight) override;
-  virtual uint32_t EncodedHeight() override;
-  // Microseconds
-  virtual void     SetTimeStamp(uint64_t aTimeStamp) override;
-  virtual uint64_t TimeStamp() override;
-  // Set frame duration (microseconds)
-  // NOTE: next-frame's Timestamp() != this-frame's TimeStamp()+Duration()
-  // depending on rounding to avoid having to track roundoff errors
-  // and dropped/missing frames(!) (which may leave a large gap)
-  virtual void     SetDuration(uint64_t aDuration) override;
-  virtual uint64_t Duration() const override;
-  virtual void     SetFrameType(GMPVideoFrameType aFrameType) override;
-  virtual GMPVideoFrameType FrameType() override;
-  virtual void     SetAllocatedSize(uint32_t aNewSize) override;
-  virtual uint32_t AllocatedSize() override;
-  virtual void     SetSize(uint32_t aSize) override;
-  virtual uint32_t Size() override;
-  virtual void     SetCompleteFrame(bool aCompleteFrame) override;
-  virtual bool     CompleteFrame() override;
-  virtual const uint8_t* Buffer() const override;
-  virtual uint8_t* Buffer() override;
-  virtual GMPBufferType BufferType() const override;
-  virtual void     SetBufferType(GMPBufferType aBufferType) override;
-  virtual const    GMPEncryptedBufferMetadata* GetDecryptionData() const override;
-
-private:
-  void DestroyBuffer();
-
-  uint32_t mEncodedWidth;
-  uint32_t mEncodedHeight;
-  uint64_t mTimeStamp;
-  uint64_t mDuration;
-  GMPVideoFrameType mFrameType;
-  uint32_t mSize;
-  bool     mCompleteFrame;
-  GMPVideoHostImpl* mHost;
-  ipc::Shmem mBuffer;
-  GMPBufferType mBufferType;
-  nsAutoPtr<GMPEncryptedBufferDataImpl> mCrypto;
-};
-
-} // namespace gmp
-
-} // namespace mozilla
-
-#endif // GMPVideoEncodedFrameImpl_h_
diff --git a/dom/media/gmp/GMPVideoEncoderChild.cpp b/dom/media/gmp/GMPVideoEncoderChild.cpp
deleted file mode 100644
index 14df35e..0000000
--- a/dom/media/gmp/GMPVideoEncoderChild.cpp
+++ /dev/null
@@ -1,183 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPVideoEncoderChild.h"
-#include "GMPChild.h"
-#include <stdio.h>
-#include "mozilla/unused.h"
-#include "GMPVideoEncodedFrameImpl.h"
-#include "GMPVideoi420FrameImpl.h"
-
-namespace mozilla {
-namespace gmp {
-
-GMPVideoEncoderChild::GMPVideoEncoderChild(GMPChild* aPlugin)
-: GMPSharedMemManager(aPlugin),
-  mPlugin(aPlugin),
-  mVideoEncoder(nullptr),
-  mVideoHost(this)
-{
-  MOZ_ASSERT(mPlugin);
-}
-
-GMPVideoEncoderChild::~GMPVideoEncoderChild()
-{
-}
-
-void
-GMPVideoEncoderChild::Init(GMPVideoEncoder* aEncoder)
-{
-  MOZ_ASSERT(aEncoder, "Cannot initialize video encoder child without a video encoder!");
-  mVideoEncoder = aEncoder;
-}
-
-GMPVideoHostImpl&
-GMPVideoEncoderChild::Host()
-{
-  return mVideoHost;
-}
-
-void
-GMPVideoEncoderChild::Encoded(GMPVideoEncodedFrame* aEncodedFrame,
-                              const uint8_t* aCodecSpecificInfo,
-                              uint32_t aCodecSpecificInfoLength)
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  auto ef = static_cast<GMPVideoEncodedFrameImpl*>(aEncodedFrame);
-
-  GMPVideoEncodedFrameData frameData;
-  ef->RelinquishFrameData(frameData);
-
-  nsTArray<uint8_t> codecSpecific;
-  codecSpecific.AppendElements(aCodecSpecificInfo, aCodecSpecificInfoLength);
-  SendEncoded(frameData, codecSpecific);
-
-  aEncodedFrame->Destroy();
-}
-
-void
-GMPVideoEncoderChild::Error(GMPErr aError)
-{
-  MOZ_ASSERT(mPlugin->GMPMessageLoop() == MessageLoop::current());
-
-  SendError(aError);
-}
-
-bool
-GMPVideoEncoderChild::RecvInitEncode(const GMPVideoCodec& aCodecSettings,
-                                     InfallibleTArray<uint8_t>&& aCodecSpecific,
-                                     const int32_t& aNumberOfCores,
-                                     const uint32_t& aMaxPayloadSize)
-{
-  if (!mVideoEncoder) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mVideoEncoder->InitEncode(aCodecSettings,
-                            aCodecSpecific.Elements(),
-                            aCodecSpecific.Length(),
-                            this,
-                            aNumberOfCores,
-                            aMaxPayloadSize);
-
-  return true;
-}
-
-bool
-GMPVideoEncoderChild::RecvEncode(const GMPVideoi420FrameData& aInputFrame,
-                                 InfallibleTArray<uint8_t>&& aCodecSpecificInfo,
-                                 InfallibleTArray<GMPVideoFrameType>&& aFrameTypes)
-{
-  if (!mVideoEncoder) {
-    return false;
-  }
-
-  auto f = new GMPVideoi420FrameImpl(aInputFrame, &mVideoHost);
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mVideoEncoder->Encode(f,
-                        aCodecSpecificInfo.Elements(),
-                        aCodecSpecificInfo.Length(),
-                        aFrameTypes.Elements(),
-                        aFrameTypes.Length());
-
-  return true;
-}
-
-bool
-GMPVideoEncoderChild::RecvChildShmemForPool(Shmem&& aEncodedBuffer)
-{
-  if (aEncodedBuffer.IsWritable()) {
-    mVideoHost.SharedMemMgr()->MgrDeallocShmem(GMPSharedMem::kGMPEncodedData,
-                                               aEncodedBuffer);
-  }
-  return true;
-}
-
-bool
-GMPVideoEncoderChild::RecvSetChannelParameters(const uint32_t& aPacketLoss,
-                                               const uint32_t& aRTT)
-{
-  if (!mVideoEncoder) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mVideoEncoder->SetChannelParameters(aPacketLoss, aRTT);
-
-  return true;
-}
-
-bool
-GMPVideoEncoderChild::RecvSetRates(const uint32_t& aNewBitRate,
-                                   const uint32_t& aFrameRate)
-{
-  if (!mVideoEncoder) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mVideoEncoder->SetRates(aNewBitRate, aFrameRate);
-
-  return true;
-}
-
-bool
-GMPVideoEncoderChild::RecvSetPeriodicKeyFrames(const bool& aEnable)
-{
-  if (!mVideoEncoder) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mVideoEncoder->SetPeriodicKeyFrames(aEnable);
-
-  return true;
-}
-
-bool
-GMPVideoEncoderChild::RecvEncodingComplete()
-{
-  if (!mVideoEncoder) {
-    unused << Send__delete__(this);
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mVideoEncoder->EncodingComplete();
-
-  mVideoHost.DoneWithAPI();
-
-  mPlugin = nullptr;
-
-  unused << Send__delete__(this);
-
-  return true;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPVideoEncoderChild.h b/dom/media/gmp/GMPVideoEncoderChild.h
deleted file mode 100644
index 6010fe3..0000000
--- a/dom/media/gmp/GMPVideoEncoderChild.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPVideoEncoderChild_h_
-#define GMPVideoEncoderChild_h_
-
-#include "nsString.h"
-#include "mozilla/gmp/PGMPVideoEncoderChild.h"
-#include "gmp-video-encode.h"
-#include "GMPSharedMemManager.h"
-#include "GMPVideoHost.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPChild;
-
-class GMPVideoEncoderChild : public PGMPVideoEncoderChild,
-                             public GMPVideoEncoderCallback,
-                             public GMPSharedMemManager
-{
-public:
-  explicit GMPVideoEncoderChild(GMPChild* aPlugin);
-  virtual ~GMPVideoEncoderChild();
-
-  void Init(GMPVideoEncoder* aEncoder);
-  GMPVideoHostImpl& Host();
-
-  // GMPVideoEncoderCallback
-  virtual void Encoded(GMPVideoEncodedFrame* aEncodedFrame,
-                       const uint8_t* aCodecSpecificInfo,
-                       uint32_t aCodecSpecificInfoLength) override;
-  virtual void Error(GMPErr aError) override;
-
-  // GMPSharedMemManager
-  virtual bool Alloc(size_t aSize, Shmem::SharedMemory::SharedMemoryType aType, Shmem* aMem) override
-  {
-#ifndef SHMEM_ALLOC_IN_CHILD
-    return CallNeedShmem(aSize, aMem);
-#else
-#ifdef GMP_SAFE_SHMEM
-    return AllocShmem(aSize, aType, aMem);
-#else
-    return AllocUnsafeShmem(aSize, aType, aMem);
-#endif
-#endif
-  }
-  virtual void Dealloc(Shmem& aMem) override
-  {
-#ifndef SHMEM_ALLOC_IN_CHILD
-    SendParentShmemForPool(aMem);
-#else
-    DeallocShmem(aMem);
-#endif
-  }
-
-private:
-  // PGMPVideoEncoderChild
-  virtual bool RecvInitEncode(const GMPVideoCodec& aCodecSettings,
-                              InfallibleTArray<uint8_t>&& aCodecSpecific,
-                              const int32_t& aNumberOfCores,
-                              const uint32_t& aMaxPayloadSize) override;
-  virtual bool RecvEncode(const GMPVideoi420FrameData& aInputFrame,
-                          InfallibleTArray<uint8_t>&& aCodecSpecificInfo,
-                          InfallibleTArray<GMPVideoFrameType>&& aFrameTypes) override;
-  virtual bool RecvChildShmemForPool(Shmem&& aEncodedBuffer) override;
-  virtual bool RecvSetChannelParameters(const uint32_t& aPacketLoss,
-                                        const uint32_t& aRTT) override;
-  virtual bool RecvSetRates(const uint32_t& aNewBitRate,
-                            const uint32_t& aFrameRate) override;
-  virtual bool RecvSetPeriodicKeyFrames(const bool& aEnable) override;
-  virtual bool RecvEncodingComplete() override;
-
-  GMPChild* mPlugin;
-  GMPVideoEncoder* mVideoEncoder;
-  GMPVideoHostImpl mVideoHost;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPVideoEncoderChild_h_
diff --git a/dom/media/gmp/GMPVideoEncoderParent.cpp b/dom/media/gmp/GMPVideoEncoderParent.cpp
deleted file mode 100644
index 0585d69..0000000
--- a/dom/media/gmp/GMPVideoEncoderParent.cpp
+++ /dev/null
@@ -1,365 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPVideoEncoderParent.h"
-#include "prlog.h"
-#include "GMPVideoi420FrameImpl.h"
-#include "GMPVideoEncodedFrameImpl.h"
-#include "mozilla/unused.h"
-#include "GMPMessageUtils.h"
-#include "nsAutoRef.h"
-#include "GMPParent.h"
-#include "mozilla/gmp/GMPTypes.h"
-#include "nsThread.h"
-#include "nsThreadUtils.h"
-#include "runnable_utils.h"
-#include "GMPUtils.h"
-
-namespace mozilla {
-
-#ifdef LOG
-#undef LOG
-#endif
-
-#ifdef PR_LOGGING
-extern PRLogModuleInfo* GetGMPLog();
-
-#define LOGD(msg) PR_LOG(GetGMPLog(), PR_LOG_DEBUG, msg)
-#define LOG(level, msg) PR_LOG(GetGMPLog(), (level), msg)
-#else
-#define LOGD(msg)
-#define LOG(level, msg)
-#endif
-
-#ifdef __CLASS__
-#undef __CLASS__
-#endif
-#define __CLASS__ "GMPVideoEncoderParent"
-
-namespace gmp {
-
-// States:
-// Initial: mIsOpen == false
-//    on InitDecode success -> Open
-//    on Shutdown -> Dead
-// Open: mIsOpen == true
-//    on Close -> Dead
-//    on ActorDestroy -> Dead
-//    on Shutdown -> Dead
-// Dead: mIsOpen == false
-
-GMPVideoEncoderParent::GMPVideoEncoderParent(GMPParent *aPlugin)
-: GMPSharedMemManager(aPlugin),
-  mIsOpen(false),
-  mShuttingDown(false),
-  mPlugin(aPlugin),
-  mCallback(nullptr),
-  mVideoHost(this)
-{
-  MOZ_ASSERT(mPlugin);
-
-  nsresult rv = NS_NewNamedThread("GMPEncoded", getter_AddRefs(mEncodedThread));
-  if (NS_FAILED(rv)) {
-    MOZ_CRASH();
-  }
-}
-
-GMPVideoEncoderParent::~GMPVideoEncoderParent()
-{
-  if (mEncodedThread) {
-    mEncodedThread->Shutdown();
-  }
-}
-
-GMPVideoHostImpl&
-GMPVideoEncoderParent::Host()
-{
-  return mVideoHost;
-}
-
-// Note: may be called via Terminated()
-void
-GMPVideoEncoderParent::Close()
-{
-  LOGD(("%s::%s: %p", __CLASS__, __FUNCTION__, this));
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-  // Consumer is done with us; we can shut down.  No more callbacks should
-  // be made to mCallback.  Note: do this before Shutdown()!
-  mCallback = nullptr;
-  // Let Shutdown mark us as dead so it knows if we had been alive
-
-  // In case this is the last reference
-  nsRefPtr<GMPVideoEncoderParent> kungfudeathgrip(this);
-  Release();
-  Shutdown();
-}
-
-GMPErr
-GMPVideoEncoderParent::InitEncode(const GMPVideoCodec& aCodecSettings,
-                                  const nsTArray<uint8_t>& aCodecSpecific,
-                                  GMPVideoEncoderCallbackProxy* aCallback,
-                                  int32_t aNumberOfCores,
-                                  uint32_t aMaxPayloadSize)
-{
-  LOGD(("%s::%s: %p", __CLASS__, __FUNCTION__, this));
-  if (mIsOpen) {
-    NS_WARNING("Trying to re-init an in-use GMP video encoder!");
-    return GMPGenericErr;;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (!aCallback) {
-    return GMPGenericErr;
-  }
-  mCallback = aCallback;
-
-  if (!SendInitEncode(aCodecSettings, aCodecSpecific, aNumberOfCores, aMaxPayloadSize)) {
-    return GMPGenericErr;
-  }
-  mIsOpen = true;
-
-  // Async IPC, we don't have access to a return value.
-  return GMPNoErr;
-}
-
-GMPErr
-GMPVideoEncoderParent::Encode(GMPUnique<GMPVideoi420Frame>::Ptr aInputFrame,
-                              const nsTArray<uint8_t>& aCodecSpecificInfo,
-                              const nsTArray<GMPVideoFrameType>& aFrameTypes)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use an dead GMP video encoder");
-    return GMPGenericErr;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  GMPUnique<GMPVideoi420FrameImpl>::Ptr inputFrameImpl(
-    static_cast<GMPVideoi420FrameImpl*>(aInputFrame.release()));
-
-  // Very rough kill-switch if the plugin stops processing.  If it's merely
-  // hung and continues, we'll come back to life eventually.
-  // 3* is because we're using 3 buffers per frame for i420 data for now.
-  if ((NumInUse(GMPSharedMem::kGMPFrameData) > 3*GMPSharedMem::kGMPBufLimit) ||
-      (NumInUse(GMPSharedMem::kGMPEncodedData) > GMPSharedMem::kGMPBufLimit)) {
-    return GMPGenericErr;
-  }
-
-  GMPVideoi420FrameData frameData;
-  inputFrameImpl->InitFrameData(frameData);
-
-  if (!SendEncode(frameData,
-                  aCodecSpecificInfo,
-                  aFrameTypes)) {
-    return GMPGenericErr;
-  }
-
-  // Async IPC, we don't have access to a return value.
-  return GMPNoErr;
-}
-
-GMPErr
-GMPVideoEncoderParent::SetChannelParameters(uint32_t aPacketLoss, uint32_t aRTT)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use an invalid GMP video encoder!");
-    return GMPGenericErr;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (!SendSetChannelParameters(aPacketLoss, aRTT)) {
-    return GMPGenericErr;
-  }
-
-  // Async IPC, we don't have access to a return value.
-  return GMPNoErr;
-}
-
-GMPErr
-GMPVideoEncoderParent::SetRates(uint32_t aNewBitRate, uint32_t aFrameRate)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use an dead GMP video decoder");
-    return GMPGenericErr;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (!SendSetRates(aNewBitRate, aFrameRate)) {
-    return GMPGenericErr;
-  }
-
-  // Async IPC, we don't have access to a return value.
-  return GMPNoErr;
-}
-
-GMPErr
-GMPVideoEncoderParent::SetPeriodicKeyFrames(bool aEnable)
-{
-  if (!mIsOpen) {
-    NS_WARNING("Trying to use an invalid GMP video encoder!");
-    return GMPGenericErr;
-  }
-
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (!SendSetPeriodicKeyFrames(aEnable)) {
-    return GMPGenericErr;
-  }
-
-  // Async IPC, we don't have access to a return value.
-  return GMPNoErr;
-}
-
-// Note: Consider keeping ActorDestroy sync'd up when making changes here.
-void
-GMPVideoEncoderParent::Shutdown()
-{
-  LOGD(("%s::%s: %p", __CLASS__, __FUNCTION__, this));
-  MOZ_ASSERT(mPlugin->GMPThread() == NS_GetCurrentThread());
-
-  if (mShuttingDown) {
-    return;
-  }
-  mShuttingDown = true;
-
-  // Notify client we're gone!  Won't occur after Close()
-  if (mCallback) {
-    mCallback->Terminated();
-    mCallback = nullptr;
-  }
-  mVideoHost.DoneWithAPI();
-
-  mIsOpen = false;
-  unused << SendEncodingComplete();
-}
-
-static void
-ShutdownEncodedThread(nsCOMPtr<nsIThread>& aThread)
-{
-  aThread->Shutdown();
-}
-
-// Note: Keep this sync'd up with Shutdown
-void
-GMPVideoEncoderParent::ActorDestroy(ActorDestroyReason aWhy)
-{
-  LOGD(("%s::%s: %p (%d)", __CLASS__, __FUNCTION__, this, (int) aWhy));
-  mIsOpen = false;
-  if (mCallback) {
-    // May call Close() (and Shutdown()) immediately or with a delay
-    mCallback->Terminated();
-    mCallback = nullptr;
-  }
-  // Must be shut down before VideoEncoderDestroyed(), since this can recurse
-  // the GMPThread event loop.  See bug 1049501
-  if (mEncodedThread) {
-    // Can't get it to allow me to use WrapRunnable with a nsCOMPtr<nsIThread>()
-    NS_DispatchToMainThread(
-      WrapRunnableNM<decltype(&ShutdownEncodedThread),
-                     nsCOMPtr<nsIThread> >(&ShutdownEncodedThread, mEncodedThread));
-    mEncodedThread = nullptr;
-  }
-  if (mPlugin) {
-    // Ignore any return code. It is OK for this to fail without killing the process.
-    mPlugin->VideoEncoderDestroyed(this);
-    mPlugin = nullptr;
-  }
-  mVideoHost.ActorDestroyed();
-}
-
-static void
-EncodedCallback(GMPVideoEncoderCallbackProxy* aCallback,
-                GMPVideoEncodedFrame* aEncodedFrame,
-                nsTArray<uint8_t>* aCodecSpecificInfo,
-                nsCOMPtr<nsIThread> aThread)
-{
-  aCallback->Encoded(aEncodedFrame, *aCodecSpecificInfo);
-  delete aCodecSpecificInfo;
-  // Ugh.  Must destroy the frame on GMPThread.
-  // XXX add locks to the ShmemManager instead?
-  aThread->Dispatch(WrapRunnable(aEncodedFrame,
-                                &GMPVideoEncodedFrame::Destroy),
-                   NS_DISPATCH_NORMAL);
-}
-
-bool
-GMPVideoEncoderParent::RecvEncoded(const GMPVideoEncodedFrameData& aEncodedFrame,
-                                   InfallibleTArray<uint8_t>&& aCodecSpecificInfo)
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  auto f = new GMPVideoEncodedFrameImpl(aEncodedFrame, &mVideoHost);
-  nsTArray<uint8_t> *codecSpecificInfo = new nsTArray<uint8_t>;
-  codecSpecificInfo->AppendElements((uint8_t*)aCodecSpecificInfo.Elements(), aCodecSpecificInfo.Length());
-  nsCOMPtr<nsIThread> thread = NS_GetCurrentThread();
-
-  mEncodedThread->Dispatch(WrapRunnableNM(&EncodedCallback,
-                                          mCallback, f, codecSpecificInfo, thread),
-                           NS_DISPATCH_NORMAL);
-
-  return true;
-}
-
-bool
-GMPVideoEncoderParent::RecvError(const GMPErr& aError)
-{
-  if (!mCallback) {
-    return false;
-  }
-
-  // Ignore any return code. It is OK for this to fail without killing the process.
-  mCallback->Error(aError);
-
-  return true;
-}
-
-bool
-GMPVideoEncoderParent::RecvParentShmemForPool(Shmem&& aFrameBuffer)
-{
-  if (aFrameBuffer.IsWritable()) {
-    mVideoHost.SharedMemMgr()->MgrDeallocShmem(GMPSharedMem::kGMPFrameData,
-                                               aFrameBuffer);
-  }
-  return true;
-}
-
-bool
-GMPVideoEncoderParent::AnswerNeedShmem(const uint32_t& aEncodedBufferSize,
-                                       Shmem* aMem)
-{
-  ipc::Shmem mem;
-
-  if (!mVideoHost.SharedMemMgr()->MgrAllocShmem(GMPSharedMem::kGMPEncodedData,
-                                                aEncodedBufferSize,
-                                                ipc::SharedMemory::TYPE_BASIC, &mem))
-  {
-    LOG(PR_LOG_ERROR, ("%s::%s: Failed to get a shared mem buffer for Child! size %u",
-                       __CLASS__, __FUNCTION__, aEncodedBufferSize));
-    return false;
-  }
-  *aMem = mem;
-  mem = ipc::Shmem();
-  return true;
-}
-
-bool
-GMPVideoEncoderParent::Recv__delete__()
-{
-  if (mPlugin) {
-    // Ignore any return code. It is OK for this to fail without killing the process.
-    mPlugin->VideoEncoderDestroyed(this);
-    mPlugin = nullptr;
-  }
-
-  return true;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPVideoEncoderParent.h b/dom/media/gmp/GMPVideoEncoderParent.h
deleted file mode 100644
index 2a7000a..0000000
--- a/dom/media/gmp/GMPVideoEncoderParent.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPVideoEncoderParent_h_
-#define GMPVideoEncoderParent_h_
-
-#include "mozilla/RefPtr.h"
-#include "gmp-video-encode.h"
-#include "mozilla/gmp/PGMPVideoEncoderParent.h"
-#include "GMPMessageUtils.h"
-#include "GMPSharedMemManager.h"
-#include "GMPUtils.h"
-#include "GMPVideoHost.h"
-#include "GMPVideoEncoderProxy.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPParent;
-
-class GMPVideoEncoderParent : public GMPVideoEncoderProxy,
-                              public PGMPVideoEncoderParent,
-                              public GMPSharedMemManager
-{
-public:
-  NS_INLINE_DECL_REFCOUNTING(GMPVideoEncoderParent)
-
-  explicit GMPVideoEncoderParent(GMPParent *aPlugin);
-
-  GMPVideoHostImpl& Host();
-  void Shutdown();
-
-  // GMPVideoEncoderProxy
-  virtual void Close() override;
-  virtual GMPErr InitEncode(const GMPVideoCodec& aCodecSettings,
-                            const nsTArray<uint8_t>& aCodecSpecific,
-                            GMPVideoEncoderCallbackProxy* aCallback,
-                            int32_t aNumberOfCores,
-                            uint32_t aMaxPayloadSize) override;
-  virtual GMPErr Encode(GMPUnique<GMPVideoi420Frame>::Ptr aInputFrame,
-                        const nsTArray<uint8_t>& aCodecSpecificInfo,
-                        const nsTArray<GMPVideoFrameType>& aFrameTypes) override;
-  virtual GMPErr SetChannelParameters(uint32_t aPacketLoss, uint32_t aRTT) override;
-  virtual GMPErr SetRates(uint32_t aNewBitRate, uint32_t aFrameRate) override;
-  virtual GMPErr SetPeriodicKeyFrames(bool aEnable) override;
-  virtual const uint64_t ParentID() override { return reinterpret_cast<uint64_t>(mPlugin.get()); }
-
-  // GMPSharedMemManager
-  virtual bool Alloc(size_t aSize, Shmem::SharedMemory::SharedMemoryType aType, Shmem* aMem) override
-  {
-#ifdef GMP_SAFE_SHMEM
-    return AllocShmem(aSize, aType, aMem);
-#else
-    return AllocUnsafeShmem(aSize, aType, aMem);
-#endif
-  }
-  virtual void Dealloc(Shmem& aMem) override
-  {
-    DeallocShmem(aMem);
-  }
-
-private:
-  virtual ~GMPVideoEncoderParent();
-
-  // PGMPVideoEncoderParent
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-  virtual bool RecvEncoded(const GMPVideoEncodedFrameData& aEncodedFrame,
-                           InfallibleTArray<uint8_t>&& aCodecSpecificInfo) override;
-  virtual bool RecvError(const GMPErr& aError) override;
-  virtual bool RecvParentShmemForPool(Shmem&& aFrameBuffer) override;
-  virtual bool AnswerNeedShmem(const uint32_t& aEncodedBufferSize,
-                               Shmem* aMem) override;
-  virtual bool Recv__delete__() override;
-
-  bool mIsOpen;
-  bool mShuttingDown;
-  nsRefPtr<GMPParent> mPlugin;
-  GMPVideoEncoderCallbackProxy* mCallback;
-  GMPVideoHostImpl mVideoHost;
-  nsCOMPtr<nsIThread> mEncodedThread;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPVideoEncoderParent_h_
diff --git a/dom/media/gmp/GMPVideoEncoderProxy.h b/dom/media/gmp/GMPVideoEncoderProxy.h
deleted file mode 100644
index 3faea40..0000000
--- a/dom/media/gmp/GMPVideoEncoderProxy.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPVideoEncoderProxy_h_
-#define GMPVideoEncoderProxy_h_
-
-#include "nsTArray.h"
-#include "gmp-video-encode.h"
-#include "gmp-video-frame-i420.h"
-#include "gmp-video-frame-encoded.h"
-
-#include "GMPCallbackBase.h"
-#include "GMPUtils.h"
-
-class GMPVideoEncoderCallbackProxy : public GMPCallbackBase {
-public:
-  virtual ~GMPVideoEncoderCallbackProxy() {}
-  virtual void Encoded(GMPVideoEncodedFrame* aEncodedFrame,
-                       const nsTArray<uint8_t>& aCodecSpecificInfo) = 0;
-  virtual void Error(GMPErr aError) = 0;
-};
-
-// A proxy to GMPVideoEncoder in the child process.
-// GMPVideoEncoderParent exposes this to users the GMP.
-// This enables Goanna to pass nsTArrays to the child GMP and avoid
-// an extra copy when doing so.
-
-// The consumer must call Close() when done with the codec, or when
-// Terminated() is called by the GMP plugin indicating an abnormal shutdown
-// of the underlying plugin.  After calling Close(), the consumer must
-// not access this again.
-
-// This interface is not thread-safe and must only be used from GMPThread.
-class GMPVideoEncoderProxy {
-public:
-  virtual GMPErr InitEncode(const GMPVideoCodec& aCodecSettings,
-                            const nsTArray<uint8_t>& aCodecSpecific,
-                            GMPVideoEncoderCallbackProxy* aCallback,
-                            int32_t aNumberOfCores,
-                            uint32_t aMaxPayloadSize) = 0;
-  virtual GMPErr Encode(mozilla::GMPUnique<GMPVideoi420Frame>::Ptr aInputFrame,
-                        const nsTArray<uint8_t>& aCodecSpecificInfo,
-                        const nsTArray<GMPVideoFrameType>& aFrameTypes) = 0;
-  virtual GMPErr SetChannelParameters(uint32_t aPacketLoss, uint32_t aRTT) = 0;
-  virtual GMPErr SetRates(uint32_t aNewBitRate, uint32_t aFrameRate) = 0;
-  virtual GMPErr SetPeriodicKeyFrames(bool aEnable) = 0;
-  virtual const uint64_t ParentID() = 0;
-
-  // Call to tell GMP/plugin the consumer will no longer use this
-  // interface/codec.
-  virtual void Close() = 0;
-};
-
-#endif // GMPVideoEncoderProxy_h_
diff --git a/dom/media/gmp/GMPVideoHost.cpp b/dom/media/gmp/GMPVideoHost.cpp
deleted file mode 100644
index f736ee1..0000000
--- a/dom/media/gmp/GMPVideoHost.cpp
+++ /dev/null
@@ -1,127 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPVideoHost.h"
-#include "mozilla/Assertions.h"
-#include "GMPVideoi420FrameImpl.h"
-#include "GMPVideoEncodedFrameImpl.h"
-
-namespace mozilla {
-namespace gmp {
-
-GMPVideoHostImpl::GMPVideoHostImpl(GMPSharedMemManager* aSharedMemMgr)
-: mSharedMemMgr(aSharedMemMgr)
-{
-}
-
-GMPVideoHostImpl::~GMPVideoHostImpl()
-{
-}
-
-GMPErr
-GMPVideoHostImpl::CreateFrame(GMPVideoFrameFormat aFormat, GMPVideoFrame** aFrame)
-{
-  if (!mSharedMemMgr) {
-    return GMPGenericErr;
-  }
-
-  if (!aFrame) {
-    return GMPGenericErr;
-  }
-  *aFrame = nullptr;
-
-  switch (aFormat) {
-    case kGMPI420VideoFrame:
-      *aFrame = new GMPVideoi420FrameImpl(this);
-      return GMPNoErr;
-    case kGMPEncodedVideoFrame:
-      *aFrame = new GMPVideoEncodedFrameImpl(this);
-      return GMPNoErr;
-    default:
-      NS_NOTREACHED("Unknown frame format!");
-  }
-
-  return GMPGenericErr;
-}
-
-GMPErr
-GMPVideoHostImpl::CreatePlane(GMPPlane** aPlane)
-{
-  if (!mSharedMemMgr) {
-    return GMPGenericErr;
-  }
-
-  if (!aPlane) {
-    return GMPGenericErr;
-  }
-  *aPlane = nullptr;
-
-  auto p = new GMPPlaneImpl(this);
-
-  *aPlane = p;
-
-  return GMPNoErr;
-}
-
-GMPSharedMemManager*
-GMPVideoHostImpl::SharedMemMgr()
-{
-  return mSharedMemMgr;
-}
-
-void
-GMPVideoHostImpl::DoneWithAPI()
-{
-  for (uint32_t i = mPlanes.Length(); i > 0; i--) {
-    mPlanes[i - 1]->DoneWithAPI();
-    mPlanes.RemoveElementAt(i - 1);
-  }
-  for (uint32_t i = mEncodedFrames.Length(); i > 0; i--) {
-    mEncodedFrames[i - 1]->DoneWithAPI();
-    mEncodedFrames.RemoveElementAt(i - 1);
-  }
-  mSharedMemMgr = nullptr;
-}
-
-void
-GMPVideoHostImpl::ActorDestroyed()
-{
-  for (uint32_t i = mPlanes.Length(); i > 0; i--) {
-    mPlanes[i - 1]->ActorDestroyed();
-    mPlanes.RemoveElementAt(i - 1);
-  }
-  for (uint32_t i = mEncodedFrames.Length(); i > 0; i--) {
-    mEncodedFrames[i - 1]->ActorDestroyed();
-    mEncodedFrames.RemoveElementAt(i - 1);
-  }
-  mSharedMemMgr = nullptr;
-}
-
-void
-GMPVideoHostImpl::PlaneCreated(GMPPlaneImpl* aPlane)
-{
-  mPlanes.AppendElement(aPlane);
-}
-
-void
-GMPVideoHostImpl::PlaneDestroyed(GMPPlaneImpl* aPlane)
-{
-  MOZ_ALWAYS_TRUE(mPlanes.RemoveElement(aPlane));
-}
-
-void
-GMPVideoHostImpl::EncodedFrameCreated(GMPVideoEncodedFrameImpl* aEncodedFrame)
-{
-  mEncodedFrames.AppendElement(aEncodedFrame);
-}
-
-void
-GMPVideoHostImpl::EncodedFrameDestroyed(GMPVideoEncodedFrameImpl* aFrame)
-{
-  MOZ_ALWAYS_TRUE(mEncodedFrames.RemoveElement(aFrame));
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPVideoHost.h b/dom/media/gmp/GMPVideoHost.h
deleted file mode 100644
index c3cddd2..0000000
--- a/dom/media/gmp/GMPVideoHost.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPVideoHost_h_
-#define GMPVideoHost_h_
-
-#include "gmp-video-host.h"
-#include "gmp-video-plane.h"
-#include "gmp-video-frame.h"
-#include "gmp-video-host.h"
-#include "nsTArray.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPSharedMemManager;
-class GMPPlaneImpl;
-class GMPVideoEncodedFrameImpl;
-
-class GMPVideoHostImpl : public GMPVideoHost
-{
-public:
-  explicit GMPVideoHostImpl(GMPSharedMemManager* aSharedMemMgr);
-  virtual ~GMPVideoHostImpl();
-
-  // Used for shared memory allocation and deallocation.
-  GMPSharedMemManager* SharedMemMgr();
-  void DoneWithAPI();
-  void ActorDestroyed();
-  void PlaneCreated(GMPPlaneImpl* aPlane);
-  void PlaneDestroyed(GMPPlaneImpl* aPlane);
-  void EncodedFrameCreated(GMPVideoEncodedFrameImpl* aEncodedFrame);
-  void EncodedFrameDestroyed(GMPVideoEncodedFrameImpl* aFrame);
-
-  // GMPVideoHost
-  virtual GMPErr CreateFrame(GMPVideoFrameFormat aFormat, GMPVideoFrame** aFrame) override;
-  virtual GMPErr CreatePlane(GMPPlane** aPlane) override;
-
-private:
-  // All shared memory allocations have to be made by an IPDL actor.
-  // This is a reference to the owning actor. If this reference is
-  // null then the actor has died and all allocations must fail.
-  GMPSharedMemManager* mSharedMemMgr;
-
-  // We track all of these things because they need to handle further
-  // allocations through us and we need to notify them when they
-  // can't use us any more.
-  nsTArray<GMPPlaneImpl*> mPlanes;
-  nsTArray<GMPVideoEncodedFrameImpl*> mEncodedFrames;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPVideoHost_h_
diff --git a/dom/media/gmp/GMPVideoPlaneImpl.cpp b/dom/media/gmp/GMPVideoPlaneImpl.cpp
deleted file mode 100644
index 074a965..0000000
--- a/dom/media/gmp/GMPVideoPlaneImpl.cpp
+++ /dev/null
@@ -1,225 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPVideoPlaneImpl.h"
-#include "mozilla/gmp/GMPTypes.h"
-#include "GMPVideoHost.h"
-#include "GMPSharedMemManager.h"
-
-namespace mozilla {
-namespace gmp {
-
-GMPPlaneImpl::GMPPlaneImpl(GMPVideoHostImpl* aHost)
-: mSize(0),
-  mStride(0),
-  mHost(aHost)
-{
-  MOZ_ASSERT(mHost);
-  mHost->PlaneCreated(this);
-}
-
-GMPPlaneImpl::GMPPlaneImpl(const GMPPlaneData& aPlaneData, GMPVideoHostImpl* aHost)
-: mBuffer(aPlaneData.mBuffer()),
-  mSize(aPlaneData.mSize()),
-  mStride(aPlaneData.mStride()),
-  mHost(aHost)
-{
-  MOZ_ASSERT(mHost);
-  mHost->PlaneCreated(this);
-}
-
-GMPPlaneImpl::~GMPPlaneImpl()
-{
-  DestroyBuffer();
-  if (mHost) {
-    mHost->PlaneDestroyed(this);
-  }
-}
-
-void
-GMPPlaneImpl::DoneWithAPI()
-{
-  DestroyBuffer();
-
-  // Do this after destroying the buffer because destruction
-  // involves deallocation, which requires a host.
-  mHost = nullptr;
-}
-
-void
-GMPPlaneImpl::ActorDestroyed()
-{
-  // Simply clear out Shmem reference, do not attempt to
-  // properly free it. It has already been freed.
-  mBuffer = ipc::Shmem();
-  // No more host.
-  mHost = nullptr;
-}
-
-bool
-GMPPlaneImpl::InitPlaneData(GMPPlaneData& aPlaneData)
-{
-  aPlaneData.mBuffer() = mBuffer;
-  aPlaneData.mSize() = mSize;
-  aPlaneData.mStride() = mStride;
-
-  // This method is called right before Shmem is sent to another process.
-  // We need to effectively zero out our member copy so that we don't
-  // try to delete memory we don't own later.
-  mBuffer = ipc::Shmem();
-
-  return true;
-}
-
-GMPErr
-GMPPlaneImpl::MaybeResize(int32_t aNewSize) {
-  if (aNewSize <= AllocatedSize()) {
-    return GMPNoErr;
-  }
-
-  if (!mHost) {
-    return GMPGenericErr;
-  }
-
-  ipc::Shmem new_mem;
-  if (!mHost->SharedMemMgr()->MgrAllocShmem(GMPSharedMem::kGMPFrameData, aNewSize,
-                                            ipc::SharedMemory::TYPE_BASIC, &new_mem) ||
-      !new_mem.get<uint8_t>()) {
-    return GMPAllocErr;
-  }
-
-  if (mBuffer.IsReadable()) {
-    memcpy(new_mem.get<uint8_t>(), Buffer(), mSize);
-  }
-
-  DestroyBuffer();
-
-  mBuffer = new_mem;
-
-  return GMPNoErr;
-}
-
-void
-GMPPlaneImpl::DestroyBuffer()
-{
-  if (mHost && mBuffer.IsWritable()) {
-    mHost->SharedMemMgr()->MgrDeallocShmem(GMPSharedMem::kGMPFrameData, mBuffer);
-  }
-  mBuffer = ipc::Shmem();
-}
-
-GMPErr
-GMPPlaneImpl::CreateEmptyPlane(int32_t aAllocatedSize, int32_t aStride, int32_t aPlaneSize)
-{
-  if (aAllocatedSize < 1 || aStride < 1 || aPlaneSize < 1) {
-    return GMPGenericErr;
-  }
-
-  GMPErr err = MaybeResize(aAllocatedSize);
-  if (err != GMPNoErr) {
-    return err;
-  }
-
-  mSize = aPlaneSize;
-  mStride = aStride;
-
-  return GMPNoErr;
-}
-
-GMPErr
-GMPPlaneImpl::Copy(const GMPPlane& aPlane)
-{
-  auto& planeimpl = static_cast<const GMPPlaneImpl&>(aPlane);
-
-  GMPErr err = MaybeResize(planeimpl.mSize);
-  if (err != GMPNoErr) {
-    return err;
-  }
-
-  if (planeimpl.Buffer() && planeimpl.mSize > 0) {
-    memcpy(Buffer(), planeimpl.Buffer(), mSize);
-  }
-
-  mSize = planeimpl.mSize;
-  mStride = planeimpl.mStride;
-
-  return GMPNoErr;
-}
-
-GMPErr
-GMPPlaneImpl::Copy(int32_t aSize, int32_t aStride, const uint8_t* aBuffer)
-{
-  GMPErr err = MaybeResize(aSize);
-  if (err != GMPNoErr) {
-    return err;
-  }
-
-  if (aBuffer && aSize > 0) {
-    memcpy(Buffer(), aBuffer, aSize);
-  }
-
-  mSize = aSize;
-  mStride = aStride;
-
-  return GMPNoErr;
-}
-
-void
-GMPPlaneImpl::Swap(GMPPlane& aPlane)
-{
-  auto& planeimpl = static_cast<GMPPlaneImpl&>(aPlane);
-
-  std::swap(mStride, planeimpl.mStride);
-  std::swap(mSize, planeimpl.mSize);
-  std::swap(mBuffer, planeimpl.mBuffer);
-}
-
-int32_t
-GMPPlaneImpl::AllocatedSize() const
-{
-  if (mBuffer.IsWritable()) {
-    return mBuffer.Size<uint8_t>();
-  }
-  return 0;
-}
-
-void
-GMPPlaneImpl::ResetSize()
-{
-  mSize = 0;
-}
-
-bool
-GMPPlaneImpl::IsZeroSize() const
-{
-  return (mSize == 0);
-}
-
-int32_t
-GMPPlaneImpl::Stride() const
-{
-  return mStride;
-}
-
-const uint8_t*
-GMPPlaneImpl::Buffer() const
-{
-  return mBuffer.get<uint8_t>();
-}
-
-uint8_t*
-GMPPlaneImpl::Buffer()
-{
-  return mBuffer.get<uint8_t>();
-}
-
-void
-GMPPlaneImpl::Destroy()
-{
-  delete this;
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPVideoPlaneImpl.h b/dom/media/gmp/GMPVideoPlaneImpl.h
deleted file mode 100644
index d2d2e53..0000000
--- a/dom/media/gmp/GMPVideoPlaneImpl.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPVideoPlaneImpl_h_
-#define GMPVideoPlaneImpl_h_
-
-#include "gmp-video-plane.h"
-#include "mozilla/ipc/Shmem.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPVideoHostImpl;
-class GMPPlaneData;
-
-class GMPPlaneImpl : public GMPPlane
-{
-  friend struct IPC::ParamTraits<mozilla::gmp::GMPPlaneImpl>;
-public:
-  explicit GMPPlaneImpl(GMPVideoHostImpl* aHost);
-  GMPPlaneImpl(const GMPPlaneData& aPlaneData, GMPVideoHostImpl* aHost);
-  virtual ~GMPPlaneImpl();
-
-  // This is called during a normal destroy sequence, which is
-  // when a consumer is finished or during XPCOM shutdown.
-  void DoneWithAPI();
-  // This is called when something has gone wrong - specicifically,
-  // a child process has crashed. Does not attempt to release Shmem,
-  // as the Shmem has already been released.
-  void ActorDestroyed();
-
-  bool InitPlaneData(GMPPlaneData& aPlaneData);
-
-  // GMPPlane
-  virtual GMPErr CreateEmptyPlane(int32_t aAllocatedSize,
-                                  int32_t aStride,
-                                  int32_t aPlaneSize) override;
-  virtual GMPErr Copy(const GMPPlane& aPlane) override;
-  virtual GMPErr Copy(int32_t aSize,
-                      int32_t aStride,
-                      const uint8_t* aBuffer) override;
-  virtual void Swap(GMPPlane& aPlane) override;
-  virtual int32_t AllocatedSize() const override;
-  virtual void ResetSize() override;
-  virtual bool IsZeroSize() const override;
-  virtual int32_t Stride() const override;
-  virtual const uint8_t* Buffer() const override;
-  virtual uint8_t* Buffer() override;
-  virtual void Destroy() override;
-
-private:
-  GMPErr MaybeResize(int32_t aNewSize);
-  void DestroyBuffer();
-
-  ipc::Shmem mBuffer;
-  int32_t mSize;
-  int32_t mStride;
-  GMPVideoHostImpl* mHost;
-};
-
-} // namespace gmp
-} // namespace mozilla
-
-#endif // GMPVideoPlaneImpl_h_
diff --git a/dom/media/gmp/GMPVideoi420FrameImpl.cpp b/dom/media/gmp/GMPVideoi420FrameImpl.cpp
deleted file mode 100644
index fdbb9a9..0000000
--- a/dom/media/gmp/GMPVideoi420FrameImpl.cpp
+++ /dev/null
@@ -1,365 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPVideoi420FrameImpl.h"
-#include "mozilla/gmp/GMPTypes.h"
-#include "mozilla/CheckedInt.h"
-
-namespace mozilla {
-namespace gmp {
-
-GMPVideoi420FrameImpl::GMPVideoi420FrameImpl(GMPVideoHostImpl* aHost)
-: mYPlane(aHost),
-  mUPlane(aHost),
-  mVPlane(aHost),
-  mWidth(0),
-  mHeight(0),
-  mTimestamp(0ll),
-  mDuration(0ll)
-{
-  MOZ_ASSERT(aHost);
-}
-
-GMPVideoi420FrameImpl::GMPVideoi420FrameImpl(const GMPVideoi420FrameData& aFrameData,
-                                             GMPVideoHostImpl* aHost)
-: mYPlane(aFrameData.mYPlane(), aHost),
-  mUPlane(aFrameData.mUPlane(), aHost),
-  mVPlane(aFrameData.mVPlane(), aHost),
-  mWidth(aFrameData.mWidth()),
-  mHeight(aFrameData.mHeight()),
-  mTimestamp(aFrameData.mTimestamp()),
-  mDuration(aFrameData.mDuration())
-{
-  MOZ_ASSERT(aHost);
-}
-
-GMPVideoi420FrameImpl::~GMPVideoi420FrameImpl()
-{
-}
-
-bool
-GMPVideoi420FrameImpl::InitFrameData(GMPVideoi420FrameData& aFrameData)
-{
-  mYPlane.InitPlaneData(aFrameData.mYPlane());
-  mUPlane.InitPlaneData(aFrameData.mUPlane());
-  mVPlane.InitPlaneData(aFrameData.mVPlane());
-  aFrameData.mWidth() = mWidth;
-  aFrameData.mHeight() = mHeight;
-  aFrameData.mTimestamp() = mTimestamp;
-  aFrameData.mDuration() = mDuration;
-  return true;
-}
-
-GMPVideoFrameFormat
-GMPVideoi420FrameImpl::GetFrameFormat()
-{
-  return kGMPI420VideoFrame;
-}
-
-void
-GMPVideoi420FrameImpl::Destroy()
-{
-  delete this;
-}
-
-/* static */ bool
-GMPVideoi420FrameImpl::CheckFrameData(const GMPVideoi420FrameData& aFrameData)
-{
-  // We may be passed the "wrong" shmem (one smaller than the actual size).
-  // This implies a bug or serious error on the child size.  Ignore this frame if so.
-  // Note: Size() greater than expected is also an error, but with no negative consequences
-  int32_t half_width = (aFrameData.mWidth() + 1) / 2;
-  if ((aFrameData.mYPlane().mStride() <= 0) || (aFrameData.mYPlane().mSize() <= 0) ||
-      (aFrameData.mUPlane().mStride() <= 0) || (aFrameData.mUPlane().mSize() <= 0) ||
-      (aFrameData.mVPlane().mStride() <= 0) || (aFrameData.mVPlane().mSize() <= 0) ||
-      (aFrameData.mYPlane().mSize() > (int32_t) aFrameData.mYPlane().mBuffer().Size<uint8_t>()) ||
-      (aFrameData.mUPlane().mSize() > (int32_t) aFrameData.mUPlane().mBuffer().Size<uint8_t>()) ||
-      (aFrameData.mVPlane().mSize() > (int32_t) aFrameData.mVPlane().mBuffer().Size<uint8_t>()) ||
-      (aFrameData.mYPlane().mStride() < aFrameData.mWidth()) ||
-      (aFrameData.mUPlane().mStride() < half_width) ||
-      (aFrameData.mVPlane().mStride() < half_width) ||
-      (aFrameData.mYPlane().mSize() < aFrameData.mYPlane().mStride() * aFrameData.mHeight()) ||
-      (aFrameData.mUPlane().mSize() < aFrameData.mUPlane().mStride() * ((aFrameData.mHeight()+1)/2)) ||
-      (aFrameData.mVPlane().mSize() < aFrameData.mVPlane().mStride() * ((aFrameData.mHeight()+1)/2)))
-  {
-    return false;
-  }
-  return true;
-}
-
-bool
-GMPVideoi420FrameImpl::CheckDimensions(int32_t aWidth, int32_t aHeight,
-                                       int32_t aStride_y, int32_t aStride_u, int32_t aStride_v)
-{
-  int32_t half_width = (aWidth + 1) / 2;
-  if (aWidth < 1 || aHeight < 1 ||
-      aStride_y < aWidth || aStride_u < half_width || aStride_v < half_width ||
-      !(CheckedInt<int32_t>(aHeight) * aStride_y
-        + ((CheckedInt<int32_t>(aHeight) + 1) / 2)
-          * (CheckedInt<int32_t>(aStride_u) + aStride_v)).isValid()) {
-    return false;
-  }
-  return true;
-}
-
-const GMPPlaneImpl*
-GMPVideoi420FrameImpl::GetPlane(GMPPlaneType aType) const {
-  switch (aType) {
-    case kGMPYPlane:
-      return &mYPlane;
-    case kGMPUPlane:
-      return &mUPlane;
-    case kGMPVPlane:
-      return &mVPlane;
-    default:
-      MOZ_CRASH("Unknown plane type!");
-  }
-  return nullptr;
-}
-
-GMPPlaneImpl*
-GMPVideoi420FrameImpl::GetPlane(GMPPlaneType aType) {
-  switch (aType) {
-    case kGMPYPlane :
-      return &mYPlane;
-    case kGMPUPlane :
-      return &mUPlane;
-    case kGMPVPlane :
-      return &mVPlane;
-    default:
-      MOZ_CRASH("Unknown plane type!");
-  }
-  return nullptr;
-}
-
-GMPErr
-GMPVideoi420FrameImpl::CreateEmptyFrame(int32_t aWidth, int32_t aHeight,
-                                        int32_t aStride_y, int32_t aStride_u, int32_t aStride_v)
-{
-  if (!CheckDimensions(aWidth, aHeight, aStride_y, aStride_u, aStride_v)) {
-    return GMPGenericErr;
-  }
-
-  int32_t size_y = aStride_y * aHeight;
-  int32_t half_height = (aHeight + 1) / 2;
-  int32_t size_u = aStride_u * half_height;
-  int32_t size_v = aStride_v * half_height;
-
-  GMPErr err = mYPlane.CreateEmptyPlane(size_y, aStride_y, size_y);
-  if (err != GMPNoErr) {
-    return err;
-  }
-  err = mUPlane.CreateEmptyPlane(size_u, aStride_u, size_u);
-  if (err != GMPNoErr) {
-    return err;
-  }
-  err = mVPlane.CreateEmptyPlane(size_v, aStride_v, size_v);
-  if (err != GMPNoErr) {
-    return err;
-  }
-
-  mWidth = aWidth;
-  mHeight = aHeight;
-  mTimestamp = 0ll;
-  mDuration = 0ll;
-
-  return GMPNoErr;
-}
-
-GMPErr
-GMPVideoi420FrameImpl::CreateFrame(int32_t aSize_y, const uint8_t* aBuffer_y,
-                                   int32_t aSize_u, const uint8_t* aBuffer_u,
-                                   int32_t aSize_v, const uint8_t* aBuffer_v,
-                                   int32_t aWidth, int32_t aHeight,
-                                   int32_t aStride_y, int32_t aStride_u, int32_t aStride_v)
-{
-  MOZ_ASSERT(aBuffer_y);
-  MOZ_ASSERT(aBuffer_u);
-  MOZ_ASSERT(aBuffer_v);
-
-  if (aSize_y < 1 || aSize_u < 1 || aSize_v < 1) {
-    return GMPGenericErr;
-  }
-
-  if (!CheckDimensions(aWidth, aHeight, aStride_y, aStride_u, aStride_v)) {
-    return GMPGenericErr;
-  }
-
-  GMPErr err = mYPlane.Copy(aSize_y, aStride_y, aBuffer_y);
-  if (err != GMPNoErr) {
-    return err;
-  }
-  err = mUPlane.Copy(aSize_u, aStride_u, aBuffer_u);
-  if (err != GMPNoErr) {
-    return err;
-  }
-  err = mVPlane.Copy(aSize_v, aStride_v, aBuffer_v);
-  if (err != GMPNoErr) {
-    return err;
-  }
-
-  mWidth = aWidth;
-  mHeight = aHeight;
-
-  return GMPNoErr;
-}
-
-GMPErr
-GMPVideoi420FrameImpl::CopyFrame(const GMPVideoi420Frame& aFrame)
-{
-  auto& f = static_cast<const GMPVideoi420FrameImpl&>(aFrame);
-
-  GMPErr err = mYPlane.Copy(f.mYPlane);
-  if (err != GMPNoErr) {
-    return err;
-  }
-
-  err = mUPlane.Copy(f.mUPlane);
-  if (err != GMPNoErr) {
-    return err;
-  }
-
-  err = mVPlane.Copy(f.mVPlane);
-  if (err != GMPNoErr) {
-    return err;
-  }
-
-  mWidth = f.mWidth;
-  mHeight = f.mHeight;
-  mTimestamp = f.mTimestamp;
-  mDuration = f.mDuration;
-
-  return GMPNoErr;
-}
-
-void
-GMPVideoi420FrameImpl::SwapFrame(GMPVideoi420Frame* aFrame)
-{
-  auto f = static_cast<GMPVideoi420FrameImpl*>(aFrame);
-  mYPlane.Swap(f->mYPlane);
-  mUPlane.Swap(f->mUPlane);
-  mVPlane.Swap(f->mVPlane);
-  std::swap(mWidth, f->mWidth);
-  std::swap(mHeight, f->mHeight);
-  std::swap(mTimestamp, f->mTimestamp);
-  std::swap(mDuration, f->mDuration);
-}
-
-uint8_t*
-GMPVideoi420FrameImpl::Buffer(GMPPlaneType aType)
-{
-  GMPPlane* p = GetPlane(aType);
-  if (p) {
-    return p->Buffer();
-  }
-  return nullptr;
-}
-
-const uint8_t*
-GMPVideoi420FrameImpl::Buffer(GMPPlaneType aType) const
-{
- const GMPPlane* p = GetPlane(aType);
-  if (p) {
-    return p->Buffer();
-  }
-  return nullptr;
-}
-
-int32_t
-GMPVideoi420FrameImpl::AllocatedSize(GMPPlaneType aType) const
-{
-  const GMPPlane* p = GetPlane(aType);
-  if (p) {
-    return p->AllocatedSize();
-  }
-  return -1;
-}
-
-int32_t
-GMPVideoi420FrameImpl::Stride(GMPPlaneType aType) const
-{
-  const GMPPlane* p = GetPlane(aType);
-  if (p) {
-    return p->Stride();
-  }
-  return -1;
-}
-
-GMPErr
-GMPVideoi420FrameImpl::SetWidth(int32_t aWidth)
-{
-  if (!CheckDimensions(aWidth, mHeight,
-                       mYPlane.Stride(), mUPlane.Stride(),
-                       mVPlane.Stride())) {
-    return GMPGenericErr;
-  }
-  mWidth = aWidth;
-  return GMPNoErr;
-}
-
-GMPErr
-GMPVideoi420FrameImpl::SetHeight(int32_t aHeight)
-{
-  if (!CheckDimensions(mWidth, aHeight,
-                       mYPlane.Stride(), mUPlane.Stride(),
-                       mVPlane.Stride())) {
-    return GMPGenericErr;
-  }
-  mHeight = aHeight;
-  return GMPNoErr;
-}
-
-int32_t
-GMPVideoi420FrameImpl::Width() const
-{
-  return mWidth;
-}
-
-int32_t
-GMPVideoi420FrameImpl::Height() const
-{
-  return mHeight;
-}
-
-void
-GMPVideoi420FrameImpl::SetTimestamp(uint64_t aTimestamp)
-{
-  mTimestamp = aTimestamp;
-}
-
-uint64_t
-GMPVideoi420FrameImpl::Timestamp() const
-{
-  return mTimestamp;
-}
-
-void
-GMPVideoi420FrameImpl::SetDuration(uint64_t aDuration)
-{
-  mDuration = aDuration;
-}
-
-uint64_t
-GMPVideoi420FrameImpl::Duration() const
-{
-  return mDuration;
-}
-
-bool
-GMPVideoi420FrameImpl::IsZeroSize() const
-{
-  return (mYPlane.IsZeroSize() && mUPlane.IsZeroSize() && mVPlane.IsZeroSize());
-}
-
-void
-GMPVideoi420FrameImpl::ResetSize()
-{
-  mYPlane.ResetSize();
-  mUPlane.ResetSize();
-  mVPlane.ResetSize();
-}
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/GMPVideoi420FrameImpl.h b/dom/media/gmp/GMPVideoi420FrameImpl.h
deleted file mode 100644
index 2089854..0000000
--- a/dom/media/gmp/GMPVideoi420FrameImpl.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef GMPVideoi420FrameImpl_h_
-#define GMPVideoi420FrameImpl_h_
-
-#include "gmp-video-frame-i420.h"
-#include "mozilla/ipc/Shmem.h"
-#include "GMPVideoPlaneImpl.h"
-
-namespace mozilla {
-namespace gmp {
-
-class GMPVideoi420FrameData;
-
-class GMPVideoi420FrameImpl : public GMPVideoi420Frame
-{
-  friend struct IPC::ParamTraits<mozilla::gmp::GMPVideoi420FrameImpl>;
-public:
-  explicit GMPVideoi420FrameImpl(GMPVideoHostImpl* aHost);
-  GMPVideoi420FrameImpl(const GMPVideoi420FrameData& aFrameData, GMPVideoHostImpl* aHost);
-  virtual ~GMPVideoi420FrameImpl();
-
-  static bool CheckFrameData(const GMPVideoi420FrameData& aFrameData);
-
-  bool InitFrameData(GMPVideoi420FrameData& aFrameData);
-  const GMPPlaneImpl* GetPlane(GMPPlaneType aType) const;
-  GMPPlaneImpl* GetPlane(GMPPlaneType aType);
-
-  // GMPVideoFrame
-  virtual GMPVideoFrameFormat GetFrameFormat() override;
-  virtual void Destroy() override;
-
-  // GMPVideoi420Frame
-  virtual GMPErr CreateEmptyFrame(int32_t aWidth,
-                                  int32_t aHeight,
-                                  int32_t aStride_y,
-                                  int32_t aStride_u,
-                                  int32_t aStride_v) override;
-  virtual GMPErr CreateFrame(int32_t aSize_y, const uint8_t* aBuffer_y,
-                             int32_t aSize_u, const uint8_t* aBuffer_u,
-                             int32_t aSize_v, const uint8_t* aBuffer_v,
-                             int32_t aWidth,
-                             int32_t aHeight,
-                             int32_t aStride_y,
-                             int32_t aStride_u,
-                             int32_t aStride_v) override;
-  virtual GMPErr CopyFrame(const GMPVideoi420Frame& aFrame) override;
-  virtual void SwapFrame(GMPVideoi420Frame* aFrame) override;
-  virtual uint8_t* Buffer(GMPPlaneType aType) override;
-  virtual const uint8_t* Buffer(GMPPlaneType aType) const override;
-  virtual int32_t AllocatedSize(GMPPlaneType aType) const override;
-  virtual int32_t Stride(GMPPlaneType aType) const override;
-  virtual GMPErr SetWidth(int32_t aWidth) override;
-  virtual GMPErr SetHeight(int32_t aHeight) override;
-  virtual int32_t Width() const override;
-  virtual int32_t Height() const override;
-  virtual void SetTimestamp(uint64_t aTimestamp) override;
-  virtual uint64_t Timestamp() const override;
-  virtual void SetDuration(uint64_t aDuration) override;
-  virtual uint64_t Duration() const override;
-  virtual bool IsZeroSize() const override;
-  virtual void ResetSize() override;
-
-private:
-  bool CheckDimensions(int32_t aWidth, int32_t aHeight,
-                       int32_t aStride_y, int32_t aStride_u, int32_t aStride_v);
-
-  GMPPlaneImpl mYPlane;
-  GMPPlaneImpl mUPlane;
-  GMPPlaneImpl mVPlane;
-  int32_t mWidth;
-  int32_t mHeight;
-  uint64_t mTimestamp;
-  uint64_t mDuration;
-};
-
-} // namespace gmp
-
-} // namespace mozilla
-
-#endif // GMPVideoi420FrameImpl_h_
diff --git a/dom/media/gmp/PGMP.ipdl b/dom/media/gmp/PGMP.ipdl
deleted file mode 100644
index d40b990..0000000
--- a/dom/media/gmp/PGMP.ipdl
+++ /dev/null
@@ -1,45 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PGMPVideoDecoder;
-include protocol PGMPVideoEncoder;
-include protocol PGMPDecryptor;
-include protocol PGMPAudioDecoder;
-include protocol PGMPTimer;
-include protocol PGMPStorage;
-
-namespace mozilla {
-namespace gmp {
-
-intr protocol PGMP
-{
-  manages PGMPAudioDecoder;
-  manages PGMPDecryptor;
-  manages PGMPVideoDecoder;
-  manages PGMPVideoEncoder;
-  manages PGMPTimer;
-  manages PGMPStorage;
-
-parent:
-  async PGMPTimer();
-  async PGMPStorage();
-
-  async AsyncShutdownComplete();
-  async AsyncShutdownRequired();
-
-child:
-  async PGMPAudioDecoder();
-  async PGMPDecryptor();
-  async PGMPVideoDecoder();
-  async PGMPVideoEncoder();
-
-  async SetNodeId(nsCString nodeId);
-  async StartPlugin();
-  async BeginAsyncShutdown();
-  async CrashPluginNow();
-};
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/PGMPAudioDecoder.ipdl b/dom/media/gmp/PGMPAudioDecoder.ipdl
deleted file mode 100644
index 7b19125..0000000
--- a/dom/media/gmp/PGMPAudioDecoder.ipdl
+++ /dev/null
@@ -1,36 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PGMP;
-include GMPTypes;
-
-using GMPCodecSpecificInfo from "gmp-audio-codec.h";
-using GMPErr from "gmp-errors.h";
-
-include "GMPMessageUtils.h";
-
-namespace mozilla {
-namespace gmp {
-
-async protocol PGMPAudioDecoder
-{
-  manager PGMP;
-child:
-  InitDecode(GMPAudioCodecData aCodecSettings);
-  Decode(GMPAudioEncodedSampleData aInput);
-  Reset();
-  Drain();
-  DecodingComplete();
-parent:
-  __delete__();
-  Decoded(GMPAudioDecodedSampleData aDecoded);
-  InputDataExhausted();
-  DrainComplete();
-  ResetComplete();
-  Error(GMPErr aErr);
-};
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/PGMPDecryptor.ipdl b/dom/media/gmp/PGMPDecryptor.ipdl
deleted file mode 100644
index 03417a5..0000000
--- a/dom/media/gmp/PGMPDecryptor.ipdl
+++ /dev/null
@@ -1,90 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PGMP;
-include GMPTypes;
-
-using GMPSessionMessageType from  "gmp-decryption.h";
-using GMPMediaKeyStatus from  "gmp-decryption.h";
-using GMPSessionType from  "gmp-decryption.h";
-using GMPDOMException from "gmp-decryption.h";
-using GMPErr from "gmp-errors.h";
-
-namespace mozilla {
-namespace gmp {
-
-async protocol PGMPDecryptor
-{
-  manager PGMP;
-child:
-
-  Init();
-
-  CreateSession(uint32_t aCreateSessionToken,
-                uint32_t aPromiseId,
-                nsCString aInitDataType,
-                uint8_t[] aInitData,
-                GMPSessionType aSessionType);
-
-  LoadSession(uint32_t aPromiseId,
-              nsCString aSessionId);
-
-  UpdateSession(uint32_t aPromiseId,
-                nsCString aSessionId,
-                uint8_t[] aResponse);
-
-  CloseSession(uint32_t aPromiseId,
-               nsCString aSessionId);
-
-  RemoveSession(uint32_t aPromiseId,
-                nsCString aSessionId);
-
-  SetServerCertificate(uint32_t aPromiseId,
-                       uint8_t[] aServerCert);
-
-  Decrypt(uint32_t aId,
-          uint8_t[] aBuffer,
-          GMPDecryptionData aMetadata);
-
-  DecryptingComplete();
-
-parent:
-  __delete__();
-
-  SetSessionId(uint32_t aCreateSessionToken,
-               nsCString aSessionId);
-
-  ResolveLoadSessionPromise(uint32_t aPromiseId,
-                            bool aSuccess);
-
-  ResolvePromise(uint32_t aPromiseId);
-
-  RejectPromise(uint32_t aPromiseId,
-                GMPDOMException aDOMExceptionCode,
-                nsCString aMessage);
-
-  SessionMessage(nsCString aSessionId,
-                 GMPSessionMessageType aMessageType,
-                 uint8_t[] aMessage);
-
-  ExpirationChange(nsCString aSessionId, double aExpiryTime);
-
-  SessionClosed(nsCString aSessionId);
-
-  SessionError(nsCString aSessionId,
-               GMPDOMException aDOMExceptionCode,
-               uint32_t aSystemCode,
-               nsCString aMessage);
-
-  KeyStatusChanged(nsCString aSessionId, uint8_t[] aKey,
-                   GMPMediaKeyStatus aStatus);
-
-  SetCaps(uint64_t aCaps);
-
-  Decrypted(uint32_t aId, GMPErr aResult, uint8_t[] aBuffer);
-};
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/PGMPStorage.ipdl b/dom/media/gmp/PGMPStorage.ipdl
deleted file mode 100644
index 1ebdd98..0000000
--- a/dom/media/gmp/PGMPStorage.ipdl
+++ /dev/null
@@ -1,36 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PGMP;
-include GMPTypes;
-
-using GMPErr from "gmp-errors.h";
-
-namespace mozilla {
-namespace gmp {
-
-async protocol PGMPStorage
-{
-  manager PGMP;
-
-child:
-  OpenComplete(nsCString aRecordName, GMPErr aStatus);
-  ReadComplete(nsCString aRecordName, GMPErr aStatus, uint8_t[] aBytes);
-  WriteComplete(nsCString aRecordName, GMPErr aStatus);
-  RecordNames(nsCString[] aRecordNames, GMPErr aStatus);
-  Shutdown();
-
-parent:
-  Open(nsCString aRecordName);
-  Read(nsCString aRecordName);
-  Write(nsCString aRecordName, uint8_t[] aBytes);
-  Close(nsCString aRecordName);
-  GetRecordNames();
-  __delete__();
-
-};
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/PGMPTimer.ipdl b/dom/media/gmp/PGMPTimer.ipdl
deleted file mode 100644
index 57bea28..0000000
--- a/dom/media/gmp/PGMPTimer.ipdl
+++ /dev/null
@@ -1,22 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PGMP;
-
-namespace mozilla {
-namespace gmp {
-
-async protocol PGMPTimer
-{
-  manager PGMP;
-child:
-  TimerExpired(uint32_t aTimerId);
-parent:
-  SetTimer(uint32_t aTimerId, uint32_t aTimeoutMs);
-  __delete__();
-};
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/PGMPVideoDecoder.ipdl b/dom/media/gmp/PGMPVideoDecoder.ipdl
deleted file mode 100644
index c25a988..0000000
--- a/dom/media/gmp/PGMPVideoDecoder.ipdl
+++ /dev/null
@@ -1,49 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PGMP;
-include GMPTypes;
-
-using GMPVideoCodec from "gmp-video-codec.h";
-using GMPErr from "gmp-errors.h";
-
-include "GMPMessageUtils.h";
-
-namespace mozilla {
-namespace gmp {
-
-intr protocol PGMPVideoDecoder
-{
-  manager PGMP;
-child:
-  async InitDecode(GMPVideoCodec aCodecSettings,
-                   uint8_t[] aCodecSpecific,
-                   int32_t aCoreCount);
-  async Decode(GMPVideoEncodedFrameData aInputFrame,
-               bool aMissingFrames,
-               uint8_t[] aCodecSpecificInfo,
-               int64_t aRenderTimeMs);
-  async Reset();
-  async Drain();
-  async DecodingComplete();
-  async ChildShmemForPool(Shmem aFrameBuffer);
-
-parent:
-  async __delete__();
-  async Decoded(GMPVideoi420FrameData aDecodedFrame);
-  async ReceivedDecodedReferenceFrame(uint64_t aPictureId);
-  async ReceivedDecodedFrame(uint64_t aPictureId);
-  async InputDataExhausted();
-  async DrainComplete();
-  async ResetComplete();
-  async Error(GMPErr aErr);
-  async ParentShmemForPool(Shmem aEncodedBuffer);
-  // MUST be intr - if sync and we create a new Shmem, when the returned
-  // Shmem is received in the Child it will fail to Deserialize
-  intr NeedShmem(uint32_t aFrameBufferSize) returns (Shmem aMem);
-};
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/PGMPVideoEncoder.ipdl b/dom/media/gmp/PGMPVideoEncoder.ipdl
deleted file mode 100644
index f7b910b..0000000
--- a/dom/media/gmp/PGMPVideoEncoder.ipdl
+++ /dev/null
@@ -1,47 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PGMP;
-include GMPTypes;
-
-using GMPVideoCodec from "gmp-video-codec.h";
-using GMPVideoFrameType from "gmp-video-frame-encoded.h";
-using GMPErr from "gmp-errors.h";
-
-include "GMPMessageUtils.h";
-
-namespace mozilla {
-namespace gmp {
-
-intr protocol PGMPVideoEncoder
-{
-  manager PGMP;
-child:
-  async InitEncode(GMPVideoCodec aCodecSettings,
-                   uint8_t[] aCodecSpecific,
-                   int32_t aNumberOfCores,
-                   uint32_t aMaxPayloadSize);
-  async Encode(GMPVideoi420FrameData aInputFrame,
-               uint8_t[] aCodecSpecificInfo,
-               GMPVideoFrameType[] aFrameTypes);
-  async SetChannelParameters(uint32_t aPacketLoss, uint32_t aRTT);
-  async SetRates(uint32_t aNewBitRate, uint32_t aFrameRate);
-  async SetPeriodicKeyFrames(bool aEnable);
-  async EncodingComplete();
-  async ChildShmemForPool(Shmem aEncodedBuffer);
-
-parent:
-  async __delete__();
-  async Encoded(GMPVideoEncodedFrameData aEncodedFrame,
-                uint8_t[] aCodecSpecificInfo);
-  async Error(GMPErr aErr);
-  async ParentShmemForPool(Shmem aFrameBuffer);
-  // MUST be intr - if sync and we create a new Shmem, when the returned
-  // Shmem is received in the Child it will fail to Deserialize
-  intr NeedShmem(uint32_t aEncodedBufferSize) returns (Shmem aMem);
-};
-
-} // namespace gmp
-} // namespace mozilla
diff --git a/dom/media/gmp/README.txt b/dom/media/gmp/README.txt
deleted file mode 100644
index 32f8b60..0000000
--- a/dom/media/gmp/README.txt
+++ /dev/null
@@ -1 +0,0 @@
-This directory contains code supporting Goanna Media Plugins (GMPs). The GMP API is not the same thing as the Media Plugin API (MPAPI).
diff --git a/dom/media/gmp/gmp-api/gmp-async-shutdown.h b/dom/media/gmp/gmp-api/gmp-async-shutdown.h
deleted file mode 100644
index 4226866..0000000
--- a/dom/media/gmp/gmp-api/gmp-async-shutdown.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
-* Copyright 2013, Mozilla Foundation and contributors
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef GMP_ASYNC_SHUTDOWN_H_
-#define GMP_ASYNC_SHUTDOWN_H_
-
-#define GMP_API_ASYNC_SHUTDOWN "async-shutdown"
-
-// API exposed by the plugin library to manage asynchronous shutdown.
-// Some plugins require special cleanup which may need to make calls
-// to host services and wait for async responses.
-//
-// To enable a plugins to block shutdown until its async shutdown is
-// complete, implement the GMPAsyncShutdown interface and return it when
-// your plugin's GMPGetAPI function is called with "async-shutdown".
-// When your GMPAsyncShutdown's BeginShutdown() implementation is called
-// by the GMP host, you should initate your async shutdown process.
-// Once you have completed shutdown, call the ShutdownComplete() function
-// of the GMPAsyncShutdownHost that is passed as the host argument to the
-// GMPGetAPI() call.
-//
-// Note: Your GMP's GMPShutdown function will still be called after your
-// call to ShutdownComplete().
-//
-// API name macro: GMP_API_ASYNC_SHUTDOWN
-// Host API: GMPAsyncShutdownHost
-class GMPAsyncShutdown {
-public:
-  virtual ~GMPAsyncShutdown() {}
-
-  virtual void BeginShutdown() = 0;
-};
-
-class GMPAsyncShutdownHost {
-public:
-  virtual ~GMPAsyncShutdownHost() {}
-
-  virtual void ShutdownComplete() = 0;
-};
-
-#endif // GMP_ASYNC_SHUTDOWN_H_
diff --git a/dom/media/gmp/gmp-api/gmp-audio-codec.h b/dom/media/gmp/gmp-api/gmp-audio-codec.h
deleted file mode 100644
index 5a5c17b..0000000
--- a/dom/media/gmp/gmp-api/gmp-audio-codec.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
-* Copyright 2013, Mozilla Foundation and contributors
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef GMP_AUDIO_CODEC_h_
-#define GMP_AUDIO_CODEC_h_
-
-#include <stdint.h>
-
-enum GMPAudioCodecType
-{
-  kGMPAudioCodecAAC,
-  kGMPAudioCodecVorbis,
-  kGMPAudioCodecInvalid // Should always be last.
-};
-
-struct GMPAudioCodec
-{
-  GMPAudioCodecType mCodecType;
-  uint32_t mChannelCount;
-  uint32_t mBitsPerChannel;
-  uint32_t mSamplesPerSecond;
-
-  // Codec extra data, such as vorbis setup header, or
-  // AAC AudioSpecificConfig.
-  // These are null/0 if not externally negotiated
-  const uint8_t* mExtraData;
-  uint32_t       mExtraDataLen;
-};
-
-#endif // GMP_AUDIO_CODEC_h_
diff --git a/dom/media/gmp/gmp-api/gmp-audio-decode.h b/dom/media/gmp/gmp-api/gmp-audio-decode.h
deleted file mode 100644
index 5828e98..0000000
--- a/dom/media/gmp/gmp-api/gmp-audio-decode.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
-* Copyright 2013, Mozilla Foundation and contributors
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef GMP_AUDIO_DECODE_h_
-#define GMP_AUDIO_DECODE_h_
-
-#include "gmp-errors.h"
-#include "gmp-audio-samples.h"
-#include "gmp-audio-codec.h"
-#include <stdint.h>
-
-// ALL METHODS MUST BE CALLED ON THE MAIN THREAD
-class GMPAudioDecoderCallback
-{
-public:
-  virtual ~GMPAudioDecoderCallback() {}
-
-  virtual void Decoded(GMPAudioSamples* aDecodedSamples) = 0;
-
-  virtual void InputDataExhausted() = 0;
-
-  virtual void DrainComplete() = 0;
-
-  virtual void ResetComplete() = 0;
-
-  // Called when the decoder encounters a catestrophic error and cannot
-  // continue. Goanna will not send any more input for decoding.
-  virtual void Error(GMPErr aError) = 0;
-};
-
-#define GMP_API_AUDIO_DECODER "decode-audio"
-
-// Audio decoding for a single stream. A GMP may be asked to create multiple
-// decoders concurrently.
-//
-// API name macro: GMP_API_AUDIO_DECODER
-// Host API: GMPAudioHost
-//
-// ALL METHODS MUST BE CALLED ON THE MAIN THREAD
-class GMPAudioDecoder
-{
-public:
-  virtual ~GMPAudioDecoder() {}
-
-  // aCallback: Subclass should retain reference to it until DecodingComplete
-  //            is called. Do not attempt to delete it, host retains ownership.
-  // TODO: Pass AudioHost so decoder can create GMPAudioEncodedFrame objects?
-  virtual void InitDecode(const GMPAudioCodec& aCodecSettings,
-                          GMPAudioDecoderCallback* aCallback) = 0;
-
-  // Decode encoded audio frames (as a part of an audio stream). The decoded
-  // frames must be returned to the user through the decode complete callback.
-  virtual void Decode(GMPAudioSamples* aEncodedSamples) = 0;
-
-  // Reset decoder state and prepare for a new call to Decode(...).
-  // Flushes the decoder pipeline.
-  // The decoder should enqueue a task to run ResetComplete() on the main
-  // thread once the reset has finished.
-  virtual void Reset() = 0;
-
-  // Output decoded frames for any data in the pipeline, regardless of ordering.
-  // All remaining decoded frames should be immediately returned via callback.
-  // The decoder should enqueue a task to run DrainComplete() on the main
-  // thread once the reset has finished.
-  virtual void Drain() = 0;
-
-  // May free decoder memory.
-  virtual void DecodingComplete() = 0;
-};
-
-#endif // GMP_VIDEO_DECODE_h_
diff --git a/dom/media/gmp/gmp-api/gmp-audio-host.h b/dom/media/gmp/gmp-api/gmp-audio-host.h
deleted file mode 100644
index fe36419..0000000
--- a/dom/media/gmp/gmp-api/gmp-audio-host.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
-* Copyright 2013, Mozilla Foundation and contributors
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef GMP_AUDIO_HOST_h_
-#define GMP_AUDIO_HOST_h_
-
-#include "gmp-errors.h"
-#include "gmp-audio-samples.h"
-
-class GMPAudioHost
-{
-public:
-  // Construct various Audio API objects. Host does not retain reference,
-  // caller is owner and responsible for deleting.
-  virtual GMPErr CreateSamples(GMPAudioFormat aFormat,
-                               GMPAudioSamples** aSamples) = 0;
-};
-
-#endif // GMP_AUDIO_HOST_h_
diff --git a/dom/media/gmp/gmp-api/gmp-audio-samples.h b/dom/media/gmp/gmp-api/gmp-audio-samples.h
deleted file mode 100644
index a47fc74..0000000
--- a/dom/media/gmp/gmp-api/gmp-audio-samples.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
-* Copyright 2013, Mozilla Foundation and contributors
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef GMP_AUDIO_FRAME_h_
-#define GMP_AUDIO_FRAME_h_
-
-#include <stdint.h>
-#include "gmp-errors.h"
-#include "gmp-decryption.h"
-
-enum GMPAudioFormat
-{
-  kGMPAudioEncodedSamples, // Raw compressed data, i.e. an AAC/Vorbis packet.
-  kGMPAudioIS16Samples, // Interleaved int16_t PCM samples.
-  kGMPAudioSamplesFormatInvalid // Should always be last.
-};
-
-class GMPAudioSamples {
-public:
-  // The format of the buffer.
-  virtual GMPAudioFormat GetFormat() = 0;
-  virtual void Destroy() = 0;
-
-  // MAIN THREAD ONLY
-  // Buffer size must be exactly what's required to contain all samples in
-  // the buffer; every byte is assumed to be part of a sample.
-  virtual GMPErr SetBufferSize(uint32_t aSize) = 0;
-
-  // Size of the buffer in bytes.
-  virtual uint32_t Size() = 0;
-
-  // Timestamps are in microseconds, and are the playback start time of the
-  // first sample in the buffer.
-  virtual void SetTimeStamp(uint64_t aTimeStamp) = 0;
-  virtual uint64_t TimeStamp() = 0;
-  virtual const uint8_t* Buffer() const = 0;
-  virtual uint8_t*       Buffer() = 0;
-
-  // Get metadata describing how this frame is encrypted, or nullptr if the
-  // buffer is not encrypted.
-  virtual const GMPEncryptedBufferMetadata* GetDecryptionData() const = 0;
-
-  virtual uint32_t Channels() const = 0;
-  virtual void SetChannels(uint32_t aChannels) = 0;
-
-  // Rate; the number of frames per second, where a "frame" is one sample for
-  // each channel.
-  //
-  // For IS16 samples, the number of samples should be:
-  //   Size() / (Channels() * sizeof(int16_t)).
-  //
-  // Note: Channels() and Rate() may not be constant across a decoding
-  // session. For example the rate for decoded samples may be different
-  // than the rate advertised by the MP4 container for encoded samples
-  // for HE-AAC streams with SBR/PS, and an EME-GMP may need to downsample
-  // to satisfy DRM requirements.
-  virtual uint32_t Rate() const = 0;
-  virtual void SetRate(uint32_t aRate) = 0;
-};
-
-#endif // GMP_AUDIO_FRAME_h_
diff --git a/dom/media/gmp/gmp-api/gmp-decryption.h b/dom/media/gmp/gmp-api/gmp-decryption.h
deleted file mode 100644
index cb4800d..0000000
--- a/dom/media/gmp/gmp-api/gmp-decryption.h
+++ /dev/null
@@ -1,361 +0,0 @@
-/*
-* Copyright 2013, Mozilla Foundation and contributors
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef GMP_DECRYPTION_h_
-#define GMP_DECRYPTION_h_
-
-#include "gmp-platform.h"
-
-class GMPStringList {
-public:
-  virtual const uint32_t Size() const = 0;
-
-  virtual void StringAt(uint32_t aIndex,
-                        const char** aOutString, uint32_t* aOutLength) const = 0;
-
-  virtual ~GMPStringList() { }
-};
-
-class GMPEncryptedBufferMetadata {
-public:
-  // Key ID to identify the decryption key.
-  virtual const uint8_t* KeyId() const = 0;
-
-  // Size (in bytes) of |KeyId()|.
-  virtual uint32_t KeyIdSize() const = 0;
-
-  // Initialization vector.
-  virtual const uint8_t* IV() const = 0;
-
-  // Size (in bytes) of |IV|.
-  virtual uint32_t IVSize() const = 0;
-
-  // Number of entries returned by ClearBytes() and CipherBytes().
-  virtual uint32_t NumSubsamples() const = 0;
-
-  virtual const uint16_t* ClearBytes() const = 0;
-
-  virtual const uint32_t* CipherBytes() const = 0;
-
-  virtual ~GMPEncryptedBufferMetadata() {}
-
-  // The set of MediaKeySession IDs associated with this decryption key in
-  // the current stream.
-  virtual const GMPStringList* SessionIds() const = 0;
-};
-
-class GMPBuffer {
-public:
-  virtual uint32_t Id() const = 0;
-  virtual uint8_t* Data() = 0;
-  virtual uint32_t Size() const = 0;
-  virtual void Resize(uint32_t aSize) = 0;
-  virtual ~GMPBuffer() {}
-};
-
-// These match to the DOMException codes as per:
-// http://www.w3.org/TR/dom/#domexception
-enum GMPDOMException {
-  kGMPNoModificationAllowedError = 7,
-  kGMPNotFoundError = 8,
-  kGMPNotSupportedError = 9,
-  kGMPInvalidStateError = 11,
-  kGMPSyntaxError = 12,
-  kGMPInvalidModificationError = 13,
-  kGMPInvalidAccessError = 15,
-  kGMPSecurityError = 18,
-  kGMPAbortError = 20,
-  kGMPQuotaExceededError = 22,
-  kGMPTimeoutError = 23
-};
-
-enum GMPSessionMessageType {
-  kGMPLicenseRequest = 0,
-  kGMPLicenseRenewal = 1,
-  kGMPLicenseRelease = 2,
-  kGMPIndividualizationRequest = 3,
-  kGMPMessageInvalid = 4 // Must always be last.
-};
-
-enum GMPMediaKeyStatus {
-  kGMPUsable = 0,
-  kGMPExpired = 1,
-  kGMPOutputDownscaled = 2,
-  kGMPOutputNotAllowed = 3,
-  kGMPInternalError = 4,
-  kGMPUnknown = 5,
-  kGMPMediaKeyStatusInvalid = 6 // Must always be last.
-};
-
-// Time in milliseconds, as offset from epoch, 1 Jan 1970.
-typedef int64_t GMPTimestamp;
-
-// Capability definitions. The capabilities of the EME GMP are reported
-// to Goanna by calling the GMPDecryptorCallback::SetCapabilities()
-// callback and specifying the logical OR of the GMP_EME_CAP_* flags below.
-//
-// Note the DECRYPT and the DECRYPT_AND_DECODE are mutually exclusive;
-// only one mode should be reported for each stream type, but different
-// modes can be reported for different stream types.
-//
-// Note: Goanna does not currently support the caps changing at runtime.
-// Set them once per plugin initialization, during the startup of
-// the GMPDecryptor.
-
-// Capability; CDM can decrypt encrypted buffers and return still
-// compressed buffers back to Goanna for decompression there.
-#define GMP_EME_CAP_DECRYPT_AUDIO (uint64_t(1) << 0)
-#define GMP_EME_CAP_DECRYPT_VIDEO (uint64_t(1) << 1)
-
-// Capability; CDM can decrypt and then decode encrypted buffers,
-// and return decompressed samples to Goanna for playback.
-#define GMP_EME_CAP_DECRYPT_AND_DECODE_AUDIO (uint64_t(1) << 2)
-#define GMP_EME_CAP_DECRYPT_AND_DECODE_VIDEO (uint64_t(1) << 3)
-
-// Callbacks to be called from the CDM. Threadsafe.
-class GMPDecryptorCallback {
-public:
-
-  // The GMPDecryptor should call this in response to a call to
-  // GMPDecryptor::CreateSession(). The GMP host calls CreateSession() when
-  // MediaKeySession.generateRequest() is called by JavaScript.
-  // After CreateSession() is called, the GMPDecryptor should call
-  // GMPDecryptorCallback::SetSessionId() to set the sessionId exposed to
-  // JavaScript on the MediaKeySession on which the generateRequest() was
-  // called. SetSessionId() must be called before
-  // GMPDecryptorCallback::SessionMessage() will work.
-  // aSessionId must be null terminated.
-  // Note: pass the aCreateSessionToken from the CreateSession() call,
-  // and then once the session has sent any messages required for the
-  // license request to be sent, then resolve the aPromiseId that was passed
-  // to GMPDecryptor::CreateSession().
-  // Note: GMPDecryptor::LoadSession() does *not* need to call SetSessionId()
-  // for GMPDecryptorCallback::SessionMessage() to work.
-  virtual void SetSessionId(uint32_t aCreateSessionToken,
-                            const char* aSessionId,
-                            uint32_t aSessionIdLength) = 0;
-
-  // Resolves a promise for a session loaded.
-  // Resolves to false if we don't have any session data stored for the given
-  // session ID.
-  // Must be called before SessionMessage().
-  virtual void ResolveLoadSessionPromise(uint32_t aPromiseId,
-                                         bool aSuccess) = 0;
-
-  // Called to resolve a specified promise with "undefined".
-  virtual void ResolvePromise(uint32_t aPromiseId) = 0;
-
-  // Called to reject a promise with a DOMException.
-  // aMessage is logged to the WebConsole.
-  // aMessage is optional, but if present must be null terminated.
-  virtual void RejectPromise(uint32_t aPromiseId,
-                             GMPDOMException aException,
-                             const char* aMessage,
-                             uint32_t aMessageLength) = 0;
-
-  // Called by the CDM when it has a message for a session.
-  // Length parameters should not include null termination.
-  // aSessionId must be null terminated.
-  virtual void SessionMessage(const char* aSessionId,
-                              uint32_t aSessionIdLength,
-                              GMPSessionMessageType aMessageType,
-                              const uint8_t* aMessage,
-                              uint32_t aMessageLength) = 0;
-
-  // aSessionId must be null terminated.
-   virtual void ExpirationChange(const char* aSessionId,
-                                 uint32_t aSessionIdLength,
-                                 GMPTimestamp aExpiryTime) = 0;
-
-  // Called by the GMP when a session is closed. All file IO
-  // that a session requires should be complete before calling this.
-  // aSessionId must be null terminated.
-  virtual void SessionClosed(const char* aSessionId,
-                             uint32_t aSessionIdLength) = 0;
-
-  // Called by the GMP when an error occurs in a session.
-  // aSessionId must be null terminated.
-  // aMessage is logged to the WebConsole.
-  // aMessage is optional, but if present must be null terminated.
-  virtual void SessionError(const char* aSessionId,
-                            uint32_t aSessionIdLength,
-                            GMPDOMException aException,
-                            uint32_t aSystemCode,
-                            const char* aMessage,
-                            uint32_t aMessageLength) = 0;
-
-  // Notifies the status of a key. Goanna will not call into the CDM to decrypt
-  // or decode content encrypted with a key unless the CDM has marked it
-  // usable first. So a CDM *MUST* mark its usable keys as usable!
-  virtual void KeyStatusChanged(const char* aSessionId,
-                                uint32_t aSessionIdLength,
-                                const uint8_t* aKeyId,
-                                uint32_t aKeyIdLength,
-                                GMPMediaKeyStatus aStatus) = 0;
-
-  // The CDM must report its capabilites of this CDM. aCaps should be a
-  // logical OR of the GMP_EME_CAP_* flags. The CDM *MUST* call this
-  // function and report whether it can decrypt and/or decode. Without
-  // this, Goanna does not know how to use the CDM and will not send
-  // samples to the CDM to decrypt or decrypt-and-decode mode. Note a
-  // CDM cannot change modes once playback has begun.
-  virtual void SetCapabilities(uint64_t aCaps) = 0;
-
-  // Returns decrypted buffer to Goanna, or reports failure.
-  virtual void Decrypted(GMPBuffer* aBuffer, GMPErr aResult) = 0;
-
-  virtual ~GMPDecryptorCallback() {}
-};
-
-// Host interface, passed to GetAPIFunc(), with "decrypt".
-class GMPDecryptorHost {
-public:
-  virtual void GetSandboxVoucher(const uint8_t** aVoucher,
-                                 uint32_t* aVoucherLength) = 0;
-
-  virtual void GetPluginVoucher(const uint8_t** aVoucher,
-                                uint32_t* aVoucherLength) = 0;
-
-  virtual ~GMPDecryptorHost() {}
-};
-
-enum GMPSessionType {
-  kGMPTemporySession = 0,
-  kGMPPersistentSession = 1,
-  kGMPSessionInvalid = 2 // Must always be last.
-};
-
-#define GMP_API_DECRYPTOR "eme-decrypt-v7"
-
-// XXX remove in bug 1147692
-#define GMP_API_DECRYPTOR_COMPAT "eme-decrypt-v6"
-
-// API exposed by plugin library to manage decryption sessions.
-// When the Host requests this by calling GMPGetAPIFunc().
-//
-// API name macro: GMP_API_DECRYPTOR
-// Host API: GMPDecryptorHost
-class GMPDecryptor {
-public:
-
-  // Sets the callback to use with the decryptor to return results
-  // to Goanna.
-  //
-  // The CDM must also call GMPDecryptorCallback::SetCapabilities()
-  // exactly once during start up, to inform Goanna whether to use the CDM
-  // in decrypt or decrypt-and-decode mode.
-  //
-  // Note: GMPDecryptorCallback::SetCapabilities() must be called before
-  // Goanna will send any samples for decryption to the GMP.
-  virtual void Init(GMPDecryptorCallback* aCallback) = 0;
-
-  // Initiates the creation of a session given |aType| and |aInitData|, and
-  // the generation of a license request message.
-  //
-  // This corresponds to a MediaKeySession.generateRequest() call in JS.
-  //
-  // The GMPDecryptor must do the following, in order, upon this method
-  // being called:
-  //
-  // 1. Generate a sessionId to expose to JS, and call
-  //    GMPDecryptorCallback::SetSessionId(aCreateSessionToken, sessionId...)
-  //    with the sessionId to be exposed to JS/EME on the MediaKeySession
-  //    object on which generateRequest() was called, and then
-  // 2. send any messages to JS/EME required to generate a license request
-  //    given the supplied initData, and then
-  // 3. generate a license request message, and send it to JS/EME, and then
-  // 4. call GMPDecryptorCallback::ResolvePromise().
-  //
-  // Note: GMPDecryptorCallback::SetSessionId(aCreateSessionToken, sessionId, ...)
-  // *must* be called before GMPDecryptorCallback::SendMessage(sessionId, ...)
-  // will work.
-  //
-  // If generating the request fails, reject aPromiseId by calling
-  // GMPDecryptorCallback::RejectPromise().
-  virtual void CreateSession(uint32_t aCreateSessionToken,
-                             uint32_t aPromiseId,
-                             const char* aInitDataType,
-                             uint32_t aInitDataTypeSize,
-                             const uint8_t* aInitData,
-                             uint32_t aInitDataSize,
-                             GMPSessionType aSessionType) = 0;
-
-  // Loads a previously loaded persistent session.
-  //
-  // This corresponds to a MediaKeySession.load() call in JS.
-  //
-  // The GMPDecryptor must do the following, in order, upon this method
-  // being called:
-  //
-  // 1. Send any messages to JS/EME, or read from storage, whatever is
-  //    required to load the session, and then
-  // 2. if there is no session with the given sessionId loadable, call
-  //    ResolveLoadSessionPromise(aPromiseId, false), otherwise
-  // 2. mark the session's keys as usable, and then
-  // 3. update the session's expiration, and then
-  // 4. call GMPDecryptorCallback::ResolveLoadSessionPromise(aPromiseId, true).
-  //
-  // If loading the session fails due to error, reject aPromiseId by calling
-  // GMPDecryptorCallback::RejectPromise().
-  virtual void LoadSession(uint32_t aPromiseId,
-                           const char* aSessionId,
-                           uint32_t aSessionIdLength) = 0;
-
-  // Updates the session with |aResponse|.
-  // This corresponds to a MediaKeySession.update() call in JS.
-  virtual void UpdateSession(uint32_t aPromiseId,
-                             const char* aSessionId,
-                             uint32_t aSessionIdLength,
-                             const uint8_t* aResponse,
-                             uint32_t aResponseSize) = 0;
-
-  // Releases the resources (keys) for the specified session.
-  // This corresponds to a MediaKeySession.close() call in JS.
-  virtual void CloseSession(uint32_t aPromiseId,
-                            const char* aSessionId,
-                            uint32_t aSessionIdLength) = 0;
-
-  // Removes the resources (keys) for the specified session.
-  // This corresponds to a MediaKeySession.remove() call in JS.
-  virtual void RemoveSession(uint32_t aPromiseId,
-                             const char* aSessionId,
-                             uint32_t aSessionIdLength) = 0;
-
-  // Resolve/reject promise on completion.
-  // This corresponds to a MediaKeySession.setServerCertificate() call in JS.
-  virtual void SetServerCertificate(uint32_t aPromiseId,
-                                    const uint8_t* aServerCert,
-                                    uint32_t aServerCertSize) = 0;
-
-  // Asynchronously decrypts aBuffer in place. When the decryption is
-  // complete, GMPDecryptor should write the decrypted data back into the
-  // same GMPBuffer object and return it to Goanna by calling Decrypted(),
-  // with the GMPNoErr successcode. If decryption fails, call Decrypted()
-  // with a failure code, and an error event will fire on the media element.
-  // Note: When Decrypted() is called and aBuffer is passed back, aBuffer
-  // is deleted. Don't forget to call Decrypted(), as otherwise aBuffer's
-  // memory will leak!
-  virtual void Decrypt(GMPBuffer* aBuffer,
-                       GMPEncryptedBufferMetadata* aMetadata) = 0;
-
-  // Called when the decryption operations are complete.
-  // Do not call the GMPDecryptorCallback's functions after this is called.
-  virtual void DecryptingComplete() = 0;
-
-  virtual ~GMPDecryptor() {}
-};
-
-#endif // GMP_DECRYPTION_h_
diff --git a/dom/media/gmp/gmp-api/gmp-entrypoints.h b/dom/media/gmp/gmp-api/gmp-entrypoints.h
deleted file mode 100644
index 51a9668..0000000
--- a/dom/media/gmp/gmp-api/gmp-entrypoints.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* Copyright (c) 2011, The WebRTC project authors. All rights reserved.
- * Copyright (c) 2014, Mozilla
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- ** Redistributions of source code must retain the above copyright
- *  notice, this list of conditions and the following disclaimer.
- *
- ** Redistributions in binary form must reproduce the above copyright
- *  notice, this list of conditions and the following disclaimer in
- *  the documentation and/or other materials provided with the
- *  distribution.
- *
- ** Neither the name of Google nor the names of its contributors may
- *  be used to endorse or promote products derived from this software
- *  without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GMP_ENTRYPOINTS_h_
-#define GMP_ENTRYPOINTS_h_
-
-#include "gmp-errors.h"
-#include "gmp-platform.h"
-
-/* C functions exposed by Goanna Media Plugin shared library. */
-
-// GMPInit
-// - Called once after plugin library is loaded, before GMPGetAPI or GMPShutdown are called.
-// - Called on main thread.
-// - 'aPlatformAPI' is a structure containing platform-provided APIs. It is valid until
-//   'GMPShutdown' is called. Owned and must be deleted by plugin.
-typedef GMPErr (*GMPInitFunc)(const GMPPlatformAPI* aPlatformAPI);
-
-// GMPGetAPI
-// - Called when host wants to use an API.
-// - Called on main thread.
-// - 'aAPIName' is a string indicating the API being requested. This should
-//   match one of the GMP_API_* macros. Subsequent iterations of the GMP_APIs
-//   may change the value of the GMP_API_* macros when ABI changes occur. So
-//   make sure you compare aAPIName against the corresponding GMP_API_* macro!
-// - 'aHostAPI' is the host API which is specific to the API being requested
-//   from the plugin. It is valid so long as the API object requested from the
-//   plugin is valid. It is owned by the host, plugin should not attempt to delete.
-//   May be null.
-// - 'aPluginAPI' is for returning the requested API. Destruction of the requsted
-//   API object is defined by the API.
-typedef GMPErr (*GMPGetAPIFunc)(const char* aAPIName, void* aHostAPI, void** aPluginAPI);
-
-// GMPShutdown
-// - Called once before exiting process (unloading library).
-// - Called on main thread.
-typedef void   (*GMPShutdownFunc)(void);
-
-// GMPSetNodeId
-// - Optional, not required to be implemented. Only useful for EME plugins.
-// - Called after GMPInit to set the device-bound origin-specific node id
-//   that this GMP instance is running under.
-typedef void   (*GMPSetNodeIdFunc)(const char* aNodeId, uint32_t aLength);
-
-#endif // GMP_ENTRYPOINTS_h_
diff --git a/dom/media/gmp/gmp-api/gmp-errors.h b/dom/media/gmp/gmp-api/gmp-errors.h
deleted file mode 100644
index ca88b4f..0000000
--- a/dom/media/gmp/gmp-api/gmp-errors.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* Copyright (c) 2014, Mozilla
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- ** Redistributions of source code must retain the above copyright
- *  notice, this list of conditions and the following disclaimer.
- *
- ** Redistributions in binary form must reproduce the above copyright
- *  notice, this list of conditions and the following disclaimer in
- *  the documentation and/or other materials provided with the
- *  distribution.
- *
- ** Neither the name of Google nor the names of its contributors may
- *  be used to endorse or promote products derived from this software
- *  without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GMP_ERRORS_h_
-#define GMP_ERRORS_h_
-
-typedef enum {
-  GMPNoErr = 0,
-  GMPGenericErr = 1,
-  GMPClosedErr = 2,
-  GMPAllocErr = 3,
-  GMPNotImplementedErr = 4,
-  GMPRecordInUse = 5,
-  GMPQuotaExceededErr = 6,
-  GMPDecodeErr = 7,
-  GMPEncodeErr = 8,
-  GMPNoKeyErr = 9,
-  GMPCryptoErr = 10,
-  GMPEndOfEnumeration = 11,
-  GMPInvalidArgErr = 12,
-  GMPAbortedErr = 13,
-  GMPLastErr // Placeholder, must be last. This enum's values must remain consecutive!
-} GMPErr;
-
-#define GMP_SUCCEEDED(x) ((x) == GMPNoErr)
-#define GMP_FAILED(x) ((x) != GMPNoErr)
-
-#endif // GMP_ERRORS_h_
diff --git a/dom/media/gmp/gmp-api/gmp-platform.h b/dom/media/gmp/gmp-api/gmp-platform.h
deleted file mode 100644
index f915050..0000000
--- a/dom/media/gmp/gmp-api/gmp-platform.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* Copyright (c) 2014, Mozilla
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- ** Redistributions of source code must retain the above copyright
- *  notice, this list of conditions and the following disclaimer.
- *
- ** Redistributions in binary form must reproduce the above copyright
- *  notice, this list of conditions and the following disclaimer in
- *  the documentation and/or other materials provided with the
- *  distribution.
- *
- ** Neither the name of Google nor the names of its contributors may
- *  be used to endorse or promote products derived from this software
- *  without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GMP_PLATFORM_h_
-#define GMP_PLATFORM_h_
-
-#include "gmp-errors.h"
-#include "gmp-storage.h"
-#include <stdint.h>
-
-/* Platform helper API. */
-
-class GMPTask {
-public:
-  virtual void Destroy() = 0; // Deletes object.
-  virtual ~GMPTask() {}
-  virtual void Run() = 0;
-};
-
-class GMPThread {
-public:
-  virtual ~GMPThread() {}
-  virtual void Post(GMPTask* aTask) = 0;
-  virtual void Join() = 0; // Deletes object after join completes.
-};
-
-// A re-entrant monitor; can be locked from the same thread multiple times.
-// Must be unlocked the same number of times it's locked.
-class GMPMutex {
-public:
-  virtual ~GMPMutex() {}
-  virtual void Acquire() = 0;
-  virtual void Release() = 0;
-  virtual void Destroy() = 0; // Deletes object.
-};
-
-// Time is defined as the number of milliseconds since the
-// Epoch (00:00:00 UTC, January 1, 1970).
-typedef int64_t GMPTimestamp;
-
-typedef GMPErr (*GMPCreateThreadPtr)(GMPThread** aThread);
-typedef GMPErr (*GMPRunOnMainThreadPtr)(GMPTask* aTask);
-typedef GMPErr (*GMPSyncRunOnMainThreadPtr)(GMPTask* aTask);
-typedef GMPErr (*GMPCreateMutexPtr)(GMPMutex** aMutex);
-
-// Call on main thread only.
-typedef GMPErr (*GMPCreateRecordPtr)(const char* aRecordName,
-                                     uint32_t aRecordNameSize,
-                                     GMPRecord** aOutRecord,
-                                     GMPRecordClient* aClient);
-
-// Call on main thread only.
-typedef GMPErr (*GMPSetTimerOnMainThreadPtr)(GMPTask* aTask, int64_t aTimeoutMS);
-typedef GMPErr (*GMPGetCurrentTimePtr)(GMPTimestamp* aOutTime);
-
-typedef void (*RecvGMPRecordIteratorPtr)(GMPRecordIterator* aRecordIterator,
-                                         void* aUserArg,
-                                         GMPErr aStatus);
-
-// Creates a GMPCreateRecordIterator to enumerate the records in storage.
-// When the iterator is ready, the function at aRecvIteratorFunc
-// is called with the GMPRecordIterator as an argument. If the operation
-// fails, RecvGMPRecordIteratorPtr is called with a failure aStatus code.
-// The list that the iterator is covering is fixed when
-// GMPCreateRecordIterator is called, it is *not* updated when changes are
-// made to storage.
-// Iterator begins pointing at first record.
-// aUserArg is passed to the aRecvIteratorFunc upon completion.
-typedef GMPErr (*GMPCreateRecordIteratorPtr)(RecvGMPRecordIteratorPtr aRecvIteratorFunc,
-                                             void* aUserArg);
-
-struct GMPPlatformAPI {
-  // Increment the version when things change. Can only add to the struct,
-  // do not change what already exists. Pointers to functions may be NULL
-  // when passed to plugins, but beware backwards compat implications of
-  // doing that.
-  uint16_t version; // Currently version 0
-
-  GMPCreateThreadPtr createthread;
-  GMPRunOnMainThreadPtr runonmainthread;
-  GMPSyncRunOnMainThreadPtr syncrunonmainthread;
-  GMPCreateMutexPtr createmutex;
-  GMPCreateRecordPtr createrecord;
-  GMPSetTimerOnMainThreadPtr settimer;
-  GMPGetCurrentTimePtr getcurrenttime;
-  GMPCreateRecordIteratorPtr getrecordenumerator;
-};
-
-#endif // GMP_PLATFORM_h_
diff --git a/dom/media/gmp/gmp-api/gmp-storage.h b/dom/media/gmp/gmp-api/gmp-storage.h
deleted file mode 100644
index 43ad12b..0000000
--- a/dom/media/gmp/gmp-api/gmp-storage.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
-* Copyright 2013, Mozilla Foundation and contributors
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef GMP_STORAGE_h_
-#define GMP_STORAGE_h_
-
-#include "gmp-errors.h"
-#include <stdint.h>
-
-// Maximum size of a record, in bytes; 10 megabytes.
-#define GMP_MAX_RECORD_SIZE (10 * 1024 * 1024)
-
-// Maximum length of a record name in bytes.
-#define GMP_MAX_RECORD_NAME_SIZE 2000
-
-// Provides basic per-origin storage for CDMs. GMPRecord instances can be
-// retrieved by calling GMPPlatformAPI->openstorage. Multiple GMPRecords
-// with different names can be open at once, but a single record can only
-// be opened by one client at a time. This interface is asynchronous, with
-// results being returned via callbacks to the GMPRecordClient pointer
-// provided to the GMPPlatformAPI->openstorage call, on the main thread.
-//
-// Lifecycle: Once opened, the GMPRecord object remains allocated until
-// GMPRecord::Close() is called. If any GMPRecord function, either
-// synchronously or asynchronously through a GMPRecordClient callback,
-// returns an error, the GMP is responsible for calling Close() on the
-// GMPRecord to delete the GMPRecord object's memory. If your GMP does not
-// call Close(), the GMPRecord's memory will leak.
-class GMPRecord {
-public:
-
-  // Opens the record. Calls OpenComplete() once the record is open.
-  // Note: Only work when GMP is loading content from a webserver.
-  // Does not work for web pages on loaded from disk.
-  // Note: OpenComplete() is only called if this returns GMPNoErr.
-  virtual GMPErr Open() = 0;
-
-  // Reads the entire contents of the record, and calls
-  // GMPRecordClient::ReadComplete() once the operation is complete.
-  // Note: ReadComplete() is only called if this returns GMPNoErr.
-  virtual GMPErr Read() = 0;
-
-  // Writes aDataSize bytes of aData into the record, overwriting the
-  // contents of the record, truncating it to aDataSize length.
-  // Overwriting with 0 bytes "deletes" the record.
-  // Note: WriteComplete is only called if this returns GMPNoErr.
-  virtual GMPErr Write(const uint8_t* aData, uint32_t aDataSize) = 0;
-
-  // Closes a record, deletes the GMPRecord object. The GMPRecord object
-  // must not be used after this is called, request a new one with
-  // GMPPlatformAPI->openstorage to re-open this record. Cancels all
-  // callbacks.
-  virtual GMPErr Close() = 0;
-
-  virtual ~GMPRecord() {}
-};
-
-// Callback object that receives the results of GMPRecord calls. Callbacks
-// run asynchronously to the GMPRecord call, on the main thread.
-class GMPRecordClient {
- public:
-
-  // Response to a GMPRecord::Open() call with the open |status|.
-  // aStatus values:
-  // - GMPNoErr - Record opened successfully. Record may be empty.
-  // - GMPRecordInUse - This record is in use by another client.
-  // - GMPGenericErr - Unspecified error.
-  // If aStatus is not GMPNoErr, the GMPRecord is unusable, and you must
-  // call Close() on the GMPRecord to dispose of it.
-  virtual void OpenComplete(GMPErr aStatus) = 0;
-
-  // Response to a GMPRecord::Read() call, where aData is the record contents,
-  // of length aDataSize.
-  // aData is only valid for the duration of the call to ReadComplete.
-  // Copy it if you want to hang onto it!
-  // aStatus values:
-  // - GMPNoErr - Record contents read successfully, aDataSize 0 means record
-  //   is empty.
-  // - GMPRecordInUse - There are other operations or clients in use on
-  //   this record.
-  // - GMPGenericErr - Unspecified error.
-  // If aStatus is not GMPNoErr, the GMPRecord is unusable, and you must
-  // call Close() on the GMPRecord to dispose of it.
-  virtual void ReadComplete(GMPErr aStatus,
-                            const uint8_t* aData,
-                            uint32_t aDataSize) = 0;
-
-  // Response to a GMPRecord::Write() call.
-  // - GMPNoErr - File contents written successfully.
-  // - GMPRecordInUse - There are other operations or clients in use on
-  //   this record.
-  // - GMPGenericErr - Unspecified error.
-  // If aStatus is not GMPNoErr, the GMPRecord is unusable, and you must
-  // call Close() on the GMPRecord to dispose of it.
-  virtual void WriteComplete(GMPErr aStatus) = 0;
-
-  virtual ~GMPRecordClient() {}
-};
-
-// Iterates over the records that are available. Note: this list maintains
-// a snapshot of the records that were present when the iterator was created.
-// Create by calling the GMPCreateRecordIteratorPtr function on the
-// GMPPlatformAPI struct.
-// Iteration is in alphabetical order.
-class GMPRecordIterator {
-public:
-  // Retrieve the name for the current record.
-  // aOutName is null terminated at character  at index (*aOutNameLength).
-  // Returns GMPNoErr if successful, or GMPEndOfEnumeration if iteration has
-  // reached the end.
-  virtual GMPErr GetName(const char ** aOutName, uint32_t * aOutNameLength) = 0;
-
-  // Advance iteration to the next record.
-  // Returns GMPNoErr if successful, or GMPEndOfEnumeration if iteration has
-  // reached the end.
-  virtual GMPErr NextRecord() = 0;
-
-  // Signals to the GMP host that the GMP is finished with the
-  // GMPRecordIterator. GMPs must call this to release memory held by
-  // the GMPRecordIterator. Do not access the GMPRecordIterator pointer
-  // after calling this!
-  // Memory retrieved by GetName is *not* valid after calling Close()!
-  virtual void Close() = 0;
-
-  virtual ~GMPRecordIterator() {}
-};
-
-#endif // GMP_STORAGE_h_
diff --git a/dom/media/gmp/gmp-api/gmp-video-codec.h b/dom/media/gmp/gmp-api/gmp-video-codec.h
deleted file mode 100644
index 7e50ff7..0000000
--- a/dom/media/gmp/gmp-api/gmp-video-codec.h
+++ /dev/null
@@ -1,225 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* Copyright (c) 2011, The WebRTC project authors. All rights reserved.
- * Copyright (c) 2014, Mozilla
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- ** Redistributions of source code must retain the above copyright
- *  notice, this list of conditions and the following disclaimer.
- *
- ** Redistributions in binary form must reproduce the above copyright
- *  notice, this list of conditions and the following disclaimer in
- *  the documentation and/or other materials provided with the
- *  distribution.
- *
- ** Neither the name of Google nor the names of its contributors may
- *  be used to endorse or promote products derived from this software
- *  without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GMP_VIDEO_CODEC_h_
-#define GMP_VIDEO_CODEC_h_
-
-#include <stdint.h>
-#include <stddef.h>
-
-enum { kGMPPayloadNameSize = 32};
-enum { kGMPMaxSimulcastStreams = 4};
-
-enum GMPVideoCodecComplexity
-{
-  kGMPComplexityNormal = 0,
-  kGMPComplexityHigh = 1,
-  kGMPComplexityHigher = 2,
-  kGMPComplexityMax = 3,
-  kGMPComplexityInvalid // Should always be last
-};
-
-enum GMPVP8ResilienceMode {
-  kResilienceOff,    // The stream produced by the encoder requires a
-                     // recovery frame (typically a key frame) to be
-                     // decodable after a packet loss.
-  kResilientStream,  // A stream produced by the encoder is resilient to
-                     // packet losses, but packets within a frame subsequent
-                     // to a loss can't be decoded.
-  kResilientFrames,  // Same as kResilientStream but with added resilience
-                     // within a frame.
-  kResilienceInvalid // Should always be last.
-};
-
-// VP8 specific
-struct GMPVideoCodecVP8
-{
-  bool mPictureLossIndicationOn;
-  bool mFeedbackModeOn;
-  GMPVideoCodecComplexity mComplexity;
-  GMPVP8ResilienceMode mResilience;
-  uint32_t mNumberOfTemporalLayers;
-  bool mDenoisingOn;
-  bool mErrorConcealmentOn;
-  bool mAutomaticResizeOn;
-};
-
-// H264 specific
-
-// Needs to match a binary spec for this structure.
-// Note: the mSPS at the end of this structure is variable length.
-struct GMPVideoCodecH264AVCC
-{
-  uint8_t        mVersion; // == 0x01
-  uint8_t        mProfile; // these 3 are profile_level_id
-  uint8_t        mConstraints;
-  uint8_t        mLevel;
-  uint8_t        mLengthSizeMinusOne; // lower 2 bits (== GMPBufferType-1). Top 6 reserved (1's)
-
-  // SPS/PPS will not generally be present for interactive use unless SDP
-  // parameter-sets are used.
-  uint8_t        mNumSPS; // lower 5 bits; top 5 reserved (1's)
-
-  /*** uint8_t   mSPS[];  (Not defined due to compiler warnings and warnings-as-errors ...) **/
-  // Following mNumSPS is a variable number of bytes, which is the SPS and PPS.
-  // Each SPS == 16 bit size, ("N"), then "N" bytes,
-  // then uint8_t mNumPPS, then each PPS == 16 bit size ("N"), then "N" bytes.
-};
-
-// Codec specific data for H.264 decoding/encoding.
-// Cast the "aCodecSpecific" parameter of GMPVideoDecoder::InitDecode() and
-// GMPVideoEncoder::InitEncode() to this structure.
-struct GMPVideoCodecH264
-{
-  uint8_t        mPacketizationMode; // 0 or 1
-  struct GMPVideoCodecH264AVCC mAVCC; // holds a variable-sized struct GMPVideoCodecH264AVCC mAVCC;
-};
-
-enum GMPVideoCodecType
-{
-  kGMPVideoCodecVP8,
-
-  // Encoded frames are in AVCC format; NAL length field of 4 bytes, followed
-  // by frame data. May be multiple NALUs per sample. Codec specific extra data
-  // is the AVCC extra data (in AVCC format).
-  kGMPVideoCodecH264,
-  kGMPVideoCodecInvalid // Should always be last.
-};
-
-// Simulcast is when the same stream is encoded multiple times with different
-// settings such as resolution.
-struct GMPSimulcastStream
-{
-  uint32_t mWidth;
-  uint32_t mHeight;
-  uint32_t mNumberOfTemporalLayers;
-  uint32_t mMaxBitrate; // kilobits/sec.
-  uint32_t mTargetBitrate; // kilobits/sec.
-  uint32_t mMinBitrate; // kilobits/sec.
-  uint32_t mQPMax; // minimum quality
-};
-
-enum GMPVideoCodecMode {
-  kGMPRealtimeVideo,
-  kGMPScreensharing,
-  kGMPStreamingVideo,
-  kGMPCodecModeInvalid // Should always be last.
-};
-
-enum GMPApiVersion {
-  kGMPVersion32 = 1, // leveraging that V32 had mCodecType first, and only supported H264
-  kGMPVersion33 = 33,
-};
-
-struct GMPVideoCodec
-{
-  uint32_t mGMPApiVersion;
-
-  GMPVideoCodecType mCodecType;
-  char mPLName[kGMPPayloadNameSize]; // Must be NULL-terminated!
-  uint32_t mPLType;
-
-  uint32_t mWidth;
-  uint32_t mHeight;
-
-  uint32_t mStartBitrate; // kilobits/sec.
-  uint32_t mMaxBitrate; // kilobits/sec.
-  uint32_t mMinBitrate; // kilobits/sec.
-  uint32_t mMaxFramerate;
-
-  bool mFrameDroppingOn;
-  int32_t mKeyFrameInterval;
-
-  uint32_t mQPMax;
-  uint32_t mNumberOfSimulcastStreams;
-  GMPSimulcastStream mSimulcastStream[kGMPMaxSimulcastStreams];
-
-  GMPVideoCodecMode mMode;
-};
-
-// Either single encoded unit, or multiple units separated by 8/16/24/32
-// bit lengths, all with the same timestamp.  Note there is no final 0-length
-// entry; one should check the overall end-of-buffer against where the next
-// length would be.
-enum GMPBufferType {
-  GMP_BufferSingle = 0,
-  GMP_BufferLength8,
-  GMP_BufferLength16,
-  GMP_BufferLength24,
-  GMP_BufferLength32,
-  GMP_BufferInvalid,
-};
-
-struct GMPCodecSpecificInfoGeneric {
-  uint8_t mSimulcastIdx;
-};
-
-struct GMPCodecSpecificInfoH264 {
-  uint8_t mSimulcastIdx;
-};
-
-// Note: if any pointers are added to this struct, it must be fitted
-// with a copy-constructor. See below.
-struct GMPCodecSpecificInfoVP8
-{
-  bool mHasReceivedSLI;
-  uint8_t mPictureIdSLI;
-  bool mHasReceivedRPSI;
-  uint64_t mPictureIdRPSI;
-  int16_t mPictureId; // negative value to skip pictureId
-  bool mNonReference;
-  uint8_t mSimulcastIdx;
-  uint8_t mTemporalIdx;
-  bool mLayerSync;
-  int32_t mTL0PicIdx; // negative value to skip tl0PicIdx
-  int8_t mKeyIdx; // negative value to skip keyIdx
-};
-
-union GMPCodecSpecificInfoUnion
-{
-  GMPCodecSpecificInfoGeneric mGeneric;
-  GMPCodecSpecificInfoVP8 mVP8;
-  GMPCodecSpecificInfoH264 mH264;
-};
-
-// Note: if any pointers are added to this struct or its sub-structs, it
-// must be fitted with a copy-constructor. This is because it is copied
-// in the copy-constructor of VCMEncodedFrame.
-struct GMPCodecSpecificInfo
-{
-  GMPVideoCodecType mCodecType;
-  GMPBufferType mBufferType;
-  GMPCodecSpecificInfoUnion mCodecSpecific;
-};
-
-#endif // GMP_VIDEO_CODEC_h_
diff --git a/dom/media/gmp/gmp-api/gmp-video-decode.h b/dom/media/gmp/gmp-api/gmp-video-decode.h
deleted file mode 100644
index 9e9ab7e..0000000
--- a/dom/media/gmp/gmp-api/gmp-video-decode.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* Copyright (c) 2011, The WebRTC project authors. All rights reserved.
- * Copyright (c) 2014, Mozilla
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- ** Redistributions of source code must retain the above copyright
- *  notice, this list of conditions and the following disclaimer.
- *
- ** Redistributions in binary form must reproduce the above copyright
- *  notice, this list of conditions and the following disclaimer in
- *  the documentation and/or other materials provided with the
- *  distribution.
- *
- ** Neither the name of Google nor the names of its contributors may
- *  be used to endorse or promote products derived from this software
- *  without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GMP_VIDEO_DECODE_h_
-#define GMP_VIDEO_DECODE_h_
-
-#include "gmp-errors.h"
-#include "gmp-video-frame-i420.h"
-#include "gmp-video-frame-encoded.h"
-#include "gmp-video-codec.h"
-#include <stdint.h>
-
-// ALL METHODS MUST BE CALLED ON THE MAIN THREAD
-class GMPVideoDecoderCallback
-{
-public:
-  virtual ~GMPVideoDecoderCallback() {}
-
-  virtual void Decoded(GMPVideoi420Frame* aDecodedFrame) = 0;
-
-  virtual void ReceivedDecodedReferenceFrame(const uint64_t aPictureId) = 0;
-
-  virtual void ReceivedDecodedFrame(const uint64_t aPictureId) = 0;
-
-  virtual void InputDataExhausted() = 0;
-
-  virtual void DrainComplete() = 0;
-
-  virtual void ResetComplete() = 0;
-
-  // Called when the decoder encounters a catestrophic error and cannot
-  // continue. Goanna will not send any more input for decoding.
-  virtual void Error(GMPErr aError) = 0;
-};
-
-#define GMP_API_VIDEO_DECODER "decode-video"
-
-// Video decoding for a single stream. A GMP may be asked to create multiple
-// decoders concurrently.
-//
-// API name macro: GMP_API_VIDEO_DECODER
-// Host API: GMPVideoHost
-//
-// ALL METHODS MUST BE CALLED ON THE MAIN THREAD
-class GMPVideoDecoder
-{
-public:
-  virtual ~GMPVideoDecoder() {}
-
-  // - aCodecSettings: Details of decoder to create.
-  // - aCodecSpecific: codec specific data, cast to a GMPVideoCodecXXX struct
-  //                   to get codec specific config data.
-  // - aCodecSpecificLength: number of bytes in aCodecSpecific.
-  // - aCallback: Subclass should retain reference to it until DecodingComplete
-  //              is called. Do not attempt to delete it, host retains ownership.
-  // aCoreCount: number of CPU cores.
-  virtual void InitDecode(const GMPVideoCodec& aCodecSettings,
-                          const uint8_t* aCodecSpecific,
-                          uint32_t aCodecSpecificLength,
-                          GMPVideoDecoderCallback* aCallback,
-                          int32_t aCoreCount) = 0;
-
-  // Decode encoded frame (as a part of a video stream). The decoded frame
-  // will be returned to the user through the decode complete callback.
-  //
-  // - aInputFrame: Frame to decode. Call Destroy() on frame when it's decoded.
-  // - aMissingFrames: True if one or more frames have been lost since the
-  //                   previous decode call.
-  // - aCodecSpecificInfo : codec specific data, pointer to a
-  //                        GMPCodecSpecificInfo structure appropriate for
-  //                        this codec type.
-  // - aCodecSpecificInfoLength : number of bytes in aCodecSpecificInfo
-  // - renderTimeMs : System time to render in milliseconds. Only used by
-  //                  decoders with internal rendering.
-  virtual void Decode(GMPVideoEncodedFrame* aInputFrame,
-                      bool aMissingFrames,
-                      const uint8_t* aCodecSpecificInfo,
-                      uint32_t aCodecSpecificInfoLength,
-                      int64_t aRenderTimeMs = -1) = 0;
-
-  // Reset decoder state and prepare for a new call to Decode(...).
-  // Flushes the decoder pipeline.
-  // The decoder should enqueue a task to run ResetComplete() on the main
-  // thread once the reset has finished.
-  virtual void Reset() = 0;
-
-  // Output decoded frames for any data in the pipeline, regardless of ordering.
-  // All remaining decoded frames should be immediately returned via callback.
-  // The decoder should enqueue a task to run DrainComplete() on the main
-  // thread once the reset has finished.
-  virtual void Drain() = 0;
-
-  // May free decoder memory.
-  virtual void DecodingComplete() = 0;
-};
-
-#endif // GMP_VIDEO_DECODE_h_
diff --git a/dom/media/gmp/gmp-api/gmp-video-encode.h b/dom/media/gmp/gmp-api/gmp-video-encode.h
deleted file mode 100644
index bb5a908..0000000
--- a/dom/media/gmp/gmp-api/gmp-video-encode.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* Copyright (c) 2011, The WebRTC project authors. All rights reserved.
- * Copyright (c) 2014, Mozilla
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- ** Redistributions of source code must retain the above copyright
- *  notice, this list of conditions and the following disclaimer.
- *
- ** Redistributions in binary form must reproduce the above copyright
- *  notice, this list of conditions and the following disclaimer in
- *  the documentation and/or other materials provided with the
- *  distribution.
- *
- ** Neither the name of Google nor the names of its contributors may
- *  be used to endorse or promote products derived from this software
- *  without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GMP_VIDEO_ENCODE_h_
-#define GMP_VIDEO_ENCODE_h_
-
-#include <vector>
-#include <stdint.h>
-
-#include "gmp-errors.h"
-#include "gmp-video-frame-i420.h"
-#include "gmp-video-frame-encoded.h"
-#include "gmp-video-codec.h"
-
-// ALL METHODS MUST BE CALLED ON THE MAIN THREAD
-class GMPVideoEncoderCallback
-{
-public:
-  virtual ~GMPVideoEncoderCallback() {}
-
-  virtual void Encoded(GMPVideoEncodedFrame* aEncodedFrame,
-                       const uint8_t* aCodecSpecificInfo,
-                       uint32_t aCodecSpecificInfoLength) = 0;
-
-  // Called when the encoder encounters a catestrophic error and cannot
-  // continue. Goanna will not send any more input for encoding.
-  virtual void Error(GMPErr aError) = 0;
-};
-
-#define GMP_API_VIDEO_ENCODER "encode-video"
-
-// Video encoding for a single stream. A GMP may be asked to create multiple
-// encoders concurrently.
-//
-// API name macro: GMP_API_VIDEO_ENCODER
-// Host API: GMPVideoHost
-//
-// ALL METHODS MUST BE CALLED ON THE MAIN THREAD
-class GMPVideoEncoder
-{
-public:
-  virtual ~GMPVideoEncoder() {}
-
-  // Initialize the encoder with the information from the VideoCodec.
-  //
-  // Input:
-  // - codecSettings : Codec settings
-  // - aCodecSpecific : codec specific data, pointer to a
-  //                    GMPCodecSpecific structure appropriate for
-  //                    this codec type.
-  // - aCodecSpecificLength : number of bytes in aCodecSpecific
-  // - aCallback: Subclass should retain reference to it until EncodingComplete
-  //              is called. Do not attempt to delete it, host retains ownership.
-  // - aNnumberOfCores : Number of cores available for the encoder
-  // - aMaxPayloadSize : The maximum size each payload is allowed
-  //                    to have. Usually MTU - overhead.
-  virtual void InitEncode(const GMPVideoCodec& aCodecSettings,
-                          const uint8_t* aCodecSpecific,
-                          uint32_t aCodecSpecificLength,
-                          GMPVideoEncoderCallback* aCallback,
-                          int32_t aNumberOfCores,
-                          uint32_t aMaxPayloadSize) = 0;
-
-  // Encode an I420 frame (as a part of a video stream). The encoded frame
-  // will be returned to the user through the encode complete callback.
-  //
-  // Input:
-  // - aInputFrame : Frame to be encoded
-  // - aCodecSpecificInfo : codec specific data, pointer to a
-  //                        GMPCodecSpecificInfo structure appropriate for
-  //                        this codec type.
-  // - aCodecSpecificInfoLength : number of bytes in aCodecSpecific
-  // - aFrameTypes : The frame type to encode
-  // - aFrameTypesLength : The number of elements in aFrameTypes array.
-  virtual void Encode(GMPVideoi420Frame* aInputFrame,
-                      const uint8_t* aCodecSpecificInfo,
-                      uint32_t aCodecSpecificInfoLength,
-                      const GMPVideoFrameType* aFrameTypes,
-                      uint32_t aFrameTypesLength) = 0;
-
-  // Inform the encoder about the packet loss and round trip time on the
-  // network used to decide the best pattern and signaling.
-  //
-  // - packetLoss : Fraction lost (loss rate in percent =
-  // 100 * packetLoss / 255)
-  // - rtt : Round-trip time in milliseconds
-  virtual void SetChannelParameters(uint32_t aPacketLoss, uint32_t aRTT) = 0;
-
-  // Inform the encoder about the new target bit rate.
-  //
-  // - newBitRate : New target bit rate
-  // - frameRate : The target frame rate
-  virtual void SetRates(uint32_t aNewBitRate, uint32_t aFrameRate) = 0;
-
-  // Use this function to enable or disable periodic key frames. Can be useful for codecs
-  // which have other ways of stopping error propagation.
-  //
-  // - enable : Enable or disable periodic key frames
-  virtual void SetPeriodicKeyFrames(bool aEnable) = 0;
-
-  // May free Encoder memory.
-  virtual void EncodingComplete() = 0;
-};
-
-#endif // GMP_VIDEO_ENCODE_h_
diff --git a/dom/media/gmp/gmp-api/gmp-video-frame-encoded.h b/dom/media/gmp/gmp-api/gmp-video-frame-encoded.h
deleted file mode 100644
index 76af734..0000000
--- a/dom/media/gmp/gmp-api/gmp-video-frame-encoded.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* Copyright (c) 2011, The WebRTC project authors. All rights reserved.
- * Copyright (c) 2014, Mozilla
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- ** Redistributions of source code must retain the above copyright
- *  notice, this list of conditions and the following disclaimer.
- *
- ** Redistributions in binary form must reproduce the above copyright
- *  notice, this list of conditions and the following disclaimer in
- *  the documentation and/or other materials provided with the
- *  distribution.
- *
- ** Neither the name of Google nor the names of its contributors may
- *  be used to endorse or promote products derived from this software
- *  without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GMP_VIDEO_FRAME_ENCODED_h_
-#define GMP_VIDEO_FRAME_ENCODED_h_
-
-#include <stdint.h>
-#include "gmp-decryption.h"
-#include "gmp-video-frame.h"
-#include "gmp-video-codec.h"
-
-enum GMPVideoFrameType
-{
-  kGMPKeyFrame = 0,
-  kGMPDeltaFrame = 1,
-  kGMPGoldenFrame = 2,
-  kGMPAltRefFrame = 3,
-  kGMPSkipFrame = 4,
-  kGMPVideoFrameInvalid = 5 // Must always be last.
-};
-
-// The implementation backing this interface uses shared memory for the
-// buffer(s). This means it can only be used by the "owning" process.
-// At first the process which created the object owns it. When the object
-// is passed to an interface the creator loses ownership and must Destroy()
-// the object. Further attempts to use it may fail due to not being able to
-// access the underlying buffer(s).
-//
-// Methods that create or destroy shared memory must be called on the main
-// thread. They are marked below.
-class GMPVideoEncodedFrame : public GMPVideoFrame
-{
-public:
-  // MAIN THREAD ONLY
-  virtual GMPErr CreateEmptyFrame(uint32_t aSize) = 0;
-  // MAIN THREAD ONLY
-  virtual GMPErr CopyFrame(const GMPVideoEncodedFrame& aVideoFrame) = 0;
-  virtual void     SetEncodedWidth(uint32_t aEncodedWidth) = 0;
-  virtual uint32_t EncodedWidth() = 0;
-  virtual void     SetEncodedHeight(uint32_t aEncodedHeight) = 0;
-  virtual uint32_t EncodedHeight() = 0;
-  // Microseconds
-  virtual void     SetTimeStamp(uint64_t aTimeStamp) = 0;
-  virtual uint64_t TimeStamp() = 0;
-  // Set frame duration (microseconds)
-  // NOTE: next-frame's Timestamp() != this-frame's TimeStamp()+Duration()
-  // depending on rounding to avoid having to track roundoff errors
-  // and dropped/missing frames(!) (which may leave a large gap)
-  virtual void     SetDuration(uint64_t aDuration) = 0;
-  virtual uint64_t Duration() const = 0;
-  virtual void     SetFrameType(GMPVideoFrameType aFrameType) = 0;
-  virtual GMPVideoFrameType FrameType() = 0;
-  virtual void     SetAllocatedSize(uint32_t aNewSize) = 0;
-  virtual uint32_t AllocatedSize() = 0;
-  virtual void     SetSize(uint32_t aSize) = 0;
-  virtual uint32_t Size() = 0;
-  virtual void     SetCompleteFrame(bool aCompleteFrame) = 0;
-  virtual bool     CompleteFrame() = 0;
-  virtual const uint8_t* Buffer() const = 0;
-  virtual uint8_t*       Buffer() = 0;
-  virtual GMPBufferType  BufferType() const = 0;
-  virtual void     SetBufferType(GMPBufferType aBufferType) = 0;
-
-  // Get metadata describing how this frame is encrypted, or nullptr if the
-  // frame is not encrypted.
-  virtual const GMPEncryptedBufferMetadata* GetDecryptionData() const = 0;
-};
-
-#endif // GMP_VIDEO_FRAME_ENCODED_h_
diff --git a/dom/media/gmp/gmp-api/gmp-video-frame-i420.h b/dom/media/gmp/gmp-api/gmp-video-frame-i420.h
deleted file mode 100644
index 14c2c33..0000000
--- a/dom/media/gmp/gmp-api/gmp-video-frame-i420.h
+++ /dev/null
@@ -1,132 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* Copyright (c) 2011, The WebRTC project authors. All rights reserved.
- * Copyright (c) 2014, Mozilla
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- ** Redistributions of source code must retain the above copyright
- *  notice, this list of conditions and the following disclaimer.
- *
- ** Redistributions in binary form must reproduce the above copyright
- *  notice, this list of conditions and the following disclaimer in
- *  the documentation and/or other materials provided with the
- *  distribution.
- *
- ** Neither the name of Google nor the names of its contributors may
- *  be used to endorse or promote products derived from this software
- *  without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GMP_VIDEO_FRAME_I420_h_
-#define GMP_VIDEO_FRAME_I420_h_
-
-#include "gmp-errors.h"
-#include "gmp-video-frame.h"
-#include "gmp-video-plane.h"
-
-#include <stdint.h>
-
-enum GMPPlaneType {
-  kGMPYPlane = 0,
-  kGMPUPlane = 1,
-  kGMPVPlane = 2,
-  kGMPNumOfPlanes = 3
-};
-
-// The implementation backing this interface uses shared memory for the
-// buffer(s). This means it can only be used by the "owning" process.
-// At first the process which created the object owns it. When the object
-// is passed to an interface the creator loses ownership and must Destroy()
-// the object. Further attempts to use it may fail due to not being able to
-// access the underlying buffer(s).
-//
-// Methods that create or destroy shared memory must be called on the main
-// thread. They are marked below.
-class GMPVideoi420Frame : public GMPVideoFrame {
-public:
-  // MAIN THREAD ONLY
-  // CreateEmptyFrame: Sets frame dimensions and allocates buffers based
-  // on set dimensions - height and plane stride.
-  // If required size is bigger than the allocated one, new buffers of adequate
-  // size will be allocated.
-  virtual GMPErr CreateEmptyFrame(int32_t aWidth, int32_t aHeight,
-                                  int32_t aStride_y, int32_t aStride_u, int32_t aStride_v) = 0;
-
-  // MAIN THREAD ONLY
-  // CreateFrame: Sets the frame's members and buffers. If required size is
-  // bigger than allocated one, new buffers of adequate size will be allocated.
-  virtual GMPErr CreateFrame(int32_t aSize_y, const uint8_t* aBuffer_y,
-                             int32_t aSize_u, const uint8_t* aBuffer_u,
-                             int32_t aSize_v, const uint8_t* aBuffer_v,
-                             int32_t aWidth, int32_t aHeight,
-                             int32_t aStride_y, int32_t aStride_u, int32_t aStride_v) = 0;
-
-  // MAIN THREAD ONLY
-  // Copy frame: If required size is bigger than allocated one, new buffers of
-  // adequate size will be allocated.
-  virtual GMPErr CopyFrame(const GMPVideoi420Frame& aVideoFrame) = 0;
-
-  // Swap Frame.
-  virtual void SwapFrame(GMPVideoi420Frame* aVideoFrame) = 0;
-
-  // Get pointer to buffer per plane.
-  virtual uint8_t* Buffer(GMPPlaneType aType) = 0;
-
-  // Overloading with const.
-  virtual const uint8_t* Buffer(GMPPlaneType aType) const = 0;
-
-  // Get allocated size per plane.
-  virtual int32_t AllocatedSize(GMPPlaneType aType) const = 0;
-
-  // Get allocated stride per plane.
-  virtual int32_t Stride(GMPPlaneType aType) const = 0;
-
-  // Set frame width.
-  virtual GMPErr SetWidth(int32_t aWidth) = 0;
-
-  // Set frame height.
-  virtual GMPErr SetHeight(int32_t aHeight) = 0;
-
-  // Get frame width.
-  virtual int32_t Width() const = 0;
-
-  // Get frame height.
-  virtual int32_t Height() const = 0;
-
-  // Set frame timestamp (microseconds)
-  virtual void SetTimestamp(uint64_t aTimestamp) = 0;
-
-  // Get frame timestamp (microseconds)
-  virtual uint64_t Timestamp() const = 0;
-
-  // Set frame duration (microseconds)
-  // NOTE: next-frame's Timestamp() != this-frame's TimeStamp()+Duration()
-  // depending on rounding to avoid having to track roundoff errors
-  // and dropped/missing frames(!) (which may leave a large gap)
-  virtual void SetDuration(uint64_t aDuration) = 0;
-
-  // Get frame duration (microseconds)
-  virtual uint64_t Duration() const = 0;
-
-  // Return true if underlying plane buffers are of zero size, false if not.
-  virtual bool IsZeroSize() const = 0;
-
-  // Reset underlying plane buffers sizes to 0. This function doesn't clear memory.
-  virtual void ResetSize() = 0;
-};
-
-#endif // GMP_VIDEO_FRAME_I420_h_
diff --git a/dom/media/gmp/gmp-api/gmp-video-frame.h b/dom/media/gmp/gmp-api/gmp-video-frame.h
deleted file mode 100644
index b3c9f53..0000000
--- a/dom/media/gmp/gmp-api/gmp-video-frame.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* Copyright (c) 2011, The WebRTC project authors. All rights reserved.
- * Copyright (c) 2014, Mozilla
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- ** Redistributions of source code must retain the above copyright
- *  notice, this list of conditions and the following disclaimer.
- *
- ** Redistributions in binary form must reproduce the above copyright
- *  notice, this list of conditions and the following disclaimer in
- *  the documentation and/or other materials provided with the
- *  distribution.
- *
- ** Neither the name of Google nor the names of its contributors may
- *  be used to endorse or promote products derived from this software
- *  without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GMP_VIDEO_FRAME_h_
-#define GMP_VIDEO_FRAME_h_
-
-#include "gmp-video-plane.h"
-
-enum GMPVideoFrameFormat {
-  kGMPEncodedVideoFrame = 0,
-  kGMPI420VideoFrame = 1
-};
-
-class GMPVideoFrame {
-public:
-  virtual GMPVideoFrameFormat GetFrameFormat() = 0;
-  // MAIN THREAD ONLY IF OWNING PROCESS
-  virtual void Destroy() = 0;
-};
-
-#endif // GMP_VIDEO_FRAME_h_
diff --git a/dom/media/gmp/gmp-api/gmp-video-host.h b/dom/media/gmp/gmp-api/gmp-video-host.h
deleted file mode 100644
index cf20e3f..0000000
--- a/dom/media/gmp/gmp-api/gmp-video-host.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* Copyright (c) 2011, The WebRTC project authors. All rights reserved.
- * Copyright (c) 2014, Mozilla
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- ** Redistributions of source code must retain the above copyright
- *  notice, this list of conditions and the following disclaimer.
- *
- ** Redistributions in binary form must reproduce the above copyright
- *  notice, this list of conditions and the following disclaimer in
- *  the documentation and/or other materials provided with the
- *  distribution.
- *
- ** Neither the name of Google nor the names of its contributors may
- *  be used to endorse or promote products derived from this software
- *  without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GMP_VIDEO_HOST_h_
-#define GMP_VIDEO_HOST_h_
-
-#include "gmp-errors.h"
-#include "gmp-video-frame-i420.h"
-#include "gmp-video-frame-encoded.h"
-#include "gmp-video-codec.h"
-
-// This interface must be called on the main thread only.
-class GMPVideoHost
-{
-public:
-  // Construct various video API objects. Host does not retain reference,
-  // caller is owner and responsible for deleting.
-  // MAIN THREAD ONLY
-  virtual GMPErr CreateFrame(GMPVideoFrameFormat aFormat, GMPVideoFrame** aFrame) = 0;
-  virtual GMPErr CreatePlane(GMPPlane** aPlane) = 0;
-};
-
-#endif // GMP_VIDEO_HOST_h_
diff --git a/dom/media/gmp/gmp-api/gmp-video-plane.h b/dom/media/gmp/gmp-api/gmp-video-plane.h
deleted file mode 100644
index 777cc24..0000000
--- a/dom/media/gmp/gmp-api/gmp-video-plane.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* Copyright (c) 2011, The WebRTC project authors. All rights reserved.
- * Copyright (c) 2014, Mozilla
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- ** Redistributions of source code must retain the above copyright
- *  notice, this list of conditions and the following disclaimer.
- *
- ** Redistributions in binary form must reproduce the above copyright
- *  notice, this list of conditions and the following disclaimer in
- *  the documentation and/or other materials provided with the
- *  distribution.
- *
- ** Neither the name of Google nor the names of its contributors may
- *  be used to endorse or promote products derived from this software
- *  without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GMP_VIDEO_PLANE_h_
-#define GMP_VIDEO_PLANE_h_
-
-#include "gmp-errors.h"
-#include <stdint.h>
-
-// The implementation backing this interface uses shared memory for the
-// buffer(s). This means it can only be used by the "owning" process.
-// At first the process which created the object owns it. When the object
-// is passed to an interface the creator loses ownership and must Destroy()
-// the object. Further attempts to use it may fail due to not being able to
-// access the underlying buffer(s).
-//
-// Methods that create or destroy shared memory must be called on the main
-// thread. They are marked below.
-class GMPPlane {
-public:
-  // MAIN THREAD ONLY
-  // CreateEmptyPlane - set allocated size, actual plane size and stride:
-  // If current size is smaller than current size, then a buffer of sufficient
-  // size will be allocated.
-  virtual GMPErr CreateEmptyPlane(int32_t aAllocatedSize,
-                                  int32_t aStride,
-                                  int32_t aPlaneSize) = 0;
-
-  // MAIN THREAD ONLY
-  // Copy the entire plane data.
-  virtual GMPErr Copy(const GMPPlane& aPlane) = 0;
-
-  // MAIN THREAD ONLY
-  // Copy buffer: If current size is smaller
-  // than current size, then a buffer of sufficient size will be allocated.
-  virtual GMPErr Copy(int32_t aSize, int32_t aStride, const uint8_t* aBuffer) = 0;
-
-  // Swap plane data.
-  virtual void Swap(GMPPlane& aPlane) = 0;
-
-  // Get allocated size.
-  virtual int32_t AllocatedSize() const = 0;
-
-  // Set actual size.
-  virtual void ResetSize() = 0;
-
-  // Return true is plane size is zero, false if not.
-  virtual bool IsZeroSize() const = 0;
-
-  // Get stride value.
-  virtual int32_t Stride() const = 0;
-
-  // Return data pointer.
-  virtual const uint8_t* Buffer() const = 0;
-
-  // Overloading with non-const.
-  virtual uint8_t* Buffer() = 0;
-
-  // MAIN THREAD ONLY IF OWNING PROCESS
-  // Call this when done with the object. This may delete it.
-  virtual void Destroy() = 0;
-};
-
-#endif // GMP_VIDEO_PLANE_h_
diff --git a/dom/media/gmp/mozIGoannaMediaPluginService.idl b/dom/media/gmp/mozIGoannaMediaPluginService.idl
deleted file mode 100644
index 3ea6944..0000000
--- a/dom/media/gmp/mozIGoannaMediaPluginService.idl
+++ /dev/null
@@ -1,132 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "nsISupports.idl"
-#include "nsIThread.idl"
-#include "nsIPrincipal.idl"
-#include "nsIFile.idl"
-
-%{C++
-#include "nsTArray.h"
-#include "nsStringGlue.h"
-class GMPAudioDecoderProxy;
-class GMPDecryptorProxy;
-class GMPVideoDecoderProxy;
-class GMPVideoEncoderProxy;
-class GMPVideoHost;
-%}
-
-[ptr] native GMPVideoDecoderProxy(GMPVideoDecoderProxy);
-[ptr] native GMPVideoEncoderProxy(GMPVideoEncoderProxy);
-[ptr] native GMPVideoHost(GMPVideoHost);
-[ptr] native MessageLoop(MessageLoop);
-[ptr] native TagArray(nsTArray<nsCString>);
-[ptr] native GMPDecryptorProxy(GMPDecryptorProxy);
-[ptr] native GMPAudioDecoderProxy(GMPAudioDecoderProxy);
-
-[scriptable, uuid(46c7cd80-a19d-49e7-a147-ca314ad8d8b0)]
-interface mozIGoannaMediaPluginService : nsISupports
-{
-
-  /**
-   * The GMP thread. Callable from any thread.
-   */
-  readonly attribute nsIThread thread;
-
-  /**
-   * Get a plugin that supports the specified tags.
-   * Callable on any thread
-   */
-  [noscript]
-  boolean hasPluginForAPI(in ACString api, in TagArray tags);
-
-  /**
-   * Get the version of the plugin that supports the specified tags.
-   * Callable on any thread
-   */
-  [noscript]
-  ACString getPluginVersionForAPI(in ACString api,
-                                  in TagArray tags);
-
-  /**
-   * Get a video decoder that supports the specified tags.
-   * The array of tags should at least contain a codec tag, and optionally
-   * other tags such as for EME keysystem.
-   * Callable only on GMP thread.
-   */
-  [noscript]
-  GMPVideoDecoderProxy getGMPVideoDecoder(in TagArray tags,
-                                          [optional] in ACString nodeId,
-                                          out GMPVideoHost outVideoHost);
-
-  /**
-   * Get a video encoder that supports the specified tags.
-   * The array of tags should at least contain a codec tag, and optionally
-   * other tags.
-   * Callable only on GMP thread.
-   */
-  [noscript]
-  GMPVideoEncoderProxy getGMPVideoEncoder(in TagArray tags,
-		                                      [optional] in ACString nodeId,
-		                                      out GMPVideoHost outVideoHost);
-
-  // Returns an audio decoder that supports the specified tags.
-  // The array of tags should at least contain a codec tag, and optionally
-  // other tags such as for EME keysystem.
-  // Callable only on GMP thread.
-  GMPAudioDecoderProxy getGMPAudioDecoder(in TagArray tags,
-                                          [optional] in ACString nodeId);
-
-  // Returns a decryption session manager that supports the specified tags.
-  // The array of tags should at least contain a key system tag, and optionally
-  // other tags.
-  // Callable only on GMP thread.
-  GMPDecryptorProxy getGMPDecryptor(in TagArray tags, in ACString nodeId);
-
-  /**
-   * Add a directory to scan for goanna media plugins.
-   * @note Main-thread API.
-   */
-  void addPluginDirectory(in AString directory);
-
-  /**
-   * Remove a directory for goanna media plugins.
-   * @note Main-thread API.
-   */
-  void removePluginDirectory(in AString directory);
-
-  /**
-   * Remove a directory for goanna media plugins and delete it from disk.
-   * If |defer| is true, wait until the plugin is unused before removing.
-   * @note Main-thread API.
-   */
-  void removeAndDeletePluginDirectory(in AString directory,
-                                      [optional] in bool defer);
-
-  /**
-   * Gets the NodeId for a (origin, urlbarOrigin, isInprivateBrowsing) tuple.
-   */
-  ACString getNodeId(in AString origin,
-                     in AString topLevelOrigin,
-                     in bool inPrivateBrowsingMode);
-
-  /**
-   * Clears storage data associated with the site.
-   */
-  void forgetThisSite(in AString site);
-
-  /**
-   * Returns true if the given node id is allowed to store things
-   * persistently on disk. Private Browsing and local content are not
-   * allowed to store persistent data.
-   */
-  bool isPersistentStorageAllowed(in ACString nodeId);
-
-  /**
-   * Returns the directory to use as the base for storing data about GMPs.
-   */
-  nsIFile getStorageDir();
-
-};
diff --git a/dom/media/gmp/rlz/COPYING b/dom/media/gmp/rlz/COPYING
deleted file mode 100644
index b89042a..0000000
--- a/dom/media/gmp/rlz/COPYING
+++ /dev/null
@@ -1,14 +0,0 @@
-Copyright 2010 Google Inc.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
diff --git a/dom/media/gmp/rlz/README.mozilla b/dom/media/gmp/rlz/README.mozilla
deleted file mode 100644
index fffc5de..0000000
--- a/dom/media/gmp/rlz/README.mozilla
+++ /dev/null
@@ -1,6 +0,0 @@
-Code taken from rlz project: https://code.google.com/p/rlz/
-
-Revision: 134, then with unused code stripped out.
-
-Note: base/ contains wrappers/dummies to provide implementations of the
-Chromium APIs that this code relies upon.
diff --git a/dom/media/gmp/rlz/base/memory/scoped_ptr.h b/dom/media/gmp/rlz/base/memory/scoped_ptr.h
deleted file mode 100644
index c837e04..0000000
--- a/dom/media/gmp/rlz/base/memory/scoped_ptr.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-// The scoped_ptr.h our IPC copy of Chromium's code does not include
-// scoped_array, so adapt it to nsAutoArrayPtr here.
-
-#ifndef FAKE_SCOPED_PTR_H_
-#define FAKE_SCOPED_PTR_H_
-
-#include "mozilla/ArrayUtils.h"
-#include "nsAutoPtr.h"
-
-template<class T>
-class scoped_array : public nsAutoArrayPtr<T> {
-public:
-  scoped_array(T* t) : nsAutoArrayPtr<T>(t) {}
-  void reset(T* t) {
-    scoped_array<T> other(t);
-    this->operator=(other);
-  }
-};
-
-#define arraysize mozilla::ArrayLength
-
-#endif
diff --git a/dom/media/gmp/rlz/base/string16.h b/dom/media/gmp/rlz/base/string16.h
deleted file mode 100644
index a2c56df..0000000
--- a/dom/media/gmp/rlz/base/string16.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef FAKE_STRING16_H
-#define FAKE_STRING16_H
-
-#include <string>
-typedef std::wstring string16;
-
-#endif
diff --git a/dom/media/gmp/rlz/lib/assert.h b/dom/media/gmp/rlz/lib/assert.h
deleted file mode 100644
index 68737b1..0000000
--- a/dom/media/gmp/rlz/lib/assert.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef FAKE_ASSERT_H_
-#define FAKE_ASSERT_H_
-
-#include <assert.h>
-
-#define ASSERT_STRING(x) { assert(false); }
-#define VERIFY(x) { assert(x); };
-
-#endif
diff --git a/dom/media/gmp/rlz/lib/machine_id.h b/dom/media/gmp/rlz/lib/machine_id.h
deleted file mode 100644
index 98d66d5..0000000
--- a/dom/media/gmp/rlz/lib/machine_id.h
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright 2012 Google Inc. All Rights Reserved.
-// Use of this source code is governed by an Apache-style license that can be
-// found in the COPYING file.
-
-#ifndef RLZ_LIB_MACHINE_ID_H_
-#define RLZ_LIB_MACHINE_ID_H_
-
-#include "base/string16.h"
-
-#include <string>
-
-namespace rlz_lib {
-
-// Retrieves a raw machine identifier string and a machine-specific
-// 4 byte value. GetMachineId() will SHA1 |data|, append |more_data|, compute
-// the Crc8 of that, and return a hex-encoded string of that data.
-bool GetRawMachineId(string16* data, int* more_data);
-
-}  // namespace rlz_lib
-
-#endif  // RLZ_LIB_MACHINE_ID_H_
diff --git a/dom/media/gmp/rlz/lib/string_utils.cc b/dom/media/gmp/rlz/lib/string_utils.cc
deleted file mode 100644
index b6a71ac..0000000
--- a/dom/media/gmp/rlz/lib/string_utils.cc
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright 2010 Google Inc. All Rights Reserved.
-// Use of this source code is governed by an Apache-style license that can be
-// found in the COPYING file.
-//
-// String manipulation functions used in the RLZ library.
-
-#include "rlz/lib/string_utils.h"
-
-namespace rlz_lib {
-
-bool BytesToString(const unsigned char* data,
-                   int data_len,
-                   std::string* string) {
-  if (!string)
-    return false;
-
-  string->clear();
-  if (data_len < 1 || !data)
-    return false;
-
-  static const char kHex[] = "0123456789ABCDEF";
-
-  // Fix the buffer size to begin with to avoid repeated re-allocation.
-  string->resize(data_len * 2);
-  int index = data_len;
-  while (index--) {
-    string->at(2 * index) = kHex[data[index] >> 4];  // high digit
-    string->at(2 * index + 1) = kHex[data[index] & 0x0F];  // low digit
-  }
-
-  return true;
-}
-
-}  // namespace rlz_lib
diff --git a/dom/media/gmp/rlz/lib/string_utils.h b/dom/media/gmp/rlz/lib/string_utils.h
deleted file mode 100644
index 294f1b2..0000000
--- a/dom/media/gmp/rlz/lib/string_utils.h
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright 2010 Google Inc. All Rights Reserved.
-// Use of this source code is governed by an Apache-style license that can be
-// found in the COPYING file.
-//
-// String manipulation functions used in the RLZ library.
-
-#ifndef RLZ_LIB_STRING_UTILS_H_
-#define RLZ_LIB_STRING_UTILS_H_
-
-#include <string>
-
-namespace rlz_lib {
-
-bool BytesToString(const unsigned char* data,
-                   int data_len,
-                   std::string* string);
-
-};  // namespace
-
-#endif  // RLZ_LIB_STRING_UTILS_H_
diff --git a/dom/media/gmp/rlz/moz.build b/dom/media/gmp/rlz/moz.build
deleted file mode 100644
index 104ab11..0000000
--- a/dom/media/gmp/rlz/moz.build
+++ /dev/null
@@ -1,24 +0,0 @@
-# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-# Note: build rlz in its own moz.build, so it doesn't pickup any of
-# Chromium IPC's headers used in the moz.build of the parent file.
-
-Library('rlz')
-FORCE_STATIC_LIB = True
-USE_STATIC_LIBS = True
-
-UNIFIED_SOURCES += [
-    'lib/string_utils.cc',
-    'win/lib/machine_id_win.cc',
-]
-
-LOCAL_INCLUDES += [
-    '..',
-]
-
-if CONFIG['GNU_CXX']:
-    FAIL_ON_WARNINGS = True
diff --git a/dom/media/gmp/rlz/win/lib/machine_id_win.cc b/dom/media/gmp/rlz/win/lib/machine_id_win.cc
deleted file mode 100644
index fb54542..0000000
--- a/dom/media/gmp/rlz/win/lib/machine_id_win.cc
+++ /dev/null
@@ -1,131 +0,0 @@
-// Copyright 2011 Google Inc. All Rights Reserved.
-// Use of this source code is governed by an Apache-style license that can be
-// found in the COPYING file.
-
-#include <windows.h>
-#include <sddl.h>  // For ConvertSidToStringSidW.
-#include <string>
-
-#include "base/memory/scoped_ptr.h"
-#include "base/string16.h"
-#include "rlz/lib/assert.h"
-
-namespace rlz_lib {
-
-namespace {
-
-bool GetSystemVolumeSerialNumber(int* number) {
-  if (!number)
-    return false;
-
-  *number = 0;
-
-  // Find the system root path (e.g: C:\).
-  wchar_t system_path[MAX_PATH + 1];
-  if (!GetSystemDirectoryW(system_path, MAX_PATH))
-    return false;
-
-  wchar_t* first_slash = wcspbrk(system_path, L"\\/");
-  if (first_slash != NULL)
-    *(first_slash + 1) = 0;
-
-  DWORD number_local = 0;
-  if (!GetVolumeInformationW(system_path, NULL, 0, &number_local, NULL, NULL,
-                             NULL, 0))
-    return false;
-
-  *number = (int)number_local;
-  return true;
-}
-
-bool GetComputerSid(const wchar_t* account_name, SID* sid, DWORD sid_size) {
-  static const DWORD kStartDomainLength = 128;  // reasonable to start with
-
-  scoped_array<wchar_t> domain_buffer(new wchar_t[kStartDomainLength]);
-  DWORD domain_size = kStartDomainLength;
-  DWORD sid_dword_size = sid_size;
-  SID_NAME_USE sid_name_use;
-
-  BOOL success = ::LookupAccountNameW(NULL, account_name, sid,
-                                      &sid_dword_size, domain_buffer.get(),
-                                      &domain_size, &sid_name_use);
-  if (!success && ::GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
-    // We could have gotten the insufficient buffer error because
-    // one or both of sid and szDomain was too small. Check for that
-    // here.
-    if (sid_dword_size > sid_size)
-      return false;
-
-    if (domain_size > kStartDomainLength)
-      domain_buffer.reset(new wchar_t[domain_size]);
-
-    success = ::LookupAccountNameW(NULL, account_name, sid, &sid_dword_size,
-                                   domain_buffer.get(), &domain_size,
-                                   &sid_name_use);
-  }
-
-  return success != FALSE;
-}
-
-std::wstring ConvertSidToString(SID* sid) {
-  std::wstring sid_string;
-#if _WIN32_WINNT >= 0x500
-  wchar_t* sid_buffer = NULL;
-  if (ConvertSidToStringSidW(sid, &sid_buffer)) {
-    sid_string = sid_buffer;
-    LocalFree(sid_buffer);
-  }
-#else
-  SID_IDENTIFIER_AUTHORITY* sia = ::GetSidIdentifierAuthority(sid);
-
-  if(sia->Value[0] || sia->Value[1]) {
-    base::SStringPrintf(
-        &sid_string, L"S-%d-0x%02hx%02hx%02hx%02hx%02hx%02hx",
-        SID_REVISION, (USHORT)sia->Value[0], (USHORT)sia->Value[1],
-        (USHORT)sia->Value[2], (USHORT)sia->Value[3], (USHORT)sia->Value[4],
-        (USHORT)sia->Value[5]);
-  } else {
-    ULONG authority = 0;
-    for (int i = 2; i < 6; ++i) {
-      authority <<= 8;
-      authority |= sia->Value[i];
-    }
-    base::SStringPrintf(&sid_string, L"S-%d-%lu", SID_REVISION, authority);
-  }
-
-  int sub_auth_count = *::GetSidSubAuthorityCount(sid);
-  for(int i = 0; i < sub_auth_count; ++i)
-    base::StringAppendF(&sid_string, L"-%lu", *::GetSidSubAuthority(sid, i));
-#endif
-
-  return sid_string;
-}
-
-}  // namespace
-
-bool GetRawMachineId(string16* sid_string, int* volume_id) {
-  // Calculate the Windows SID.
-
-  wchar_t computer_name[MAX_COMPUTERNAME_LENGTH + 1] = {0};
-  DWORD size = arraysize(computer_name);
-
-  if (!GetComputerNameW(computer_name, &size)) {
-    return false;
-  }
-  char sid_buffer[SECURITY_MAX_SID_SIZE];
-  SID* sid = reinterpret_cast<SID*>(sid_buffer);
-  if (GetComputerSid(computer_name, sid, SECURITY_MAX_SID_SIZE)) {
-    *sid_string = ConvertSidToString(sid);
-  }
-
-  // Get the system drive volume serial number.
-  *volume_id = 0;
-  if (!GetSystemVolumeSerialNumber(volume_id)) {
-    ASSERT_STRING("GetMachineId: Failed to retrieve volume serial number");
-    *volume_id = 0;
-  }
-
-  return true;
-}
-
-}  // namespace rlz_lib
diff --git a/dom/media/gtest/TestGMPCrossOrigin.cpp b/dom/media/gtest/TestGMPCrossOrigin.cpp
deleted file mode 100644
index f903c20..0000000
--- a/dom/media/gtest/TestGMPCrossOrigin.cpp
+++ /dev/null
@@ -1,1244 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "gtest/gtest.h"
-#include "nsIObserverService.h"
-#include "mozilla/Services.h"
-#include "mozilla/StaticPtr.h"
-#include "GMPVideoDecoderProxy.h"
-#include "GMPVideoEncoderProxy.h"
-#include "GMPDecryptorProxy.h"
-#include "GMPService.h"
-#include "nsAppDirectoryServiceDefs.h"
-#include "nsIFile.h"
-#include "nsISimpleEnumerator.h"
-#include "mozilla/Atomics.h"
-#include "nsNSSComponent.h"
-
-#if defined(XP_WIN)
-#include "mozilla/WindowsVersion.h"
-#endif
-
-using namespace std;
-
-using namespace mozilla;
-using namespace mozilla::gmp;
-
-struct GMPTestRunner
-{
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(GMPTestRunner)
-
-  void DoTest(void (GMPTestRunner::*aTestMethod)());
-  void RunTestGMPTestCodec();
-  void RunTestGMPCrossOrigin();
-
-private:
-  ~GMPTestRunner() { }
-};
-
-void
-GMPTestRunner::RunTestGMPTestCodec()
-{
-  nsRefPtr<GoannaMediaPluginService> service =
-    GoannaMediaPluginService::GetGoannaMediaPluginService();
-
-  GMPVideoHost* host = nullptr;
-  GMPVideoDecoderProxy* decoder = nullptr;
-  GMPVideoDecoderProxy* decoder2 = nullptr;
-  GMPVideoEncoderProxy* encoder = nullptr;
-
-  nsTArray<nsCString> tags;
-  tags.AppendElement(NS_LITERAL_CSTRING("h264"));
-
-  service->GetGMPVideoDecoder(&tags, NS_LITERAL_CSTRING("o"), &host, &decoder2);
-  service->GetGMPVideoDecoder(&tags, NS_LITERAL_CSTRING(""), &host, &decoder);
-
-  service->GetGMPVideoEncoder(&tags, NS_LITERAL_CSTRING(""), &host, &encoder);
-
-  EXPECT_TRUE(host);
-  EXPECT_TRUE(decoder);
-  EXPECT_TRUE(decoder2);
-  EXPECT_TRUE(encoder);
-
-  if (decoder) decoder->Close();
-  if (decoder2) decoder2->Close();
-  if (encoder) encoder->Close();
-}
-
-void
-GMPTestRunner::RunTestGMPCrossOrigin()
-{
-  nsRefPtr<GoannaMediaPluginService> service =
-    GoannaMediaPluginService::GetGoannaMediaPluginService();
-
-  GMPVideoHost* host = nullptr;
-  nsTArray<nsCString> tags;
-  tags.AppendElement(NS_LITERAL_CSTRING("h264"));
-
-  GMPVideoDecoderProxy* decoder1 = nullptr;
-  GMPVideoDecoderProxy* decoder2 = nullptr;
-  GMPVideoEncoderProxy* encoder1 = nullptr;
-  GMPVideoEncoderProxy* encoder2 = nullptr;
-
-  service->GetGMPVideoDecoder(&tags, NS_LITERAL_CSTRING("origin1"), &host, &decoder1);
-  service->GetGMPVideoDecoder(&tags, NS_LITERAL_CSTRING("origin2"), &host, &decoder2);
-  EXPECT_TRUE(!!decoder1 && !!decoder2 &&
-              decoder1->ParentID() != decoder2->ParentID());
-
-  service->GetGMPVideoEncoder(&tags, NS_LITERAL_CSTRING("origin1"), &host, &encoder1);
-  service->GetGMPVideoEncoder(&tags, NS_LITERAL_CSTRING("origin2"), &host, &encoder2);
-  EXPECT_TRUE(!!encoder1 && !!encoder2 &&
-              encoder1->ParentID() != encoder2->ParentID());
-
-  if (decoder2) decoder2->Close();
-  if (encoder2) encoder2->Close();
-
-  service->GetGMPVideoDecoder(&tags, NS_LITERAL_CSTRING("origin1"), &host, &decoder2);
-  EXPECT_TRUE(!!decoder1 && !!decoder2 &&
-              decoder1->ParentID() == decoder2->ParentID());
-
-  service->GetGMPVideoEncoder(&tags, NS_LITERAL_CSTRING("origin1"), &host, &encoder2);
-  EXPECT_TRUE(!!encoder1 && !!encoder2 &&
-              encoder1->ParentID() == encoder2->ParentID());
-
-  if (decoder1) decoder1->Close();
-  if (decoder2) decoder2->Close();
-  if (encoder1) encoder1->Close();
-  if (encoder2) encoder2->Close();
-}
-
-static already_AddRefed<nsIThread>
-GetGMPThread()
-{
-  nsRefPtr<GoannaMediaPluginService> service =
-    GoannaMediaPluginService::GetGoannaMediaPluginService();
-  nsCOMPtr<nsIThread> thread;
-  EXPECT_TRUE(NS_SUCCEEDED(service->GetThread(getter_AddRefs(thread))));
-  return thread.forget();
-}
-
-/**
- * Enumerate files under |aPath| (non-recursive).
- */
-template<typename T>
-static nsresult
-EnumerateDir(nsIFile* aPath, T&& aDirIter)
-{
-  nsCOMPtr<nsISimpleEnumerator> iter;
-  nsresult rv = aPath->GetDirectoryEntries(getter_AddRefs(iter));
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  bool hasMore = false;
-  while (NS_SUCCEEDED(iter->HasMoreElements(&hasMore)) && hasMore) {
-    nsCOMPtr<nsISupports> supports;
-    rv = iter->GetNext(getter_AddRefs(supports));
-    if (NS_FAILED(rv)) {
-      continue;
-    }
-
-    nsCOMPtr<nsIFile> entry(do_QueryInterface(supports, &rv));
-    if (NS_FAILED(rv)) {
-      continue;
-    }
-
-    aDirIter(entry);
-  }
-  return NS_OK;
-}
-
-/**
- * Enumerate files under $profileDir/gmp/$aDir/ (non-recursive).
- */
-template<typename T>
-static nsresult
-EnumerateGMPStorageDir(const nsACString& aDir, T&& aDirIter)
-{
-  nsRefPtr<GoannaMediaPluginService> service =
-    GoannaMediaPluginService::GetGoannaMediaPluginService();
-  MOZ_ASSERT(service);
-
-  // $profileDir/gmp/
-  nsCOMPtr<nsIFile> path;
-  nsresult rv = service->GetStorageDir(getter_AddRefs(path));
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  // $profileDir/gmp/$aDir/
-  rv = path->AppendNative(aDir);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  return EnumerateDir(path, aDirIter);
-}
-
-class GMPShutdownObserver : public nsIRunnable
-                          , public nsIObserver {
-public:
-  GMPShutdownObserver(nsIRunnable* aShutdownTask,
-                      nsIRunnable* Continuation,
-                      const nsACString& aNodeId)
-    : mShutdownTask(aShutdownTask)
-    , mContinuation(Continuation)
-    , mNodeId(NS_ConvertUTF8toUTF16(aNodeId))
-  {}
-
-  NS_DECL_THREADSAFE_ISUPPORTS
-
-  NS_IMETHOD Run() override {
-    MOZ_ASSERT(NS_IsMainThread());
-    nsCOMPtr<nsIObserverService> observerService =
-        mozilla::services::GetObserverService();
-    EXPECT_TRUE(observerService);
-    observerService->AddObserver(this, "gmp-shutdown", false);
-
-    nsCOMPtr<nsIThread> thread(GetGMPThread());
-    thread->Dispatch(mShutdownTask, NS_DISPATCH_NORMAL);
-    return NS_OK;
-  }
-
-  NS_IMETHOD Observe(nsISupports* aSubject,
-                     const char* aTopic,
-                     const char16_t* aSomeData) override
-  {
-    if (!strcmp(aTopic, "gmp-shutdown") &&
-        mNodeId.Equals(nsDependentString(aSomeData))) {
-      nsCOMPtr<nsIObserverService> observerService =
-          mozilla::services::GetObserverService();
-      EXPECT_TRUE(observerService);
-      observerService->RemoveObserver(this, "gmp-shutdown");
-      nsCOMPtr<nsIThread> thread(GetGMPThread());
-      thread->Dispatch(mContinuation, NS_DISPATCH_NORMAL);
-    }
-    return NS_OK;
-  }
-
-private:
-  virtual ~GMPShutdownObserver() {}
-  nsRefPtr<nsIRunnable> mShutdownTask;
-  nsRefPtr<nsIRunnable> mContinuation;
-  const nsString mNodeId;
-};
-
-NS_IMPL_ISUPPORTS(GMPShutdownObserver, nsIRunnable, nsIObserver)
-
-class NotifyObserversTask : public nsRunnable {
-public:
-  explicit NotifyObserversTask(const char* aTopic)
-    : mTopic(aTopic)
-  {}
-  NS_IMETHOD Run() {
-    MOZ_ASSERT(NS_IsMainThread());
-    nsCOMPtr<nsIObserverService> observerService =
-        mozilla::services::GetObserverService();
-    if (observerService) {
-      observerService->NotifyObservers(nullptr, mTopic, nullptr);
-    }
-    return NS_OK;
-  }
-  const char* mTopic;
-};
-
-class ClearGMPStorageTask : public nsIRunnable
-                          , public nsIObserver {
-public:
-  ClearGMPStorageTask(nsIRunnable* Continuation,
-                      nsIThread* aTarget, PRTime aSince)
-    : mContinuation(Continuation)
-    , mTarget(aTarget)
-    , mSince(aSince)
-  {}
-
-  NS_DECL_THREADSAFE_ISUPPORTS
-
-  NS_IMETHOD Run() override {
-    MOZ_ASSERT(NS_IsMainThread());
-    nsCOMPtr<nsIObserverService> observerService =
-        mozilla::services::GetObserverService();
-    EXPECT_TRUE(observerService);
-    observerService->AddObserver(this, "gmp-clear-storage-complete", false);
-    if (observerService) {
-      nsAutoString str;
-      if (mSince >= 0) {
-        str.AppendInt(static_cast<int64_t>(mSince));
-      }
-      observerService->NotifyObservers(
-          nullptr, "browser:purge-session-history", str.Data());
-    }
-    return NS_OK;
-  }
-
-  NS_IMETHOD Observe(nsISupports* aSubject,
-                     const char* aTopic,
-                     const char16_t* aSomeData) override
-  {
-    if (!strcmp(aTopic, "gmp-clear-storage-complete")) {
-      nsCOMPtr<nsIObserverService> observerService =
-          mozilla::services::GetObserverService();
-      EXPECT_TRUE(observerService);
-      observerService->RemoveObserver(this, "gmp-clear-storage-complete");
-      mTarget->Dispatch(mContinuation, NS_DISPATCH_NORMAL);
-    }
-    return NS_OK;
-  }
-
-private:
-  virtual ~ClearGMPStorageTask() {}
-  nsRefPtr<nsIRunnable> mContinuation;
-  nsCOMPtr<nsIThread> mTarget;
-  const PRTime mSince;
-};
-
-NS_IMPL_ISUPPORTS(ClearGMPStorageTask, nsIRunnable, nsIObserver)
-
-static void
-ClearGMPStorage(nsIRunnable* aContinuation,
-                nsIThread* aTarget, PRTime aSince = -1)
-{
-  nsRefPtr<ClearGMPStorageTask> task(
-      new ClearGMPStorageTask(aContinuation, aTarget, aSince));
-  NS_DispatchToMainThread(task, NS_DISPATCH_NORMAL);
-}
-
-static void
-SimulatePBModeExit()
-{
-  NS_DispatchToMainThread(new NotifyObserversTask("last-pb-context-exited"), NS_DISPATCH_SYNC);
-}
-
-static nsCString
-GetNodeId(const nsAString& aOrigin,
-          const nsAString& aTopLevelOrigin,
-          bool aInPBMode)
-{
-  nsRefPtr<GoannaMediaPluginService> service =
-    GoannaMediaPluginService::GetGoannaMediaPluginService();
-  EXPECT_TRUE(service);
-  nsCString nodeId;
-  nsresult rv = service->GetNodeId(aOrigin,
-                                   aTopLevelOrigin,
-                                   aInPBMode,
-                                   nodeId);
-  EXPECT_TRUE(NS_SUCCEEDED(rv));
-  return nodeId;
-}
-
-static bool
-IsGMPStorageIsEmpty()
-{
-  nsRefPtr<GoannaMediaPluginService> service =
-    GoannaMediaPluginService::GetGoannaMediaPluginService();
-  MOZ_ASSERT(service);
-  nsCOMPtr<nsIFile> storage;
-  nsresult rv = service->GetStorageDir(getter_AddRefs(storage));
-  EXPECT_TRUE(NS_SUCCEEDED(rv));
-  bool exists = false;
-  if (storage) {
-    storage->Exists(&exists);
-  }
-  return !exists;
-}
-
-static void
-AssertIsOnGMPThread()
-{
-  nsRefPtr<GoannaMediaPluginService> service =
-    GoannaMediaPluginService::GetGoannaMediaPluginService();
-  MOZ_ASSERT(service);
-  nsCOMPtr<nsIThread> thread;
-  service->GetThread(getter_AddRefs(thread));
-  MOZ_ASSERT(thread);
-  nsCOMPtr<nsIThread> currentThread;
-  DebugOnly<nsresult> rv = NS_GetCurrentThread(getter_AddRefs(currentThread));
-  MOZ_ASSERT(NS_SUCCEEDED(rv));
-  MOZ_ASSERT(currentThread == thread);
-}
-
-class GMPStorageTest : public GMPDecryptorProxyCallback
-{
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(GMPStorageTest)
-
-  void DoTest(void (GMPStorageTest::*aTestMethod)()) {
-    EnsureNSSInitializedChromeOrContent();
-    nsCOMPtr<nsIThread> thread(GetGMPThread());
-    ClearGMPStorage(NS_NewRunnableMethod(this, aTestMethod), thread);
-    AwaitFinished();
-  }
-
-  GMPStorageTest()
-    : mDecryptor(nullptr)
-    , mMonitor("GMPStorageTest")
-    , mFinished(false)
-  {
-  }
-
-  void
-  Update(const nsCString& aMessage)
-  {
-    nsTArray<uint8_t> msg;
-    msg.AppendElements(aMessage.get(), aMessage.Length());
-    mDecryptor->UpdateSession(1, NS_LITERAL_CSTRING("fake-session-id"), msg);
-  }
-
-  void TestGetNodeId()
-  {
-    AssertIsOnGMPThread();
-
-    EXPECT_TRUE(IsGMPStorageIsEmpty());
-
-    const nsString origin1 = NS_LITERAL_STRING("example1.com");
-    const nsString origin2 = NS_LITERAL_STRING("example2.org");
-
-    nsCString PBnodeId1 = GetNodeId(origin1, origin2, true);
-    nsCString PBnodeId2 = GetNodeId(origin1, origin2, true);
-
-    // Node ids for the same origins should be the same in PB mode.
-    EXPECT_TRUE(PBnodeId1.Equals(PBnodeId2));
-
-    nsCString PBnodeId3 = GetNodeId(origin2, origin1, true);
-
-    // Node ids with origin and top level origin swapped should be different.
-    EXPECT_TRUE(!PBnodeId3.Equals(PBnodeId1));
-
-    // Getting node ids in PB mode should not result in the node id being stored.
-    EXPECT_TRUE(IsGMPStorageIsEmpty());
-
-    nsCString nodeId1 = GetNodeId(origin1, origin2, false);
-    nsCString nodeId2 = GetNodeId(origin1, origin2, false);
-
-    // NodeIds for the same origin pair in non-pb mode should be the same.
-    EXPECT_TRUE(nodeId1.Equals(nodeId2));
-
-    // Node ids for a given origin pair should be different for the PB origins should be the same in PB mode.
-    EXPECT_TRUE(!PBnodeId1.Equals(nodeId1));
-    EXPECT_TRUE(!PBnodeId2.Equals(nodeId2));
-
-    nsCOMPtr<nsIThread> thread(GetGMPThread());
-    ClearGMPStorage(NS_NewRunnableMethodWithArg<nsCString>(
-      this, &GMPStorageTest::TestGetNodeId_Continuation, nodeId1), thread);
-  }
-
-  void TestGetNodeId_Continuation(nsCString aNodeId1) {
-    EXPECT_TRUE(IsGMPStorageIsEmpty());
-
-    // Once we clear storage, the node ids generated for the same origin-pair
-    // should be different.
-    const nsString origin1 = NS_LITERAL_STRING("example1.com");
-    const nsString origin2 = NS_LITERAL_STRING("example2.org");
-    nsCString nodeId3 = GetNodeId(origin1, origin2, false);
-    EXPECT_TRUE(!aNodeId1.Equals(nodeId3));
-
-    SetFinished();
-  }
-
-  void CreateDecryptor(const nsAString& aOrigin,
-                       const nsAString& aTopLevelOrigin,
-                       bool aInPBMode) {
-    nsRefPtr<GoannaMediaPluginService> service =
-      GoannaMediaPluginService::GetGoannaMediaPluginService();
-    EXPECT_TRUE(service);
-
-    mNodeId = GetNodeId(aOrigin, aTopLevelOrigin, aInPBMode);
-    EXPECT_TRUE(!mNodeId.IsEmpty());
-
-    nsTArray<nsCString> tags;
-    tags.AppendElement(NS_LITERAL_CSTRING("fake"));
-
-    nsresult rv = service->GetGMPDecryptor(&tags, mNodeId, &mDecryptor);
-    EXPECT_TRUE(NS_SUCCEEDED(rv));
-    EXPECT_TRUE(!!mDecryptor);
-
-    if (mDecryptor) {
-      mDecryptor->Init(this);
-    }
-  }
-
-  void TestBasicStorage() {
-    AssertIsOnGMPThread();
-    EXPECT_TRUE(IsGMPStorageIsEmpty());
-
-    nsRefPtr<GoannaMediaPluginService> service =
-      GoannaMediaPluginService::GetGoannaMediaPluginService();
-
-    CreateDecryptor(NS_LITERAL_STRING("example1.com"),
-                    NS_LITERAL_STRING("example2.com"),
-                    false);
-
-    // Send a message to the fake GMP for it to run its own tests internally.
-    // It sends us a "test-storage complete" message when its passed, or
-    // some other message if its tests fail.
-    Expect(NS_LITERAL_CSTRING("test-storage complete"),
-           NS_NewRunnableMethod(this, &GMPStorageTest::SetFinished));
-    Update(NS_LITERAL_CSTRING("test-storage"));
-  }
-
-  /**
-   * 1. Generate storage data for some sites.
-   * 2. Forget about one of the sites.
-   * 3. Check if the storage data for the forgotten site are erased correctly.
-   * 4. Check if the storage data for other sites remain unchanged.
-   */
-  void TestForgetThisSite() {
-    AssertIsOnGMPThread();
-    EXPECT_TRUE(IsGMPStorageIsEmpty());
-
-    // Generate storage data for some site.
-    CreateDecryptor(NS_LITERAL_STRING("example1.com"),
-                    NS_LITERAL_STRING("example2.com"),
-                    false);
-
-    nsCOMPtr<nsIRunnable> r = NS_NewRunnableMethod(
-        this, &GMPStorageTest::TestForgetThisSite_AnotherSite);
-    Expect(NS_LITERAL_CSTRING("test-storage complete"), r);
-    Update(NS_LITERAL_CSTRING("test-storage"));
-  }
-
-  void TestForgetThisSite_AnotherSite() {
-    Shutdown();
-
-    // Generate storage data for another site.
-    CreateDecryptor(NS_LITERAL_STRING("example3.com"),
-                    NS_LITERAL_STRING("example4.com"),
-                    false);
-
-    nsCOMPtr<nsIRunnable> r = NS_NewRunnableMethod(
-        this, &GMPStorageTest::TestForgetThisSite_CollectSiteInfo);
-    Expect(NS_LITERAL_CSTRING("test-storage complete"), r);
-    Update(NS_LITERAL_CSTRING("test-storage"));
-  }
-
-  struct NodeInfo {
-    explicit NodeInfo(const nsACString& aSite) : siteToForget(aSite) {}
-    nsCString siteToForget;
-    nsTArray<nsCString> expectedRemainingNodeIds;
-  };
-
-  class NodeIdCollector {
-  public:
-    explicit NodeIdCollector(NodeInfo* aInfo) : mNodeInfo(aInfo) {}
-    void operator()(nsIFile* aFile) {
-      nsCString salt;
-      nsresult rv = ReadSalt(aFile, salt);
-      ASSERT_TRUE(NS_SUCCEEDED(rv));
-      if (!MatchOrigin(aFile, mNodeInfo->siteToForget)) {
-        mNodeInfo->expectedRemainingNodeIds.AppendElement(salt);
-      }
-    }
-  private:
-    NodeInfo* mNodeInfo;
-  };
-
-  void TestForgetThisSite_CollectSiteInfo() {
-    nsAutoPtr<NodeInfo> siteInfo(
-        new NodeInfo(NS_LITERAL_CSTRING("example1.com")));
-    // Collect nodeIds that are expected to remain for later comparison.
-    EnumerateGMPStorageDir(NS_LITERAL_CSTRING("id"), NodeIdCollector(siteInfo));
-    // Invoke "Forget this site" on the main thread.
-    NS_DispatchToMainThread(NS_NewRunnableMethodWithArg<nsAutoPtr<NodeInfo>>(
-        this, &GMPStorageTest::TestForgetThisSite_Forget, siteInfo));
-  }
-
-  void TestForgetThisSite_Forget(nsAutoPtr<NodeInfo> aSiteInfo) {
-    nsRefPtr<GoannaMediaPluginService> service =
-        GoannaMediaPluginService::GetGoannaMediaPluginService();
-    service->ForgetThisSite(NS_ConvertUTF8toUTF16(aSiteInfo->siteToForget));
-
-    nsCOMPtr<nsIThread> thread;
-    service->GetThread(getter_AddRefs(thread));
-
-    nsCOMPtr<nsIRunnable> r = NS_NewRunnableMethodWithArg<nsAutoPtr<NodeInfo>>(
-        this, &GMPStorageTest::TestForgetThisSite_Verify, aSiteInfo);
-    thread->Dispatch(r, NS_DISPATCH_NORMAL);
-
-    nsCOMPtr<nsIRunnable> f = NS_NewRunnableMethod(
-        this, &GMPStorageTest::SetFinished);
-    thread->Dispatch(f, NS_DISPATCH_NORMAL);
-  }
-
-  class NodeIdVerifier {
-  public:
-    explicit NodeIdVerifier(const NodeInfo* aInfo)
-      : mNodeInfo(aInfo)
-      , mExpectedRemainingNodeIds(aInfo->expectedRemainingNodeIds) {}
-    void operator()(nsIFile* aFile) {
-      nsCString salt;
-      nsresult rv = ReadSalt(aFile, salt);
-      ASSERT_TRUE(NS_SUCCEEDED(rv));
-      // Shouldn't match the origin if we clear correctly.
-      EXPECT_FALSE(MatchOrigin(aFile, mNodeInfo->siteToForget));
-      // Check if remaining nodeIDs are as expected.
-      EXPECT_TRUE(mExpectedRemainingNodeIds.RemoveElement(salt));
-    }
-    ~NodeIdVerifier() {
-      EXPECT_TRUE(mExpectedRemainingNodeIds.IsEmpty());
-    }
-  private:
-    const NodeInfo* mNodeInfo;
-    nsTArray<nsCString> mExpectedRemainingNodeIds;
-  };
-
-  class StorageVerifier {
-  public:
-    explicit StorageVerifier(const NodeInfo* aInfo)
-      : mExpectedRemainingNodeIds(aInfo->expectedRemainingNodeIds) {}
-    void operator()(nsIFile* aFile) {
-      nsCString salt;
-      nsresult rv = aFile->GetNativeLeafName(salt);
-      ASSERT_TRUE(NS_SUCCEEDED(rv));
-      EXPECT_TRUE(mExpectedRemainingNodeIds.RemoveElement(salt));
-    }
-    ~StorageVerifier() {
-      EXPECT_TRUE(mExpectedRemainingNodeIds.IsEmpty());
-    }
-  private:
-    nsTArray<nsCString> mExpectedRemainingNodeIds;
-  };
-
-  void TestForgetThisSite_Verify(nsAutoPtr<NodeInfo> aSiteInfo) {
-    nsresult rv = EnumerateGMPStorageDir(
-        NS_LITERAL_CSTRING("id"), NodeIdVerifier(aSiteInfo));
-    EXPECT_TRUE(NS_SUCCEEDED(rv));
-
-    rv = EnumerateGMPStorageDir(
-        NS_LITERAL_CSTRING("storage"), StorageVerifier(aSiteInfo));
-    EXPECT_TRUE(NS_SUCCEEDED(rv));
-  }
-
-  /**
-   * 1. Generate some storage data.
-   * 2. Find the max mtime |t| in $profileDir/gmp/id/.
-   * 3. Pass |t| to clear recent history.
-   * 4. Check if all directories in $profileDir/gmp/id/ and
-   *    $profileDir/gmp/storage are removed.
-   */
-  void TestClearRecentHistory1() {
-    AssertIsOnGMPThread();
-    EXPECT_TRUE(IsGMPStorageIsEmpty());
-
-    // Generate storage data for some site.
-    CreateDecryptor(NS_LITERAL_STRING("example1.com"),
-                    NS_LITERAL_STRING("example2.com"),
-                    false);
-
-    nsCOMPtr<nsIRunnable> r = NS_NewRunnableMethod(
-        this, &GMPStorageTest::TestClearRecentHistory1_Clear);
-    Expect(NS_LITERAL_CSTRING("test-storage complete"), r);
-    Update(NS_LITERAL_CSTRING("test-storage"));
-
-  }
-
-  /**
-   * 1. Generate some storage data.
-   * 2. Find the max mtime |t| in $profileDir/gmp/storage/.
-   * 3. Pass |t| to clear recent history.
-   * 4. Check if all directories in $profileDir/gmp/id/ and
-   *    $profileDir/gmp/storage are removed.
-   */
-  void TestClearRecentHistory2() {
-    AssertIsOnGMPThread();
-    EXPECT_TRUE(IsGMPStorageIsEmpty());
-
-    // Generate storage data for some site.
-    CreateDecryptor(NS_LITERAL_STRING("example1.com"),
-                    NS_LITERAL_STRING("example2.com"),
-                    false);
-
-    nsCOMPtr<nsIRunnable> r = NS_NewRunnableMethod(
-        this, &GMPStorageTest::TestClearRecentHistory2_Clear);
-    Expect(NS_LITERAL_CSTRING("test-storage complete"), r);
-    Update(NS_LITERAL_CSTRING("test-storage"));
-
-  }
-
-  /**
-   * 1. Generate some storage data.
-   * 2. Find the max mtime |t| in $profileDir/gmp/storage/.
-   * 3. Pass |t+1| to clear recent history.
-   * 4. Check if all directories in $profileDir/gmp/id/ and
-   *    $profileDir/gmp/storage remain unchanged.
-   */
-  void TestClearRecentHistory3() {
-    AssertIsOnGMPThread();
-    EXPECT_TRUE(IsGMPStorageIsEmpty());
-
-    // Generate storage data for some site.
-    CreateDecryptor(NS_LITERAL_STRING("example1.com"),
-                    NS_LITERAL_STRING("example2.com"),
-                    false);
-
-    nsCOMPtr<nsIRunnable> r = NS_NewRunnableMethod(
-        this, &GMPStorageTest::TestClearRecentHistory3_Clear);
-    Expect(NS_LITERAL_CSTRING("test-storage complete"), r);
-    Update(NS_LITERAL_CSTRING("test-storage"));
-
-  }
-
-  class MaxMTimeFinder {
-  public:
-    MaxMTimeFinder() : mMaxTime(0) {}
-    void operator()(nsIFile* aFile) {
-      PRTime lastModified;
-      nsresult rv = aFile->GetLastModifiedTime(&lastModified);
-      if (NS_SUCCEEDED(rv) && lastModified > mMaxTime) {
-        mMaxTime = lastModified;
-      }
-      EnumerateDir(aFile, *this);
-    }
-    PRTime GetResult() const { return mMaxTime; }
-  private:
-    PRTime mMaxTime;
-  };
-
-  void TestClearRecentHistory1_Clear() {
-    MaxMTimeFinder f;
-    nsresult rv = EnumerateGMPStorageDir(NS_LITERAL_CSTRING("id"), f);
-    EXPECT_TRUE(NS_SUCCEEDED(rv));
-
-    nsCOMPtr<nsIRunnable> r = NS_NewRunnableMethod(
-        this, &GMPStorageTest::TestClearRecentHistory_CheckEmpty);
-    nsCOMPtr<nsIThread> t(GetGMPThread());
-    ClearGMPStorage(r, t, f.GetResult());
-  }
-
-  void TestClearRecentHistory2_Clear() {
-    MaxMTimeFinder f;
-    nsresult rv = EnumerateGMPStorageDir(NS_LITERAL_CSTRING("storage"), f);
-    EXPECT_TRUE(NS_SUCCEEDED(rv));
-
-    nsCOMPtr<nsIRunnable> r = NS_NewRunnableMethod(
-        this, &GMPStorageTest::TestClearRecentHistory_CheckEmpty);
-    nsCOMPtr<nsIThread> t(GetGMPThread());
-    ClearGMPStorage(r, t, f.GetResult());
-  }
-
-  void TestClearRecentHistory3_Clear() {
-    MaxMTimeFinder f;
-    nsresult rv = EnumerateGMPStorageDir(NS_LITERAL_CSTRING("storage"), f);
-    EXPECT_TRUE(NS_SUCCEEDED(rv));
-
-    nsCOMPtr<nsIRunnable> r = NS_NewRunnableMethod(
-        this, &GMPStorageTest::TestClearRecentHistory_CheckNonEmpty);
-    nsCOMPtr<nsIThread> t(GetGMPThread());
-    ClearGMPStorage(r, t, f.GetResult() + 1);
-  }
-
-  class FileCounter {
-  public:
-    FileCounter() : mCount(0) {}
-    void operator()(nsIFile* aFile) {
-      ++mCount;
-    }
-    int GetCount() const { return mCount; }
-  private:
-    int mCount;
-  };
-
-  void TestClearRecentHistory_CheckEmpty() {
-    FileCounter c1;
-    nsresult rv = EnumerateGMPStorageDir(NS_LITERAL_CSTRING("id"), c1);
-    EXPECT_TRUE(NS_SUCCEEDED(rv));
-    // There should be no files under $profileDir/gmp/id/
-    EXPECT_EQ(c1.GetCount(), 0);
-
-    FileCounter c2;
-    rv = EnumerateGMPStorageDir(NS_LITERAL_CSTRING("storage"), c2);
-    EXPECT_TRUE(NS_SUCCEEDED(rv));
-    // There should be no files under $profileDir/gmp/storage/
-    EXPECT_EQ(c2.GetCount(), 0);
-
-    SetFinished();
-  }
-
-  void TestClearRecentHistory_CheckNonEmpty() {
-    FileCounter c1;
-    nsresult rv = EnumerateGMPStorageDir(NS_LITERAL_CSTRING("id"), c1);
-    EXPECT_TRUE(NS_SUCCEEDED(rv));
-    // There should be one directory under $profileDir/gmp/id/
-    EXPECT_EQ(c1.GetCount(), 1);
-
-    FileCounter c2;
-    rv = EnumerateGMPStorageDir(NS_LITERAL_CSTRING("storage"), c2);
-    EXPECT_TRUE(NS_SUCCEEDED(rv));
-    // There should be one directory under $profileDir/gmp/storage/
-    EXPECT_EQ(c2.GetCount(), 1);
-
-    SetFinished();
-  }
-
-  void TestCrossOriginStorage() {
-    EXPECT_TRUE(!mDecryptor);
-
-    // Open decryptor on one, origin, write a record, and test that that
-    // record can't be read on another origin.
-    CreateDecryptor(NS_LITERAL_STRING("example3.com"),
-                    NS_LITERAL_STRING("example4.com"),
-                    false);
-
-    // Send the decryptor the message "store recordid $time"
-    // Wait for the decrytor to send us "stored recordid $time"
-    auto t = time(0);
-    nsCString response("stored crossOriginTestRecordId ");
-    response.AppendInt((int64_t)t);
-    Expect(response, NS_NewRunnableMethod(this,
-      &GMPStorageTest::TestCrossOriginStorage_RecordStoredContinuation));
-
-    nsCString update("store crossOriginTestRecordId ");
-    update.AppendInt((int64_t)t);
-    Update(update);
-  }
-
-  void TestCrossOriginStorage_RecordStoredContinuation() {
-    // Close the old decryptor, and create a new one on a different origin,
-    // and try to read the record.
-    Shutdown();
-
-    CreateDecryptor(NS_LITERAL_STRING("example5.com"),
-                    NS_LITERAL_STRING("example6.com"),
-                    false);
-
-    Expect(NS_LITERAL_CSTRING("retrieve crossOriginTestRecordId succeeded (length 0 bytes)"),
-           NS_NewRunnableMethod(this, &GMPStorageTest::SetFinished));
-    Update(NS_LITERAL_CSTRING("retrieve crossOriginTestRecordId"));
-  }
-
-  void TestPBStorage() {
-    // Open decryptor on one, origin, write a record, close decryptor,
-    // open another, and test that record can be read, close decryptor,
-    // then send pb-last-context-closed notification, then open decryptor
-    // and check that it can't read that data; it should have been purged.
-    CreateDecryptor(NS_LITERAL_STRING("pb1.com"),
-                    NS_LITERAL_STRING("pb2.com"),
-                    true);
-
-    // Send the decryptor the message "store recordid $time"
-    // Wait for the decrytor to send us "stored recordid $time"
-    nsCString response("stored pbdata test-pb-data");
-    Expect(response, NS_NewRunnableMethod(this,
-      &GMPStorageTest::TestPBStorage_RecordStoredContinuation));
-
-    nsCString update("store pbdata test-pb-data");
-    Update(update);
-  }
-
-  void TestPBStorage_RecordStoredContinuation() {
-    Shutdown();
-
-    CreateDecryptor(NS_LITERAL_STRING("pb1.com"),
-                    NS_LITERAL_STRING("pb2.com"),
-                    true);
-
-    Expect(NS_LITERAL_CSTRING("retrieve pbdata succeeded (length 12 bytes)"),
-           NS_NewRunnableMethod(this,
-              &GMPStorageTest::TestPBStorage_RecordRetrievedContinuation));
-    Update(NS_LITERAL_CSTRING("retrieve pbdata"));
-  }
-
-  void TestPBStorage_RecordRetrievedContinuation() {
-    Shutdown();
-    SimulatePBModeExit();
-
-    CreateDecryptor(NS_LITERAL_STRING("pb1.com"),
-                    NS_LITERAL_STRING("pb2.com"),
-                    true);
-
-    Expect(NS_LITERAL_CSTRING("retrieve pbdata succeeded (length 0 bytes)"),
-           NS_NewRunnableMethod(this,
-              &GMPStorageTest::SetFinished));
-    Update(NS_LITERAL_CSTRING("retrieve pbdata"));
-  }
-
-  void CreateAsyncShutdownTimeoutGMP(const nsAString& aOrigin1,
-                                     const nsAString& aOrigin2) {
-    CreateDecryptor(aOrigin1, aOrigin2, false);
-    Update(NS_LITERAL_CSTRING("shutdown-mode timeout"));
-    Shutdown();
-  }
-
-  void TestAsyncShutdownTimeout() {
-    // Create decryptors that timeout in their async shutdown.
-    // If the gtest hangs on shutdown, test fails!
-    CreateAsyncShutdownTimeoutGMP(NS_LITERAL_STRING("example7.com"),
-                                  NS_LITERAL_STRING("example8.com"));
-    CreateAsyncShutdownTimeoutGMP(NS_LITERAL_STRING("example9.com"),
-                                  NS_LITERAL_STRING("example10.com"));
-    CreateAsyncShutdownTimeoutGMP(NS_LITERAL_STRING("example11.com"),
-                                  NS_LITERAL_STRING("example12.com"));
-    SetFinished();
-  };
-
-  void TestAsyncShutdownStorage() {
-    // Test that a GMP can write to storage during shutdown, and retrieve
-    // that written data in a subsequent session.
-    CreateDecryptor(NS_LITERAL_STRING("example13.com"),
-                    NS_LITERAL_STRING("example14.com"),
-                    false);
-
-    // Instruct the GMP to write a token (the current timestamp, so it's
-    // unique) during async shutdown, then shutdown the plugin, re-create
-    // it, and check that the token was successfully stored.
-    auto t = time(0);
-    nsCString update("shutdown-mode token ");
-    nsCString token;
-    token.AppendInt((int64_t)t);
-    update.Append(token);
-
-    // Wait for a response from the GMP, so we know it's had time to receive
-    // the token.
-    nsCString response("shutdown-token received ");
-    response.Append(token);
-    Expect(response, NS_NewRunnableMethodWithArg<nsCString>(this,
-      &GMPStorageTest::TestAsyncShutdownStorage_ReceivedShutdownToken, token));
-
-    Update(update);
-  }
-
-  void TestAsyncShutdownStorage_ReceivedShutdownToken(const nsCString& aToken) {
-    ShutdownThen(NS_NewRunnableMethodWithArg<nsCString>(this,
-      &GMPStorageTest::TestAsyncShutdownStorage_AsyncShutdownComplete, aToken));
-  }
-
-  void TestAsyncShutdownStorage_AsyncShutdownComplete(const nsCString& aToken) {
-    // Create a new instance of the plugin, retrieve the token written
-    // during shutdown and verify it is correct.
-    CreateDecryptor(NS_LITERAL_STRING("example13.com"),
-                    NS_LITERAL_STRING("example14.com"),
-                    false);
-    nsCString response("retrieved shutdown-token ");
-    response.Append(aToken);
-    Expect(response,
-           NS_NewRunnableMethod(this, &GMPStorageTest::SetFinished));
-    Update(NS_LITERAL_CSTRING("retrieve-shutdown-token"));
-  }
-
-#if defined(XP_WIN)
-  void TestOutputProtection() {
-    Shutdown();
-
-    CreateDecryptor(NS_LITERAL_STRING("example15.com"),
-                    NS_LITERAL_STRING("example16.com"),
-                    false);
-
-    Expect(NS_LITERAL_CSTRING("OP tests completed"),
-           NS_NewRunnableMethod(this, &GMPStorageTest::SetFinished));
-    Update(NS_LITERAL_CSTRING("test-op-apis"));
-  }
-#endif
-
-  void TestPluginVoucher() {
-    CreateDecryptor(NS_LITERAL_STRING("example17.com"),
-                    NS_LITERAL_STRING("example18.com"),
-                    false);
-    Expect(NS_LITERAL_CSTRING("retrieved plugin-voucher: gmp-fake placeholder voucher"),
-           NS_NewRunnableMethod(this, &GMPStorageTest::SetFinished));
-    Update(NS_LITERAL_CSTRING("retrieve-plugin-voucher"));
-  }
-
-  void TestGetRecordNamesInMemoryStorage() {
-    TestGetRecordNames(true);
-  }
-
-  nsCString mRecordNames;
-
-  void AppendIntPadded(nsACString& aString, uint32_t aInt) {
-    if (aInt > 0 && aInt < 10) {
-      aString.AppendLiteral("0");
-    }
-    aString.AppendInt(aInt);
-  }
-
-  void TestGetRecordNames(bool aPrivateBrowsing) {
-    CreateDecryptor(NS_LITERAL_STRING("foo.com"),
-                    NS_LITERAL_STRING("bar.com"),
-                    aPrivateBrowsing);
-
-    // Create a number of records of different names.
-    const uint32_t num = 100;
-    for (uint32_t i = 0; i < num; i++) {
-      nsAutoCString response;
-      response.AppendLiteral("stored data");
-      AppendIntPadded(response, i);
-      response.AppendLiteral(" test-data");
-      AppendIntPadded(response, i);
-
-      if (i != 0) {
-        mRecordNames.AppendLiteral(",");
-      }
-      mRecordNames.AppendLiteral("data");
-      AppendIntPadded(mRecordNames, i);
-
-      nsAutoCString update;
-      update.AppendLiteral("store data");
-      AppendIntPadded(update, i);
-      update.AppendLiteral(" test-data");
-      AppendIntPadded(update, i);
-
-      nsIRunnable* continuation = nullptr;
-      if (i + 1 == num) {
-        continuation =
-          NS_NewRunnableMethod(this, &GMPStorageTest::TestGetRecordNames_QueryNames);
-      }
-      Expect(response, continuation);
-      Update(update);
-    }
-  }
-
-  void TestGetRecordNames_QueryNames() {
-    nsCString response("record-names ");
-    response.Append(mRecordNames);
-    Expect(response,
-           NS_NewRunnableMethod(this, &GMPStorageTest::SetFinished));
-    Update(NS_LITERAL_CSTRING("retrieve-record-names"));
-  }
-
-  void GetRecordNamesPersistentStorage() {
-    TestGetRecordNames(false);
-  }
-
-  void TestLongRecordNames() {
-    NS_NAMED_LITERAL_CSTRING(longRecordName,
-      "A_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "very_very_very_very_very_very_very_very_very_very_very_very_very_very_very_"
-      "long_record_name");
-
-    NS_NAMED_LITERAL_CSTRING(data, "Just_some_arbitrary_data.");
-
-    MOZ_ASSERT(longRecordName.Length() < GMP_MAX_RECORD_NAME_SIZE);
-    MOZ_ASSERT(longRecordName.Length() > 260); // Windows MAX_PATH
-
-    CreateDecryptor(NS_LITERAL_STRING("fuz.com"),
-                    NS_LITERAL_STRING("baz.com"),
-                    false);
-
-    nsCString response("stored ");
-    response.Append(longRecordName);
-    response.AppendLiteral(" ");
-    response.Append(data);
-    Expect(response, NS_NewRunnableMethod(this, &GMPStorageTest::SetFinished));
-
-    nsCString update("store ");
-    update.Append(longRecordName);
-    update.AppendLiteral(" ");
-    update.Append(data);
-    Update(update);
-  }
-
-  void Expect(const nsCString& aMessage, nsIRunnable* aContinuation) {
-    mExpected.AppendElement(ExpectedMessage(aMessage, aContinuation));
-  }
-
-  void AwaitFinished() {
-    while (!mFinished) {
-      NS_ProcessNextEvent(nullptr, true);
-    }
-    mFinished = false;
-  }
-
-  void ShutdownThen(nsIRunnable* aContinuation) {
-    EXPECT_TRUE(!!mDecryptor);
-    if (!mDecryptor) {
-      return;
-    }
-    EXPECT_FALSE(mNodeId.IsEmpty());
-    nsRefPtr<GMPShutdownObserver> task(
-      new GMPShutdownObserver(NS_NewRunnableMethod(this, &GMPStorageTest::Shutdown),
-                              aContinuation, mNodeId));
-    NS_DispatchToMainThread(task, NS_DISPATCH_NORMAL);
-  }
-
-  void Shutdown() {
-    if (mDecryptor) {
-      mDecryptor->Close();
-      mDecryptor = nullptr;
-      mNodeId = EmptyCString();
-    }
-  }
-
-  void Dummy() {
-  }
-
-  void SetFinished() {
-    mFinished = true;
-    Shutdown();
-    NS_DispatchToMainThread(NS_NewRunnableMethod(this, &GMPStorageTest::Dummy));
-  }
-
-  virtual void SessionMessage(const nsCString& aSessionId,
-                              GMPSessionMessageType aMessageType,
-                              const nsTArray<uint8_t>& aMessage) override
-  {
-    MonitorAutoLock mon(mMonitor);
-
-    nsCString msg((const char*)aMessage.Elements(), aMessage.Length());
-    EXPECT_TRUE(mExpected.Length() > 0);
-    bool matches = mExpected[0].mMessage.Equals(msg);
-    EXPECT_STREQ(mExpected[0].mMessage.get(), msg.get());
-    if (mExpected.Length() > 0 && matches) {
-      nsRefPtr<nsIRunnable> continuation = mExpected[0].mContinuation;
-      mExpected.RemoveElementAt(0);
-      if (continuation) {
-        NS_DispatchToCurrentThread(continuation);
-      }
-    }
-  }
-
-  virtual void SetSessionId(uint32_t aCreateSessionToken,
-                            const nsCString& aSessionId) override { }
-  virtual void ResolveLoadSessionPromise(uint32_t aPromiseId,
-                                         bool aSuccess) override {}
-  virtual void ResolvePromise(uint32_t aPromiseId) override {}
-  virtual void RejectPromise(uint32_t aPromiseId,
-                             nsresult aException,
-                             const nsCString& aSessionId) override { }
-  virtual void ExpirationChange(const nsCString& aSessionId,
-                                GMPTimestamp aExpiryTime) override {}
-  virtual void SessionClosed(const nsCString& aSessionId) override {}
-  virtual void SessionError(const nsCString& aSessionId,
-                            nsresult aException,
-                            uint32_t aSystemCode,
-                            const nsCString& aMessage) override {}
-  virtual void KeyStatusChanged(const nsCString& aSessionId,
-                                const nsTArray<uint8_t>& aKeyId,
-                                GMPMediaKeyStatus aStatus) override { }
-  virtual void SetCaps(uint64_t aCaps) override {}
-  virtual void Decrypted(uint32_t aId,
-                         GMPErr aResult,
-                         const nsTArray<uint8_t>& aDecryptedData) override { }
-  virtual void Terminated() override { }
-
-private:
-  ~GMPStorageTest() { }
-
-  struct ExpectedMessage {
-    ExpectedMessage(const nsCString& aMessage, nsIRunnable* aContinuation)
-      : mMessage(aMessage)
-      , mContinuation(aContinuation)
-    {}
-    nsCString mMessage;
-    nsRefPtr<nsIRunnable> mContinuation;
-  };
-
-  nsTArray<ExpectedMessage> mExpected;
-
-  GMPDecryptorProxy* mDecryptor;
-  Monitor mMonitor;
-  Atomic<bool> mFinished;
-  nsCString mNodeId;
-};
-
-void
-GMPTestRunner::DoTest(void (GMPTestRunner::*aTestMethod)())
-{
-  nsRefPtr<GoannaMediaPluginService> service =
-    GoannaMediaPluginService::GetGoannaMediaPluginService();
-  nsCOMPtr<nsIThread> thread;
-
-  service->GetThread(getter_AddRefs(thread));
-  thread->Dispatch(NS_NewRunnableMethod(this, aTestMethod), NS_DISPATCH_SYNC);
-}
-
-TEST(GoannaMediaPlugins, GMPTestCodec) {
-  nsRefPtr<GMPTestRunner> runner = new GMPTestRunner();
-  runner->DoTest(&GMPTestRunner::RunTestGMPTestCodec);
-}
-
-TEST(GoannaMediaPlugins, GMPCrossOrigin) {
-  nsRefPtr<GMPTestRunner> runner = new GMPTestRunner();
-  runner->DoTest(&GMPTestRunner::RunTestGMPCrossOrigin);
-}
-
-TEST(GoannaMediaPlugins, GMPStorageGetNodeId) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestGetNodeId);
-}
-
-TEST(GoannaMediaPlugins, GMPStorageBasic) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestBasicStorage);
-}
-
-TEST(GoannaMediaPlugins, GMPStorageForgetThisSite) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestForgetThisSite);
-}
-
-TEST(GoannaMediaPlugins, GMPStorageClearRecentHistory1) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestClearRecentHistory1);
-}
-
-TEST(GoannaMediaPlugins, GMPStorageClearRecentHistory2) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestClearRecentHistory2);
-}
-
-TEST(GoannaMediaPlugins, GMPStorageClearRecentHistory3) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestClearRecentHistory3);
-}
-
-TEST(GoannaMediaPlugins, GMPStorageCrossOrigin) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestCrossOriginStorage);
-}
-
-TEST(GoannaMediaPlugins, GMPStoragePrivateBrowsing) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestPBStorage);
-}
-
-TEST(GoannaMediaPlugins, GMPStorageAsyncShutdownTimeout) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestAsyncShutdownTimeout);
-}
-
-TEST(GoannaMediaPlugins, GMPStorageAsyncShutdownStorage) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestAsyncShutdownStorage);
-}
-
-TEST(GoannaMediaPlugins, GMPPluginVoucher) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestPluginVoucher);
-}
-
-#if defined(XP_WIN)
-TEST(GoannaMediaPlugins, GMPOutputProtection) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestOutputProtection);
-}
-#endif
-
-TEST(GoannaMediaPlugins, GMPStorageGetRecordNamesInMemoryStorage) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestGetRecordNamesInMemoryStorage);
-}
-
-TEST(GoannaMediaPlugins, GMPStorageGetRecordNamesPersistentStorage) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::GetRecordNamesPersistentStorage);
-}
-
-TEST(GoannaMediaPlugins, GMPStorageLongRecordNames) {
-  nsRefPtr<GMPStorageTest> runner = new GMPStorageTest();
-  runner->DoTest(&GMPStorageTest::TestLongRecordNames);
-}
diff --git a/dom/media/gtest/moz.build b/dom/media/gtest/moz.build
index 1497390..9d409e9 100644
--- a/dom/media/gtest/moz.build
+++ b/dom/media/gtest/moz.build
@@ -7,7 +7,6 @@
 SOURCES += [
     'MockMediaResource.cpp',
     'TestAudioCompactor.cpp',
-    'TestGMPCrossOrigin.cpp',
     'TestIntervalSet.cpp',
     'TestMediaPromise.cpp',
     'TestMP3Demuxer.cpp',
@@ -33,8 +32,6 @@ TEST_HARNESS_FILES.gtest += [
     'mediasource_test.mp4',
     'noise.mp3',
     'noise_vbr.mp3',
-    'small-shot-false-positive.mp3',
-    'small-shot.mp3',
     'test.webm',
 ]
 
@@ -44,7 +41,6 @@ LOCAL_INCLUDES += [
     '/dom/media',
     '/dom/media/encoder',
     '/dom/media/fmp4',
-    '/dom/media/gmp',
     '/security/certverifier',
     '/security/pkix/include',
 ]
diff --git a/dom/media/moz.build b/dom/media/moz.build
index 3be9bcd..be5dd18 100644
--- a/dom/media/moz.build
+++ b/dom/media/moz.build
@@ -6,9 +6,6 @@
 
 DIRS += [
     'encoder',
-    'gmp',
-    'gmp-plugin',
-    'gmp-plugin-openh264',
     'imagecapture',
     'mediasource',
     'ogg',
diff --git a/dom/media/platforms/PlatformDecoderModule.cpp b/dom/media/platforms/PlatformDecoderModule.cpp
index 07752cb..0b4eec4 100644
--- a/dom/media/platforms/PlatformDecoderModule.cpp
+++ b/dom/media/platforms/PlatformDecoderModule.cpp
@@ -21,6 +21,5 @@
 #ifdef MOZ_WIDGET_ANDROID
 #include "AndroidDecoderModule.h"
 #endif
-#include "GMPDecoderModule.h"
 
 #include "mozilla/Preferences.h"
@@ -46,7 +45,6 @@ bool PlatformDecoderModule::sGonkDecoderEnabled = false;
 bool PlatformDecoderModule::sAndroidMCDecoderEnabled = false;
 bool PlatformDecoderModule::sAndroidMCDecoderPreferred = false;
 #endif
-bool PlatformDecoderModule::sGMPDecoderEnabled = false;
 
 /* static */
 void
@@ -76,9 +74,6 @@ PlatformDecoderModule::Init()
                                "media.android-media-codec.preferred", false);
 #endif
 
-  Preferences::AddBoolVarCache(&sGMPDecoderEnabled,
-                               "media.gmp.decoder.enabled", false);
-
 #ifdef XP_WIN
   WMFDecoderModule::Init();
 #endif
@@ -143,10 +138,6 @@ PlatformDecoderModule::CreatePDM()
     return m.forget();
   }
 #endif
-  if (sGMPDecoderEnabled) {
-    nsRefPtr<PlatformDecoderModule> m(new GMPDecoderModule());
-    return m.forget();
-  }
   return nullptr;
 }
 
diff --git a/dom/media/platforms/PlatformDecoderModule.h b/dom/media/platforms/PlatformDecoderModule.h
index 69fdbee..8e28589 100644
--- a/dom/media/platforms/PlatformDecoderModule.h
+++ b/dom/media/platforms/PlatformDecoderModule.h
@@ -154,7 +154,6 @@ protected:
   static bool sAndroidMCDecoderPreferred;
   static bool sAndroidMCDecoderEnabled;
 #endif
-  static bool sGMPDecoderEnabled;
 };
 
 // A callback used by MediaDataDecoder to return output/errors to the
diff --git a/dom/media/platforms/agnostic/gmp/GMPAudioDecoder.cpp b/dom/media/platforms/agnostic/gmp/GMPAudioDecoder.cpp
deleted file mode 100644
index 357b20c..0000000
--- a/dom/media/platforms/agnostic/gmp/GMPAudioDecoder.cpp
+++ /dev/null
@@ -1,225 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:set ts=2 sw=2 sts=2 et cindent: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPAudioDecoder.h"
-#include "MediaInfo.h"
-
-namespace mozilla {
-
-#if defined(DEBUG)
-bool IsOnGMPThread()
-{
-  nsCOMPtr<mozIGoannaMediaPluginService> mps = do_GetService("@mozilla.org/goanna-media-plugin-service;1");
-  MOZ_ASSERT(mps);
-
-  nsCOMPtr<nsIThread> gmpThread;
-  nsresult rv = mps->GetThread(getter_AddRefs(gmpThread));
-  MOZ_ASSERT(NS_SUCCEEDED(rv) && gmpThread);
-  return NS_GetCurrentThread() == gmpThread;
-}
-#endif
-
-void
-AudioCallbackAdapter::Decoded(const nsTArray<int16_t>& aPCM, uint64_t aTimeStamp, uint32_t aChannels, uint32_t aRate)
-{
-  MOZ_ASSERT(IsOnGMPThread());
-
-  if (aRate == 0 || aChannels == 0) {
-    NS_WARNING("Invalid rate or num channels returned on GMP audio samples");
-    mCallback->Error();
-    return;
-  }
-
-  size_t numFrames = aPCM.Length() / aChannels;
-  MOZ_ASSERT((aPCM.Length() % aChannels) == 0);
-  nsAutoArrayPtr<AudioDataValue> audioData(new AudioDataValue[aPCM.Length()]);
-
-  for (size_t i = 0; i < aPCM.Length(); ++i) {
-    audioData[i] = AudioSampleToFloat(aPCM[i]);
-  }
-
-  if (mMustRecaptureAudioPosition) {
-    mAudioFrameSum = 0;
-    auto timestamp = UsecsToFrames(aTimeStamp, aRate);
-    if (!timestamp.isValid()) {
-      NS_WARNING("Invalid timestamp");
-      mCallback->Error();
-      return;
-    }
-    mAudioFrameOffset = timestamp.value();
-    MOZ_ASSERT(mAudioFrameOffset >= 0);
-    mMustRecaptureAudioPosition = false;
-  }
-
-  auto timestamp = FramesToUsecs(mAudioFrameOffset + mAudioFrameSum, aRate);
-  if (!timestamp.isValid()) {
-    NS_WARNING("Invalid timestamp on audio samples");
-    mCallback->Error();
-    return;
-  }
-  mAudioFrameSum += numFrames;
-
-  auto duration = FramesToUsecs(numFrames, aRate);
-  if (!duration.isValid()) {
-    NS_WARNING("Invalid duration on audio samples");
-    mCallback->Error();
-    return;
-  }
-
-  nsRefPtr<AudioData> audio(new AudioData(mLastStreamOffset,
-                                          timestamp.value(),
-                                          duration.value(),
-                                          numFrames,
-                                          audioData.forget(),
-                                          aChannels,
-                                          aRate));
-
-#ifdef LOG_SAMPLE_DECODE
-  LOG("Decoded audio sample! timestamp=%lld duration=%lld currentLength=%u",
-      timestamp, duration, currentLength);
-#endif
-
-  mCallback->Output(audio);
-}
-
-void
-AudioCallbackAdapter::InputDataExhausted()
-{
-  MOZ_ASSERT(IsOnGMPThread());
-  mCallback->InputExhausted();
-}
-
-void
-AudioCallbackAdapter::DrainComplete()
-{
-  MOZ_ASSERT(IsOnGMPThread());
-  mCallback->DrainComplete();
-}
-
-void
-AudioCallbackAdapter::ResetComplete()
-{
-  MOZ_ASSERT(IsOnGMPThread());
-  mMustRecaptureAudioPosition = true;
-  mCallback->FlushComplete();
-}
-
-void
-AudioCallbackAdapter::Error(GMPErr aErr)
-{
-  MOZ_ASSERT(IsOnGMPThread());
-  mCallback->Error();
-}
-
-void
-AudioCallbackAdapter::Terminated()
-{
-  NS_WARNING("AAC GMP decoder terminated.");
-  mCallback->Error();
-}
-
-void
-GMPAudioDecoder::InitTags(nsTArray<nsCString>& aTags)
-{
-  aTags.AppendElement(NS_LITERAL_CSTRING("aac"));
-}
-
-nsCString
-GMPAudioDecoder::GetNodeId()
-{
-  return NS_LITERAL_CSTRING("");
-}
-
-nsresult
-GMPAudioDecoder::Init()
-{
-  MOZ_ASSERT(IsOnGMPThread());
-
-  mMPS = do_GetService("@mozilla.org/goanna-media-plugin-service;1");
-  MOZ_ASSERT(mMPS);
-
-  nsTArray<nsCString> tags;
-  InitTags(tags);
-  nsresult rv = mMPS->GetGMPAudioDecoder(&tags, GetNodeId(), &mGMP);
-  NS_ENSURE_SUCCESS(rv, rv);
-  MOZ_ASSERT(mGMP);
-
-  nsTArray<uint8_t> codecSpecific;
-  codecSpecific.AppendElements(mConfig.mCodecSpecificConfig->Elements(),
-                               mConfig.mCodecSpecificConfig->Length());
-
-  rv = mGMP->InitDecode(kGMPAudioCodecAAC,
-                        mConfig.mChannels,
-                        mConfig.mBitDepth,
-                        mConfig.mRate,
-                        codecSpecific,
-                        mAdapter);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return NS_OK;
-}
-
-nsresult
-GMPAudioDecoder::Input(MediaRawData* aSample)
-{
-  MOZ_ASSERT(IsOnGMPThread());
-
-  nsRefPtr<MediaRawData> sample(aSample);
-  if (!mGMP) {
-    mCallback->Error();
-    return NS_ERROR_FAILURE;
-  }
-
-  mAdapter->SetLastStreamOffset(sample->mOffset);
-
-  gmp::GMPAudioSamplesImpl samples(sample, mConfig.mChannels, mConfig.mRate);
-  nsresult rv = mGMP->Decode(samples);
-  if (NS_FAILED(rv)) {
-    mCallback->Error();
-    return rv;
-  }
-
-  return NS_OK;
-}
-
-nsresult
-GMPAudioDecoder::Flush()
-{
-  MOZ_ASSERT(IsOnGMPThread());
-
-  if (!mGMP || NS_FAILED(mGMP->Reset())) {
-    // Abort the flush.
-    mCallback->FlushComplete();
-  }
-
-  return NS_OK;
-}
-
-nsresult
-GMPAudioDecoder::Drain()
-{
-  MOZ_ASSERT(IsOnGMPThread());
-
-  if (!mGMP || NS_FAILED(mGMP->Drain())) {
-    mCallback->DrainComplete();
-  }
-
-  return NS_OK;
-}
-
-nsresult
-GMPAudioDecoder::Shutdown()
-{
-  if (!mGMP) {
-    return NS_ERROR_FAILURE;
-  }
-  mGMP->Close();
-  mGMP = nullptr;
-
-  return NS_OK;
-}
-
-} // namespace mozilla
diff --git a/dom/media/platforms/agnostic/gmp/GMPAudioDecoder.h b/dom/media/platforms/agnostic/gmp/GMPAudioDecoder.h
deleted file mode 100644
index 446e4c7..0000000
--- a/dom/media/platforms/agnostic/gmp/GMPAudioDecoder.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:set ts=2 sw=2 sts=2 et cindent: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#if !defined(GMPAudioDecoder_h_)
-#define GMPAudioDecoder_h_
-
-#include "GMPAudioDecoderProxy.h"
-#include "MediaDataDecoderProxy.h"
-#include "PlatformDecoderModule.h"
-#include "mozIGoannaMediaPluginService.h"
-
-namespace mozilla {
-
-class AudioCallbackAdapter : public GMPAudioDecoderCallbackProxy {
-public:
-  explicit AudioCallbackAdapter(MediaDataDecoderCallbackProxy* aCallback)
-   : mCallback(aCallback)
-   , mLastStreamOffset(0)
-   , mAudioFrameSum(0)
-   , mAudioFrameOffset(0)
-   , mMustRecaptureAudioPosition(true)
-  {}
-
-  // GMPAudioDecoderCallbackProxy
-  virtual void Decoded(const nsTArray<int16_t>& aPCM, uint64_t aTimeStamp, uint32_t aChannels, uint32_t aRate) override;
-  virtual void InputDataExhausted() override;
-  virtual void DrainComplete() override;
-  virtual void ResetComplete() override;
-  virtual void Error(GMPErr aErr) override;
-  virtual void Terminated() override;
-
-  void SetLastStreamOffset(int64_t aStreamOffset) {
-    mLastStreamOffset = aStreamOffset;
-  }
-
-private:
-  MediaDataDecoderCallbackProxy* mCallback;
-  int64_t mLastStreamOffset;
-
-  int64_t mAudioFrameSum;
-  int64_t mAudioFrameOffset;
-  bool mMustRecaptureAudioPosition;
-};
-
-class GMPAudioDecoder : public MediaDataDecoder {
-protected:
-  GMPAudioDecoder(const AudioInfo& aConfig,
-                  MediaTaskQueue* aTaskQueue,
-                  MediaDataDecoderCallbackProxy* aCallback,
-                  AudioCallbackAdapter* aAdapter)
-   : mConfig(aConfig)
-   , mCallback(aCallback)
-   , mGMP(nullptr)
-   , mAdapter(aAdapter)
-  {
-  }
-
-public:
-  GMPAudioDecoder(const AudioInfo& aConfig,
-                  MediaTaskQueue* aTaskQueue,
-                  MediaDataDecoderCallbackProxy* aCallback)
-   : mConfig(aConfig)
-   , mCallback(aCallback)
-   , mGMP(nullptr)
-   , mAdapter(new AudioCallbackAdapter(aCallback))
-  {
-  }
-
-  virtual nsresult Init() override;
-  virtual nsresult Input(MediaRawData* aSample) override;
-  virtual nsresult Flush() override;
-  virtual nsresult Drain() override;
-  virtual nsresult Shutdown() override;
-
-protected:
-  virtual void InitTags(nsTArray<nsCString>& aTags);
-  virtual nsCString GetNodeId();
-
-private:
-  const AudioInfo& mConfig;
-  MediaDataDecoderCallbackProxy* mCallback;
-  nsCOMPtr<mozIGoannaMediaPluginService> mMPS;
-  GMPAudioDecoderProxy* mGMP;
-  nsAutoPtr<AudioCallbackAdapter> mAdapter;
-};
-
-} // namespace mozilla
-
-#endif // GMPAudioDecoder_h_
diff --git a/dom/media/platforms/agnostic/gmp/GMPDecoderModule.cpp b/dom/media/platforms/agnostic/gmp/GMPDecoderModule.cpp
deleted file mode 100644
index b70d847..0000000
--- a/dom/media/platforms/agnostic/gmp/GMPDecoderModule.cpp
+++ /dev/null
@@ -1,89 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:set ts=2 sw=2 sts=2 et cindent: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPDecoderModule.h"
-#include "GMPAudioDecoder.h"
-#include "GMPVideoDecoder.h"
-#include "MediaDataDecoderProxy.h"
-#include "mozIGoannaMediaPluginService.h"
-#include "nsServiceManagerUtils.h"
-
-namespace mozilla {
-
-GMPDecoderModule::GMPDecoderModule()
-{
-}
-
-GMPDecoderModule::~GMPDecoderModule()
-{
-}
-
-static already_AddRefed<MediaDataDecoderProxy>
-CreateDecoderWrapper(MediaDataDecoderCallback* aCallback)
-{
-  nsCOMPtr<mozIGoannaMediaPluginService> gmpService = do_GetService("@mozilla.org/goanna-media-plugin-service;1");
-  if (!gmpService) {
-    return nullptr;
-  }
-
-  nsCOMPtr<nsIThread> thread;
-  nsresult rv = gmpService->GetThread(getter_AddRefs(thread));
-  if (NS_FAILED(rv)) {
-    return nullptr;
-  }
-
-  nsRefPtr<MediaDataDecoderProxy> decoder(new MediaDataDecoderProxy(thread, aCallback));
-  return decoder.forget();
-}
-
-already_AddRefed<MediaDataDecoder>
-GMPDecoderModule::CreateVideoDecoder(const VideoInfo& aConfig,
-                                     layers::LayersBackend aLayersBackend,
-                                     layers::ImageContainer* aImageContainer,
-                                     FlushableMediaTaskQueue* aVideoTaskQueue,
-                                     MediaDataDecoderCallback* aCallback)
-{
-  if (!aConfig.mMimeType.EqualsLiteral("video/avc")) {
-    return nullptr;
-  }
-
-  nsRefPtr<MediaDataDecoderProxy> wrapper = CreateDecoderWrapper(aCallback);
-  wrapper->SetProxyTarget(new GMPVideoDecoder(aConfig,
-                                              aLayersBackend,
-                                              aImageContainer,
-                                              aVideoTaskQueue,
-                                              wrapper->Callback()));
-  return wrapper.forget();
-}
-
-already_AddRefed<MediaDataDecoder>
-GMPDecoderModule::CreateAudioDecoder(const AudioInfo& aConfig,
-                                     FlushableMediaTaskQueue* aAudioTaskQueue,
-                                     MediaDataDecoderCallback* aCallback)
-{
-  if (!aConfig.mMimeType.EqualsLiteral("audio/mp4a-latm")) {
-    return nullptr;
-  }
-
-  nsRefPtr<MediaDataDecoderProxy> wrapper = CreateDecoderWrapper(aCallback);
-  wrapper->SetProxyTarget(new GMPAudioDecoder(aConfig,
-                                              aAudioTaskQueue,
-                                              wrapper->Callback()));
-  return wrapper.forget();
-}
-
-PlatformDecoderModule::ConversionRequired
-GMPDecoderModule::DecoderNeedsConversion(const TrackInfo& aConfig) const
-{
-  // GMPVideoCodecType::kGMPVideoCodecH264 specifies that encoded frames must be in AVCC format.
-  if (aConfig.IsVideo()) {
-    return kNeedAVCC;
-  } else {
-    return kNeedNone;
-  }
-}
-
-} // namespace mozilla
diff --git a/dom/media/platforms/agnostic/gmp/GMPDecoderModule.h b/dom/media/platforms/agnostic/gmp/GMPDecoderModule.h
deleted file mode 100644
index 6a0fa80..0000000
--- a/dom/media/platforms/agnostic/gmp/GMPDecoderModule.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:set ts=2 sw=2 sts=2 et cindent: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#if !defined(GMPDecoderModule_h_)
-#define GMPDecoderModule_h_
-
-#include "PlatformDecoderModule.h"
-
-namespace mozilla {
-
-class GMPDecoderModule : public PlatformDecoderModule {
-public:
-  GMPDecoderModule();
-
-  virtual ~GMPDecoderModule();
-
-  // Decode thread.
-  virtual already_AddRefed<MediaDataDecoder>
-  CreateVideoDecoder(const VideoInfo& aConfig,
-                     layers::LayersBackend aLayersBackend,
-                     layers::ImageContainer* aImageContainer,
-                     FlushableMediaTaskQueue* aVideoTaskQueue,
-                     MediaDataDecoderCallback* aCallback) override;
-
-  // Decode thread.
-  virtual already_AddRefed<MediaDataDecoder>
-  CreateAudioDecoder(const AudioInfo& aConfig,
-                     FlushableMediaTaskQueue* aAudioTaskQueue,
-                     MediaDataDecoderCallback* aCallback) override;
-
-  virtual ConversionRequired
-  DecoderNeedsConversion(const TrackInfo& aConfig) const override;
-};
-
-} // namespace mozilla
-
-#endif // GMPDecoderModule_h_
diff --git a/dom/media/platforms/agnostic/gmp/GMPVideoDecoder.cpp b/dom/media/platforms/agnostic/gmp/GMPVideoDecoder.cpp
deleted file mode 100644
index e80f304..0000000
--- a/dom/media/platforms/agnostic/gmp/GMPVideoDecoder.cpp
+++ /dev/null
@@ -1,270 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:set ts=2 sw=2 sts=2 et cindent: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GMPVideoDecoder.h"
-#include "GMPVideoHost.h"
-#include "mozilla/Endian.h"
-#include "prsystem.h"
-#include "MediaData.h"
-
-namespace mozilla {
-
-#if defined(DEBUG)
-extern bool IsOnGMPThread();
-#endif
-
-void
-VideoCallbackAdapter::Decoded(GMPVideoi420Frame* aDecodedFrame)
-{
-  GMPUnique<GMPVideoi420Frame>::Ptr decodedFrame(aDecodedFrame);
-
-  MOZ_ASSERT(IsOnGMPThread());
-
-  VideoData::YCbCrBuffer b;
-  for (int i = 0; i < kGMPNumOfPlanes; ++i) {
-    b.mPlanes[i].mData = decodedFrame->Buffer(GMPPlaneType(i));
-    b.mPlanes[i].mStride = decodedFrame->Stride(GMPPlaneType(i));
-    if (i == kGMPYPlane) {
-      b.mPlanes[i].mWidth = decodedFrame->Width();
-      b.mPlanes[i].mHeight = decodedFrame->Height();
-    } else {
-      b.mPlanes[i].mWidth = (decodedFrame->Width() + 1) / 2;
-      b.mPlanes[i].mHeight = (decodedFrame->Height() + 1) / 2;
-    }
-    b.mPlanes[i].mOffset = 0;
-    b.mPlanes[i].mSkip = 0;
-  }
-
-  gfx::IntRect pictureRegion(0, 0, decodedFrame->Width(), decodedFrame->Height());
-  nsRefPtr<VideoData> v = VideoData::Create(mVideoInfo,
-                                            mImageContainer,
-                                            mLastStreamOffset,
-                                            decodedFrame->Timestamp(),
-                                            decodedFrame->Duration(),
-                                            b,
-                                            false,
-                                            -1,
-                                            pictureRegion);
-  if (v) {
-    mCallback->Output(v);
-  } else {
-    mCallback->Error();
-  }
-}
-
-void
-VideoCallbackAdapter::ReceivedDecodedReferenceFrame(const uint64_t aPictureId)
-{
-  MOZ_ASSERT(IsOnGMPThread());
-}
-
-void
-VideoCallbackAdapter::ReceivedDecodedFrame(const uint64_t aPictureId)
-{
-  MOZ_ASSERT(IsOnGMPThread());
-}
-
-void
-VideoCallbackAdapter::InputDataExhausted()
-{
-  MOZ_ASSERT(IsOnGMPThread());
-  mCallback->InputExhausted();
-}
-
-void
-VideoCallbackAdapter::DrainComplete()
-{
-  MOZ_ASSERT(IsOnGMPThread());
-  mCallback->DrainComplete();
-}
-
-void
-VideoCallbackAdapter::ResetComplete()
-{
-  MOZ_ASSERT(IsOnGMPThread());
-  mCallback->FlushComplete();
-}
-
-void
-VideoCallbackAdapter::Error(GMPErr aErr)
-{
-  MOZ_ASSERT(IsOnGMPThread());
-  mCallback->Error();
-}
-
-void
-VideoCallbackAdapter::Terminated()
-{
-  // Note that this *may* be called from the proxy thread also.
-  NS_WARNING("H.264 GMP decoder terminated.");
-  mCallback->Error();
-}
-
-void
-GMPVideoDecoder::InitTags(nsTArray<nsCString>& aTags)
-{
-  aTags.AppendElement(NS_LITERAL_CSTRING("h264"));
-}
-
-nsCString
-GMPVideoDecoder::GetNodeId()
-{
-  return NS_LITERAL_CSTRING("");
-}
-
-GMPUnique<GMPVideoEncodedFrame>::Ptr
-GMPVideoDecoder::CreateFrame(MediaRawData* aSample)
-{
-  GMPVideoFrame* ftmp = nullptr;
-  GMPErr err = mHost->CreateFrame(kGMPEncodedVideoFrame, &ftmp);
-  if (GMP_FAILED(err)) {
-    mCallback->Error();
-    return nullptr;
-  }
-
-  GMPUnique<GMPVideoEncodedFrame>::Ptr frame(static_cast<GMPVideoEncodedFrame*>(ftmp));
-  err = frame->CreateEmptyFrame(aSample->Size());
-  if (GMP_FAILED(err)) {
-    mCallback->Error();
-    return nullptr;
-  }
-
-  memcpy(frame->Buffer(), aSample->Data(), frame->Size());
-
-  // Convert 4-byte NAL unit lengths to host-endian 4-byte buffer lengths to
-  // suit the GMP API.
-  if (mConvertNALUnitLengths) {
-    const int kNALLengthSize = 4;
-    uint8_t* buf = frame->Buffer();
-    while (buf < frame->Buffer() + frame->Size() - kNALLengthSize) {
-      uint32_t length = BigEndian::readUint32(buf) + kNALLengthSize;
-      *reinterpret_cast<uint32_t *>(buf) = length;
-      buf += length;
-    }
-  }
-
-  frame->SetBufferType(GMP_BufferLength32);
-
-  frame->SetEncodedWidth(mConfig.mDisplay.width);
-  frame->SetEncodedHeight(mConfig.mDisplay.height);
-  frame->SetTimeStamp(aSample->mTime);
-  frame->SetCompleteFrame(true);
-  frame->SetDuration(aSample->mDuration);
-  frame->SetFrameType(aSample->mKeyframe ? kGMPKeyFrame : kGMPDeltaFrame);
-
-  return frame;
-}
-
-nsresult
-GMPVideoDecoder::Init()
-{
-  MOZ_ASSERT(IsOnGMPThread());
-
-  mMPS = do_GetService("@mozilla.org/goanna-media-plugin-service;1");
-  MOZ_ASSERT(mMPS);
-
-  nsTArray<nsCString> tags;
-  InitTags(tags);
-  nsresult rv = mMPS->GetGMPVideoDecoder(&tags, GetNodeId(), &mHost, &mGMP);
-  NS_ENSURE_SUCCESS(rv, rv);
-  MOZ_ASSERT(mHost && mGMP);
-
-  // GMP implementations have interpreted the meaning of GMP_BufferLength32
-  // differently.  The OpenH264 GMP expects GMP_BufferLength32 to behave as
-  // specified in the GMP API, where each buffer is prefixed by a 32-bit
-  // host-endian buffer length that includes the size of the buffer length
-  // field.  Other existing GMPs currently expect GMP_BufferLength32 (when
-  // combined with kGMPVideoCodecH264) to mean "like AVCC but restricted to
-  // 4-byte NAL lengths" (i.e. buffer lengths are specified in big-endian
-  // and do not include the length of the buffer length field.
-  mConvertNALUnitLengths = mGMP->GetDisplayName().EqualsLiteral("gmpopenh264");
-
-  GMPVideoCodec codec;
-  memset(&codec, 0, sizeof(codec));
-
-  codec.mGMPApiVersion = kGMPVersion33;
-
-  codec.mCodecType = kGMPVideoCodecH264;
-  codec.mWidth = mConfig.mDisplay.width;
-  codec.mHeight = mConfig.mDisplay.height;
-
-  nsTArray<uint8_t> codecSpecific;
-  codecSpecific.AppendElement(0); // mPacketizationMode.
-  codecSpecific.AppendElements(mConfig.mExtraData->Elements(),
-                               mConfig.mExtraData->Length());
-
-  rv = mGMP->InitDecode(codec,
-                        codecSpecific,
-                        mAdapter,
-                        PR_GetNumberOfProcessors());
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return NS_OK;
-}
-
-nsresult
-GMPVideoDecoder::Input(MediaRawData* aSample)
-{
-  MOZ_ASSERT(IsOnGMPThread());
-
-  nsRefPtr<MediaRawData> sample(aSample);
-  if (!mGMP) {
-    mCallback->Error();
-    return NS_ERROR_FAILURE;
-  }
-
-  mAdapter->SetLastStreamOffset(sample->mOffset);
-
-  GMPUnique<GMPVideoEncodedFrame>::Ptr frame = CreateFrame(sample);
-  nsTArray<uint8_t> info; // No codec specific per-frame info to pass.
-  nsresult rv = mGMP->Decode(Move(frame), false, info, 0);
-  if (NS_FAILED(rv)) {
-    mCallback->Error();
-    return rv;
-  }
-
-  return NS_OK;
-}
-
-nsresult
-GMPVideoDecoder::Flush()
-{
-  MOZ_ASSERT(IsOnGMPThread());
-
-  if (!mGMP || NS_FAILED(mGMP->Reset())) {
-    // Abort the flush.
-    mCallback->FlushComplete();
-  }
-
-  return NS_OK;
-}
-
-nsresult
-GMPVideoDecoder::Drain()
-{
-  MOZ_ASSERT(IsOnGMPThread());
-
-  if (!mGMP || NS_FAILED(mGMP->Drain())) {
-    mCallback->DrainComplete();
-  }
-
-  return NS_OK;
-}
-
-nsresult
-GMPVideoDecoder::Shutdown()
-{
-  // Note that this *may* be called from the proxy thread also.
-  if (!mGMP) {
-    return NS_ERROR_FAILURE;
-  }
-  mGMP->Close();
-  mGMP = nullptr;
-
-  return NS_OK;
-}
-
-} // namespace mozilla
diff --git a/dom/media/platforms/agnostic/gmp/GMPVideoDecoder.h b/dom/media/platforms/agnostic/gmp/GMPVideoDecoder.h
deleted file mode 100644
index c52a9e5..0000000
--- a/dom/media/platforms/agnostic/gmp/GMPVideoDecoder.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:set ts=2 sw=2 sts=2 et cindent: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#if !defined(GMPVideoDecoder_h_)
-#define GMPVideoDecoder_h_
-
-#include "GMPVideoDecoderProxy.h"
-#include "ImageContainer.h"
-#include "MediaDataDecoderProxy.h"
-#include "PlatformDecoderModule.h"
-#include "mozIGoannaMediaPluginService.h"
-#include "MediaInfo.h"
-
-namespace mozilla {
-
-class VideoCallbackAdapter : public GMPVideoDecoderCallbackProxy {
-public:
-  VideoCallbackAdapter(MediaDataDecoderCallbackProxy* aCallback,
-                       VideoInfo aVideoInfo,
-                       layers::ImageContainer* aImageContainer)
-   : mCallback(aCallback)
-   , mLastStreamOffset(0)
-   , mVideoInfo(aVideoInfo)
-   , mImageContainer(aImageContainer)
-  {}
-
-  // GMPVideoDecoderCallbackProxy
-  virtual void Decoded(GMPVideoi420Frame* aDecodedFrame) override;
-  virtual void ReceivedDecodedReferenceFrame(const uint64_t aPictureId) override;
-  virtual void ReceivedDecodedFrame(const uint64_t aPictureId) override;
-  virtual void InputDataExhausted() override;
-  virtual void DrainComplete() override;
-  virtual void ResetComplete() override;
-  virtual void Error(GMPErr aErr) override;
-  virtual void Terminated() override;
-
-  void SetLastStreamOffset(int64_t aStreamOffset) {
-    mLastStreamOffset = aStreamOffset;
-  }
-
-private:
-  MediaDataDecoderCallbackProxy* mCallback;
-  int64_t mLastStreamOffset;
-
-  VideoInfo mVideoInfo;
-  nsRefPtr<layers::ImageContainer> mImageContainer;
-};
-
-class GMPVideoDecoder : public MediaDataDecoder {
-protected:
-  GMPVideoDecoder(const VideoInfo& aConfig,
-                  layers::LayersBackend aLayersBackend,
-                  layers::ImageContainer* aImageContainer,
-                  MediaTaskQueue* aTaskQueue,
-                  MediaDataDecoderCallbackProxy* aCallback,
-                  VideoCallbackAdapter* aAdapter)
-   : mConfig(aConfig)
-   , mCallback(aCallback)
-   , mGMP(nullptr)
-   , mHost(nullptr)
-   , mAdapter(aAdapter)
-   , mConvertNALUnitLengths(false)
-  {
-  }
-
-public:
-  GMPVideoDecoder(const VideoInfo& aConfig,
-                  layers::LayersBackend aLayersBackend,
-                  layers::ImageContainer* aImageContainer,
-                  MediaTaskQueue* aTaskQueue,
-                  MediaDataDecoderCallbackProxy* aCallback)
-   : mConfig(aConfig)
-   , mCallback(aCallback)
-   , mGMP(nullptr)
-   , mHost(nullptr)
-   , mAdapter(new VideoCallbackAdapter(aCallback,
-                                       VideoInfo(aConfig.mDisplay.width,
-                                                 aConfig.mDisplay.height),
-                                       aImageContainer))
-   , mConvertNALUnitLengths(false)
-  {
-  }
-
-  virtual nsresult Init() override;
-  virtual nsresult Input(MediaRawData* aSample) override;
-  virtual nsresult Flush() override;
-  virtual nsresult Drain() override;
-  virtual nsresult Shutdown() override;
-
-protected:
-  virtual void InitTags(nsTArray<nsCString>& aTags);
-  virtual nsCString GetNodeId();
-  virtual GMPUnique<GMPVideoEncodedFrame>::Ptr CreateFrame(MediaRawData* aSample);
-
-private:
-  const VideoInfo& mConfig;
-  MediaDataDecoderCallbackProxy* mCallback;
-  nsCOMPtr<mozIGoannaMediaPluginService> mMPS;
-  GMPVideoDecoderProxy* mGMP;
-  GMPVideoHost* mHost;
-  nsAutoPtr<VideoCallbackAdapter> mAdapter;
-  bool mConvertNALUnitLengths;
-};
-
-} // namespace mozilla
-
-#endif // GMPVideoDecoder_h_
diff --git a/dom/media/platforms/agnostic/gmp/MediaDataDecoderProxy.cpp b/dom/media/platforms/agnostic/gmp/MediaDataDecoderProxy.cpp
deleted file mode 100644
index 9205173..0000000
--- a/dom/media/platforms/agnostic/gmp/MediaDataDecoderProxy.cpp
+++ /dev/null
@@ -1,101 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:set ts=2 sw=2 sts=2 et cindent: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "MediaDataDecoderProxy.h"
-#include "MediaData.h"
-
-namespace mozilla {
-
-void
-MediaDataDecoderCallbackProxy::Error()
-{
-  mProxyCallback->Error();
-}
-
-void
-MediaDataDecoderCallbackProxy::FlushComplete()
-{
-  mProxyDecoder->FlushComplete();
-}
-
-nsresult
-MediaDataDecoderProxy::Init()
-{
-  MOZ_ASSERT(!mIsShutdown);
-  nsRefPtr<InitTask> task(new InitTask(mProxyDecoder));
-  nsresult rv = mProxyThread->Dispatch(task, NS_DISPATCH_SYNC);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_SUCCESS(task->Result(), task->Result());
-
-  return NS_OK;
-}
-
-nsresult
-MediaDataDecoderProxy::Input(MediaRawData* aSample)
-{
-  MOZ_ASSERT(!IsOnProxyThread());
-  MOZ_ASSERT(!mIsShutdown);
-
-  nsRefPtr<nsIRunnable> task(new InputTask(mProxyDecoder, aSample));
-  nsresult rv = mProxyThread->Dispatch(task, NS_DISPATCH_NORMAL);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return NS_OK;
-}
-
-nsresult
-MediaDataDecoderProxy::Flush()
-{
-  MOZ_ASSERT(!IsOnProxyThread());
-  MOZ_ASSERT(!mIsShutdown);
-
-  mFlushComplete.Set(false);
-
-  nsRefPtr<nsIRunnable> task;
-  task = NS_NewRunnableMethod(mProxyDecoder, &MediaDataDecoder::Flush);
-  nsresult rv = mProxyThread->Dispatch(task, NS_DISPATCH_NORMAL);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  mFlushComplete.WaitUntil(true);
-
-  return NS_OK;
-}
-
-nsresult
-MediaDataDecoderProxy::Drain()
-{
-  MOZ_ASSERT(!IsOnProxyThread());
-  MOZ_ASSERT(!mIsShutdown);
-
-  nsRefPtr<nsIRunnable> task;
-  task = NS_NewRunnableMethod(mProxyDecoder, &MediaDataDecoder::Drain);
-  nsresult rv = mProxyThread->Dispatch(task, NS_DISPATCH_NORMAL);
-  NS_ENSURE_SUCCESS(rv, rv);
-  return NS_OK;
-}
-
-nsresult
-MediaDataDecoderProxy::Shutdown()
-{
-  // Note that this *may* be called from the proxy thread also.
-  MOZ_ASSERT(!mIsShutdown);
-#if defined(DEBUG)
-  mIsShutdown = true;
-#endif
-  nsRefPtr<nsIRunnable> task;
-  task = NS_NewRunnableMethod(mProxyDecoder, &MediaDataDecoder::Shutdown);
-  nsresult rv = mProxyThread->Dispatch(task, NS_DISPATCH_SYNC);
-  NS_ENSURE_SUCCESS(rv, rv);
-  return NS_OK;
-}
-
-void
-MediaDataDecoderProxy::FlushComplete()
-{
-  mFlushComplete.Set(true);
-}
-
-} // namespace mozilla
diff --git a/dom/media/platforms/agnostic/gmp/MediaDataDecoderProxy.h b/dom/media/platforms/agnostic/gmp/MediaDataDecoderProxy.h
deleted file mode 100644
index e6a2047..0000000
--- a/dom/media/platforms/agnostic/gmp/MediaDataDecoderProxy.h
+++ /dev/null
@@ -1,189 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:set ts=2 sw=2 sts=2 et cindent: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#if !defined(MediaDataDecoderProxy_h_)
-#define MediaDataDecoderProxy_h_
-
-#include "PlatformDecoderModule.h"
-#include "nsRefPtr.h"
-#include "nsThreadUtils.h"
-#include "nscore.h"
-
-namespace mozilla {
-
-class InputTask : public nsRunnable {
-public:
-  InputTask(MediaDataDecoder* aDecoder,
-            MediaRawData* aSample)
-   : mDecoder(aDecoder)
-   , mSample(aSample)
-  {}
-
-  NS_IMETHOD Run() {
-    mDecoder->Input(mSample);
-    return NS_OK;
-  }
-
-private:
-  nsRefPtr<MediaDataDecoder> mDecoder;
-  nsRefPtr<MediaRawData> mSample;
-};
-
-class InitTask : public nsRunnable {
-public:
-  explicit InitTask(MediaDataDecoder* aDecoder)
-   : mDecoder(aDecoder)
-   , mResultValid(false)
-  {}
-
-  NS_IMETHOD Run() {
-    mResult = mDecoder->Init();
-    mResultValid = true;
-    return NS_OK;
-  }
-
-  nsresult Result() {
-    MOZ_ASSERT(mResultValid);
-    return mResult;
-  }
-
-private:
-  MediaDataDecoder* mDecoder;
-  nsresult mResult;
-  bool mResultValid;
-};
-
-template<typename T>
-class Condition {
-public:
-  explicit Condition(T aValue)
-   : mMonitor("Condition")
-   , mCondition(aValue)
-  {}
-
-  void Set(T aValue) {
-    MonitorAutoLock mon(mMonitor);
-    mCondition = aValue;
-    mon.NotifyAll();
-  }
-
-  void WaitUntil(T aValue) {
-    MonitorAutoLock mon(mMonitor);
-    while (mCondition != aValue) {
-      mon.Wait();
-    }
-  }
-
-private:
-  Monitor mMonitor;
-  T mCondition;
-};
-
-class MediaDataDecoderProxy;
-
-class MediaDataDecoderCallbackProxy : public MediaDataDecoderCallback {
-public:
-  MediaDataDecoderCallbackProxy(MediaDataDecoderProxy* aProxyDecoder, MediaDataDecoderCallback* aCallback)
-   : mProxyDecoder(aProxyDecoder)
-   , mProxyCallback(aCallback)
-  {
-  }
-
-  virtual void Output(MediaData* aData) override {
-    mProxyCallback->Output(aData);
-  }
-
-  virtual void Error() override;
-
-  virtual void InputExhausted() override {
-    mProxyCallback->InputExhausted();
-  }
-
-  virtual void DrainComplete() override {
-    mProxyCallback->DrainComplete();
-  }
-
-  virtual void NotifyResourcesStatusChanged() override {
-    mProxyCallback->NotifyResourcesStatusChanged();
-  }
-
-  virtual void ReleaseMediaResources() override {
-    mProxyCallback->ReleaseMediaResources();
-  }
-
-  virtual void FlushComplete();
-
-private:
-  MediaDataDecoderProxy* mProxyDecoder;
-  MediaDataDecoderCallback* mProxyCallback;
-};
-
-class MediaDataDecoderProxy : public MediaDataDecoder {
-public:
-  MediaDataDecoderProxy(nsIThread* aProxyThread, MediaDataDecoderCallback* aCallback)
-   : mProxyThread(aProxyThread)
-   , mProxyCallback(this, aCallback)
-   , mFlushComplete(false)
-#if defined(DEBUG)
-   , mIsShutdown(false)
-#endif
-  {
-  }
-
-  // Ideally, this would return a regular MediaDataDecoderCallback pointer
-  // to retain the clean abstraction, but until MediaDataDecoderCallback
-  // supports the FlushComplete interface, this will have to do.  When MDDC
-  // supports FlushComplete, this, the GMP*Decoders, and the
-  // *CallbackAdapters can be reverted to accepting a regular
-  // MediaDataDecoderCallback pointer.
-  MediaDataDecoderCallbackProxy* Callback()
-  {
-    return &mProxyCallback;
-  }
-
-  void SetProxyTarget(MediaDataDecoder* aProxyDecoder)
-  {
-    MOZ_ASSERT(aProxyDecoder);
-    mProxyDecoder = aProxyDecoder;
-  }
-
-  // These are called from the decoder thread pool.
-  // Init and Shutdown run synchronously on the proxy thread, all others are
-  // asynchronously and responded to via the MediaDataDecoderCallback.
-  // Note: the nsresults returned by the proxied decoder are lost.
-  virtual nsresult Init() override;
-  virtual nsresult Input(MediaRawData* aSample) override;
-  virtual nsresult Flush() override;
-  virtual nsresult Drain() override;
-  virtual nsresult Shutdown() override;
-
-  // Called by MediaDataDecoderCallbackProxy.
-  void FlushComplete();
-
-private:
-#ifdef DEBUG
-  bool IsOnProxyThread() {
-    return NS_GetCurrentThread() == mProxyThread;
-  }
-#endif
-
-  friend class InputTask;
-  friend class InitTask;
-
-  nsRefPtr<MediaDataDecoder> mProxyDecoder;
-  nsCOMPtr<nsIThread> mProxyThread;
-
-  MediaDataDecoderCallbackProxy mProxyCallback;
-
-  Condition<bool> mFlushComplete;
-#if defined(DEBUG)
-  bool mIsShutdown;
-#endif
-};
-
-} // namespace mozilla
-
-#endif // MediaDataDecoderProxy_h_
diff --git a/dom/media/platforms/agnostic/gmp/moz.build b/dom/media/platforms/agnostic/gmp/moz.build
deleted file mode 100644
index 8678834..0000000
--- a/dom/media/platforms/agnostic/gmp/moz.build
+++ /dev/null
@@ -1,26 +0,0 @@
-# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-EXPORTS += [
-    'GMPAudioDecoder.h',
-    'GMPDecoderModule.h',
-    'GMPVideoDecoder.h',
-    'MediaDataDecoderProxy.h',
-]
-
-UNIFIED_SOURCES += [
-    'GMPAudioDecoder.cpp',
-    'GMPDecoderModule.cpp',
-    'GMPVideoDecoder.cpp',
-    'MediaDataDecoderProxy.cpp',
-]
-
-# GMPVideoEncodedFrameImpl.h needs IPC
-include('/ipc/chromium/chromium-config.mozbuild')
-
-FINAL_LIBRARY = 'xul'
-
-FAIL_ON_WARNINGS = True
diff --git a/dom/media/platforms/moz.build b/dom/media/platforms/moz.build
index 42c7249..103256f 100644
--- a/dom/media/platforms/moz.build
+++ b/dom/media/platforms/moz.build
@@ -17,8 +17,6 @@ UNIFIED_SOURCES += [
     'wrappers/H264Converter.cpp'
 ]
 
-DIRS += ['agnostic/gmp']
-
 if CONFIG['MOZ_WMF']:
     DIRS += [ 'wmf' ];
 
diff --git a/ipc/app/moz.build b/ipc/app/moz.build
index 0649569..ceeacab 100644
--- a/ipc/app/moz.build
+++ b/ipc/app/moz.build
@@ -33,13 +33,6 @@ LOCAL_INCLUDES += [
     '/xpcom/base',
 ]
 
-# We link GMPLoader into plugin-container on desktop so that its code is
-# covered by the desktop DRM vendor's voucher.
-if CONFIG['OS_TARGET'] != 'Android':
-    SOURCES += [
-        '../../dom/media/gmp/GMPLoader.cpp',
-    ]
-
 if CONFIG['MOZ_SANDBOX'] and CONFIG['OS_ARCH'] == 'WINNT':
     # For sandbox includes and the include dependencies those have
     LOCAL_INCLUDES += [
diff --git a/ipc/contentproc/plugin-container.cpp b/ipc/contentproc/plugin-container.cpp
index 7d4b15e..64965ca 100644
--- a/ipc/contentproc/plugin-container.cpp
+++ b/ipc/contentproc/plugin-container.cpp
@@ -22,8 +22,6 @@
 #include "nsSetDllDirectory.h"
 #endif
 
-#include "GMPLoader.h"
-
 #if defined(XP_WIN) && defined(MOZ_SANDBOX)
 #include "sandbox/chromium/base/basictypes.h"
 #include "sandbox/win/src/sandbox.h"
@@ -32,7 +30,7 @@
 #include "mozilla/sandboxing/loggingCallbacks.h"
 #endif
 
-#if defined(XP_LINUX) && defined(MOZ_GMP_SANDBOX)
+#if defined(XP_LINUX) && defined(MOZ_SANDBOX)
 #include "mozilla/Sandbox.h"
 #include "mozilla/SandboxInfo.h"
 #endif
@@ -61,6 +59,15 @@
 #include "ipc/Nuwa.h"
 #endif
 
+namespace mozilla {
+class SandboxStarter {
+public:
+  virtual ~SandboxStarter() {}
+  virtual void Start(const char* aLibPath) = 0;
+};
+
+} // namespace mozilla
+
 #ifdef MOZ_WIDGET_GONK
 static void
 InitializeBinder(void *aDummy) {
@@ -88,7 +95,7 @@ void StartSandboxCallback()
     }
 }
 
-class WinSandboxStarter : public mozilla::gmp::SandboxStarter {
+class WinSandboxStarter : public mozilla::SandboxStarter {
 public:
     virtual void Start(const char *aLibPath) override {
         StartSandboxCallback();
@@ -96,8 +103,8 @@ public:
 };
 #endif
 
-#if defined(XP_LINUX) && defined(MOZ_GMP_SANDBOX)
-class LinuxSandboxStarter : public mozilla::gmp::SandboxStarter {
+#if defined(XP_LINUX) && defined(MOZ_SANDBOX)
+class LinuxSandboxStarter : public mozilla::SandboxStarter {
     LinuxSandboxStarter() { }
 public:
     static SandboxStarter* Make() {
@@ -115,7 +122,7 @@ public:
 };
 #endif
 
-mozilla::gmp::SandboxStarter*
+mozilla::SandboxStarter*
 MakeSandboxStarter()
 {
     // Note: MacOSX creates its SandboxStarter inside xul code; it
@@ -124,7 +131,7 @@ MakeSandboxStarter()
     // SandboxStarter for it here.
 #if defined(XP_WIN) && defined(MOZ_SANDBOX)
     return new WinSandboxStarter();
-#elif defined(XP_LINUX) && defined(MOZ_GMP_SANDBOX)
+#elif defined(XP_LINUX) && defined(MOZ_SANDBOX)
     return LinuxSandboxStarter::Make();
 #else
     return nullptr;
@@ -172,11 +179,12 @@ content_process_main(int argc, char* argv[])
 #endif
 #endif
 
+    GoannaProcessType proctype = XRE_GetProcessType();
 #ifdef XP_WIN
     // For plugins, this is done in PluginProcessChild::Init, as we need to
     // avoid it for unsupported plugins.  See PluginProcessChild::Init for
     // the details.
-    if (XRE_GetProcessType() != GoannaProcessType_Plugin) {
+    if (proctype != GoannaProcessType_Plugin) {
         mozilla::SanitizeEnvironmentVariables();
         SetDllDirectory(L"");
     }
@@ -199,16 +207,8 @@ content_process_main(int argc, char* argv[])
     }
 #endif
 #endif
-    nsAutoPtr<mozilla::gmp::GMPLoader> loader;
-#if !defined(MOZ_WIDGET_ANDROID) && !defined(MOZ_WIDGET_GONK)
-    // On desktop, the GMPLoader lives in plugin-container, so that its
-    // code can be covered by an EME/GMP vendor's voucher.
-    nsAutoPtr<mozilla::gmp::SandboxStarter> starter(MakeSandboxStarter());
-    if (XRE_GetProcessType() == GoannaProcessType_GMPlugin) {
-        loader = mozilla::gmp::CreateGMPLoader(starter);
-    }
-#endif
-    nsresult rv = XRE_InitChildProcess(argc, argv, loader);
+
+    nsresult rv = XRE_InitChildProcess(argc, argv, proctype);
     NS_ENSURE_SUCCESS(rv, 1);
 
     return 0;
diff --git a/ipc/glue/GoannaChildProcessHost.cpp b/ipc/glue/GoannaChildProcessHost.cpp
index 0a2f950..49c9081 100644
--- a/ipc/glue/GoannaChildProcessHost.cpp
+++ b/ipc/glue/GoannaChildProcessHost.cpp
@@ -805,13 +805,6 @@ GoannaChildProcessHost::PerformAsyncLaunchInternal(std::vector<std::string>& aEx
       // cmdLine.AppendLooseValue(UTF8ToWide("-sandbox"));
       // shouldSandboxCurrentProcess = true;
       break;
-    case GoannaProcessType_GMPlugin:
-      if (!PR_GetEnv("MOZ_DISABLE_GMP_SANDBOX")) {
-        mSandboxBroker.SetSecurityLevelForGMPlugin();
-        cmdLine.AppendLooseValue(UTF8ToWide("-sandbox"));
-        shouldSandboxCurrentProcess = true;
-      }
-      break;
     case GoannaProcessType_Default:
     default:
       MOZ_CRASH("Bad process type in GoannaChildProcessHost");
diff --git a/layout/build/nsLayoutModule.cpp b/layout/build/nsLayoutModule.cpp
index 4f35cd7..2160b3f 100644
--- a/layout/build/nsLayoutModule.cpp
+++ b/layout/build/nsLayoutModule.cpp
@@ -229,8 +229,6 @@ static void Shutdown();
 #endif
 #include "MediaManager.h"
 
-#include "GMPService.h"
-
 #include "mozilla/dom/presentation/PresentationDeviceManager.h"
 
 #include "mozilla/TextInputProcessor.h"
@@ -248,7 +246,6 @@ using mozilla::dom::TCPServerSocketChild;
 using mozilla::dom::UDPSocketChild;
 using mozilla::dom::time::TimeService;
 using mozilla::net::StreamingProtocolControllerService;
-using mozilla::gmp::GoannaMediaPluginService;
 
 // Transformiix
 /* 5d5d92cd-6bf8-11d9-bf4a-000a95dc234c */
@@ -599,8 +596,6 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(TCPSocketParent)
 NS_GENERIC_FACTORY_CONSTRUCTOR(TCPServerSocketChild)
 NS_GENERIC_FACTORY_CONSTRUCTOR(UDPSocketChild)
 
-NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(GoannaMediaPluginService, GoannaMediaPluginService::GetGoannaMediaPluginService)
-
 #ifdef ACCESSIBILITY
 #include "nsAccessibilityService.h"
 
@@ -772,8 +767,6 @@ NS_DEFINE_NAMED_CID(NS_SYNTHVOICEREGISTRY_CID);
 NS_DEFINE_NAMED_CID(NS_ACCESSIBILITY_SERVICE_CID);
 #endif
 
-NS_DEFINE_NAMED_CID(GECKO_MEDIA_PLUGIN_SERVICE_CID);
-
 NS_DEFINE_NAMED_CID(PRESENTATION_DEVICE_MANAGER_CID);
 
 NS_DEFINE_NAMED_CID(TEXT_INPUT_PROCESSOR_CID);
@@ -1040,7 +1033,6 @@ static const mozilla::Module::CIDEntry kLayoutCIDs[] = {
   { &kTCPSOCKETPARENT_CID, false, nullptr, TCPSocketParentConstructor },
   { &kTCPSERVERSOCKETCHILD_CID, false, nullptr, TCPServerSocketChildConstructor },
   { &kUDPSOCKETCHILD_CID, false, nullptr, UDPSocketChildConstructor },
-  { &kGECKO_MEDIA_PLUGIN_SERVICE_CID, true, nullptr, GoannaMediaPluginServiceConstructor },
   { &kNS_TIMESERVICE_CID, false, nullptr, nsITimeServiceConstructor },
   { &kNS_MEDIASTREAMCONTROLLERSERVICE_CID, false, nullptr, nsIStreamingProtocolControllerServiceConstructor },
 #ifdef MOZ_WIDGET_GONK
@@ -1200,7 +1192,6 @@ static const mozilla::Module::ContractIDEntry kLayoutContracts[] = {
   { "@mozilla.org/accessibilityService;1", &kNS_ACCESSIBILITY_SERVICE_CID },
   { "@mozilla.org/accessibleRetrieval;1", &kNS_ACCESSIBILITY_SERVICE_CID },
 #endif
-  { "@mozilla.org/goanna-media-plugin-service;1",  &kGECKO_MEDIA_PLUGIN_SERVICE_CID },
   { PRESENTATION_DEVICE_MANAGER_CONTRACTID, &kPRESENTATION_DEVICE_MANAGER_CID },
   { "@mozilla.org/text-input-processor;1", &kTEXT_INPUT_PROCESSOR_CID },
   { nullptr }
diff --git a/media/gmp-clearkey/0.1/AnnexB.cpp b/media/gmp-clearkey/0.1/AnnexB.cpp
deleted file mode 100644
index a22d62a..0000000
--- a/media/gmp-clearkey/0.1/AnnexB.cpp
+++ /dev/null
@@ -1,65 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "AnnexB.h"
-#include "mozilla/Endian.h"
-
-using mozilla::BigEndian;
-
-static const uint8_t kAnnexBDelimiter[] = { 0, 0, 0, 1 };
-
-/* static */ void
-AnnexB::ConvertFrameInPlace(std::vector<uint8_t>& aBuffer)
-{
-  for (size_t i = 0; i < aBuffer.size() - 4 - sizeof(kAnnexBDelimiter) + 1; ) {
-    uint32_t nalLen = BigEndian::readUint32(&aBuffer[i]);
-    memcpy(&aBuffer[i], kAnnexBDelimiter, sizeof(kAnnexBDelimiter));
-    i += nalLen + 4;
-  }
-}
-
-static void
-ConvertParamSetToAnnexB(std::vector<uint8_t>::const_iterator& aIter,
-                        size_t aCount,
-                        std::vector<uint8_t>& aOutAnnexB)
-{
-  for (size_t i = 0; i < aCount; i++) {
-    aOutAnnexB.insert(aOutAnnexB.end(), kAnnexBDelimiter,
-                      kAnnexBDelimiter + sizeof(kAnnexBDelimiter));
-
-    uint16_t len = BigEndian::readUint16(&*aIter); aIter += 2;
-    aOutAnnexB.insert(aOutAnnexB.end(), aIter, aIter + len); aIter += len;
-  }
-}
-
-/* static */ void
-AnnexB::ConvertConfig(const std::vector<uint8_t>& aBuffer,
-                      std::vector<uint8_t>& aOutAnnexB)
-{
-  // Skip past irrelevant headers
-  auto it = aBuffer.begin() + 5;
-
-  if (it >= aBuffer.end()) {
-    return;
-  }
-
-  size_t count = *(it++) & 31;
-
-  // Check that we have enough bytes for the Annex B conversion
-  // and the next size field. Bail if not.
-  if (it + count * 2 >= aBuffer.end()) {
-    return;
-  }
-
-  ConvertParamSetToAnnexB(it, count, aOutAnnexB);
-
-  // Check that we have enough bytes for the Annex B conversion.
-  count = *(it++);
-  if (it + count * 2 > aBuffer.end()) {
-    aOutAnnexB.clear();
-    return;
-  }
-
-  ConvertParamSetToAnnexB(it, count, aOutAnnexB);
-}
diff --git a/media/gmp-clearkey/0.1/AnnexB.h b/media/gmp-clearkey/0.1/AnnexB.h
deleted file mode 100644
index 297df06..0000000
--- a/media/gmp-clearkey/0.1/AnnexB.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef __AnnexB_h__
-#define __AnnexB_h__
-
-#include <cstdint>
-#include <vector>
-
-class AnnexB
-{
-public:
-  static void ConvertFrameInPlace(std::vector<uint8_t>& aBuffer);
-
-  static void ConvertConfig(const std::vector<uint8_t>& aBuffer,
-                            std::vector<uint8_t>& aOutAnnexB);
-};
-
-#endif // __AnnexB_h__
diff --git a/media/gmp-clearkey/0.1/AudioDecoder.cpp b/media/gmp-clearkey/0.1/AudioDecoder.cpp
deleted file mode 100644
index 9d76334..0000000
--- a/media/gmp-clearkey/0.1/AudioDecoder.cpp
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
- * Copyright 2013, Mozilla Foundation and contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <cstdint>
-#include <limits>
-
-#include "AudioDecoder.h"
-#include "ClearKeyDecryptionManager.h"
-#include "ClearKeyUtils.h"
-#include "gmp-task-utils.h"
-
-using namespace wmf;
-
-AudioDecoder::AudioDecoder(GMPAudioHost *aHostAPI)
-  : mHostAPI(aHostAPI)
-  , mCallback(nullptr)
-  , mWorkerThread(nullptr)
-  , mMutex(nullptr)
-  , mNumInputTasks(0)
-  , mHasShutdown(false)
-{
-}
-
-AudioDecoder::~AudioDecoder()
-{
-  if (mMutex) {
-    mMutex->Destroy();
-  }
-}
-
-void
-AudioDecoder::InitDecode(const GMPAudioCodec& aConfig,
-                         GMPAudioDecoderCallback* aCallback)
-{
-  mCallback = aCallback;
-  assert(mCallback);
-  mDecoder = new WMFAACDecoder();
-  HRESULT hr = mDecoder->Init(aConfig.mChannelCount,
-                              aConfig.mSamplesPerSecond,
-                              (BYTE*)aConfig.mExtraData,
-                              aConfig.mExtraDataLen);
-  LOG("[%p] AudioDecoder::InitializeAudioDecoder() hr=0x%x\n", this, hr);
-  if (FAILED(hr)) {
-    mCallback->Error(GMPGenericErr);
-    return;
-  }
-  auto err = GetPlatform()->createmutex(&mMutex);
-  if (GMP_FAILED(err)) {
-    mCallback->Error(GMPGenericErr);
-    return;
-  }
-}
-
-void
-AudioDecoder::EnsureWorker()
-{
-  if (!mWorkerThread) {
-    GetPlatform()->createthread(&mWorkerThread);
-    if (!mWorkerThread) {
-      mCallback->Error(GMPAllocErr);
-      return;
-    }
-  }
-}
-
-void
-AudioDecoder::Decode(GMPAudioSamples* aInput)
-{
-  EnsureWorker();
-  {
-    AutoLock lock(mMutex);
-    mNumInputTasks++;
-  }
-  mWorkerThread->Post(WrapTask(this,
-                               &AudioDecoder::DecodeTask,
-                               aInput));
-}
-
-void
-AudioDecoder::DecodeTask(GMPAudioSamples* aInput)
-{
-  HRESULT hr;
-
-  {
-    AutoLock lock(mMutex);
-    mNumInputTasks--;
-    assert(mNumInputTasks >= 0);
-  }
-
-  if (!aInput || !mHostAPI || !mDecoder) {
-    LOG("Decode job not set up correctly!");
-    return;
-  }
-
-  const uint8_t* inBuffer = aInput->Buffer();
-  if (!inBuffer) {
-    LOG("No buffer for encoded samples!\n");
-    return;
-  }
-
-  const GMPEncryptedBufferMetadata* crypto = aInput->GetDecryptionData();
-  std::vector<uint8_t> buffer(inBuffer, inBuffer + aInput->Size());
-  if (crypto) {
-    // Plugin host should have set up its decryptor/key sessions
-    // before trying to decode!
-    GMPErr rv =
-      ClearKeyDecryptionManager::Get()->Decrypt(&buffer[0], buffer.size(), crypto);
-
-    if (GMP_FAILED(rv)) {
-      CK_LOGE("Failed to decrypt with key id %08x...", *(uint32_t*)crypto->KeyId());
-      MaybeRunOnMainThread(WrapTask(mCallback, &GMPAudioDecoderCallback::Error, rv));
-      return;
-    }
-  }
-
-  hr = mDecoder->Input(&buffer[0],
-                       buffer.size(),
-                       aInput->TimeStamp());
-
-  // We must delete the input sample!
-  GetPlatform()->runonmainthread(WrapTask(aInput, &GMPAudioSamples::Destroy));
-
-  SAMPLE_LOG("AudioDecoder::DecodeTask() Input ret hr=0x%x\n", hr);
-  if (FAILED(hr)) {
-    LOG("AudioDecoder::DecodeTask() decode failed ret=0x%x%s\n",
-        hr,
-        ((hr == MF_E_NOTACCEPTING) ? " (MF_E_NOTACCEPTING)" : ""));
-    return;
-  }
-
-  while (hr == S_OK) {
-    CComPtr<IMFSample> output;
-    hr = mDecoder->Output(&output);
-    SAMPLE_LOG("AudioDecoder::DecodeTask() output ret=0x%x\n", hr);
-    if (hr == S_OK) {
-      ReturnOutput(output);
-    }
-    if (hr == MF_E_TRANSFORM_NEED_MORE_INPUT) {
-      AutoLock lock(mMutex);
-      if (mNumInputTasks == 0) {
-        // We have run all input tasks. We *must* notify Goanna so that it will
-        // send us more data.
-        MaybeRunOnMainThread(WrapTask(mCallback, &GMPAudioDecoderCallback::InputDataExhausted));
-      }
-    } else if (FAILED(hr)) {
-      LOG("AudioDecoder::DecodeTask() output failed hr=0x%x\n", hr);
-    }
-  }
-}
-
-void
-AudioDecoder::ReturnOutput(IMFSample* aSample)
-{
-  SAMPLE_LOG("[%p] AudioDecoder::ReturnOutput()\n", this);
-  assert(aSample);
-
-  HRESULT hr;
-
-  GMPAudioSamples* samples = nullptr;
-  mHostAPI->CreateSamples(kGMPAudioIS16Samples, &samples);
-  if (!samples) {
-    LOG("Failed to create i420 frame!\n");
-    return;
-  }
-
-  hr = MFToGMPSample(aSample, samples);
-  if (FAILED(hr)) {
-    samples->Destroy();
-    LOG("Failed to prepare output sample!");
-    return;
-  }
-  ENSURE(SUCCEEDED(hr), /*void*/);
-
-  MaybeRunOnMainThread(WrapTask(mCallback, &GMPAudioDecoderCallback::Decoded, samples));
-}
-
-HRESULT
-AudioDecoder::MFToGMPSample(IMFSample* aInput,
-                            GMPAudioSamples* aOutput)
-{
-  ENSURE(aInput != nullptr, E_POINTER);
-  ENSURE(aOutput != nullptr, E_POINTER);
-
-  HRESULT hr;
-  CComPtr<IMFMediaBuffer> mediaBuffer;
-
-  hr = aInput->ConvertToContiguousBuffer(&mediaBuffer);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  BYTE* data = nullptr; // Note: *data will be owned by the IMFMediaBuffer, we don't need to free it.
-  DWORD maxLength = 0, currentLength = 0;
-  hr = mediaBuffer->Lock(&data, &maxLength, &currentLength);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  auto err = aOutput->SetBufferSize(currentLength);
-  ENSURE(GMP_SUCCEEDED(err), E_FAIL);
-
-  memcpy(aOutput->Buffer(), data, currentLength);
-
-  mediaBuffer->Unlock();
-
-  LONGLONG hns = 0;
-  hr = aInput->GetSampleTime(&hns);
-  ENSURE(SUCCEEDED(hr), hr);
-  aOutput->SetTimeStamp(HNsToUsecs(hns));
-  aOutput->SetChannels(mDecoder->Channels());
-  aOutput->SetRate(mDecoder->Rate());
-
-  return S_OK;
-}
-
-void
-AudioDecoder::Reset()
-{
-  if (mDecoder) {
-    mDecoder->Reset();
-  }
-  if (mCallback) {
-    mCallback->ResetComplete();
-  }
-}
-
-void
-AudioDecoder::DrainTask()
-{
-  mDecoder->Drain();
-
-  // Return any pending output.
-  HRESULT hr = S_OK;
-  while (hr == S_OK) {
-    CComPtr<IMFSample> output;
-    hr = mDecoder->Output(&output);
-    SAMPLE_LOG("AudioDecoder::DrainTask() output ret=0x%x\n", hr);
-    if (hr == S_OK) {
-      ReturnOutput(output);
-    }
-  }
-  MaybeRunOnMainThread(WrapTask(mCallback, &GMPAudioDecoderCallback::DrainComplete));
-}
-
-void
-AudioDecoder::Drain()
-{
-  if (!mDecoder) {
-    return;
-  }
-  EnsureWorker();
-  mWorkerThread->Post(WrapTask(this,
-                               &AudioDecoder::DrainTask));
-}
-
-void
-AudioDecoder::DecodingComplete()
-{
-  if (mWorkerThread) {
-    mWorkerThread->Join();
-  }
-  mHasShutdown = true;
-
-  // Worker thread might have dispatched more tasks to the main thread that need this object.
-  // Append another task to delete |this|.
-  GetPlatform()->runonmainthread(WrapTask(this, &AudioDecoder::Destroy));
-}
-
-void
-AudioDecoder::Destroy()
-{
-  delete this;
-}
-
-void
-AudioDecoder::MaybeRunOnMainThread(gmp_task_args_base* aTask)
-{
-  class MaybeRunTask : public GMPTask
-  {
-  public:
-    MaybeRunTask(AudioDecoder* aDecoder, gmp_task_args_base* aTask)
-      : mDecoder(aDecoder), mTask(aTask)
-    { }
-
-    virtual void Run(void) {
-      if (mDecoder->HasShutdown()) {
-        CK_LOGD("Trying to dispatch to main thread after AudioDecoder has shut down");
-        return;
-      }
-
-      mTask->Run();
-    }
-
-    virtual void Destroy()
-    {
-      mTask->Destroy();
-      delete this;
-    }
-
-  private:
-    AudioDecoder* mDecoder;
-    gmp_task_args_base* mTask;
-  };
-
-  GetPlatform()->runonmainthread(new MaybeRunTask(this, aTask));
-}
diff --git a/media/gmp-clearkey/0.1/AudioDecoder.h b/media/gmp-clearkey/0.1/AudioDecoder.h
deleted file mode 100644
index 4182d50..0000000
--- a/media/gmp-clearkey/0.1/AudioDecoder.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright 2013, Mozilla Foundation and contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef __AudioDecoder_h__
-#define __AudioDecoder_h__
-
-#include "gmp-audio-decode.h"
-#include "gmp-audio-host.h"
-#include "gmp-task-utils.h"
-#include "WMFAACDecoder.h"
-
-#include "mfobjects.h"
-
-class AudioDecoder : public GMPAudioDecoder
-{
-public:
-  AudioDecoder(GMPAudioHost *aHostAPI);
-
-  virtual ~AudioDecoder();
-
-  virtual void InitDecode(const GMPAudioCodec& aCodecSettings,
-                          GMPAudioDecoderCallback* aCallback) override;
-
-  virtual void Decode(GMPAudioSamples* aEncodedSamples);
-
-  virtual void Reset() override;
-
-  virtual void Drain() override;
-
-  virtual void DecodingComplete() override;
-
-  bool HasShutdown() { return mHasShutdown; }
-
-private:
-
-  void EnsureWorker();
-
-  void DecodeTask(GMPAudioSamples* aEncodedSamples);
-  void DrainTask();
-
-  void ReturnOutput(IMFSample* aSample);
-
-  HRESULT MFToGMPSample(IMFSample* aSample,
-                        GMPAudioSamples* aAudioFrame);
-
-  void MaybeRunOnMainThread(gmp_task_args_base* aTask);
-  void Destroy();
-
-  GMPAudioHost *mHostAPI; // host-owned, invalid at DecodingComplete
-  GMPAudioDecoderCallback* mCallback; // host-owned, invalid at DecodingComplete
-  GMPThread* mWorkerThread;
-  GMPMutex* mMutex;
-  wmf::AutoPtr<wmf::WMFAACDecoder> mDecoder;
-
-  int32_t mNumInputTasks;
-
-  bool mHasShutdown;
-};
-
-#endif // __AudioDecoder_h__
diff --git a/media/gmp-clearkey/0.1/ClearKeyBase64.cpp b/media/gmp-clearkey/0.1/ClearKeyBase64.cpp
deleted file mode 100644
index 1afa420..0000000
--- a/media/gmp-clearkey/0.1/ClearKeyBase64.cpp
+++ /dev/null
@@ -1,82 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
-* License, v. 2.0. If a copy of the MPL was not distributed with this
-* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "ClearKeyBase64.h"
-
-#include <algorithm>
-
-#include "mozilla/ArrayUtils.h"
-
-using namespace std;
-
-/**
-* Take a base64-encoded string, convert (in-place) each character to its
-* corresponding value in the [0x00, 0x3f] range, and truncate any padding.
-*/
-static bool
-Decode6Bit(string& aStr)
-{
-  for (size_t i = 0; i < aStr.length(); i++) {
-    if (aStr[i] >= 'A' && aStr[i] <= 'Z') {
-      aStr[i] -= 'A';
-    }
-    else if (aStr[i] >= 'a' && aStr[i] <= 'z') {
-      aStr[i] -= 'a' - 26;
-    }
-    else if (aStr[i] >= '0' && aStr[i] <= '9') {
-      aStr[i] -= '0' - 52;
-    }
-    else if (aStr[i] == '-' || aStr[i] == '+') {
-      aStr[i] = 62;
-    }
-    else if (aStr[i] == '_' || aStr[i] == '/') {
-      aStr[i] = 63;
-    }
-    else {
-      // Truncate '=' padding at the end of the aString.
-      if (aStr[i] != '=') {
-        aStr.erase(i, string::npos);
-        return false;
-      }
-      aStr[i] = '\0';
-      aStr.resize(i);
-      break;
-    }
-  }
-
-  return true;
-}
-
-bool
-DecodeBase64KeyOrId(const string& aEncoded, vector<uint8_t>& aOutDecoded)
-{
-  string encoded = aEncoded;
-  if (!Decode6Bit(encoded) ||
-    encoded.size() != 22) { // Can't decode to 16 byte CENC key or keyId.
-    return false;
-  }
-
-  // The number of bytes we haven't yet filled in the current byte, mod 8.
-  int shift = 0;
-
-  aOutDecoded.resize(16);
-  vector<uint8_t>::iterator out = aOutDecoded.begin();
-  for (size_t i = 0; i < encoded.length(); i++) {
-    if (!shift) {
-      *out = encoded[i] << 2;
-    }
-    else {
-      *out |= encoded[i] >> (6 - shift);
-      out++;
-      if (out == aOutDecoded.end()) {
-        // Hit last 6bit octed in encoded, which is padding and can be ignored.
-        break;
-      }
-      *out = encoded[i] << (shift + 2);
-    }
-    shift = (shift + 2) % 8;
-  }
-
-  return true;
-}
\ No newline at end of file
diff --git a/media/gmp-clearkey/0.1/ClearKeyBase64.h b/media/gmp-clearkey/0.1/ClearKeyBase64.h
deleted file mode 100644
index 3e86d55..0000000
--- a/media/gmp-clearkey/0.1/ClearKeyBase64.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
-* License, v. 2.0. If a copy of the MPL was not distributed with this
-* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef __ClearKeyBase64_h__
-#define __ClearKeyBase64_h__
-
-#include <vector>
-#include <string>
-#include <stdint.h>
-
-// Decodes a base64 encoded CENC Key or KeyId into it's raw bytes. Note that
-// CENC Keys or KeyIds are 16 bytes long, so encoded they should be 22 bytes
-// plus any padding. Fails (returns false) on input that is more than 22 bytes
-// long after padding is stripped. Returns true on success.
-bool
-DecodeBase64KeyOrId(const std::string& aEncoded, std::vector<uint8_t>& aOutDecoded);
-
-#endif
diff --git a/media/gmp-clearkey/0.1/ClearKeyDecryptionManager.cpp b/media/gmp-clearkey/0.1/ClearKeyDecryptionManager.cpp
deleted file mode 100644
index 76c0305..0000000
--- a/media/gmp-clearkey/0.1/ClearKeyDecryptionManager.cpp
+++ /dev/null
@@ -1,210 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include <string.h>
-#include <vector>
-
-#include "ClearKeyDecryptionManager.h"
-#include "gmp-decryption.h"
-#include "mozilla/Assertions.h"
-#include "mozilla/Attributes.h"
-
-class ClearKeyDecryptor : public RefCounted
-{
-public:
-  MOZ_IMPLICIT ClearKeyDecryptor();
-
-  void InitKey(const Key& aKey);
-  bool HasKey() const { return !!mKey.size(); }
-
-  GMPErr Decrypt(uint8_t* aBuffer, uint32_t aBufferSize,
-                 const GMPEncryptedBufferMetadata* aMetadata);
-
-  const Key& DecryptionKey() const { return mKey; }
-
-private:
-  ~ClearKeyDecryptor();
-
-  Key mKey;
-};
-
-
-/* static */ ClearKeyDecryptionManager* ClearKeyDecryptionManager::sInstance = nullptr;
-
-/* static */ ClearKeyDecryptionManager*
-ClearKeyDecryptionManager::Get()
-{
-  if (!sInstance) {
-    sInstance = new ClearKeyDecryptionManager();
-  }
-  return sInstance;
-}
-
-ClearKeyDecryptionManager::ClearKeyDecryptionManager()
-{
-  CK_LOGD("ClearKeyDecryptionManager::ClearKeyDecryptionManager");
-}
-
-ClearKeyDecryptionManager::~ClearKeyDecryptionManager()
-{
-  CK_LOGD("ClearKeyDecryptionManager::~ClearKeyDecryptionManager");
-
-  sInstance = nullptr;
-
-  for (auto it = mDecryptors.begin(); it != mDecryptors.end(); it++) {
-    it->second->Release();
-  }
-  mDecryptors.clear();
-}
-
-bool
-ClearKeyDecryptionManager::HasSeenKeyId(const KeyId& aKeyId) const
-{
-  CK_LOGD("ClearKeyDecryptionManager::SeenKeyId %s", mDecryptors.find(aKeyId) != mDecryptors.end() ? "t" : "f");
-  return mDecryptors.find(aKeyId) != mDecryptors.end();
-}
-
-bool
-ClearKeyDecryptionManager::IsExpectingKeyForKeyId(const KeyId& aKeyId) const
-{
-  CK_LOGD("ClearKeyDecryptionManager::IsExpectingKeyForId %08x...", *(uint32_t*)&aKeyId[0]);
-  const auto& decryptor = mDecryptors.find(aKeyId);
-  return decryptor != mDecryptors.end() && !decryptor->second->HasKey();
-}
-
-bool
-ClearKeyDecryptionManager::HasKeyForKeyId(const KeyId& aKeyId) const
-{
-  CK_LOGD("ClearKeyDecryptionManager::HasKeyForKeyId");
-  const auto& decryptor = mDecryptors.find(aKeyId);
-  return decryptor != mDecryptors.end() && decryptor->second->HasKey();
-}
-
-const Key&
-ClearKeyDecryptionManager::GetDecryptionKey(const KeyId& aKeyId)
-{
-  MOZ_ASSERT(HasKeyForKeyId(aKeyId));
-  return mDecryptors[aKeyId]->DecryptionKey();
-}
-
-void
-ClearKeyDecryptionManager::InitKey(KeyId aKeyId, Key aKey)
-{
-  CK_LOGD("ClearKeyDecryptionManager::InitKey %08x...", *(uint32_t*)&aKeyId[0]);
-  if (IsExpectingKeyForKeyId(aKeyId)) {
-    mDecryptors[aKeyId]->InitKey(aKey);
-  }
-}
-
-void
-ClearKeyDecryptionManager::ExpectKeyId(KeyId aKeyId)
-{
-  CK_LOGD("ClearKeyDecryptionManager::ExpectKeyId %08x...", *(uint32_t*)&aKeyId[0]);
-  if (!HasSeenKeyId(aKeyId)) {
-    mDecryptors[aKeyId] = new ClearKeyDecryptor();
-  }
-  mDecryptors[aKeyId]->AddRef();
-}
-
-void
-ClearKeyDecryptionManager::ReleaseKeyId(KeyId aKeyId)
-{
-  CK_LOGD("ClearKeyDecryptionManager::ReleaseKeyId");
-  MOZ_ASSERT(HasKeyForKeyId(aKeyId));
-
-  ClearKeyDecryptor* decryptor = mDecryptors[aKeyId];
-  if (!decryptor->Release()) {
-    mDecryptors.erase(aKeyId);
-  }
-}
-
-GMPErr
-ClearKeyDecryptionManager::Decrypt(uint8_t* aBuffer, uint32_t aBufferSize,
-                                   const GMPEncryptedBufferMetadata* aMetadata)
-{
-  CK_LOGD("ClearKeyDecryptionManager::Decrypt");
-  KeyId keyId(aMetadata->KeyId(), aMetadata->KeyId() + aMetadata->KeyIdSize());
-
-  if (!HasKeyForKeyId(keyId)) {
-    return GMPNoKeyErr;
-  }
-
-  return mDecryptors[keyId]->Decrypt(aBuffer, aBufferSize, aMetadata);
-}
-
-ClearKeyDecryptor::ClearKeyDecryptor()
-{
-  CK_LOGD("ClearKeyDecryptor ctor");
-}
-
-ClearKeyDecryptor::~ClearKeyDecryptor()
-{
-  CK_LOGD("ClearKeyDecryptor dtor; key = %08x...", *(uint32_t*)&mKey[0]);
-}
-
-void
-ClearKeyDecryptor::InitKey(const Key& aKey)
-{
-  mKey = aKey;
-}
-
-GMPErr
-ClearKeyDecryptor::Decrypt(uint8_t* aBuffer, uint32_t aBufferSize,
-                           const GMPEncryptedBufferMetadata* aMetadata)
-{
-  CK_LOGD("ClearKeyDecryptor::Decrypt");
-  // If the sample is split up into multiple encrypted subsamples, we need to
-  // stitch them into one continuous buffer for decryption.
-  std::vector<uint8_t> tmp(aBufferSize);
-
-  if (aMetadata->NumSubsamples()) {
-    // Take all encrypted parts of subsamples and stitch them into one
-    // continuous encrypted buffer.
-    unsigned char* data = aBuffer;
-    unsigned char* iter = &tmp[0];
-    for (size_t i = 0; i < aMetadata->NumSubsamples(); i++) {
-      data += aMetadata->ClearBytes()[i];
-      uint32_t cipherBytes = aMetadata->CipherBytes()[i];
-      if (data + cipherBytes > aBuffer + aBufferSize) {
-        // Trying to read past the end of the buffer!
-        return GMPCryptoErr;
-      }
-
-      memcpy(iter, data, cipherBytes);
-
-      data += cipherBytes;
-      iter += cipherBytes;
-    }
-
-    tmp.resize((size_t)(iter - &tmp[0]));
-  } else {
-    memcpy(&tmp[0], aBuffer, aBufferSize);
-  }
-
-  MOZ_ASSERT(aMetadata->IVSize() == 8 || aMetadata->IVSize() == 16);
-  std::vector<uint8_t> iv(aMetadata->IV(), aMetadata->IV() + aMetadata->IVSize());
-  iv.insert(iv.end(), CLEARKEY_KEY_LEN - aMetadata->IVSize(), 0);
-
-  ClearKeyUtils::DecryptAES(mKey, tmp, iv);
-
-  if (aMetadata->NumSubsamples()) {
-    // Take the decrypted buffer, split up into subsamples, and insert those
-    // subsamples back into their original position in the original buffer.
-    unsigned char* data = aBuffer;
-    unsigned char* iter = &tmp[0];
-    for (size_t i = 0; i < aMetadata->NumSubsamples(); i++) {
-      data += aMetadata->ClearBytes()[i];
-      uint32_t cipherBytes = aMetadata->CipherBytes()[i];
-
-      memcpy(data, iter, cipherBytes);
-
-      data += cipherBytes;
-      iter += cipherBytes;
-    }
-  } else {
-    memcpy(aBuffer, &tmp[0], aBufferSize);
-  }
-
-  return GMPNoErr;
-}
diff --git a/media/gmp-clearkey/0.1/ClearKeyDecryptionManager.h b/media/gmp-clearkey/0.1/ClearKeyDecryptionManager.h
deleted file mode 100644
index 3fb2153..0000000
--- a/media/gmp-clearkey/0.1/ClearKeyDecryptionManager.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef __ClearKeyDecryptionManager_h__
-#define __ClearKeyDecryptionManager_h__
-
-#include <map>
-
-#include "ClearKeyUtils.h"
-#include "RefCounted.h"
-
-class ClearKeyDecryptor;
-
-class ClearKeyDecryptionManager : public RefCounted
-{
-private:
-  ClearKeyDecryptionManager();
-  ~ClearKeyDecryptionManager();
-
-  static ClearKeyDecryptionManager* sInstance;
-
-public:
-  static ClearKeyDecryptionManager* Get();
-
-  bool HasSeenKeyId(const KeyId& aKeyId) const;
-  bool HasKeyForKeyId(const KeyId& aKeyId) const;
-
-  const Key& GetDecryptionKey(const KeyId& aKeyId);
-
-  // Create a decryptor for the given KeyId if one does not already exist.
-  void InitKey(KeyId aKeyId, Key aKey);
-  void ExpectKeyId(KeyId aKeyId);
-  void ReleaseKeyId(KeyId aKeyId);
-
-  GMPErr Decrypt(uint8_t* aBuffer, uint32_t aBufferSize,
-                 const GMPEncryptedBufferMetadata* aMetadata);
-
-  void Shutdown();
-
-private:
-  bool IsExpectingKeyForKeyId(const KeyId& aKeyId) const;
-
-  std::map<KeyId, ClearKeyDecryptor*> mDecryptors;
-};
-
-#endif // __ClearKeyDecryptionManager_h__
diff --git a/media/gmp-clearkey/0.1/ClearKeyPersistence.cpp b/media/gmp-clearkey/0.1/ClearKeyPersistence.cpp
deleted file mode 100644
index 77741dc..0000000
--- a/media/gmp-clearkey/0.1/ClearKeyPersistence.cpp
+++ /dev/null
@@ -1,243 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "ClearKeyPersistence.h"
-#include "ClearKeyUtils.h"
-#include "ClearKeyStorage.h"
-#include "ClearKeySessionManager.h"
-#include "mozilla/RefPtr.h"
-
-#include <stdint.h>
-#include <string.h>
-#include <set>
-#include <vector>
-#include <sstream>
-
-using namespace mozilla;
-using namespace std;
-
-// Whether we've loaded the persistent session ids from GMPStorage yet.
-enum PersistentKeyState {
-  UNINITIALIZED,
-  LOADING,
-  LOADED
-};
-static PersistentKeyState sPersistentKeyState = UNINITIALIZED;
-
-// Set of session Ids of the persistent sessions created or residing in
-// storage.
-static set<uint32_t> sPersistentSessionIds;
-
-static vector<GMPTask*> sTasksBlockedOnSessionIdLoad;
-
-static void
-ReadAllRecordsFromIterator(GMPRecordIterator* aRecordIterator,
-                           void* aUserArg,
-                           GMPErr aStatus)
-{
-  MOZ_ASSERT(sPersistentKeyState == LOADING);
-  if (GMP_SUCCEEDED(aStatus)) {
-    // Extract the record names which are valid uint32_t's; they're
-    // the persistent session ids.
-    const char* name = nullptr;
-    uint32_t len = 0;
-    while (GMP_SUCCEEDED(aRecordIterator->GetName(&name, &len))) {
-      if (ClearKeyUtils::IsValidSessionId(name, len)) {
-        MOZ_ASSERT(name[len] == 0);
-        sPersistentSessionIds.insert(atoi(name));
-      }
-      aRecordIterator->NextRecord();
-    }
-  }
-  sPersistentKeyState = LOADED;
-  aRecordIterator->Close();
-
-  for (size_t i = 0; i < sTasksBlockedOnSessionIdLoad.size(); i++) {
-    sTasksBlockedOnSessionIdLoad[i]->Run();
-    sTasksBlockedOnSessionIdLoad[i]->Destroy();
-  }
-  sTasksBlockedOnSessionIdLoad.clear();
-}
-
-/* static */ void
-ClearKeyPersistence::EnsureInitialized()
-{
-  if (sPersistentKeyState == UNINITIALIZED) {
-    sPersistentKeyState = LOADING;
-    if (GMP_FAILED(EnumRecordNames(&ReadAllRecordsFromIterator))) {
-      sPersistentKeyState = LOADED;
-    }
-  }
-}
-
-/* static */ string
-ClearKeyPersistence::GetNewSessionId(GMPSessionType aSessionType)
-{
-  static uint32_t sNextSessionId = 1;
-
-  // Ensure we don't re-use a session id that was persisted.
-  while (Contains(sPersistentSessionIds, sNextSessionId)) {
-    sNextSessionId++;
-  }
-
-  string sessionId;
-  stringstream ss;
-  ss << sNextSessionId;
-  ss >> sessionId;
-
-  if (aSessionType == kGMPPersistentSession) {
-    sPersistentSessionIds.insert(sNextSessionId);
-  }
-
-  sNextSessionId++;
-
-  return sessionId;
-}
-
-
-class CreateSessionTask : public GMPTask {
-public:
-  CreateSessionTask(ClearKeySessionManager* aTarget,
-                    uint32_t aCreateSessionToken,
-                    uint32_t aPromiseId,
-                    const uint8_t* aInitData,
-                    uint32_t aInitDataSize,
-                    GMPSessionType aSessionType)
-    : mTarget(aTarget)
-    , mCreateSessionToken(aCreateSessionToken)
-    , mPromiseId(aPromiseId)
-    , mSessionType(aSessionType)
-  {
-    mInitData.insert(mInitData.end(),
-                     aInitData,
-                     aInitData + aInitDataSize);
-  }
-  virtual void Run() override {
-    mTarget->CreateSession(mCreateSessionToken,
-                           mPromiseId,
-                           "cenc",
-                           strlen("cenc"),
-                           &mInitData.front(),
-                           mInitData.size(),
-                           mSessionType);
-  }
-  virtual void Destroy() override {
-    delete this;
-  }
-private:
-  RefPtr<ClearKeySessionManager> mTarget;
-  uint32_t mCreateSessionToken;
-  uint32_t mPromiseId;
-  vector<uint8_t> mInitData;
-  GMPSessionType mSessionType;
-};
-
-
-/* static */ bool
-ClearKeyPersistence::DeferCreateSessionIfNotReady(ClearKeySessionManager* aInstance,
-                                                  uint32_t aCreateSessionToken,
-                                                  uint32_t aPromiseId,
-                                                  const uint8_t* aInitData,
-                                                  uint32_t aInitDataSize,
-                                                  GMPSessionType aSessionType)
-{
-  if (sPersistentKeyState >= LOADED)  {
-    return false;
-  }
-  GMPTask* t = new CreateSessionTask(aInstance,
-                                     aCreateSessionToken,
-                                     aPromiseId,
-                                     aInitData,
-                                     aInitDataSize,
-                                     aSessionType);
-  sTasksBlockedOnSessionIdLoad.push_back(t);
-  return true;
-}
-
-class LoadSessionTask : public GMPTask {
-public:
-  LoadSessionTask(ClearKeySessionManager* aTarget,
-                  uint32_t aPromiseId,
-                  const char* aSessionId,
-                  uint32_t aSessionIdLength)
-    : mTarget(aTarget)
-    , mPromiseId(aPromiseId)
-    , mSessionId(aSessionId, aSessionId + aSessionIdLength)
-  {
-  }
-  virtual void Run() override {
-    mTarget->LoadSession(mPromiseId,
-                         mSessionId.c_str(),
-                         mSessionId.size());
-  }
-  virtual void Destroy() override {
-    delete this;
-  }
-private:
-  RefPtr<ClearKeySessionManager> mTarget;
-  uint32_t mPromiseId;
-  string mSessionId;
-};
-
-/* static */ bool
-ClearKeyPersistence::DeferLoadSessionIfNotReady(ClearKeySessionManager* aInstance,
-                                                uint32_t aPromiseId,
-                                                const char* aSessionId,
-                                                uint32_t aSessionIdLength)
-{
-  if (sPersistentKeyState >= LOADED)  {
-    return false;
-  }
-  GMPTask* t = new LoadSessionTask(aInstance,
-                                   aPromiseId,
-                                   aSessionId,
-                                   aSessionIdLength);
-  sTasksBlockedOnSessionIdLoad.push_back(t);
-  return true;
-}
-
-/* static */ bool
-ClearKeyPersistence::IsPersistentSessionId(const string& aSessionId)
-{
-  return Contains(sPersistentSessionIds, atoi(aSessionId.c_str()));
-}
-
-class LoadSessionFromKeysTask : public ReadContinuation {
-public:
-  LoadSessionFromKeysTask(ClearKeySessionManager* aTarget,
-                          const string& aSessionId,
-                          uint32_t aPromiseId)
-    : mTarget(aTarget)
-    , mSessionId(aSessionId)
-    , mPromiseId(aPromiseId)
-  {
-  }
-
-  virtual void ReadComplete(GMPErr aStatus,
-                            const uint8_t* aData,
-                            uint32_t aLength) override
-  {
-    mTarget->PersistentSessionDataLoaded(aStatus, mPromiseId, mSessionId, aData, aLength);
-  }
-private:
-  RefPtr<ClearKeySessionManager> mTarget;
-  string mSessionId;
-  uint32_t mPromiseId;
-};
-
-/* static */ void
-ClearKeyPersistence::LoadSessionData(ClearKeySessionManager* aInstance,
-                                     const string& aSid,
-                                     uint32_t aPromiseId)
-{
-  LoadSessionFromKeysTask* loadTask =
-    new LoadSessionFromKeysTask(aInstance, aSid, aPromiseId);
-  ReadData(aSid, loadTask);
-}
-
-/* static */ void
-ClearKeyPersistence::PersistentSessionRemoved(const string& aSessionId)
-{
-  sPersistentSessionIds.erase(atoi(aSessionId.c_str()));
-}
diff --git a/media/gmp-clearkey/0.1/ClearKeyPersistence.h b/media/gmp-clearkey/0.1/ClearKeyPersistence.h
deleted file mode 100644
index 1bd3800..0000000
--- a/media/gmp-clearkey/0.1/ClearKeyPersistence.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef __ClearKeyPersistence_h__
-#define __ClearKeyPersistence_h__
-
-#include <string>
-#include "gmp-decryption.h"
-
-class ClearKeySessionManager;
-
-class ClearKeyPersistence {
-public:
-  static void EnsureInitialized();
-
-  static std::string GetNewSessionId(GMPSessionType aSessionType);
-
-  static bool DeferCreateSessionIfNotReady(ClearKeySessionManager* aInstance,
-                                           uint32_t aCreateSessionToken,
-                                           uint32_t aPromiseId,
-                                           const uint8_t* aInitData,
-                                           uint32_t aInitDataSize,
-                                           GMPSessionType aSessionType);
-
-  static bool DeferLoadSessionIfNotReady(ClearKeySessionManager* aInstance,
-                                         uint32_t aPromiseId,
-                                         const char* aSessionId,
-                                         uint32_t aSessionIdLength);
-
-  static bool IsPersistentSessionId(const std::string& aSid);
-
-  static void LoadSessionData(ClearKeySessionManager* aInstance,
-                              const std::string& aSid,
-                              uint32_t aPromiseId);
-
-  static void PersistentSessionRemoved(const std::string& aSid);
-};
-
-#endif // __ClearKeyPersistence_h__
diff --git a/media/gmp-clearkey/0.1/ClearKeySession.cpp b/media/gmp-clearkey/0.1/ClearKeySession.cpp
deleted file mode 100644
index 05cb29a..0000000
--- a/media/gmp-clearkey/0.1/ClearKeySession.cpp
+++ /dev/null
@@ -1,70 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "ClearKeyDecryptionManager.h"
-#include "ClearKeySession.h"
-#include "ClearKeyUtils.h"
-#include "ClearKeyStorage.h"
-#include "gmp-task-utils.h"
-
-#include "gmp-api/gmp-decryption.h"
-#include "mozilla/Endian.h"
-
-using namespace mozilla;
-
-ClearKeySession::ClearKeySession(const std::string& aSessionId,
-                                 GMPDecryptorCallback* aCallback,
-                                 GMPSessionType aSessionType)
-  : mSessionId(aSessionId)
-  , mCallback(aCallback)
-  , mSessionType(aSessionType)
-{
-  CK_LOGD("ClearKeySession ctor %p", this);
-}
-
-ClearKeySession::~ClearKeySession()
-{
-  CK_LOGD("ClearKeySession dtor %p", this);
-
-  auto& keyIds = GetKeyIds();
-  for (auto it = keyIds.begin(); it != keyIds.end(); it++) {
-    MOZ_ASSERT(ClearKeyDecryptionManager::Get()->HasKeyForKeyId(*it));
-
-    ClearKeyDecryptionManager::Get()->ReleaseKeyId(*it);
-    mCallback->KeyStatusChanged(&mSessionId[0], mSessionId.size(),
-                                &(*it)[0], it->size(),
-                                kGMPUnknown);
-  }
-}
-
-void
-ClearKeySession::Init(uint32_t aCreateSessionToken,
-                      uint32_t aPromiseId,
-                      const uint8_t* aInitData, uint32_t aInitDataSize)
-{
-  CK_LOGD("ClearKeySession::Init");
-
-  ClearKeyUtils::ParseInitData(aInitData, aInitDataSize, mKeyIds);
-  if (!mKeyIds.size()) {
-    const char message[] = "Couldn't parse cenc key init data";
-    mCallback->RejectPromise(aPromiseId, kGMPAbortError, message, strlen(message));
-    return;
-  }
-
-  mCallback->SetSessionId(aCreateSessionToken, &mSessionId[0], mSessionId.length());
-
-  mCallback->ResolvePromise(aPromiseId);
-}
-
-GMPSessionType
-ClearKeySession::Type() const
-{
-  return mSessionType;
-}
-
-void
-ClearKeySession::AddKeyId(const KeyId& aKeyId)
-{
-  mKeyIds.push_back(aKeyId);
-}
diff --git a/media/gmp-clearkey/0.1/ClearKeySession.h b/media/gmp-clearkey/0.1/ClearKeySession.h
deleted file mode 100644
index 68f498a..0000000
--- a/media/gmp-clearkey/0.1/ClearKeySession.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef __ClearKeySession_h__
-#define __ClearKeySession_h__
-
-#include "ClearKeyUtils.h"
-#include "gmp-decryption.h"
-
-class GMPBuffer;
-class GMPDecryptorCallback;
-class GMPDecryptorHost;
-class GMPEncryptedBufferMetadata;
-
-class ClearKeySession
-{
-public:
-  explicit ClearKeySession(const std::string& aSessionId,
-                           GMPDecryptorCallback* aCallback,
-                           GMPSessionType aSessionType);
-
-  ~ClearKeySession();
-
-  const std::vector<KeyId>& GetKeyIds() const { return mKeyIds; }
-
-  void Init(uint32_t aCreateSessionToken,
-            uint32_t aPromiseId,
-            const uint8_t* aInitData, uint32_t aInitDataSize);
-
-  GMPSessionType Type() const;
-
-  void AddKeyId(const KeyId& aKeyId);
-
-  const std::string& Id() const { return mSessionId; }
-
-private:
-  const std::string mSessionId;
-  std::vector<KeyId> mKeyIds;
-
-  GMPDecryptorCallback* mCallback;
-  const GMPSessionType mSessionType;
-};
-
-#endif // __ClearKeySession_h__
diff --git a/media/gmp-clearkey/0.1/ClearKeySessionManager.cpp b/media/gmp-clearkey/0.1/ClearKeySessionManager.cpp
deleted file mode 100644
index 78b5837..0000000
--- a/media/gmp-clearkey/0.1/ClearKeySessionManager.cpp
+++ /dev/null
@@ -1,418 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include <stdint.h>
-#include <stdio.h>
-#include <string.h>
-
-#include "ClearKeyDecryptionManager.h"
-#include "ClearKeySessionManager.h"
-#include "ClearKeyUtils.h"
-#include "ClearKeyStorage.h"
-#include "ClearKeyPersistence.h"
-#include "gmp-task-utils.h"
-#if defined(ENABLE_WMF)
-#include "WMFUtils.h"
-#include <versionhelpers.h>
-#endif
-
-#include "mozilla/Assertions.h"
-
-using namespace mozilla;
-using namespace std;
-
-ClearKeySessionManager::ClearKeySessionManager()
-  : mDecryptionManager(ClearKeyDecryptionManager::Get())
-{
-  CK_LOGD("ClearKeySessionManager ctor %p", this);
-  AddRef();
-
-  if (GetPlatform()->createthread(&mThread) != GMPNoErr) {
-    CK_LOGD("failed to create thread in clearkey cdm");
-    mThread = nullptr;
-  }
-}
-
-ClearKeySessionManager::~ClearKeySessionManager()
-{
-  CK_LOGD("ClearKeySessionManager dtor %p", this);
-   MOZ_ASSERT(!mRefCount);
-}
-
-static bool
-ShouldBeAbleToDecode()
-{
-#if !defined(ENABLE_WMF)
-  return false;
-#else
-  return IsWindowsVistaOrGreater();
-#endif
-}
-
-static bool
-CanDecode()
-{
-  return
-#if defined(ENABLE_WMF)
-    wmf::EnsureLibs() ||
-#endif
-    false;
-}
-
-void
-ClearKeySessionManager::Init(GMPDecryptorCallback* aCallback)
-{
-  CK_LOGD("ClearKeySessionManager::Init");
-  mCallback = aCallback;
-  if (ShouldBeAbleToDecode()) {
-    if (!CanDecode()) {
-      const char* err = "EME plugin can't load system decoder!";
-      mCallback->SessionError(nullptr, 0, kGMPAbortError, 0, err, strlen(err));
-    } else {
-      mCallback->SetCapabilities(GMP_EME_CAP_DECRYPT_AND_DECODE_AUDIO |
-                                 GMP_EME_CAP_DECRYPT_AND_DECODE_VIDEO);
-    }
-  } else {
-    mCallback->SetCapabilities(GMP_EME_CAP_DECRYPT_AUDIO |
-                               GMP_EME_CAP_DECRYPT_VIDEO);
-  }
-  ClearKeyPersistence::EnsureInitialized();
-}
-
-void
-ClearKeySessionManager::CreateSession(uint32_t aCreateSessionToken,
-                                      uint32_t aPromiseId,
-                                      const char* aInitDataType,
-                                      uint32_t aInitDataTypeSize,
-                                      const uint8_t* aInitData,
-                                      uint32_t aInitDataSize,
-                                      GMPSessionType aSessionType)
-{
-  CK_LOGD("ClearKeySessionManager::CreateSession type:%s", aInitDataType);
-
-  // initDataType must be "cenc".
-  if (strcmp("cenc", aInitDataType)) {
-    mCallback->RejectPromise(aPromiseId, kGMPNotSupportedError,
-                             nullptr /* message */, 0 /* messageLen */);
-    return;
-  }
-
-  if (ClearKeyPersistence::DeferCreateSessionIfNotReady(this,
-                                                        aCreateSessionToken,
-                                                        aPromiseId,
-                                                        aInitData,
-                                                        aInitDataSize,
-                                                        aSessionType)) {
-    return;
-  }
-
-  string sessionId = ClearKeyPersistence::GetNewSessionId(aSessionType);
-  MOZ_ASSERT(mSessions.find(sessionId) == mSessions.end());
-
-  ClearKeySession* session = new ClearKeySession(sessionId, mCallback, aSessionType);
-  session->Init(aCreateSessionToken, aPromiseId, aInitData, aInitDataSize);
-  mSessions[sessionId] = session;
-
-  const vector<KeyId>& sessionKeys = session->GetKeyIds();
-  vector<KeyId> neededKeys;
-  for (auto it = sessionKeys.begin(); it != sessionKeys.end(); it++) {
-    // Need to request this key ID from the client. We always send a key
-    // request, whether or not another session has sent a request with the same
-    // key ID. Otherwise a script can end up waiting for another script to
-    // respond to the request (which may not necessarily happen).
-    neededKeys.push_back(*it);
-    mDecryptionManager->ExpectKeyId(*it);
-  }
-
-  if (neededKeys.empty()) {
-    CK_LOGD("No keys needed from client.");
-    return;
-  }
-
-  // Send a request for needed key data.
-  string request;
-  ClearKeyUtils::MakeKeyRequest(neededKeys, request, aSessionType);
-  mCallback->SessionMessage(&sessionId[0], sessionId.length(),
-                            kGMPLicenseRequest,
-                            (uint8_t*)&request[0], request.length());
-}
-
-void
-ClearKeySessionManager::LoadSession(uint32_t aPromiseId,
-                                    const char* aSessionId,
-                                    uint32_t aSessionIdLength)
-{
-  CK_LOGD("ClearKeySessionManager::LoadSession");
-
-  if (!ClearKeyUtils::IsValidSessionId(aSessionId, aSessionIdLength)) {
-    mCallback->ResolveLoadSessionPromise(aPromiseId, false);
-    return;
-  }
-
-  if (ClearKeyPersistence::DeferLoadSessionIfNotReady(this,
-                                                      aPromiseId,
-                                                      aSessionId,
-                                                      aSessionIdLength)) {
-    return;
-  }
-
-  string sid(aSessionId, aSessionId + aSessionIdLength);
-  if (!ClearKeyPersistence::IsPersistentSessionId(sid)) {
-    mCallback->ResolveLoadSessionPromise(aPromiseId, false);
-    return;
-  }
-
-  // Callsback PersistentSessionDataLoaded with results...
-  ClearKeyPersistence::LoadSessionData(this, sid, aPromiseId);
-}
-
-void
-ClearKeySessionManager::PersistentSessionDataLoaded(GMPErr aStatus,
-                                                    uint32_t aPromiseId,
-                                                    const string& aSessionId,
-                                                    const uint8_t* aKeyData,
-                                                    uint32_t aKeyDataSize)
-{
-  CK_LOGD("ClearKeySessionManager::PersistentSessionDataLoaded");
-  if (GMP_FAILED(aStatus) ||
-      Contains(mSessions, aSessionId) ||
-      (aKeyDataSize % (2 * CLEARKEY_KEY_LEN)) != 0) {
-    mCallback->ResolveLoadSessionPromise(aPromiseId, false);
-    return;
-  }
-
-  ClearKeySession* session = new ClearKeySession(aSessionId,
-                                                 mCallback,
-                                                 kGMPPersistentSession);
-  mSessions[aSessionId] = session;
-
-  uint32_t numKeys = aKeyDataSize / (2 * CLEARKEY_KEY_LEN);
-  for (uint32_t i = 0; i < numKeys; i ++) {
-    const uint8_t* base = aKeyData + 2 * CLEARKEY_KEY_LEN * i;
-
-    KeyId keyId(base, base + CLEARKEY_KEY_LEN);
-    MOZ_ASSERT(keyId.size() == CLEARKEY_KEY_LEN);
-
-    Key key(base + CLEARKEY_KEY_LEN, base + 2 * CLEARKEY_KEY_LEN);
-    MOZ_ASSERT(key.size() == CLEARKEY_KEY_LEN);
-
-    session->AddKeyId(keyId);
-
-    mDecryptionManager->ExpectKeyId(keyId);
-    mDecryptionManager->InitKey(keyId, key);
-    mKeyIds.insert(key);
-    mCallback->KeyStatusChanged(&aSessionId[0], aSessionId.size(),
-                                &keyId[0], keyId.size(),
-                                kGMPUsable);
-  }
-
-  mCallback->ResolveLoadSessionPromise(aPromiseId, true);
-}
-
-void
-ClearKeySessionManager::UpdateSession(uint32_t aPromiseId,
-                                      const char* aSessionId,
-                                      uint32_t aSessionIdLength,
-                                      const uint8_t* aResponse,
-                                      uint32_t aResponseSize)
-{
-  CK_LOGD("ClearKeySessionManager::UpdateSession");
-  string sessionId(aSessionId, aSessionId + aSessionIdLength);
-
-  auto itr = mSessions.find(sessionId);
-  if (itr == mSessions.end() || !(itr->second)) {
-    CK_LOGW("ClearKey CDM couldn't resolve session ID in UpdateSession.");
-    mCallback->RejectPromise(aPromiseId, kGMPNotFoundError, nullptr, 0);
-    return;
-  }
-  ClearKeySession* session = itr->second;
-
-  // Parse the response for any (key ID, key) pairs.
-  vector<KeyIdPair> keyPairs;
-  if (!ClearKeyUtils::ParseJWK(aResponse, aResponseSize, keyPairs, session->Type())) {
-    CK_LOGW("ClearKey CDM failed to parse JSON Web Key.");
-    mCallback->RejectPromise(aPromiseId, kGMPInvalidAccessError, nullptr, 0);
-    return;
-  }
-
-  for (auto it = keyPairs.begin(); it != keyPairs.end(); it++) {
-    mDecryptionManager->InitKey(it->mKeyId, it->mKey);
-    mKeyIds.insert(it->mKeyId);
-    mCallback->KeyStatusChanged(aSessionId, aSessionIdLength,
-                                &it->mKeyId[0], it->mKeyId.size(),
-                                kGMPUsable);
-  }
-
-  if (session->Type() != kGMPPersistentSession) {
-    mCallback->ResolvePromise(aPromiseId);
-    return;
-  }
-
-  // Store the keys on disk. We store a record whose name is the sessionId,
-  // and simply append each keyId followed by its key.
-  vector<uint8_t> keydata;
-  Serialize(session, keydata);
-  GMPTask* resolve = WrapTask(mCallback, &GMPDecryptorCallback::ResolvePromise, aPromiseId);
-  static const char* message = "Couldn't store cenc key init data";
-  GMPTask* reject = WrapTask(mCallback,
-                             &GMPDecryptorCallback::RejectPromise,
-                             aPromiseId,
-                             kGMPInvalidStateError,
-                             message,
-                             strlen(message));
-  StoreData(sessionId, keydata, resolve, reject);
-}
-
-void
-ClearKeySessionManager::Serialize(const ClearKeySession* aSession,
-                                  std::vector<uint8_t>& aOutKeyData)
-{
-  const std::vector<KeyId>& keyIds = aSession->GetKeyIds();
-  for (size_t i = 0; i < keyIds.size(); i++) {
-    const KeyId& keyId = keyIds[i];
-    if (!mDecryptionManager->HasKeyForKeyId(keyId)) {
-      continue;
-    }
-    MOZ_ASSERT(keyId.size() == CLEARKEY_KEY_LEN);
-    aOutKeyData.insert(aOutKeyData.end(), keyId.begin(), keyId.end());
-    const Key& key = mDecryptionManager->GetDecryptionKey(keyId);
-    MOZ_ASSERT(key.size() == CLEARKEY_KEY_LEN);
-    aOutKeyData.insert(aOutKeyData.end(), key.begin(), key.end());
-  }
-}
-
-void
-ClearKeySessionManager::CloseSession(uint32_t aPromiseId,
-                                     const char* aSessionId,
-                                     uint32_t aSessionIdLength)
-{
-  CK_LOGD("ClearKeySessionManager::CloseSession");
-
-  string sessionId(aSessionId, aSessionId + aSessionIdLength);
-  auto itr = mSessions.find(sessionId);
-  if (itr == mSessions.end()) {
-    CK_LOGW("ClearKey CDM couldn't close non-existent session.");
-    mCallback->RejectPromise(aPromiseId, kGMPNotFoundError, nullptr, 0);
-    return;
-  }
-
-  ClearKeySession* session = itr->second;
-  MOZ_ASSERT(session);
-
-  ClearInMemorySessionData(session);
-  mCallback->ResolvePromise(aPromiseId);
-  mCallback->SessionClosed(aSessionId, aSessionIdLength);
-}
-
-void
-ClearKeySessionManager::ClearInMemorySessionData(ClearKeySession* aSession)
-{
-  mSessions.erase(aSession->Id());
-  delete aSession;
-}
-
-void
-ClearKeySessionManager::RemoveSession(uint32_t aPromiseId,
-                                      const char* aSessionId,
-                                      uint32_t aSessionIdLength)
-{
-  CK_LOGD("ClearKeySessionManager::RemoveSession");
-  string sessionId(aSessionId, aSessionId + aSessionIdLength);
-  auto itr = mSessions.find(sessionId);
-  if (itr == mSessions.end()) {
-    CK_LOGW("ClearKey CDM couldn't remove non-existent session.");
-    mCallback->RejectPromise(aPromiseId, kGMPNotFoundError, nullptr, 0);
-    return;
-  }
-
-  ClearKeySession* session = itr->second;
-  MOZ_ASSERT(session);
-  string sid = session->Id();
-  bool isPersistent = session->Type() == kGMPPersistentSession;
-  ClearInMemorySessionData(session);
-
-  if (!isPersistent) {
-    mCallback->ResolvePromise(aPromiseId);
-    return;
-  }
-
-  ClearKeyPersistence::PersistentSessionRemoved(sid);
-
-  // Overwrite the record storing the sessionId's key data with a zero
-  // length record to delete it.
-  vector<uint8_t> emptyKeydata;
-  GMPTask* resolve = WrapTask(mCallback, &GMPDecryptorCallback::ResolvePromise, aPromiseId);
-  static const char* message = "Could not remove session";
-  GMPTask* reject = WrapTask(mCallback,
-                             &GMPDecryptorCallback::RejectPromise,
-                             aPromiseId,
-                             kGMPInvalidAccessError,
-                             message,
-                             strlen(message));
-  StoreData(sessionId, emptyKeydata, resolve, reject);
-}
-
-void
-ClearKeySessionManager::SetServerCertificate(uint32_t aPromiseId,
-                                             const uint8_t* aServerCert,
-                                             uint32_t aServerCertSize)
-{
-  // ClearKey CDM doesn't support this method by spec.
-  CK_LOGD("ClearKeySessionManager::SetServerCertificate");
-  mCallback->RejectPromise(aPromiseId, kGMPNotSupportedError,
-                           nullptr /* message */, 0 /* messageLen */);
-}
-
-void
-ClearKeySessionManager::Decrypt(GMPBuffer* aBuffer,
-                                GMPEncryptedBufferMetadata* aMetadata)
-{
-  CK_LOGD("ClearKeySessionManager::Decrypt");
-
-  if (!mThread) {
-    CK_LOGW("No decrypt thread");
-    mCallback->Decrypted(aBuffer, GMPGenericErr);
-    return;
-  }
-
-  mThread->Post(WrapTask(this,
-                         &ClearKeySessionManager::DoDecrypt,
-                         aBuffer, aMetadata));
-}
-
-void
-ClearKeySessionManager::DoDecrypt(GMPBuffer* aBuffer,
-                                  GMPEncryptedBufferMetadata* aMetadata)
-{
-  CK_LOGD("ClearKeySessionManager::DoDecrypt");
-
-  GMPErr rv = mDecryptionManager->Decrypt(aBuffer->Data(), aBuffer->Size(),
-                                              aMetadata);
-  CK_LOGD("DeDecrypt finished with code %x\n", rv);
-  mCallback->Decrypted(aBuffer, rv);
-}
-
-void
-ClearKeySessionManager::Shutdown()
-{
-  CK_LOGD("ClearKeySessionManager::Shutdown %p", this);
-
-  for (auto it = mSessions.begin(); it != mSessions.end(); it++) {
-    delete it->second;
-  }
-  mSessions.clear();
-}
-
-void
-ClearKeySessionManager::DecryptingComplete()
-{
-  CK_LOGD("ClearKeySessionManager::DecryptingComplete %p", this);
-
-  GMPThread* thread = mThread;
-  thread->Join();
-
-  Shutdown();
-  mDecryptionManager = nullptr;
-  Release();
-}
diff --git a/media/gmp-clearkey/0.1/ClearKeySessionManager.h b/media/gmp-clearkey/0.1/ClearKeySessionManager.h
deleted file mode 100644
index 3e734a6..0000000
--- a/media/gmp-clearkey/0.1/ClearKeySessionManager.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef __ClearKeyDecryptor_h__
-#define __ClearKeyDecryptor_h__
-
-#include <map>
-#include <set>
-#include <string>
-#include <vector>
-
-#include "ClearKeyDecryptionManager.h"
-#include "ClearKeySession.h"
-#include "ClearKeyUtils.h"
-#include "gmp-api/gmp-decryption.h"
-#include "mozilla/Attributes.h"
-#include "mozilla/RefPtr.h"
-#include "RefCounted.h"
-
-class ClearKeySessionManager final : public GMPDecryptor
-                                       , public RefCounted
-{
-public:
-  ClearKeySessionManager();
-
-  virtual void Init(GMPDecryptorCallback* aCallback) override;
-
-  virtual void CreateSession(uint32_t aCreateSessionToken,
-                             uint32_t aPromiseId,
-                             const char* aInitDataType,
-                             uint32_t aInitDataTypeSize,
-                             const uint8_t* aInitData,
-                             uint32_t aInitDataSize,
-                             GMPSessionType aSessionType) override;
-
-  virtual void LoadSession(uint32_t aPromiseId,
-                           const char* aSessionId,
-                           uint32_t aSessionIdLength) override;
-
-  virtual void UpdateSession(uint32_t aPromiseId,
-                             const char* aSessionId,
-                             uint32_t aSessionIdLength,
-                             const uint8_t* aResponse,
-                             uint32_t aResponseSize) override;
-
-  virtual void CloseSession(uint32_t aPromiseId,
-                            const char* aSessionId,
-                            uint32_t aSessionIdLength) override;
-
-  virtual void RemoveSession(uint32_t aPromiseId,
-                             const char* aSessionId,
-                             uint32_t aSessionIdLength) override;
-
-  virtual void SetServerCertificate(uint32_t aPromiseId,
-                                    const uint8_t* aServerCert,
-                                    uint32_t aServerCertSize) override;
-
-  virtual void Decrypt(GMPBuffer* aBuffer,
-                       GMPEncryptedBufferMetadata* aMetadata) override;
-
-  virtual void DecryptingComplete() override;
-
-  void PersistentSessionDataLoaded(GMPErr aStatus,
-                                   uint32_t aPromiseId,
-                                   const std::string& aSessionId,
-                                   const uint8_t* aKeyData,
-                                   uint32_t aKeyDataSize);
-
-private:
-  ~ClearKeySessionManager();
-
-  void DoDecrypt(GMPBuffer* aBuffer, GMPEncryptedBufferMetadata* aMetadata);
-  void Shutdown();
-
-  void ClearInMemorySessionData(ClearKeySession* aSession);
-  void Serialize(const ClearKeySession* aSession, std::vector<uint8_t>& aOutKeyData);
-
-  mozilla::RefPtr<ClearKeyDecryptionManager> mDecryptionManager;
-
-  GMPDecryptorCallback* mCallback;
-  GMPThread* mThread;
-
-  std::set<KeyId> mKeyIds;
-  std::map<std::string, ClearKeySession*> mSessions;
-};
-
-#endif // __ClearKeyDecryptor_h__
diff --git a/media/gmp-clearkey/0.1/ClearKeyStorage.cpp b/media/gmp-clearkey/0.1/ClearKeyStorage.cpp
deleted file mode 100644
index b76d6e5..0000000
--- a/media/gmp-clearkey/0.1/ClearKeyStorage.cpp
+++ /dev/null
@@ -1,182 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "ClearKeyStorage.h"
-#include "ClearKeyUtils.h"
-
-#include "gmp-task-utils.h"
-
-#include "mozilla/Assertions.h"
-#include "mozilla/ArrayUtils.h"
-
-#include <vector>
-
-static GMPErr
-RunOnMainThread(GMPTask* aTask)
-{
-  return GetPlatform()->runonmainthread(aTask);
-}
-
-GMPErr
-OpenRecord(const char* aName,
-           uint32_t aNameLength,
-           GMPRecord** aOutRecord,
-           GMPRecordClient* aClient)
-{
-  return GetPlatform()->createrecord(aName, aNameLength, aOutRecord, aClient);
-}
-
-class WriteRecordClient : public GMPRecordClient {
-public:
-  /*
-   * This function will take the memory ownership of the parameters and
-   * delete them when done.
-   */
-  static void Write(const std::string& aRecordName,
-                    const std::vector<uint8_t>& aData,
-                    GMPTask* aOnSuccess,
-                    GMPTask* aOnFailure) {
-    (new WriteRecordClient(aData, aOnSuccess, aOnFailure))->Do(aRecordName);
-  }
-
-  virtual void OpenComplete(GMPErr aStatus) override {
-    if (GMP_FAILED(aStatus) ||
-        GMP_FAILED(mRecord->Write(&mData.front(), mData.size()))) {
-      Done(mOnFailure, mOnSuccess);
-    }
-  }
-
-  virtual void ReadComplete(GMPErr aStatus,
-                            const uint8_t* aData,
-                            uint32_t aDataSize) override {
-    MOZ_ASSERT(false, "Should not reach here.");
-  }
-
-  virtual void WriteComplete(GMPErr aStatus) override {
-    if (GMP_FAILED(aStatus)) {
-      Done(mOnFailure, mOnSuccess);
-    } else {
-      Done(mOnSuccess, mOnFailure);
-    }
-  }
-
-private:
-  WriteRecordClient(const std::vector<uint8_t>& aData,
-                    GMPTask* aOnSuccess,
-                    GMPTask* aOnFailure)
-    : mRecord(nullptr)
-    , mOnSuccess(aOnSuccess)
-    , mOnFailure(aOnFailure)
-    , mData(aData) {}
-
-  void Do(const std::string& aName) {
-    auto err = OpenRecord(aName.c_str(), aName.size(), &mRecord, this);
-    if (GMP_FAILED(err) ||
-        GMP_FAILED(mRecord->Open())) {
-      Done(mOnFailure, mOnSuccess);
-    }
-  }
-
-  void Done(GMPTask* aToRun, GMPTask* aToDestroy) {
-    // Note: Call Close() before running continuation, in case the
-    // continuation tries to open the same record; if we call Close()
-    // after running the continuation, the Close() call will arrive
-    // just after the Open() call succeeds, immediately closing the
-    // record we just opened.
-    if (mRecord) {
-      mRecord->Close();
-    }
-    aToDestroy->Destroy();
-    RunOnMainThread(aToRun);
-    delete this;
-  }
-
-  GMPRecord* mRecord;
-  GMPTask* mOnSuccess;
-  GMPTask* mOnFailure;
-  const std::vector<uint8_t> mData;
-};
-
-void
-StoreData(const std::string& aRecordName,
-          const std::vector<uint8_t>& aData,
-          GMPTask* aOnSuccess,
-          GMPTask* aOnFailure)
-{
-  WriteRecordClient::Write(aRecordName, aData, aOnSuccess, aOnFailure);
-}
-
-class ReadRecordClient : public GMPRecordClient {
-public:
-  /*
-   * This function will take the memory ownership of the parameters and
-   * delete them when done.
-   */
-  static void Read(const std::string& aRecordName,
-                   ReadContinuation* aContinuation) {
-    MOZ_ASSERT(aContinuation);
-    (new ReadRecordClient(aContinuation))->Do(aRecordName);
-  }
-
-  virtual void OpenComplete(GMPErr aStatus) override {
-    auto err = aStatus;
-    if (GMP_FAILED(err) ||
-        GMP_FAILED(err = mRecord->Read())) {
-      Done(err, nullptr, 0);
-    }
-  }
-
-  virtual void ReadComplete(GMPErr aStatus,
-                            const uint8_t* aData,
-                            uint32_t aDataSize) override {
-    Done(aStatus, aData, aDataSize);
-  }
-
-  virtual void WriteComplete(GMPErr aStatus) override {
-    MOZ_ASSERT(false, "Should not reach here.");
-  }
-
-private:
-  explicit ReadRecordClient(ReadContinuation* aContinuation)
-    : mRecord(nullptr)
-    , mContinuation(aContinuation) {}
-
-  void Do(const std::string& aName) {
-    auto err = OpenRecord(aName.c_str(), aName.size(), &mRecord, this);
-    if (GMP_FAILED(err) ||
-        GMP_FAILED(err = mRecord->Open())) {
-      Done(err, nullptr, 0);
-    }
-  }
-
-  void Done(GMPErr err, const uint8_t* aData, uint32_t aDataSize) {
-    // Note: Call Close() before running continuation, in case the
-    // continuation tries to open the same record; if we call Close()
-    // after running the continuation, the Close() call will arrive
-    // just after the Open() call succeeds, immediately closing the
-    // record we just opened.
-    if (mRecord) {
-      mRecord->Close();
-    }
-    mContinuation->ReadComplete(err, aData, aDataSize);
-    delete mContinuation;
-    delete this;
-  }
-
-  GMPRecord* mRecord;
-  ReadContinuation* mContinuation;
-};
-
-void
-ReadData(const std::string& aRecordName,
-         ReadContinuation* aContinuation)
-{
-  ReadRecordClient::Read(aRecordName, aContinuation);
-}
-
-GMPErr
-EnumRecordNames(RecvGMPRecordIteratorPtr aRecvIteratorFunc)
-{
-  return GetPlatform()->getrecordenumerator(aRecvIteratorFunc, nullptr);
-}
diff --git a/media/gmp-clearkey/0.1/ClearKeyStorage.h b/media/gmp-clearkey/0.1/ClearKeyStorage.h
deleted file mode 100644
index 41f7c86..0000000
--- a/media/gmp-clearkey/0.1/ClearKeyStorage.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef __ClearKeyStorage_h__
-#define __ClearKeyStorage_h__
-
-#include "gmp-errors.h"
-#include "gmp-platform.h"
-#include <string>
-#include <vector>
-#include <stdint.h>
-
-class GMPTask;
-
-// Responsible for ensuring that both aOnSuccess and aOnFailure are destroyed.
-void StoreData(const std::string& aRecordName,
-               const std::vector<uint8_t>& aData,
-               GMPTask* aOnSuccess,
-               GMPTask* aOnFailure);
-
-class ReadContinuation {
-public:
-  virtual void ReadComplete(GMPErr aStatus,
-                            const uint8_t* aData,
-                            uint32_t aLength) = 0;
-  virtual ~ReadContinuation() {}
-};
-
-// Deletes aContinuation after running it to report the result.
-void ReadData(const std::string& aSessionId,
-              ReadContinuation* aContinuation);
-
-GMPErr EnumRecordNames(RecvGMPRecordIteratorPtr aRecvIteratorFunc);
-
-#endif // __ClearKeyStorage_h__
diff --git a/media/gmp-clearkey/0.1/ClearKeyUtils.cpp b/media/gmp-clearkey/0.1/ClearKeyUtils.cpp
deleted file mode 100644
index 3d7e584..0000000
--- a/media/gmp-clearkey/0.1/ClearKeyUtils.cpp
+++ /dev/null
@@ -1,530 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include <algorithm>
-#include <ctype.h>
-#include <stdarg.h>
-#include <stdint.h>
-#include <vector>
-
-#include "ClearKeyUtils.h"
-#include "ClearKeyBase64.h"
-#include "mozilla/ArrayUtils.h"
-#include "mozilla/Assertions.h"
-#include "mozilla/Endian.h"
-#include "openaes/oaes_lib.h"
-
-using namespace std;
-
-#define FOURCC(a,b,c,d) ((a << 24) + (b << 16) + (c << 8) + d)
-
-// System ID identifying the cenc v2 pssh box format; specified at:
-// https://dvcs.w3.org/hg/html-media/raw-file/tip/encrypted-media/cenc-format.html
-const uint8_t kSystemID[] = {
-  0x10, 0x77, 0xef, 0xec, 0xc0, 0xb2, 0x4d, 0x02,
-  0xac, 0xe3, 0x3c, 0x1e, 0x52, 0xe2, 0xfb, 0x4b
-};
-
-void
-CK_Log(const char* aFmt, ...)
-{
-  va_list ap;
-
-  va_start(ap, aFmt);
-  vprintf(aFmt, ap);
-  va_end(ap);
-
-  printf("\n");
-  fflush(stdout);
-}
-
-static void
-IncrementIV(vector<uint8_t>& aIV) {
-  using mozilla::BigEndian;
-
-  MOZ_ASSERT(aIV.size() == 16);
-  BigEndian::writeUint64(&aIV[8], BigEndian::readUint64(&aIV[8]) + 1);
-}
-
-/* static */ void
-ClearKeyUtils::DecryptAES(const vector<uint8_t>& aKey,
-                          vector<uint8_t>& aData, vector<uint8_t>& aIV)
-{
-  MOZ_ASSERT(aIV.size() == CLEARKEY_KEY_LEN);
-  MOZ_ASSERT(aKey.size() == CLEARKEY_KEY_LEN);
-
-  OAES_CTX* aes = oaes_alloc();
-  oaes_key_import_data(aes, &aKey[0], aKey.size());
-  oaes_set_option(aes, OAES_OPTION_ECB, nullptr);
-
-  for (size_t i = 0; i < aData.size(); i += CLEARKEY_KEY_LEN) {
-    size_t encLen;
-    oaes_encrypt(aes, &aIV[0], CLEARKEY_KEY_LEN, nullptr, &encLen);
-
-    vector<uint8_t> enc(encLen);
-    oaes_encrypt(aes, &aIV[0], CLEARKEY_KEY_LEN, &enc[0], &encLen);
-
-    MOZ_ASSERT(encLen >= 2 * OAES_BLOCK_SIZE + CLEARKEY_KEY_LEN);
-    size_t blockLen = min(aData.size() - i, CLEARKEY_KEY_LEN);
-    for (size_t j = 0; j < blockLen; j++) {
-      aData[i + j] ^= enc[2 * OAES_BLOCK_SIZE + j];
-    }
-    IncrementIV(aIV);
-  }
-
-  oaes_free(&aes);
-}
-
-/**
- * ClearKey expects all Key IDs to be base64 encoded with non-standard alphabet
- * and padding.
- */
-static bool
-EncodeBase64Web(vector<uint8_t> aBinary, string& aEncoded)
-{
-  const char sAlphabet[] =
-    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
-  const uint8_t sMask = 0x3f;
-
-  aEncoded.resize((aBinary.size() * 8 + 5) / 6);
-
-  // Pad binary data in case there's rubbish past the last byte.
-  aBinary.push_back(0);
-
-  // Number of bytes not consumed in the previous character
-  uint32_t shift = 0;
-
-  auto out = aEncoded.begin();
-  auto data = aBinary.begin();
-  for (string::size_type i = 0; i < aEncoded.length(); i++) {
-    if (shift) {
-      out[i] = (*data << (6 - shift)) & sMask;
-      data++;
-    } else {
-      out[i] = 0;
-    }
-
-    out[i] += (*data >> (shift + 2)) & sMask;
-    shift = (shift + 2) % 8;
-
-    // Cast idx to size_t before using it as an array-index,
-    // to pacify clang 'Wchar-subscripts' warning:
-    size_t idx = static_cast<size_t>(out[i]);
-    MOZ_ASSERT(idx < MOZ_ARRAY_LENGTH(sAlphabet),
-               "out of bounds index for 'sAlphabet'");
-    out[i] = sAlphabet[idx];
-  }
-
-  return true;
-}
-
-/* static */ void
-ClearKeyUtils::ParseInitData(const uint8_t* aInitData, uint32_t aInitDataSize,
-                             vector<KeyId>& aOutKeys)
-{
-  using mozilla::BigEndian;
-
-  uint32_t size = 0;
-  for (uint32_t offset = 0; offset + sizeof(uint32_t) < aInitDataSize; offset += size) {
-    const uint8_t* data = aInitData + offset;
-    size = BigEndian::readUint32(data); data += sizeof(uint32_t);
-
-    CK_LOGD("Looking for pssh at offset %u", offset);
-
-    if (size + offset > aInitDataSize) {
-      CK_LOGE("Box size %u overflows init data buffer", size);
-      return;
-    }
-
-    if (size < 36) {
-      // Too small to be a cenc2 pssh box
-      continue;
-    }
-
-    uint32_t box = BigEndian::readUint32(data); data += sizeof(uint32_t);
-    if (box != FOURCC('p','s','s','h')) {
-      CK_LOGE("ClearKey CDM passed non-pssh initData");
-      return;
-    }
-
-    uint32_t head = BigEndian::readUint32(data); data += sizeof(uint32_t);
-    CK_LOGD("Got version %u pssh box, length %u", head & 0xff, size);
-
-    if ((head >> 24) != 1) {
-      // Ignore pssh boxes with wrong version
-      CK_LOGD("Ignoring pssh box with wrong version");
-      continue;
-    }
-
-    if (memcmp(kSystemID, data, sizeof(kSystemID))) {
-      // Ignore pssh boxes with wrong system ID
-      continue;
-    }
-    data += sizeof(kSystemID);
-
-    uint32_t kidCount = BigEndian::readUint32(data); data += sizeof(uint32_t);
-    if (data + kidCount * CLEARKEY_KEY_LEN > aInitData + aInitDataSize) {
-      CK_LOGE("pssh key IDs overflow init data buffer");
-      return;
-    }
-
-    for (uint32_t i = 0; i < kidCount; i++) {
-      aOutKeys.push_back(KeyId(data, data + CLEARKEY_KEY_LEN));
-      data += CLEARKEY_KEY_LEN;
-    }
-  }
-}
-
-/* static */ void
-ClearKeyUtils::MakeKeyRequest(const vector<KeyId>& aKeyIDs,
-                              string& aOutRequest,
-                              GMPSessionType aSessionType)
-{
-  MOZ_ASSERT(aKeyIDs.size() && aOutRequest.empty());
-
-  aOutRequest.append("{ \"kids\":[");
-  for (size_t i = 0; i < aKeyIDs.size(); i++) {
-    if (i) {
-      aOutRequest.append(",");
-    }
-    aOutRequest.append("\"");
-
-    string base64key;
-    EncodeBase64Web(aKeyIDs[i], base64key);
-    aOutRequest.append(base64key);
-
-    aOutRequest.append("\"");
-  }
-  aOutRequest.append("], \"type\":");
-
-  aOutRequest.append("\"");
-  aOutRequest.append(SessionTypeToString(aSessionType));
-  aOutRequest.append("\"}");
-}
-
-#define EXPECT_SYMBOL(CTX, X) do { \
-  if (GetNextSymbol(CTX) != (X)) { \
-    CK_LOGE("Unexpected symbol in JWK parser"); \
-    return false; \
-  } \
-} while (false)
-
-struct ParserContext {
-  const uint8_t* mIter;
-  const uint8_t* mEnd;
-};
-
-static uint8_t
-PeekSymbol(ParserContext& aCtx)
-{
-  for (; aCtx.mIter < aCtx.mEnd; (aCtx.mIter)++) {
-    if (!isspace(*aCtx.mIter)) {
-      return *aCtx.mIter;
-    }
-  }
-
-  return 0;
-}
-
-static uint8_t
-GetNextSymbol(ParserContext& aCtx)
-{
-  uint8_t sym = PeekSymbol(aCtx);
-  aCtx.mIter++;
-  return sym;
-}
-
-static bool SkipToken(ParserContext& aCtx);
-
-static bool
-SkipString(ParserContext& aCtx)
-{
-  EXPECT_SYMBOL(aCtx, '"');
-  for (uint8_t sym = GetNextSymbol(aCtx); sym; sym = GetNextSymbol(aCtx)) {
-    if (sym == '\\') {
-      sym = GetNextSymbol(aCtx);
-    } else if (sym == '"') {
-      return true;
-    }
-  }
-
-  return false;
-}
-
-/**
- * Skip whole object and values it contains.
- */
-static bool
-SkipObject(ParserContext& aCtx)
-{
-  EXPECT_SYMBOL(aCtx, '{');
-
-  if (PeekSymbol(aCtx) == '}') {
-    GetNextSymbol(aCtx);
-    return true;
-  }
-
-  while (true) {
-    if (!SkipString(aCtx)) return false;
-    EXPECT_SYMBOL(aCtx, ':');
-    if (!SkipToken(aCtx)) return false;
-
-    if (PeekSymbol(aCtx) == '}') {
-      GetNextSymbol(aCtx);
-      return true;
-    }
-    EXPECT_SYMBOL(aCtx, ',');
-  }
-
-  return false;
-}
-
-/**
- * Skip array value and the values it contains.
- */
-static bool
-SkipArray(ParserContext& aCtx)
-{
-  EXPECT_SYMBOL(aCtx, '[');
-
-  if (PeekSymbol(aCtx) == ']') {
-    GetNextSymbol(aCtx);
-    return true;
-  }
-
-  while (SkipToken(aCtx)) {
-    if (PeekSymbol(aCtx) == ']') {
-      GetNextSymbol(aCtx);
-      return true;
-    }
-    EXPECT_SYMBOL(aCtx, ',');
-  }
-
-  return false;
-}
-
-/**
- * Skip unquoted literals like numbers, |true|, and |null|.
- * (XXX and anything else that matches /([:alnum:]|[+-.])+/)
- */
-static bool
-SkipLiteral(ParserContext& aCtx)
-{
-  for (; aCtx.mIter < aCtx.mEnd; aCtx.mIter++) {
-    if (!isalnum(*aCtx.mIter) &&
-        *aCtx.mIter != '.' && *aCtx.mIter != '-' && *aCtx.mIter != '+') {
-      return true;
-    }
-  }
-
-  return false;
-}
-
-static bool
-SkipToken(ParserContext& aCtx)
-{
-  uint8_t startSym = PeekSymbol(aCtx);
-  if (startSym == '"') {
-    CK_LOGD("JWK parser skipping string");
-    return SkipString(aCtx);
-  } else if (startSym == '{') {
-    CK_LOGD("JWK parser skipping object");
-    return SkipObject(aCtx);
-  } else if (startSym == '[') {
-    CK_LOGD("JWK parser skipping array");
-    return SkipArray(aCtx);
-  } else {
-    CK_LOGD("JWK parser skipping literal");
-    return SkipLiteral(aCtx);
-  }
-
-  return false;
-}
-
-static bool
-GetNextLabel(ParserContext& aCtx, string& aOutLabel)
-{
-  EXPECT_SYMBOL(aCtx, '"');
-
-  const uint8_t* start = aCtx.mIter;
-  for (uint8_t sym = GetNextSymbol(aCtx); sym; sym = GetNextSymbol(aCtx)) {
-    if (sym == '\\') {
-      GetNextSymbol(aCtx);
-      continue;
-    }
-
-    if (sym == '"') {
-      aOutLabel.assign(start, aCtx.mIter - 1);
-      return true;
-    }
-  }
-
-  return false;
-}
-
-static bool
-DecodeKey(string& aEncoded, Key& aOutDecoded)
-{
-  return
-    DecodeBase64KeyOrId(aEncoded, aOutDecoded) &&
-    // Key should be 128 bits long.
-    aOutDecoded.size() == CLEARKEY_KEY_LEN;
-}
-
-static bool
-ParseKeyObject(ParserContext& aCtx, KeyIdPair& aOutKey)
-{
-  EXPECT_SYMBOL(aCtx, '{');
-
-  // Reject empty objects as invalid licenses.
-  if (PeekSymbol(aCtx) == '}') {
-    GetNextSymbol(aCtx);
-    return false;
-  }
-
-  string keyId;
-  string key;
-
-  while (true) {
-    string label;
-    string value;
-
-    if (!GetNextLabel(aCtx, label)) {
-      return false;
-    }
-
-    EXPECT_SYMBOL(aCtx, ':');
-    if (label == "kty") {
-      if (!GetNextLabel(aCtx, value)) return false;
-      // By spec, type must be "oct".
-      if (value != "oct") return false;
-    } else if (label == "alg") {
-      if (!GetNextLabel(aCtx, value)) return false;
-      // By spec, alg must be "A128KW".
-      if (value != "A128KW") return false;
-    } else if (label == "k" && PeekSymbol(aCtx) == '"') {
-      // if this isn't a string we will fall through to the SkipToken() path.
-      if (!GetNextLabel(aCtx, key)) return false;
-    } else if (label == "kid" && PeekSymbol(aCtx) == '"') {
-      if (!GetNextLabel(aCtx, keyId)) return false;
-    } else {
-      if (!SkipToken(aCtx)) return false;
-    }
-
-    uint8_t sym = PeekSymbol(aCtx);
-    if (!sym || sym == '}') {
-      break;
-    }
-    EXPECT_SYMBOL(aCtx, ',');
-  }
-
-  return !key.empty() &&
-         !keyId.empty() &&
-         DecodeBase64KeyOrId(keyId, aOutKey.mKeyId) &&
-         DecodeKey(key, aOutKey.mKey) &&
-         GetNextSymbol(aCtx) == '}';
-}
-
-static bool
-ParseKeys(ParserContext& aCtx, vector<KeyIdPair>& aOutKeys)
-{
-  // Consume start of array.
-  EXPECT_SYMBOL(aCtx, '[');
-
-  while (true) {
-    KeyIdPair key;
-    if (!ParseKeyObject(aCtx, key)) {
-      CK_LOGE("Failed to parse key object");
-      return false;
-    }
-
-    MOZ_ASSERT(!key.mKey.empty() && !key.mKeyId.empty());
-    aOutKeys.push_back(key);
-
-    uint8_t sym = PeekSymbol(aCtx);
-    if (!sym || sym == ']') {
-      break;
-    }
-
-    EXPECT_SYMBOL(aCtx, ',');
-  }
-
-  return GetNextSymbol(aCtx) == ']';
-}
-
-/* static */ bool
-ClearKeyUtils::ParseJWK(const uint8_t* aKeyData, uint32_t aKeyDataSize,
-                        vector<KeyIdPair>& aOutKeys,
-                        GMPSessionType aSessionType)
-{
-  ParserContext ctx;
-  ctx.mIter = aKeyData;
-  ctx.mEnd = aKeyData + aKeyDataSize;
-
-  // Consume '{' from start of object.
-  EXPECT_SYMBOL(ctx, '{');
-
-  while (true) {
-    string label;
-    // Consume member key.
-    if (!GetNextLabel(ctx, label)) return false;
-    EXPECT_SYMBOL(ctx, ':');
-
-    if (label == "keys") {
-      // Parse "keys" array.
-      if (!ParseKeys(ctx, aOutKeys)) return false;
-    } else if (label == "type") {
-      // Consume type string.
-      string type;
-      if (!GetNextLabel(ctx, type)) return false;
-      if (type != SessionTypeToString(aSessionType)) {
-        return false;
-      }
-    } else {
-      SkipToken(ctx);
-    }
-
-    // Check for end of object.
-    if (PeekSymbol(ctx) == '}') {
-      break;
-    }
-
-    // Consume ',' between object members.
-    EXPECT_SYMBOL(ctx, ',');
-  }
-
-  // Consume '}' from end of object.
-  EXPECT_SYMBOL(ctx, '}');
-
-  return true;
-}
-
-/* static */ const char*
-ClearKeyUtils::SessionTypeToString(GMPSessionType aSessionType)
-{
-  switch (aSessionType) {
-    case kGMPTemporySession: return "temporary";
-    case kGMPPersistentSession: return "persistent";
-    default: {
-      MOZ_ASSERT(false, "Should not reach here.");
-      return "invalid";
-    }
-  }
-}
-
-/* static */ bool
-ClearKeyUtils::IsValidSessionId(const char* aBuff, uint32_t aLength)
-{
-  if (aLength > 10) {
-    // 10 is the max number of characters in UINT32_MAX when
-    // represented as a string; ClearKey session ids are integers.
-    return false;
-  }
-  for (uint32_t i = 0; i < aLength; i++) {
-    if (!isdigit(aBuff[i])) {
-      return false;
-    }
-  }
-  return true;
-}
diff --git a/media/gmp-clearkey/0.1/ClearKeyUtils.h b/media/gmp-clearkey/0.1/ClearKeyUtils.h
deleted file mode 100644
index 7700e71..0000000
--- a/media/gmp-clearkey/0.1/ClearKeyUtils.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef __ClearKeyUtils_h__
-#define __ClearKeyUtils_h__
-
-#include <stdint.h>
-#include <string>
-#include <vector>
-#include "gmp-decryption.h"
-
-#define CLEARKEY_KEY_LEN ((size_t)16)
-
-#if 0
-void CK_Log(const char* aFmt, ...);
-#define CK_LOGE(...) CK_Log(__VA_ARGS__)
-#define CK_LOGD(...) CK_Log(__VA_ARGS__)
-#define CK_LOGW(...) CK_Log(__VA_ARGS__)
-#else
-#define CK_LOGE(...)
-#define CK_LOGD(...)
-#define CK_LOGW(...)
-#endif
-
-struct GMPPlatformAPI;
-extern GMPPlatformAPI* GetPlatform();
-
-typedef std::vector<uint8_t> KeyId;
-typedef std::vector<uint8_t> Key;
-
-struct KeyIdPair
-{
-  KeyId mKeyId;
-  Key mKey;
-};
-
-class ClearKeyUtils
-{
-public:
-  static void DecryptAES(const std::vector<uint8_t>& aKey,
-                         std::vector<uint8_t>& aData, std::vector<uint8_t>& aIV);
-
-  static void ParseInitData(const uint8_t* aInitData, uint32_t aInitDataSize,
-                            std::vector<Key>& aOutKeys);
-
-  static void MakeKeyRequest(const std::vector<KeyId>& aKeyIds,
-                             std::string& aOutRequest,
-                             GMPSessionType aSessionType);
-
-  static bool ParseJWK(const uint8_t* aKeyData, uint32_t aKeyDataSize,
-                       std::vector<KeyIdPair>& aOutKeys,
-                       GMPSessionType aSessionType);
-  static const char* SessionTypeToString(GMPSessionType aSessionType);
-
-  static bool IsValidSessionId(const char* aBuff, uint32_t aLength);
-};
-
-template<class Container, class Element>
-inline bool
-Contains(const Container& aContainer, const Element& aElement)
-{
-  return aContainer.find(aElement) != aContainer.end();
-}
-
-#endif // __ClearKeyUtils_h__
diff --git a/media/gmp-clearkey/0.1/Makefile.in b/media/gmp-clearkey/0.1/Makefile.in
deleted file mode 100644
index ba8fd21..0000000
--- a/media/gmp-clearkey/0.1/Makefile.in
+++ /dev/null
@@ -1,10 +0,0 @@
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-CLEARKEY_CDM_PATH := $(DEPTH)/dist/bin/gmp-clearkey/0.1
-CLEARKEY_CDM := \
-  clearkey.info.in \
-  $(NULL)
-
-PP_TARGETS := CLEARKEY_CDM
diff --git a/media/gmp-clearkey/0.1/RefCounted.h b/media/gmp-clearkey/0.1/RefCounted.h
deleted file mode 100644
index f530675..0000000
--- a/media/gmp-clearkey/0.1/RefCounted.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef __RefCount_h__
-#define __RefCount_h__
-
-// Note: Not thread safe!
-class RefCounted {
-public:
-  void AddRef() {
-    ++mRefCount;
-  }
-
-  uint32_t Release() {
-    uint32_t newCount = --mRefCount;
-    if (!newCount) {
-      delete this;
-    }
-    return newCount;
-  }
-
-protected:
-  RefCounted()
-    : mRefCount(0)
-  {
-  }
-  virtual ~RefCounted()
-  {
-  }
-  uint32_t mRefCount;
-};
-
-#endif // __RefCount_h__
diff --git a/media/gmp-clearkey/0.1/VideoDecoder.cpp b/media/gmp-clearkey/0.1/VideoDecoder.cpp
deleted file mode 100644
index a50a935..0000000
--- a/media/gmp-clearkey/0.1/VideoDecoder.cpp
+++ /dev/null
@@ -1,436 +0,0 @@
-/*
- * Copyright 2013, Mozilla Foundation and contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <cstdint>
-#include <limits>
-
-#include "AnnexB.h"
-#include "ClearKeyDecryptionManager.h"
-#include "ClearKeyUtils.h"
-#include "gmp-task-utils.h"
-#include "mozilla/Endian.h"
-#include "VideoDecoder.h"
-#include "mozilla/Move.h"
-
-using namespace wmf;
-
-VideoDecoder::VideoDecoder(GMPVideoHost *aHostAPI)
-  : mHostAPI(aHostAPI)
-  , mCallback(nullptr)
-  , mWorkerThread(nullptr)
-  , mMutex(nullptr)
-  , mNumInputTasks(0)
-  , mSentExtraData(false)
-  , mHasShutdown(false)
-{
-}
-
-VideoDecoder::~VideoDecoder()
-{
-  if (mMutex) {
-    mMutex->Destroy();
-  }
-}
-
-void
-VideoDecoder::InitDecode(const GMPVideoCodec& aCodecSettings,
-                         const uint8_t* aCodecSpecific,
-                         uint32_t aCodecSpecificLength,
-                         GMPVideoDecoderCallback* aCallback,
-                         int32_t aCoreCount)
-{
-  mCallback = aCallback;
-  assert(mCallback);
-  mDecoder = new WMFH264Decoder();
-  HRESULT hr = mDecoder->Init();
-  if (FAILED(hr)) {
-    CK_LOGD("VideoDecoder::InitDecode failed to init WMFH264Decoder");
-    mCallback->Error(GMPGenericErr);
-    return;
-  }
-
-  auto err = GetPlatform()->createmutex(&mMutex);
-  if (GMP_FAILED(err)) {
-    CK_LOGD("VideoDecoder::InitDecode failed to create GMPMutex");
-    mCallback->Error(GMPGenericErr);
-    return;
-  }
-
-  // The first byte is mPacketizationMode, which is only relevant for
-  // WebRTC/OpenH264 usecase.
-  const uint8_t* avcc = aCodecSpecific + 1;
-  const uint8_t* avccEnd = aCodecSpecific + aCodecSpecificLength;
-  mExtraData.insert(mExtraData.end(), avcc, avccEnd);
-
-  AnnexB::ConvertConfig(mExtraData, mAnnexB);
-}
-
-void
-VideoDecoder::EnsureWorker()
-{
-  if (!mWorkerThread) {
-    GetPlatform()->createthread(&mWorkerThread);
-    if (!mWorkerThread) {
-      mCallback->Error(GMPAllocErr);
-      return;
-    }
-  }
-}
-
-void
-VideoDecoder::Decode(GMPVideoEncodedFrame* aInputFrame,
-                     bool aMissingFrames,
-                     const uint8_t* aCodecSpecificInfo,
-                     uint32_t aCodecSpecificInfoLength,
-                     int64_t aRenderTimeMs)
-{
-  if (aInputFrame->BufferType() != GMP_BufferLength32) {
-    // Goanna should only send frames with 4 byte NAL sizes to GMPs.
-    mCallback->Error(GMPGenericErr);
-    return;
-  }
-
-  EnsureWorker();
-
-  {
-    AutoLock lock(mMutex);
-    mNumInputTasks++;
-  }
-
-  // Note: we don't need the codec specific info on a per-frame basis.
-  // It's mostly useful for WebRTC use cases.
-
-  mWorkerThread->Post(WrapTask(this,
-                               &VideoDecoder::DecodeTask,
-                               aInputFrame));
-}
-
-class AutoReleaseVideoFrame {
-public:
-  AutoReleaseVideoFrame(GMPVideoEncodedFrame* aFrame)
-    : mFrame(aFrame)
-  {
-  }
-  ~AutoReleaseVideoFrame()
-  {
-    GetPlatform()->runonmainthread(WrapTask(mFrame, &GMPVideoEncodedFrame::Destroy));
-  }
-private:
-  GMPVideoEncodedFrame* mFrame;
-};
-
-void
-VideoDecoder::DecodeTask(GMPVideoEncodedFrame* aInput)
-{
-  CK_LOGD("VideoDecoder::DecodeTask");
-  AutoReleaseVideoFrame ensureFrameReleased(aInput);
-  HRESULT hr;
-
-  {
-    AutoLock lock(mMutex);
-    mNumInputTasks--;
-    assert(mNumInputTasks >= 0);
-  }
-
-  if (!aInput || !mHostAPI || !mDecoder) {
-    CK_LOGE("Decode job not set up correctly!");
-    return;
-  }
-
-  const uint8_t* inBuffer = aInput->Buffer();
-  if (!inBuffer) {
-    CK_LOGE("No buffer for encoded frame!\n");
-    return;
-  }
-
-  const GMPEncryptedBufferMetadata* crypto = aInput->GetDecryptionData();
-  std::vector<uint8_t> buffer(inBuffer, inBuffer + aInput->Size());
-  if (crypto) {
-    // Plugin host should have set up its decryptor/key sessions
-    // before trying to decode!
-    GMPErr rv =
-      ClearKeyDecryptionManager::Get()->Decrypt(&buffer[0], buffer.size(), crypto);
-
-    if (GMP_FAILED(rv)) {
-      MaybeRunOnMainThread(WrapTask(mCallback, &GMPVideoDecoderCallback::Error, rv));
-      return;
-    }
-  }
-
-  AnnexB::ConvertFrameInPlace(buffer);
-
-  if (aInput->FrameType() == kGMPKeyFrame) {
-    // We must send the SPS and PPS to Windows Media Foundation's decoder.
-    // Note: We do this *after* decryption, otherwise the subsample info
-    // would be incorrect.
-    buffer.insert(buffer.begin(), mAnnexB.begin(), mAnnexB.end());
-  }
-
-  hr = mDecoder->Input(buffer.data(),
-                       buffer.size(),
-                       aInput->TimeStamp(),
-                       aInput->Duration());
-
-  CK_LOGD("VideoDecoder::DecodeTask() Input ret hr=0x%x\n", hr);
-  if (FAILED(hr)) {
-    CK_LOGE("VideoDecoder::DecodeTask() decode failed ret=0x%x%s\n",
-        hr,
-        ((hr == MF_E_NOTACCEPTING) ? " (MF_E_NOTACCEPTING)" : ""));
-    return;
-  }
-
-  while (hr == S_OK) {
-    CComPtr<IMFSample> output;
-    hr = mDecoder->Output(&output);
-    CK_LOGD("VideoDecoder::DecodeTask() output ret=0x%x\n", hr);
-    if (hr == S_OK) {
-      MaybeRunOnMainThread(
-        WrapTask(this,
-                 &VideoDecoder::ReturnOutput,
-                 CComPtr<IMFSample>(mozilla::Move(output)),
-                 mDecoder->GetFrameWidth(),
-                 mDecoder->GetFrameHeight(),
-                 mDecoder->GetStride()));
-      assert(!output.Get());
-    }
-    if (hr == MF_E_TRANSFORM_NEED_MORE_INPUT) {
-      AutoLock lock(mMutex);
-      if (mNumInputTasks == 0) {
-        // We have run all input tasks. We *must* notify Goanna so that it will
-        // send us more data.
-        MaybeRunOnMainThread(
-          WrapTask(mCallback,
-                   &GMPVideoDecoderCallback::InputDataExhausted));
-      }
-    }
-    if (FAILED(hr)) {
-      CK_LOGE("VideoDecoder::DecodeTask() output failed hr=0x%x\n", hr);
-    }
-  }
-}
-
-void
-VideoDecoder::ReturnOutput(IMFSample* aSample,
-                           int32_t aWidth,
-                           int32_t aHeight,
-                           int32_t aStride)
-{
-  CK_LOGD("[%p] VideoDecoder::ReturnOutput()\n", this);
-  assert(aSample);
-
-  HRESULT hr;
-
-  GMPVideoFrame* f = nullptr;
-  mHostAPI->CreateFrame(kGMPI420VideoFrame, &f);
-  if (!f) {
-    CK_LOGE("Failed to create i420 frame!\n");
-    return;
-  }
-  auto vf = static_cast<GMPVideoi420Frame*>(f);
-
-  hr = SampleToVideoFrame(aSample, aWidth, aHeight, aStride, vf);
-  ENSURE(SUCCEEDED(hr), /*void*/);
-
-  mCallback->Decoded(vf);
-}
-
-HRESULT
-VideoDecoder::SampleToVideoFrame(IMFSample* aSample,
-                                 int32_t aWidth,
-                                 int32_t aHeight,
-                                 int32_t aStride,
-                                 GMPVideoi420Frame* aVideoFrame)
-{
-  ENSURE(aSample != nullptr, E_POINTER);
-  ENSURE(aVideoFrame != nullptr, E_POINTER);
-
-  HRESULT hr;
-  CComPtr<IMFMediaBuffer> mediaBuffer;
-
-  // Must convert to contiguous mediaBuffer to use IMD2DBuffer interface.
-  hr = aSample->ConvertToContiguousBuffer(&mediaBuffer);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  // Try and use the IMF2DBuffer interface if available, otherwise fallback
-  // to the IMFMediaBuffer interface. Apparently IMF2DBuffer is more efficient,
-  // but only some systems (Windows 8?) support it.
-  BYTE* data = nullptr;
-  LONG stride = 0;
-  CComPtr<IMF2DBuffer> twoDBuffer;
-  hr = mediaBuffer->QueryInterface(static_cast<IMF2DBuffer**>(&twoDBuffer));
-  if (SUCCEEDED(hr)) {
-    hr = twoDBuffer->Lock2D(&data, &stride);
-    ENSURE(SUCCEEDED(hr), hr);
-  } else {
-    hr = mediaBuffer->Lock(&data, NULL, NULL);
-    ENSURE(SUCCEEDED(hr), hr);
-    stride = aStride;
-  }
-
-  // The V and U planes are stored 16-row-aligned, so we need to add padding
-  // to the row heights to ensure the Y'CbCr planes are referenced properly.
-  // YV12, planar format: [YYYY....][VVVV....][UUUU....]
-  // i.e., Y, then V, then U.
-  uint32_t padding = 0;
-  if (aHeight % 16 != 0) {
-    padding = 16 - (aHeight % 16);
-  }
-  int32_t y_size = stride * (aHeight + padding);
-  int32_t v_size = stride * (aHeight + padding) / 4;
-  int32_t halfStride = (stride + 1) / 2;
-  int32_t halfHeight = (aHeight + 1) / 2;
-
-  aVideoFrame->CreateEmptyFrame(stride, aHeight, stride, halfStride, halfStride);
-
-  auto err = aVideoFrame->SetWidth(aWidth);
-  ENSURE(GMP_SUCCEEDED(err), E_FAIL);
-  err = aVideoFrame->SetHeight(aHeight);
-  ENSURE(GMP_SUCCEEDED(err), E_FAIL);
-
-  uint8_t* outBuffer = aVideoFrame->Buffer(kGMPYPlane);
-  ENSURE(outBuffer != nullptr, E_FAIL);
-  assert(aVideoFrame->AllocatedSize(kGMPYPlane) >= stride*aHeight);
-  memcpy(outBuffer, data, stride*aHeight);
-
-  outBuffer = aVideoFrame->Buffer(kGMPUPlane);
-  ENSURE(outBuffer != nullptr, E_FAIL);
-  assert(aVideoFrame->AllocatedSize(kGMPUPlane) >= halfStride*halfHeight);
-  memcpy(outBuffer, data+y_size, halfStride*halfHeight);
-
-  outBuffer = aVideoFrame->Buffer(kGMPVPlane);
-  ENSURE(outBuffer != nullptr, E_FAIL);
-  assert(aVideoFrame->AllocatedSize(kGMPVPlane) >= halfStride*halfHeight);
-  memcpy(outBuffer, data + y_size + v_size, halfStride*halfHeight);
-
-  if (twoDBuffer) {
-    twoDBuffer->Unlock2D();
-  } else {
-    mediaBuffer->Unlock();
-  }
-
-  LONGLONG hns = 0;
-  hr = aSample->GetSampleTime(&hns);
-  ENSURE(SUCCEEDED(hr), hr);
-  aVideoFrame->SetTimestamp(HNsToUsecs(hns));
-
-  hr = aSample->GetSampleDuration(&hns);
-  ENSURE(SUCCEEDED(hr), hr);
-  aVideoFrame->SetDuration(HNsToUsecs(hns));
-
-  return S_OK;
-}
-
-void
-VideoDecoder::Reset()
-{
-  if (mDecoder) {
-    mDecoder->Reset();
-  }
-  if (mCallback) {
-    mCallback->ResetComplete();
-  }
-}
-
-void
-VideoDecoder::DrainTask()
-{
-  mDecoder->Drain();
-
-  // Return any pending output.
-  HRESULT hr = S_OK;
-  while (hr == S_OK) {
-    CComPtr<IMFSample> output;
-    hr = mDecoder->Output(&output);
-    CK_LOGD("VideoDecoder::DrainTask() output ret=0x%x\n", hr);
-    if (hr == S_OK) {
-      MaybeRunOnMainThread(
-        WrapTask(this,
-                 &VideoDecoder::ReturnOutput,
-                 CComPtr<IMFSample>(mozilla::Move(output)),
-                 mDecoder->GetFrameWidth(),
-                 mDecoder->GetFrameHeight(),
-                 mDecoder->GetStride()));
-      assert(!output.Get());
-    }
-  }
-  MaybeRunOnMainThread(WrapTask(mCallback, &GMPVideoDecoderCallback::DrainComplete));
-}
-
-void
-VideoDecoder::Drain()
-{
-  if (!mDecoder) {
-    if (mCallback) {
-      mCallback->DrainComplete();
-    }
-    return;
-  }
-  EnsureWorker();
-  mWorkerThread->Post(WrapTask(this,
-                               &VideoDecoder::DrainTask));
-}
-
-void
-VideoDecoder::DecodingComplete()
-{
-  if (mWorkerThread) {
-    mWorkerThread->Join();
-  }
-  mHasShutdown = true;
-
-  // Worker thread might have dispatched more tasks to the main thread that need this object.
-  // Append another task to delete |this|.
-  GetPlatform()->runonmainthread(WrapTask(this, &VideoDecoder::Destroy));
-}
-
-void
-VideoDecoder::Destroy()
-{
-  delete this;
-}
-
-void
-VideoDecoder::MaybeRunOnMainThread(gmp_task_args_base* aTask)
-{
-  class MaybeRunTask : public GMPTask
-  {
-  public:
-    MaybeRunTask(VideoDecoder* aDecoder, gmp_task_args_base* aTask)
-      : mDecoder(aDecoder), mTask(aTask)
-    { }
-
-    virtual void Run(void) {
-      if (mDecoder->HasShutdown()) {
-        CK_LOGD("Trying to dispatch to main thread after VideoDecoder has shut down");
-        return;
-      }
-
-      mTask->Run();
-    }
-
-    virtual void Destroy()
-    {
-      mTask->Destroy();
-      delete this;
-    }
-
-  private:
-    VideoDecoder* mDecoder;
-    gmp_task_args_base* mTask;
-  };
-
-  GetPlatform()->runonmainthread(new MaybeRunTask(this, aTask));
-}
diff --git a/media/gmp-clearkey/0.1/VideoDecoder.h b/media/gmp-clearkey/0.1/VideoDecoder.h
deleted file mode 100644
index e96dca5..0000000
--- a/media/gmp-clearkey/0.1/VideoDecoder.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright 2013, Mozilla Foundation and contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef __VideoDecoder_h__
-#define __VideoDecoder_h__
-
-#include "gmp-task-utils.h"
-#include "gmp-video-decode.h"
-#include "gmp-video-host.h"
-#include "WMFH264Decoder.h"
-
-#include "mfobjects.h"
-
-class VideoDecoder : public GMPVideoDecoder
-{
-public:
-  VideoDecoder(GMPVideoHost *aHostAPI);
-
-  virtual ~VideoDecoder();
-
-  virtual void InitDecode(const GMPVideoCodec& aCodecSettings,
-                          const uint8_t* aCodecSpecific,
-                          uint32_t aCodecSpecificLength,
-                          GMPVideoDecoderCallback* aCallback,
-                          int32_t aCoreCount) override;
-
-  virtual void Decode(GMPVideoEncodedFrame* aInputFrame,
-                      bool aMissingFrames,
-                      const uint8_t* aCodecSpecific,
-                      uint32_t aCodecSpecificLength,
-                      int64_t aRenderTimeMs = -1);
-
-  virtual void Reset() override;
-
-  virtual void Drain() override;
-
-  virtual void DecodingComplete() override;
-
-  bool HasShutdown() { return mHasShutdown; }
-
-private:
-
-  void EnsureWorker();
-
-  void DrainTask();
-
-  void DecodeTask(GMPVideoEncodedFrame* aInputFrame);
-
-  void ReturnOutput(IMFSample* aSample,
-                    int32_t aWidth,
-                    int32_t aHeight,
-                    int32_t aStride);
-
-  HRESULT SampleToVideoFrame(IMFSample* aSample,
-                             int32_t aWidth,
-                             int32_t aHeight,
-                             int32_t aStride,
-                             GMPVideoi420Frame* aVideoFrame);
-
-  void MaybeRunOnMainThread(gmp_task_args_base* aTask);
-  void Destroy();
-
-  GMPVideoHost *mHostAPI; // host-owned, invalid at DecodingComplete
-  GMPVideoDecoderCallback* mCallback; // host-owned, invalid at DecodingComplete
-  GMPThread* mWorkerThread;
-  GMPMutex* mMutex;
-  wmf::AutoPtr<wmf::WMFH264Decoder> mDecoder;
-
-  std::vector<uint8_t> mExtraData;
-  std::vector<uint8_t> mAnnexB;
-
-  int32_t mNumInputTasks;
-  bool mSentExtraData;
-
-  bool mHasShutdown;
-};
-
-#endif // __VideoDecoder_h__
diff --git a/media/gmp-clearkey/0.1/WMFAACDecoder.cpp b/media/gmp-clearkey/0.1/WMFAACDecoder.cpp
deleted file mode 100644
index 495f840..0000000
--- a/media/gmp-clearkey/0.1/WMFAACDecoder.cpp
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * Copyright 2013, Mozilla Foundation and contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "WMFAACDecoder.h"
-#include <algorithm>
-#include <stdint.h>
-#include <vector>
-
-using std::vector;
-
-namespace wmf {
-
-WMFAACDecoder::WMFAACDecoder()
-  : mDecoder(nullptr)
-  , mChannels(0)
-  , mRate(0)
-{
-  memset(&mInputStreamInfo, 0, sizeof(MFT_INPUT_STREAM_INFO));
-  memset(&mOutputStreamInfo, 0, sizeof(MFT_OUTPUT_STREAM_INFO));
-}
-
-WMFAACDecoder::~WMFAACDecoder()
-{
-  Reset();
-}
-
-HRESULT
-AACAudioSpecificConfigToUserData(BYTE* aAudioSpecConfig, UINT32 aConfigLength,
-                                 BYTE** aOutUserData, UINT32* aOutUserDataLength)
-{
-  // For MFAudioFormat_AAC, MF_MT_USER_DATA
-  // Contains the portion of the HEAACWAVEINFO structure that appears
-  // after the WAVEFORMATEX structure (that is, after the wfx member).
-  // This is followed by the AudioSpecificConfig() data, as defined
-  // by ISO/IEC 14496-3.
-  // ...
-  // The length of the AudioSpecificConfig() data is 2 bytes for AAC-LC
-  // or HE-AAC with implicit signaling of SBR/PS. It is more than 2 bytes
-  // for HE-AAC with explicit signaling of SBR/PS.
-  //
-  // The value of audioObjectType as defined in AudioSpecificConfig()
-  // must be 2, indicating AAC-LC. The value of extensionAudioObjectType
-  // must be 5 for SBR or 29 for PS.
-  //
-  // See:
-  // http://msdn.microsoft.com/en-us/library/windows/desktop/dd742784%28v=vs.85%29.aspx
-  //
-  // HEAACWAVEINFO structure:
-  //    typedef struct heaacwaveinfo_tag {
-  //      WAVEFORMATEX wfx;
-  //      WORD         wPayloadType;
-  //      WORD         wAudioProfileLevelIndication;
-  //      WORD         wStructType;
-  //      WORD         wReserved1;
-  //      DWORD        dwReserved2;
-  //    }
-  const UINT32 heeInfoLen = 4 * sizeof(WORD) + sizeof(DWORD);
-  BYTE heeInfo[heeInfoLen] = {0};
-  WORD* w = (WORD*)heeInfo;
-  w[0] = 0x0; // Payload type raw AAC
-  w[1] = 0; // Profile level unspecified
-
-  const UINT32 len =  heeInfoLen + aConfigLength;
-  BYTE* data = new BYTE[len];
-  memcpy(data, heeInfo, heeInfoLen);
-  memcpy(data+heeInfoLen, aAudioSpecConfig, aConfigLength);
-  *aOutUserData = data;
-  *aOutUserDataLength = len;
-  return S_OK;
-}
-
-HRESULT
-WMFAACDecoder::Init(int32_t aChannelCount,
-                    int32_t aSampleRate,
-                    BYTE* aAACAudioSpecificConfig,
-                    UINT32 aAudioConfigLength)
-{
-  HRESULT hr;
-
-  // AAC decoder is in msauddecmft on Win8, and msmpeg2adec in earlier versions.
-  hr = CreateMFT(CLSID_CMSAACDecMFT,
-                 WMFDecoderDllNameFor(AAC),
-                 mDecoder);
-  if (FAILED(hr)) {
-    hr = CreateMFT(CLSID_CMSAACDecMFT,
-                   WMFDecoderDllNameFor(AAC),
-                   mDecoder);
-    if (FAILED(hr)) {
-      LOG("Failed to create AAC decoder\n");
-      return E_FAIL;
-    }
-  }
-
-  BYTE* userData = nullptr;
-  UINT32 userDataLength;
-  hr = AACAudioSpecificConfigToUserData(aAACAudioSpecificConfig,
-                                        aAudioConfigLength,
-                                        &userData,
-                                        &userDataLength);
-  ENSURE(SUCCEEDED(hr), hr);
-  hr = SetDecoderInputType(aChannelCount, aSampleRate, userData, userDataLength);
-  delete userData;
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = SetDecoderOutputType();
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = SendMFTMessage(MFT_MESSAGE_NOTIFY_BEGIN_STREAMING, 0);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = SendMFTMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, 0);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = mDecoder->GetInputStreamInfo(0, &mInputStreamInfo);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = mDecoder->GetOutputStreamInfo(0, &mOutputStreamInfo);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  return S_OK;
-}
-
-HRESULT
-WMFAACDecoder::SetDecoderInputType(int32_t aChannelCount,
-                                   int32_t aSampleRate,
-                                   BYTE* aUserData,
-                                   UINT32 aUserDataLength)
-{
-  HRESULT hr;
-
-  CComPtr<IMFMediaType> type;
-  hr = MFCreateMediaType(&type);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = type->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Audio);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = type->SetGUID(MF_MT_SUBTYPE, MFAudioFormat_AAC);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  mRate = aSampleRate;
-  hr = type->SetUINT32(MF_MT_AUDIO_SAMPLES_PER_SECOND, mRate);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  mChannels = aChannelCount;
-  hr = type->SetUINT32(MF_MT_AUDIO_NUM_CHANNELS, mChannels);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = type->SetBlob(MF_MT_USER_DATA, aUserData, aUserDataLength);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = mDecoder->SetInputType(0, type, 0);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  return S_OK;
-}
-
-HRESULT
-WMFAACDecoder::SetDecoderOutputType()
-{
-  HRESULT hr;
-
-  CComPtr<IMFMediaType> type;
-
-  UINT32 typeIndex = 0;
-  while (type = nullptr, SUCCEEDED(mDecoder->GetOutputAvailableType(0, typeIndex++, &type))) {
-    GUID subtype;
-    hr = type->GetGUID(MF_MT_SUBTYPE, &subtype);
-    if (FAILED(hr)) {
-      continue;
-    }
-    if (subtype == MFAudioFormat_PCM) {
-      hr = mDecoder->SetOutputType(0, type, 0);
-      ENSURE(SUCCEEDED(hr), hr);
-
-      hr = type->GetUINT32(MF_MT_AUDIO_NUM_CHANNELS, &mChannels);
-      ENSURE(SUCCEEDED(hr), hr);
-
-      hr = type->GetUINT32(MF_MT_AUDIO_SAMPLES_PER_SECOND, &mRate);
-      ENSURE(SUCCEEDED(hr), hr);
-
-      return S_OK;
-    }
-  }
-
-  return E_FAIL;
-}
-
-HRESULT
-WMFAACDecoder::SendMFTMessage(MFT_MESSAGE_TYPE aMsg, UINT32 aData)
-{
-  ENSURE(mDecoder != nullptr, E_POINTER);
-  HRESULT hr = mDecoder->ProcessMessage(aMsg, aData);
-  ENSURE(SUCCEEDED(hr), hr);
-  return S_OK;
-}
-
-HRESULT
-WMFAACDecoder::CreateInputSample(const uint8_t* aData,
-                                 uint32_t aDataSize,
-                                 Microseconds aTimestamp,
-                                 IMFSample** aOutSample)
-{
-  HRESULT hr;
-  CComPtr<IMFSample> sample = nullptr;
-  hr = MFCreateSample(&sample);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  CComPtr<IMFMediaBuffer> buffer = nullptr;
-  int32_t bufferSize = std::max<uint32_t>(uint32_t(mInputStreamInfo.cbSize), aDataSize);
-  UINT32 alignment = (mInputStreamInfo.cbAlignment > 1) ? mInputStreamInfo.cbAlignment - 1 : 0;
-  hr = MFCreateAlignedMemoryBuffer(bufferSize, alignment, &buffer);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  DWORD maxLength = 0;
-  DWORD currentLength = 0;
-  BYTE* dst = nullptr;
-  hr = buffer->Lock(&dst, &maxLength, &currentLength);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  // Copy data into sample's buffer.
-  memcpy(dst, aData, aDataSize);
-
-  hr = buffer->Unlock();
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = buffer->SetCurrentLength(aDataSize);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = sample->AddBuffer(buffer);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = sample->SetSampleTime(UsecsToHNs(aTimestamp));
-  ENSURE(SUCCEEDED(hr), hr);
-
-  *aOutSample = sample.Detach();
-
-  return S_OK;
-}
-
-HRESULT
-WMFAACDecoder::CreateOutputSample(IMFSample** aOutSample)
-{
-  HRESULT hr;
-  CComPtr<IMFSample> sample = nullptr;
-  hr = MFCreateSample(&sample);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  CComPtr<IMFMediaBuffer> buffer = nullptr;
-  int32_t bufferSize = mOutputStreamInfo.cbSize;
-  UINT32 alignment = (mOutputStreamInfo.cbAlignment > 1) ? mOutputStreamInfo.cbAlignment - 1 : 0;
-  hr = MFCreateAlignedMemoryBuffer(bufferSize, alignment, &buffer);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = sample->AddBuffer(buffer);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  *aOutSample = sample.Detach();
-
-  return S_OK;
-}
-
-
-HRESULT
-WMFAACDecoder::GetOutputSample(IMFSample** aOutSample)
-{
-  HRESULT hr;
-  // We allocate samples for MFT output.
-  MFT_OUTPUT_DATA_BUFFER output = {0};
-
-  CComPtr<IMFSample> sample = nullptr;
-  hr = CreateOutputSample(&sample);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  output.pSample = sample;
-
-  DWORD status = 0;
-  hr = mDecoder->ProcessOutput(0, 1, &output, &status);
-  CComPtr<IMFCollection> events = output.pEvents; // Ensure this is released.
-
-  if (hr == MF_E_TRANSFORM_STREAM_CHANGE) {
-    // Type change. Probably geometric apperature change.
-    hr = SetDecoderOutputType();
-    ENSURE(SUCCEEDED(hr), hr);
-
-    return GetOutputSample(aOutSample);
-  } else if (hr == MF_E_TRANSFORM_NEED_MORE_INPUT || !sample) {
-    return MF_E_TRANSFORM_NEED_MORE_INPUT;
-  }
-  // Treat other errors as fatal.
-  ENSURE(SUCCEEDED(hr), hr);
-
-  assert(sample);
-
-  *aOutSample = sample.Detach();
-  return S_OK;
-}
-
-HRESULT
-WMFAACDecoder::Input(const uint8_t* aData,
-                     uint32_t aDataSize,
-                     Microseconds aTimestamp)
-{
-  CComPtr<IMFSample> input = nullptr;
-  HRESULT hr = CreateInputSample(aData, aDataSize, aTimestamp, &input);
-  ENSURE(SUCCEEDED(hr) && input!=nullptr, hr);
-
-  hr = mDecoder->ProcessInput(0, input, 0);
-  if (hr == MF_E_NOTACCEPTING) {
-    // MFT *already* has enough data to produce a sample. Retrieve it.
-    LOG("ProcessInput returned MF_E_NOTACCEPTING\n");
-    return MF_E_NOTACCEPTING;
-  }
-  ENSURE(SUCCEEDED(hr), hr);
-
-  return S_OK;
-}
-
-HRESULT
-WMFAACDecoder::Output(IMFSample** aOutput)
-{
-  CComPtr<IMFSample> outputSample = nullptr;
-  HRESULT hr = GetOutputSample(&outputSample);
-  if (hr == MF_E_TRANSFORM_NEED_MORE_INPUT) {
-    return MF_E_TRANSFORM_NEED_MORE_INPUT;
-  }
-  // Treat other errors as fatal.
-  ENSURE(SUCCEEDED(hr) && outputSample, hr);
-
-  *aOutput = outputSample.Detach();
-
-  return S_OK;
-}
-
-HRESULT
-WMFAACDecoder::Reset()
-{
-  HRESULT hr = SendMFTMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  return S_OK;
-}
-
-HRESULT
-WMFAACDecoder::Drain()
-{
-  HRESULT hr = SendMFTMessage(MFT_MESSAGE_COMMAND_DRAIN, 0);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  return S_OK;
-}
-
-}
diff --git a/media/gmp-clearkey/0.1/WMFAACDecoder.h b/media/gmp-clearkey/0.1/WMFAACDecoder.h
deleted file mode 100644
index 3099eee..0000000
--- a/media/gmp-clearkey/0.1/WMFAACDecoder.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright 2013, Mozilla Foundation and contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#if !defined(WMFAACDecoder_h_)
-#define WMFAACDecoder_h_
-
-#include "WMFUtils.h"
-
-namespace wmf {
-
-class WMFAACDecoder {
-public:
-  WMFAACDecoder();
-  ~WMFAACDecoder();
-
-  HRESULT Init(int32_t aChannelCount,
-               int32_t aSampleRate,
-               BYTE* aUserData,
-               UINT32 aUserDataLength);
-
-  HRESULT Input(const uint8_t* aData,
-                uint32_t aDataSize,
-                Microseconds aTimestamp);
-
-  HRESULT Output(IMFSample** aOutput);
-
-  HRESULT Reset();
-
-  HRESULT Drain();
-
-  UINT32 Channels() const { return mChannels; }
-  UINT32 Rate() const { return mRate; }
-
-private:
-
-  HRESULT GetOutputSample(IMFSample** aOutSample);
-  HRESULT CreateOutputSample(IMFSample** aOutSample);
-  HRESULT CreateInputSample(const uint8_t* aData,
-                            uint32_t aDataSize,
-                            Microseconds aTimestamp,
-                            IMFSample** aOutSample);
-
-  HRESULT SetDecoderInputType(int32_t aChannelCount,
-                              int32_t aSampleRate,
-                              BYTE* aUserData,
-                              UINT32 aUserDataLength);
-  HRESULT SetDecoderOutputType();
-  HRESULT SendMFTMessage(MFT_MESSAGE_TYPE aMsg, UINT32 aData);
-
-  MFT_INPUT_STREAM_INFO mInputStreamInfo;
-  MFT_OUTPUT_STREAM_INFO mOutputStreamInfo;
-
-  CComPtr<IMFTransform> mDecoder;
-
-  UINT32 mChannels;
-  UINT32 mRate;
-};
-
-}
-
-#endif
diff --git a/media/gmp-clearkey/0.1/WMFH264Decoder.cpp b/media/gmp-clearkey/0.1/WMFH264Decoder.cpp
deleted file mode 100644
index c039741..0000000
--- a/media/gmp-clearkey/0.1/WMFH264Decoder.cpp
+++ /dev/null
@@ -1,350 +0,0 @@
-/*
- * Copyright 2013, Mozilla Foundation and contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "WMFH264Decoder.h"
-#include <algorithm>
-
-namespace wmf {
-
-WMFH264Decoder::WMFH264Decoder()
-  : mDecoder(nullptr)
-{
-  memset(&mInputStreamInfo, 0, sizeof(MFT_INPUT_STREAM_INFO));
-  memset(&mOutputStreamInfo, 0, sizeof(MFT_OUTPUT_STREAM_INFO));
-}
-
-WMFH264Decoder::~WMFH264Decoder()
-{
-}
-
-HRESULT
-WMFH264Decoder::Init()
-{
-  HRESULT hr;
-
-  hr = CreateMFT(__uuidof(CMSH264DecoderMFT),
-                 WMFDecoderDllNameFor(H264),
-                 mDecoder);
-  if (FAILED(hr)) {
-    // Windows 7 Enterprise Server N (which is what Mozilla's mochitests run
-    // on) need a different CLSID to instantiate the H.264 decoder.
-    hr = CreateMFT(CLSID_CMSH264DecMFT,
-                   WMFDecoderDllNameFor(H264),
-                   mDecoder);
-  }
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = SetDecoderInputType();
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = SetDecoderOutputType();
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = SendMFTMessage(MFT_MESSAGE_NOTIFY_BEGIN_STREAMING, 0);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = SendMFTMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, 0);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = mDecoder->GetInputStreamInfo(0, &mInputStreamInfo);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = mDecoder->GetOutputStreamInfo(0, &mOutputStreamInfo);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  return S_OK;
-}
-
-HRESULT
-WMFH264Decoder::ConfigureVideoFrameGeometry(IMFMediaType* aMediaType)
-{
-  ENSURE(aMediaType != nullptr, E_POINTER);
-  HRESULT hr;
-
-  IntRect pictureRegion;
-  hr = wmf::GetPictureRegion(aMediaType, pictureRegion);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  UINT32 width = 0, height = 0;
-  hr = MFGetAttributeSize(aMediaType, MF_MT_FRAME_SIZE, &width, &height);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  // Success! Save state.
-  GetDefaultStride(aMediaType, (UINT32*)&mStride);
-  mVideoWidth = width;
-  mVideoHeight = height;
-  mPictureRegion = pictureRegion;
-
-  LOG("WMFH264Decoder frame geometry frame=(%u,%u) stride=%u picture=(%d, %d, %d, %d)\n",
-      width, height,
-      mStride,
-      mPictureRegion.x, mPictureRegion.y, mPictureRegion.width, mPictureRegion.height);
-
-  return S_OK;
-}
-
-int32_t
-WMFH264Decoder::GetFrameWidth() const
-{
-  return mVideoWidth;
-}
-
-int32_t
-WMFH264Decoder::GetFrameHeight() const
-{
-  return mVideoHeight;
-}
-
-const IntRect&
-WMFH264Decoder::GetPictureRegion() const
-{
-  return mPictureRegion;
-}
-
-int32_t
-WMFH264Decoder::GetStride() const
-{
-  return mStride;
-}
-
-HRESULT
-WMFH264Decoder::SetDecoderInputType()
-{
-  HRESULT hr;
-
-  CComPtr<IMFMediaType> type;
-  hr = MFCreateMediaType(&type);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = type->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = type->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_H264);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = type->SetUINT32(MF_MT_INTERLACE_MODE, MFVideoInterlace_MixedInterlaceOrProgressive);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = mDecoder->SetInputType(0, type, 0);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  return S_OK;
-}
-
-HRESULT
-WMFH264Decoder::SetDecoderOutputType()
-{
-  HRESULT hr;
-
-  CComPtr<IMFMediaType> type;
-
-  UINT32 typeIndex = 0;
-  while (type = nullptr, SUCCEEDED(mDecoder->GetOutputAvailableType(0, typeIndex++, &type))) {
-    GUID subtype;
-    hr = type->GetGUID(MF_MT_SUBTYPE, &subtype);
-    if (FAILED(hr)) {
-      continue;
-    }
-    if (subtype == MFVideoFormat_I420 || subtype == MFVideoFormat_IYUV) {
-      // On Windows 7 Enterprise N the MFT reports it reports IYUV instead
-      // of I420. Other Windows' report I420. The formats are the same, so
-      // support both.
-      hr = mDecoder->SetOutputType(0, type, 0);
-      ENSURE(SUCCEEDED(hr), hr);
-
-      hr = ConfigureVideoFrameGeometry(type);
-      ENSURE(SUCCEEDED(hr), hr);
-
-      return S_OK;
-    }
-  }
-
-  return E_FAIL;
-}
-
-HRESULT
-WMFH264Decoder::SendMFTMessage(MFT_MESSAGE_TYPE aMsg, UINT32 aData)
-{
-  ENSURE(mDecoder != nullptr, E_POINTER);
-  HRESULT hr = mDecoder->ProcessMessage(aMsg, aData);
-  ENSURE(SUCCEEDED(hr), hr);
-  return S_OK;
-}
-
-HRESULT
-WMFH264Decoder::CreateInputSample(const uint8_t* aData,
-                                  uint32_t aDataSize,
-                                  Microseconds aTimestamp,
-                                  Microseconds aDuration,
-                                  IMFSample** aOutSample)
-{
-  HRESULT hr;
-  CComPtr<IMFSample> sample;
-  hr = MFCreateSample(&sample);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  CComPtr<IMFMediaBuffer> buffer;
-  int32_t bufferSize = std::max<uint32_t>(uint32_t(mInputStreamInfo.cbSize), aDataSize);
-  UINT32 alignment = (mInputStreamInfo.cbAlignment > 1) ? mInputStreamInfo.cbAlignment - 1 : 0;
-  hr = MFCreateAlignedMemoryBuffer(bufferSize, alignment, &buffer);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  DWORD maxLength = 0;
-  DWORD currentLength = 0;
-  BYTE* dst = nullptr;
-  hr = buffer->Lock(&dst, &maxLength, &currentLength);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  // Copy data into sample's buffer.
-  memcpy(dst, aData, aDataSize);
-
-  hr = buffer->Unlock();
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = buffer->SetCurrentLength(aDataSize);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = sample->AddBuffer(buffer);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = sample->SetSampleTime(UsecsToHNs(aTimestamp));
-  ENSURE(SUCCEEDED(hr), hr);
-
-  sample->SetSampleDuration(UsecsToHNs(aDuration));
-
-  *aOutSample = sample.Detach();
-
-  return S_OK;
-}
-
-HRESULT
-WMFH264Decoder::CreateOutputSample(IMFSample** aOutSample)
-{
-  HRESULT hr;
-  CComPtr<IMFSample> sample;
-  hr = MFCreateSample(&sample);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  CComPtr<IMFMediaBuffer> buffer;
-  int32_t bufferSize = mOutputStreamInfo.cbSize;
-  UINT32 alignment = (mOutputStreamInfo.cbAlignment > 1) ? mOutputStreamInfo.cbAlignment - 1 : 0;
-  hr = MFCreateAlignedMemoryBuffer(bufferSize, alignment, &buffer);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = sample->AddBuffer(buffer);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  *aOutSample = sample.Detach();
-
-  return S_OK;
-}
-
-
-HRESULT
-WMFH264Decoder::GetOutputSample(IMFSample** aOutSample)
-{
-  HRESULT hr;
-  // We allocate samples for MFT output.
-  MFT_OUTPUT_DATA_BUFFER output = {0};
-
-  CComPtr<IMFSample> sample;
-  hr = CreateOutputSample(&sample);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  output.pSample = sample;
-
-  DWORD status = 0;
-  hr = mDecoder->ProcessOutput(0, 1, &output, &status);
-  //LOG(L"WMFH264Decoder::GetOutputSample() ProcessOutput returned 0x%x\n", hr);
-  CComPtr<IMFCollection> events = output.pEvents; // Ensure this is released.
-
-  if (hr == MF_E_TRANSFORM_STREAM_CHANGE) {
-    // Type change. Probably geometric apperature change.
-    hr = SetDecoderOutputType();
-    ENSURE(SUCCEEDED(hr), hr);
-
-    return GetOutputSample(aOutSample);
-  } else if (hr == MF_E_TRANSFORM_NEED_MORE_INPUT) {
-    return MF_E_TRANSFORM_NEED_MORE_INPUT;
-  }
-  // Treat other errors as fatal.
-  ENSURE(SUCCEEDED(hr), hr);
-
-  assert(sample);
-
-  // output.pSample
-  *aOutSample = sample.Detach(); // AddRefs
-  return S_OK;
-}
-
-HRESULT
-WMFH264Decoder::Input(const uint8_t* aData,
-                      uint32_t aDataSize,
-                      Microseconds aTimestamp,
-                      Microseconds aDuration)
-{
-  HRESULT hr;
-  CComPtr<IMFSample> input = nullptr;
-  hr = CreateInputSample(aData, aDataSize, aTimestamp, aDuration, &input);
-  ENSURE(SUCCEEDED(hr) && input!=nullptr, hr);
-
-  hr = mDecoder->ProcessInput(0, input, 0);
-  if (hr == MF_E_NOTACCEPTING) {
-    // MFT *already* has enough data to produce a sample. Retrieve it.
-    LOG("ProcessInput returned MF_E_NOTACCEPTING\n");
-    return MF_E_NOTACCEPTING;
-  }
-  ENSURE(SUCCEEDED(hr), hr);
-
-  return S_OK;
-}
-
-HRESULT
-WMFH264Decoder::Output(IMFSample** aOutput)
-{
-  HRESULT hr;
-  CComPtr<IMFSample> outputSample;
-  hr = GetOutputSample(&outputSample);
-  if (hr == MF_E_TRANSFORM_NEED_MORE_INPUT) {
-    return MF_E_TRANSFORM_NEED_MORE_INPUT;
-  }
-  // Treat other errors as fatal.
-  ENSURE(SUCCEEDED(hr) && outputSample, hr);
-
-  *aOutput = outputSample.Detach();
-
-  return S_OK;
-}
-
-HRESULT
-WMFH264Decoder::Reset()
-{
-  HRESULT hr = SendMFTMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  return S_OK;
-}
-
-HRESULT
-WMFH264Decoder::Drain()
-{
-  HRESULT hr = SendMFTMessage(MFT_MESSAGE_COMMAND_DRAIN, 0);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  return S_OK;
-}
-
-} // namespace wmf
diff --git a/media/gmp-clearkey/0.1/WMFH264Decoder.h b/media/gmp-clearkey/0.1/WMFH264Decoder.h
deleted file mode 100644
index 2d2b396..0000000
--- a/media/gmp-clearkey/0.1/WMFH264Decoder.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright 2013, Mozilla Foundation and contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#if !defined(WMFH264Decoder_h_)
-#define WMFH264Decoder_h_
-
-#include "WMFUtils.h"
-
-namespace wmf {
-
-class WMFH264Decoder {
-public:
-  WMFH264Decoder();
-  ~WMFH264Decoder();
-
-  HRESULT Init();
-
-  HRESULT Input(const uint8_t* aData,
-                uint32_t aDataSize,
-                Microseconds aTimestamp,
-                Microseconds aDuration);
-
-  HRESULT Output(IMFSample** aOutput);
-
-  HRESULT Reset();
-
-  int32_t GetFrameWidth() const;
-  int32_t GetFrameHeight() const;
-  const IntRect& GetPictureRegion() const;
-  int32_t GetStride() const;
-
-  HRESULT Drain();
-
-private:
-
-  HRESULT SetDecoderInputType();
-  HRESULT SetDecoderOutputType();
-  HRESULT SendMFTMessage(MFT_MESSAGE_TYPE aMsg, UINT32 aData);
-
-  HRESULT CreateInputSample(const uint8_t* aData,
-                            uint32_t aDataSize,
-                            Microseconds aTimestamp,
-                            Microseconds aDuration,
-                            IMFSample** aOutSample);
-
-  HRESULT CreateOutputSample(IMFSample** aOutSample);
-
-  HRESULT GetOutputSample(IMFSample** aOutSample);
-  HRESULT ConfigureVideoFrameGeometry(IMFMediaType* aMediaType);
-
-  MFT_INPUT_STREAM_INFO mInputStreamInfo;
-  MFT_OUTPUT_STREAM_INFO mOutputStreamInfo;
-
-  CComPtr<IMFTransform> mDecoder;
-
-  int32_t mVideoWidth;
-  int32_t mVideoHeight;
-  IntRect mPictureRegion;
-  int32_t mStride;
-
-};
-
-} // namespace wmf
-
-#endif
diff --git a/media/gmp-clearkey/0.1/WMFSymbols.h b/media/gmp-clearkey/0.1/WMFSymbols.h
deleted file mode 100644
index f6302a2..0000000
--- a/media/gmp-clearkey/0.1/WMFSymbols.h
+++ /dev/null
@@ -1,8 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-MFPLAT_FUNC(MFCreateSample, "mfplat.dll");
-MFPLAT_FUNC(MFCreateAlignedMemoryBuffer, "mfplat.dll");
-MFPLAT_FUNC(MFGetStrideForBitmapInfoHeader, "evr.dll");
-MFPLAT_FUNC(MFCreateMediaType, "mfplat.dll");
\ No newline at end of file
diff --git a/media/gmp-clearkey/0.1/WMFUtils.cpp b/media/gmp-clearkey/0.1/WMFUtils.cpp
deleted file mode 100644
index afa6519..0000000
--- a/media/gmp-clearkey/0.1/WMFUtils.cpp
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- * Copyright 2013, Mozilla Foundation and contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "WMFUtils.h"
-#include "ClearKeyUtils.h"
-#include <versionhelpers.h>
-
-#include <stdio.h>
-
-#define INITGUID
-#include <guiddef.h>
-
-#pragma comment(lib, "mfuuid.lib")
-#pragma comment(lib, "wmcodecdspuuid")
-#pragma comment(lib, "mfplat.lib")
-
-void LOG(const char* format, ...)
-{
-#ifdef WMF_DECODER_LOG
-  va_list args;
-  va_start(args, format);
-  vprintf(format, args);
-#endif
-}
-
-#ifdef WMF_MUST_DEFINE_AAC_MFT_CLSID
-// Some SDK versions don't define the AAC decoder CLSID.
-// {32D186A7-218F-4C75-8876-DD77273A8999}
-DEFINE_GUID(CLSID_CMSAACDecMFT, 0x32D186A7, 0x218F, 0x4C75, 0x88, 0x76, 0xDD, 0x77, 0x27, 0x3A, 0x89, 0x99);
-#endif
-
-DEFINE_GUID(CLSID_CMSH264DecMFT, 0x62CE7E72, 0x4C71, 0x4d20, 0xB1, 0x5D, 0x45, 0x28, 0x31, 0xA8, 0x7D, 0x9D);
-
-namespace wmf {
-
-
-#define MFPLAT_FUNC(_func, _dllname) \
-  decltype(::_func)* _func;
-#include "WMFSymbols.h"
-#undef MFPLAT_FUNC
-
-static bool
-LinkMfplat()
-{
-  static bool sInitDone = false;
-  static bool sInitOk = false;
-  if (!sInitDone) {
-    sInitDone = true;
-    HMODULE handle;
-
-#define MFPLAT_FUNC(_func, _dllname) \
-      handle = GetModuleHandleA(_dllname); \
-      if (!(_func = (decltype(_func))(GetProcAddress(handle, #_func)))) { \
-        return false; \
-      }
-
-#include "WMFSymbols.h"
-#undef MFPLAT_FUNC
-    sInitOk = true;
-  }
-  return sInitOk;
-}
-
-const char*
-WMFDecoderDllNameFor(CodecType aCodec)
-{
-  if (aCodec == H264) {
-    // For H.264 decoding, we need msmpeg2vdec.dll on Win 7 & 8,
-    // and mfh264dec.dll on Vista.
-    if (IsWindows7OrGreater()) {
-      return "msmpeg2vdec.dll";
-    } else {
-      return "mfh264dec.dll";
-    }
-  } else if (aCodec == AAC) {
-    // For AAC decoding, we need to use msauddecmft.dll on Win8,
-    // msmpeg2adec.dll on Win7, and msheaacdec.dll on Vista.
-    if (IsWindows8OrGreater()) {
-      return "msauddecmft.dll";
-    } else if (IsWindows7OrGreater()) {
-      return "msmpeg2adec.dll";
-    } else {
-      return "mfheaacdec.dll";
-    }
-  } else {
-    return "";
-  }
-}
-
-
-bool
-EnsureLibs()
-{
-  static bool sInitDone = false;
-  static bool sInitOk = false;
-  if (!sInitDone) {
-    sInitOk = LinkMfplat() &&
-              !!GetModuleHandleA(WMFDecoderDllNameFor(AAC)) &&
-              !!GetModuleHandleA(WMFDecoderDllNameFor(H264));
-    sInitDone = true;
-  }
-  return sInitOk;
-}
-
-int32_t
-MFOffsetToInt32(const MFOffset& aOffset)
-{
-  return int32_t(aOffset.value + (aOffset.fract / 65536.0f));
-}
-
-// Gets the sub-region of the video frame that should be displayed.
-// See: http://msdn.microsoft.com/en-us/library/windows/desktop/bb530115(v=vs.85).aspx
-HRESULT
-GetPictureRegion(IMFMediaType* aMediaType, IntRect& aOutPictureRegion)
-{
-  // Determine if "pan and scan" is enabled for this media. If it is, we
-  // only display a region of the video frame, not the entire frame.
-  BOOL panScan = MFGetAttributeUINT32(aMediaType, MF_MT_PAN_SCAN_ENABLED, FALSE);
-
-  // If pan and scan mode is enabled. Try to get the display region.
-  HRESULT hr = E_FAIL;
-  MFVideoArea videoArea;
-  memset(&videoArea, 0, sizeof(MFVideoArea));
-  if (panScan) {
-    hr = aMediaType->GetBlob(MF_MT_PAN_SCAN_APERTURE,
-                             (UINT8*)&videoArea,
-                             sizeof(MFVideoArea),
-                             NULL);
-  }
-
-  // If we're not in pan-and-scan mode, or the pan-and-scan region is not set,
-  // check for a minimimum display aperture.
-  if (!panScan || hr == MF_E_ATTRIBUTENOTFOUND) {
-    hr = aMediaType->GetBlob(MF_MT_MINIMUM_DISPLAY_APERTURE,
-                             (UINT8*)&videoArea,
-                             sizeof(MFVideoArea),
-                             NULL);
-  }
-
-  if (hr == MF_E_ATTRIBUTENOTFOUND) {
-    // Minimum display aperture is not set, for "backward compatibility with
-    // some components", check for a geometric aperture.
-    hr = aMediaType->GetBlob(MF_MT_GEOMETRIC_APERTURE,
-                             (UINT8*)&videoArea,
-                             sizeof(MFVideoArea),
-                             NULL);
-  }
-
-  if (SUCCEEDED(hr)) {
-    // The media specified a picture region, return it.
-    aOutPictureRegion = IntRect(MFOffsetToInt32(videoArea.OffsetX),
-                                  MFOffsetToInt32(videoArea.OffsetY),
-                                  videoArea.Area.cx,
-                                  videoArea.Area.cy);
-    return S_OK;
-  }
-
-  // No picture region defined, fall back to using the entire video area.
-  UINT32 width = 0, height = 0;
-  hr = MFGetAttributeSize(aMediaType, MF_MT_FRAME_SIZE, &width, &height);
-  ENSURE(SUCCEEDED(hr), hr);
-  aOutPictureRegion = IntRect(0, 0, width, height);
-  return S_OK;
-}
-
-
-HRESULT
-GetDefaultStride(IMFMediaType *aType, uint32_t* aOutStride)
-{
-  // Try to get the default stride from the media type.
-  HRESULT hr = aType->GetUINT32(MF_MT_DEFAULT_STRIDE, aOutStride);
-  if (SUCCEEDED(hr)) {
-    return S_OK;
-  }
-
-  // Stride attribute not set, calculate it.
-  GUID subtype = GUID_NULL;
-  uint32_t width = 0;
-  uint32_t height = 0;
-
-  hr = aType->GetGUID(MF_MT_SUBTYPE, &subtype);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = MFGetAttributeSize(aType, MF_MT_FRAME_SIZE, &width, &height);
-  ENSURE(SUCCEEDED(hr), hr);
-
-  hr = MFGetStrideForBitmapInfoHeader(subtype.Data1, width, (LONG*)(aOutStride));
-  ENSURE(SUCCEEDED(hr), hr);
-
-  return hr;
-}
-
-void dump(const uint8_t* data, uint32_t len, const char* filename)
-{
-  FILE* f = 0;
-  fopen_s(&f, filename, "wb");
-  fwrite(data, len, 1, f);
-  fclose(f);
-}
-
-HRESULT
-CreateMFT(const CLSID& clsid,
-          const char* aDllName,
-          CComPtr<IMFTransform>& aOutMFT)
-{
-  HMODULE module = ::GetModuleHandleA(aDllName);
-  if (!module) {
-    LOG("Failed to get %S\n", aDllName);
-    return E_FAIL;
-  }
-
-  typedef HRESULT (WINAPI* DllGetClassObjectFnPtr)(const CLSID& clsid,
-                                                   const IID& iid,
-                                                   void** object);
-
-  DllGetClassObjectFnPtr GetClassObjPtr =
-    reinterpret_cast<DllGetClassObjectFnPtr>(GetProcAddress(module, "DllGetClassObject"));
-  if (!GetClassObjPtr) {
-    LOG("Failed to get DllGetClassObject\n");
-    return E_FAIL;
-  }
-
-  CComPtr<IClassFactory> classFactory;
-  HRESULT hr = GetClassObjPtr(clsid,
-                              __uuidof(IClassFactory),
-                              reinterpret_cast<void**>(static_cast<IClassFactory**>(&classFactory)));
-  if (FAILED(hr)) {
-    LOG("Failed to get H264 IClassFactory\n");
-    return E_FAIL;
-  }
-
-  hr = classFactory->CreateInstance(NULL,
-                                    __uuidof(IMFTransform),
-                                    reinterpret_cast<void**>(static_cast<IMFTransform**>(&aOutMFT)));
-  if (FAILED(hr)) {
-    LOG("Failed to get create MFT\n");
-    return E_FAIL;
-  }
-
-  return S_OK;
-}
-
-} // namespace
diff --git a/media/gmp-clearkey/0.1/WMFUtils.h b/media/gmp-clearkey/0.1/WMFUtils.h
deleted file mode 100644
index 6c938ef..0000000
--- a/media/gmp-clearkey/0.1/WMFUtils.h
+++ /dev/null
@@ -1,279 +0,0 @@
-/*
- * Copyright 2013, Mozilla Foundation and contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef __WMFUtils_h__
-#define __WMFUtils_h__
-
-#include <cstdint>
-#include <string>
-
-#include <assert.h>
-#include <mfapi.h>
-#include <mferror.h>
-#include <mfobjects.h>
-#include <mftransform.h>
-#include <wmcodecdsp.h>
-
-#include "gmp-platform.h"
-
-void LOG(const char* format, ...);
-
-#ifdef LOG_SAMPLE_DECODE
-#define SAMPLE_LOG LOG
-#else
-#define SAMPLE_LOG(...)
-#endif
-
-#ifndef CLSID_CMSAACDecMFT
-#define WMF_MUST_DEFINE_AAC_MFT_CLSID
-extern "C" const CLSID CLSID_CMSAACDecMFT;
-#endif
-
-extern "C" const CLSID CLSID_CMSH264DecMFT;
-
-namespace wmf {
-
-// Reimplementation of CComPtr to reduce dependence on system
-// shared libraries.
-template<class T>
-class CComPtr {
-public:
-  CComPtr(CComPtr&& aOther) : mPtr(aOther.Detach()) { }
-  CComPtr& operator=(CComPtr&& other) { mPtr = other.Detach(); }
-
-  CComPtr(const CComPtr& aOther) : mPtr(nullptr) { Set(aOther.Get()); }
-  CComPtr() : mPtr(nullptr) { }
-  CComPtr(T* const & aPtr) : mPtr(nullptr) { Set(aPtr); }
-  CComPtr(const nullptr_t& aNullPtr) : mPtr(aNullPtr) { }
-  T** operator&() { return &mPtr; }
-  T* operator->(){ return mPtr; }
-  operator T*() { return mPtr; }
-  T* operator=(T* const & aPtr) { return Set(aPtr); }
-  T* operator=(const nullptr_t& aPtr) { return mPtr = aPtr; }
-
-  T* Get() const { return mPtr; }
-
-  T* Detach() {
-    T* tmp = mPtr;
-    mPtr = nullptr;
-    return tmp;
-  }
-
-  ~CComPtr() {
-    if (mPtr) {
-      mPtr->Release();
-    }
-    mPtr = nullptr;
-  }
-
-private:
-
-  T* Set(T* aPtr) {
-    if (mPtr == aPtr) {
-      return aPtr;
-    }
-    if (mPtr) {
-      mPtr->Release();
-    }
-    mPtr = aPtr;
-    if (mPtr) {
-      mPtr->AddRef();
-    }
-    return mPtr;
-  }
-
-  T* mPtr;
-};
-
-class IntRect {
-public:
-  IntRect(int32_t _x, int32_t _y, int32_t _w, int32_t _h)
-    : x(_x), y(_y), width(_w), height(_h) {}
-  IntRect()
-    : x(0), y(0), width(0), height(0) {}
-  int32_t x;
-  int32_t y;
-  int32_t width;
-  int32_t height;
-};
-
-typedef int64_t Microseconds;
-
-#ifdef ENSURE
-#undef ENSURE
-#endif
-
-#define ENSURE(condition, ret) \
-{ if (!(condition)) { LOG("##condition## FAILED %S:%d\n", __FILE__, __LINE__); return ret; } }
-
-#define GMP_SUCCEEDED(x) ((x) == GMPNoErr)
-#define GMP_FAILED(x) ((x) != GMPNoErr)
-
-#define MFPLAT_FUNC(_func, _dllname) \
-  extern decltype(::_func)* _func;
-#include "WMFSymbols.h"
-#undef MFPLAT_FUNC
-
-bool
-EnsureLibs();
-
-HRESULT
-GetPictureRegion(IMFMediaType* aMediaType, IntRect& aOutPictureRegion);
-
-HRESULT
-GetDefaultStride(IMFMediaType *aType, uint32_t* aOutStride);
-
-// Converts from microseconds to hundreds of nanoseconds.
-// We use microseconds for our timestamps, whereas WMF uses
-// hundreds of nanoseconds.
-inline int64_t
-UsecsToHNs(int64_t aUsecs) {
-  return aUsecs * 10;
-}
-
-// Converts from hundreds of nanoseconds to microseconds.
-// We use microseconds for our timestamps, whereas WMF uses
-// hundreds of nanoseconds.
-inline int64_t
-HNsToUsecs(int64_t hNanoSecs) {
-  return hNanoSecs / 10;
-}
-
-inline std::string narrow(std::wstring &wide) {
-  std::string ns(wide.begin(), wide.end());
-  return ns;
-}
-
-inline std::wstring widen(std::string &narrow) {
-  std::wstring ws(narrow.begin(), narrow.end());
-  return ws;
-}
-
-#define ARRAY_LENGTH(array_) \
-  (sizeof(array_)/sizeof(array_[0]))
-
-template<class Type>
-class AutoPtr {
-public:
-  AutoPtr()
-    : mPtr(nullptr)
-  {
-  }
-
-  AutoPtr(AutoPtr<Type>& aPtr)
-    : mPtr(aPtr.Forget())
-  {
-  }
-
-  AutoPtr(Type* aPtr)
-    : mPtr(aPtr)
-  {
-  }
-
-  ~AutoPtr() {
-    if (mPtr) {
-      delete mPtr;
-    }
-  }
-
-  Type* Forget() {
-    Type* rv = mPtr;
-    mPtr = nullptr;
-    return rv;
-  }
-
-  AutoPtr<Type>& operator=(Type* aOther) {
-    Assign(aOther);
-    return *this;
-  }
-
-  AutoPtr<Type>& operator=(AutoPtr<Type>& aOther) {
-    Assign(aOther.Forget());
-    return *this;
-  }
-
-  Type* Get() const {
-    return mPtr;
-  }
-
-  Type* operator->() const {
-    assert(mPtr);
-    return Get();
-  }
-
-  operator Type*() const {
-    return Get();
-  }
-
-  Type** Receive() {
-    return &mPtr;
-  }
-private:
-
-  void Assign(Type* aPtr) {
-    if (mPtr) {
-      delete mPtr;
-    }
-    mPtr = aPtr;
-  }
-
-  Type* mPtr;
-};
-
-// Video frame microseconds are (currently) in 90kHz units, as used by RTP.
-// Use this to convert to microseconds...
-inline Microseconds RTPTimeToMicroseconds(int64_t rtptime) {
-  return (rtptime * 1000000) / 90000;
-}
-
-inline uint32_t MicrosecondsToRTPTime(Microseconds us) {
-  return uint32_t(0xffffffff & (us * 90000) / 1000000);
-}
-
-class AutoLock {
-public:
-  AutoLock(GMPMutex* aMutex)
-    : mMutex(aMutex)
-  {
-    assert(aMutex);
-    mMutex->Acquire();
-  }
-  ~AutoLock() {
-    mMutex->Release();
-  }
-private:
-  GMPMutex* mMutex;
-};
-
-void dump(const uint8_t* data, uint32_t len, const char* filename);
-
-HRESULT
-CreateMFT(const CLSID& clsid,
-          const char* aDllName,
-          CComPtr<IMFTransform>& aOutMFT);
-
-enum CodecType {
-  H264,
-  AAC,
-};
-
-// Returns the name of the DLL that is needed to decode H.264 or AAC on
-// the given windows version we're running on.
-const char* WMFDecoderDllNameFor(CodecType aCodec);
-
-} // namespace wmf
-
-#endif // __WMFUtils_h__
diff --git a/media/gmp-clearkey/0.1/clearkey.info.in b/media/gmp-clearkey/0.1/clearkey.info.in
deleted file mode 100644
index c60aaa0..0000000
--- a/media/gmp-clearkey/0.1/clearkey.info.in
+++ /dev/null
@@ -1,10 +0,0 @@
-Name: clearkey
-Description: ClearKey Goanna Media Plugin
-Version: 1
-#ifdef ENABLE_WMF
-APIs: eme-decrypt-v7[org.w3.clearkey], decode-audio[aac:org.w3.clearkey], decode-video[h264:org.w3.clearkey]
-Libraries: dxva2.dll, d3d9.dll, msmpeg2vdec.dll, msmpeg2adec.dll, MSAudDecMFT.dll, evr.dll, mfheaacdec.dll, mfh264dec.dll, mfplat.dll
-#else
-APIs: eme-decrypt-v7[org.w3.clearkey]
-Libraries:
-#endif
diff --git a/media/gmp-clearkey/0.1/gmp-clearkey.cpp b/media/gmp-clearkey/0.1/gmp-clearkey.cpp
deleted file mode 100644
index 6dab6f9..0000000
--- a/media/gmp-clearkey/0.1/gmp-clearkey.cpp
+++ /dev/null
@@ -1,68 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include <assert.h>
-#include <stdio.h>
-#include <string.h>
-
-#include "ClearKeySessionManager.h"
-#include "gmp-api/gmp-decryption.h"
-#include "gmp-api/gmp-platform.h"
-#include "mozilla/Attributes.h"
-
-#if defined(ENABLE_WMF)
-#include "WMFUtils.h"
-#include "AudioDecoder.h"
-#include "VideoDecoder.h"
-#endif
-
-static GMPPlatformAPI* sPlatform = nullptr;
-GMPPlatformAPI*
-GetPlatform()
-{
-  return sPlatform;
-}
-
-extern "C" {
-
-MOZ_EXPORT GMPErr
-GMPInit(GMPPlatformAPI* aPlatformAPI)
-{
-  sPlatform = aPlatformAPI;
-  return GMPNoErr;
-}
-
-MOZ_EXPORT GMPErr
-GMPGetAPI(const char* aApiName, void* aHostAPI, void** aPluginAPI)
-{
-  CK_LOGD("ClearKey GMPGetAPI |%s|", aApiName);
-  assert(!*aPluginAPI);
-
-  if (!strcmp(aApiName, GMP_API_DECRYPTOR)) {
-    *aPluginAPI = new ClearKeySessionManager();
-  }
-#if defined(ENABLE_WMF)
-  else if (wmf::EnsureLibs()) {
-    if (!strcmp(aApiName, GMP_API_AUDIO_DECODER)) {
-      *aPluginAPI = new AudioDecoder(static_cast<GMPAudioHost*>(aHostAPI));
-    } else if (!strcmp(aApiName, GMP_API_VIDEO_DECODER)) {
-      *aPluginAPI = new VideoDecoder(static_cast<GMPVideoHost*>(aHostAPI));
-    }
-  }
-#endif
-  else {
-    CK_LOGE("GMPGetAPI couldn't resolve API name |%s|\n", aApiName);
-  }
-
-  return *aPluginAPI ? GMPNoErr : GMPNotImplementedErr;
-}
-
-MOZ_EXPORT GMPErr
-GMPShutdown(void)
-{
-  CK_LOGD("ClearKey GMPShutdown");
-  return GMPNoErr;
-}
-
-}
diff --git a/media/gmp-clearkey/0.1/gmp-task-utils-generated.h b/media/gmp-clearkey/0.1/gmp-task-utils-generated.h
deleted file mode 100644
index 5eec337..0000000
--- a/media/gmp-clearkey/0.1/gmp-task-utils-generated.h
+++ /dev/null
@@ -1,1898 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-
-// 0 arguments --
-template<typename M> class gmp_task_args_nm_0 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_0(M m) :
-    m_(m)  {}
-
-  void Run() {
-    m_();
-  }
-
- private:
-  M m_;
-};
-
-
-
-// 0 arguments --
-template<typename M, typename R> class gmp_task_args_nm_0_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_0_ret(M m, R *r) :
-    m_(m), r_(r)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_();
-  }
-
- private:
-  M m_;
-  R* r_;
-};
-
-
-
-// 0 arguments --
-template<typename C, typename M> class gmp_task_args_m_0 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_0(C o, M m) :
-    o_(o), m_(m)  {}
-
-  void Run() {
-    ((*o_).*m_)();
-  }
-
- private:
-  C o_;
-  M m_;
-};
-
-
-
-// 0 arguments --
-template<typename C, typename M, typename R> class gmp_task_args_m_0_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_0_ret(C o, M m, R *r) :
-    o_(o), m_(m), r_(r)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)();
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-};
-
-
-
-// 1 arguments --
-template<typename M, typename A0> class gmp_task_args_nm_1 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_1(M m, A0 a0) :
-    m_(m), a0_(a0)  {}
-
-  void Run() {
-    m_(a0_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-};
-
-
-
-// 1 arguments --
-template<typename M, typename A0, typename R> class gmp_task_args_nm_1_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_1_ret(M m, A0 a0, R *r) :
-    m_(m), r_(r), a0_(a0)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-};
-
-
-
-// 1 arguments --
-template<typename C, typename M, typename A0> class gmp_task_args_m_1 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_1(C o, M m, A0 a0) :
-    o_(o), m_(m), a0_(a0)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-};
-
-
-
-// 1 arguments --
-template<typename C, typename M, typename A0, typename R> class gmp_task_args_m_1_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_1_ret(C o, M m, A0 a0, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-};
-
-
-
-// 2 arguments --
-template<typename M, typename A0, typename A1> class gmp_task_args_nm_2 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_2(M m, A0 a0, A1 a1) :
-    m_(m), a0_(a0), a1_(a1)  {}
-
-  void Run() {
-    m_(a0_, a1_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-};
-
-
-
-// 2 arguments --
-template<typename M, typename A0, typename A1, typename R> class gmp_task_args_nm_2_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_2_ret(M m, A0 a0, A1 a1, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-};
-
-
-
-// 2 arguments --
-template<typename C, typename M, typename A0, typename A1> class gmp_task_args_m_2 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_2(C o, M m, A0 a0, A1 a1) :
-    o_(o), m_(m), a0_(a0), a1_(a1)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-};
-
-
-
-// 2 arguments --
-template<typename C, typename M, typename A0, typename A1, typename R> class gmp_task_args_m_2_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_2_ret(C o, M m, A0 a0, A1 a1, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-};
-
-
-
-// 3 arguments --
-template<typename M, typename A0, typename A1, typename A2> class gmp_task_args_nm_3 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_3(M m, A0 a0, A1 a1, A2 a2) :
-    m_(m), a0_(a0), a1_(a1), a2_(a2)  {}
-
-  void Run() {
-    m_(a0_, a1_, a2_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-};
-
-
-
-// 3 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename R> class gmp_task_args_nm_3_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_3_ret(M m, A0 a0, A1 a1, A2 a2, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_, a2_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-};
-
-
-
-// 3 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2> class gmp_task_args_m_3 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_3(C o, M m, A0 a0, A1 a1, A2 a2) :
-    o_(o), m_(m), a0_(a0), a1_(a1), a2_(a2)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_, a2_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-};
-
-
-
-// 3 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename R> class gmp_task_args_m_3_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_3_ret(C o, M m, A0 a0, A1 a1, A2 a2, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_, a2_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-};
-
-
-
-// 4 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3> class gmp_task_args_nm_4 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_4(M m, A0 a0, A1 a1, A2 a2, A3 a3) :
-    m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3)  {}
-
-  void Run() {
-    m_(a0_, a1_, a2_, a3_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-};
-
-
-
-// 4 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename R> class gmp_task_args_nm_4_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_4_ret(M m, A0 a0, A1 a1, A2 a2, A3 a3, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_, a2_, a3_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-};
-
-
-
-// 4 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3> class gmp_task_args_m_4 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_4(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3) :
-    o_(o), m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_, a2_, a3_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-};
-
-
-
-// 4 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename R> class gmp_task_args_m_4_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_4_ret(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_, a2_, a3_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-};
-
-
-
-// 5 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4> class gmp_task_args_nm_5 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_5(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) :
-    m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4)  {}
-
-  void Run() {
-    m_(a0_, a1_, a2_, a3_, a4_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-};
-
-
-
-// 5 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename R> class gmp_task_args_nm_5_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_5_ret(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_, a2_, a3_, a4_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-};
-
-
-
-// 5 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4> class gmp_task_args_m_5 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_5(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) :
-    o_(o), m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-};
-
-
-
-// 5 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename R> class gmp_task_args_m_5_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_5_ret(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-};
-
-
-
-// 6 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5> class gmp_task_args_nm_6 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_6(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) :
-    m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)  {}
-
-  void Run() {
-    m_(a0_, a1_, a2_, a3_, a4_, a5_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-};
-
-
-
-// 6 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename R> class gmp_task_args_nm_6_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_6_ret(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_, a2_, a3_, a4_, a5_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-};
-
-
-
-// 6 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5> class gmp_task_args_m_6 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_6(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) :
-    o_(o), m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-};
-
-
-
-// 6 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename R> class gmp_task_args_m_6_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_6_ret(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-};
-
-
-
-// 7 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6> class gmp_task_args_nm_7 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_7(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) :
-    m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)  {}
-
-  void Run() {
-    m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-};
-
-
-
-// 7 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename R> class gmp_task_args_nm_7_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_7_ret(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-};
-
-
-
-// 7 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6> class gmp_task_args_m_7 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_7(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) :
-    o_(o), m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-};
-
-
-
-// 7 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename R> class gmp_task_args_m_7_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_7_ret(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-};
-
-
-
-// 8 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7> class gmp_task_args_nm_8 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_8(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) :
-    m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7)  {}
-
-  void Run() {
-    m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-};
-
-
-
-// 8 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename R> class gmp_task_args_nm_8_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_8_ret(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-};
-
-
-
-// 8 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7> class gmp_task_args_m_8 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_8(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) :
-    o_(o), m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-};
-
-
-
-// 8 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename R> class gmp_task_args_m_8_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_8_ret(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-};
-
-
-
-// 9 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8> class gmp_task_args_nm_9 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_9(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) :
-    m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8)  {}
-
-  void Run() {
-    m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-};
-
-
-
-// 9 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename R> class gmp_task_args_nm_9_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_9_ret(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-};
-
-
-
-// 9 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8> class gmp_task_args_m_9 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_9(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) :
-    o_(o), m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-};
-
-
-
-// 9 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename R> class gmp_task_args_m_9_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_9_ret(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-};
-
-
-
-// 10 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9> class gmp_task_args_nm_10 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_10(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) :
-    m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9)  {}
-
-  void Run() {
-    m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-};
-
-
-
-// 10 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename R> class gmp_task_args_nm_10_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_10_ret(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-};
-
-
-
-// 10 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9> class gmp_task_args_m_10 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_10(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) :
-    o_(o), m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-};
-
-
-
-// 10 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename R> class gmp_task_args_m_10_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_10_ret(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-};
-
-
-
-// 11 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10> class gmp_task_args_nm_11 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_11(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) :
-    m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10)  {}
-
-  void Run() {
-    m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-};
-
-
-
-// 11 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename R> class gmp_task_args_nm_11_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_11_ret(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-};
-
-
-
-// 11 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10> class gmp_task_args_m_11 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_11(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) :
-    o_(o), m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-};
-
-
-
-// 11 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename R> class gmp_task_args_m_11_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_11_ret(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-};
-
-
-
-// 12 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11> class gmp_task_args_nm_12 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_12(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) :
-    m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10), a11_(a11)  {}
-
-  void Run() {
-    m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_, a11_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-  A11 a11_;
-};
-
-
-
-// 12 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename R> class gmp_task_args_nm_12_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_12_ret(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10), a11_(a11)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_, a11_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-  A11 a11_;
-};
-
-
-
-// 12 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11> class gmp_task_args_m_12 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_12(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) :
-    o_(o), m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10), a11_(a11)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_, a11_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-  A11 a11_;
-};
-
-
-
-// 12 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename R> class gmp_task_args_m_12_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_12_ret(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10), a11_(a11)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_, a11_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-  A11 a11_;
-};
-
-
-
-// 13 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12> class gmp_task_args_nm_13 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_13(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) :
-    m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10), a11_(a11), a12_(a12)  {}
-
-  void Run() {
-    m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_, a11_, a12_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-  A11 a11_;
-  A12 a12_;
-};
-
-
-
-// 13 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename R> class gmp_task_args_nm_13_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_13_ret(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10), a11_(a11), a12_(a12)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_, a11_, a12_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-  A11 a11_;
-  A12 a12_;
-};
-
-
-
-// 13 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12> class gmp_task_args_m_13 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_13(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) :
-    o_(o), m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10), a11_(a11), a12_(a12)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_, a11_, a12_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-  A11 a11_;
-  A12 a12_;
-};
-
-
-
-// 13 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename R> class gmp_task_args_m_13_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_13_ret(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10), a11_(a11), a12_(a12)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_, a11_, a12_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-  A11 a11_;
-  A12 a12_;
-};
-
-
-
-// 14 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13> class gmp_task_args_nm_14 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_14(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) :
-    m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10), a11_(a11), a12_(a12), a13_(a13)  {}
-
-  void Run() {
-    m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_, a11_, a12_, a13_);
-  }
-
- private:
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-  A11 a11_;
-  A12 a12_;
-  A13 a13_;
-};
-
-
-
-// 14 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename R> class gmp_task_args_nm_14_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_nm_14_ret(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, R *r) :
-    m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10), a11_(a11), a12_(a12), a13_(a13)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = m_(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_, a11_, a12_, a13_);
-  }
-
- private:
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-  A11 a11_;
-  A12 a12_;
-  A13 a13_;
-};
-
-
-
-// 14 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13> class gmp_task_args_m_14 : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_14(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) :
-    o_(o), m_(m), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10), a11_(a11), a12_(a12), a13_(a13)  {}
-
-  void Run() {
-    ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_, a11_, a12_, a13_);
-  }
-
- private:
-  C o_;
-  M m_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-  A11 a11_;
-  A12 a12_;
-  A13 a13_;
-};
-
-
-
-// 14 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename R> class gmp_task_args_m_14_ret : public gmp_task_args_base {
- public:
-  explicit gmp_task_args_m_14_ret(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, R *r) :
-    o_(o), m_(m), r_(r), a0_(a0), a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8), a9_(a9), a10_(a10), a11_(a11), a12_(a12), a13_(a13)  {}
-  virtual bool returns_value() const { return true; }
-
-  void Run() {
-    *r_ = ((*o_).*m_)(a0_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_, a9_, a10_, a11_, a12_, a13_);
-  }
-
- private:
-  C o_;
-  M m_;
-  R* r_;
-  A0 a0_;
-  A1 a1_;
-  A2 a2_;
-  A3 a3_;
-  A4 a4_;
-  A5 a5_;
-  A6 a6_;
-  A7 a7_;
-  A8 a8_;
-  A9 a9_;
-  A10 a10_;
-  A11 a11_;
-  A12 a12_;
-  A13 a13_;
-};
-
-
-
-
-
-
-// 0 arguments --
-template<typename M>
-gmp_task_args_nm_0<M>* WrapTaskNM(M m) {
-  return new gmp_task_args_nm_0<M>
-    (m);
-}
-
-// 0 arguments --
-template<typename M, typename R>
-gmp_task_args_nm_0_ret<M, R>* WrapTaskNMRet(M m, R* r) {
-  return new gmp_task_args_nm_0_ret<M, R>
-    (m, r);
-}
-
-// 0 arguments --
-template<typename C, typename M>
-gmp_task_args_m_0<C, M>* WrapTask(C o, M m) {
-  return new gmp_task_args_m_0<C, M>
-    (o, m);
-}
-
-// 0 arguments --
-template<typename C, typename M, typename R>
-gmp_task_args_m_0_ret<C, M, R>* WrapTaskRet(C o, M m, R* r) {
-  return new gmp_task_args_m_0_ret<C, M, R>
-    (o, m, r);
-}
-
-// 1 arguments --
-template<typename M, typename A0>
-gmp_task_args_nm_1<M, A0>* WrapTaskNM(M m, A0 a0) {
-  return new gmp_task_args_nm_1<M, A0>
-    (m, a0);
-}
-
-// 1 arguments --
-template<typename M, typename A0, typename R>
-gmp_task_args_nm_1_ret<M, A0, R>* WrapTaskNMRet(M m, A0 a0, R* r) {
-  return new gmp_task_args_nm_1_ret<M, A0, R>
-    (m, a0, r);
-}
-
-// 1 arguments --
-template<typename C, typename M, typename A0>
-gmp_task_args_m_1<C, M, A0>* WrapTask(C o, M m, A0 a0) {
-  return new gmp_task_args_m_1<C, M, A0>
-    (o, m, a0);
-}
-
-// 1 arguments --
-template<typename C, typename M, typename A0, typename R>
-gmp_task_args_m_1_ret<C, M, A0, R>* WrapTaskRet(C o, M m, A0 a0, R* r) {
-  return new gmp_task_args_m_1_ret<C, M, A0, R>
-    (o, m, a0, r);
-}
-
-// 2 arguments --
-template<typename M, typename A0, typename A1>
-gmp_task_args_nm_2<M, A0, A1>* WrapTaskNM(M m, A0 a0, A1 a1) {
-  return new gmp_task_args_nm_2<M, A0, A1>
-    (m, a0, a1);
-}
-
-// 2 arguments --
-template<typename M, typename A0, typename A1, typename R>
-gmp_task_args_nm_2_ret<M, A0, A1, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, R* r) {
-  return new gmp_task_args_nm_2_ret<M, A0, A1, R>
-    (m, a0, a1, r);
-}
-
-// 2 arguments --
-template<typename C, typename M, typename A0, typename A1>
-gmp_task_args_m_2<C, M, A0, A1>* WrapTask(C o, M m, A0 a0, A1 a1) {
-  return new gmp_task_args_m_2<C, M, A0, A1>
-    (o, m, a0, a1);
-}
-
-// 2 arguments --
-template<typename C, typename M, typename A0, typename A1, typename R>
-gmp_task_args_m_2_ret<C, M, A0, A1, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, R* r) {
-  return new gmp_task_args_m_2_ret<C, M, A0, A1, R>
-    (o, m, a0, a1, r);
-}
-
-// 3 arguments --
-template<typename M, typename A0, typename A1, typename A2>
-gmp_task_args_nm_3<M, A0, A1, A2>* WrapTaskNM(M m, A0 a0, A1 a1, A2 a2) {
-  return new gmp_task_args_nm_3<M, A0, A1, A2>
-    (m, a0, a1, a2);
-}
-
-// 3 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename R>
-gmp_task_args_nm_3_ret<M, A0, A1, A2, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, A2 a2, R* r) {
-  return new gmp_task_args_nm_3_ret<M, A0, A1, A2, R>
-    (m, a0, a1, a2, r);
-}
-
-// 3 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2>
-gmp_task_args_m_3<C, M, A0, A1, A2>* WrapTask(C o, M m, A0 a0, A1 a1, A2 a2) {
-  return new gmp_task_args_m_3<C, M, A0, A1, A2>
-    (o, m, a0, a1, a2);
-}
-
-// 3 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename R>
-gmp_task_args_m_3_ret<C, M, A0, A1, A2, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, A2 a2, R* r) {
-  return new gmp_task_args_m_3_ret<C, M, A0, A1, A2, R>
-    (o, m, a0, a1, a2, r);
-}
-
-// 4 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3>
-gmp_task_args_nm_4<M, A0, A1, A2, A3>* WrapTaskNM(M m, A0 a0, A1 a1, A2 a2, A3 a3) {
-  return new gmp_task_args_nm_4<M, A0, A1, A2, A3>
-    (m, a0, a1, a2, a3);
-}
-
-// 4 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename R>
-gmp_task_args_nm_4_ret<M, A0, A1, A2, A3, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, A2 a2, A3 a3, R* r) {
-  return new gmp_task_args_nm_4_ret<M, A0, A1, A2, A3, R>
-    (m, a0, a1, a2, a3, r);
-}
-
-// 4 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3>
-gmp_task_args_m_4<C, M, A0, A1, A2, A3>* WrapTask(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3) {
-  return new gmp_task_args_m_4<C, M, A0, A1, A2, A3>
-    (o, m, a0, a1, a2, a3);
-}
-
-// 4 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename R>
-gmp_task_args_m_4_ret<C, M, A0, A1, A2, A3, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, R* r) {
-  return new gmp_task_args_m_4_ret<C, M, A0, A1, A2, A3, R>
-    (o, m, a0, a1, a2, a3, r);
-}
-
-// 5 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4>
-gmp_task_args_nm_5<M, A0, A1, A2, A3, A4>* WrapTaskNM(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {
-  return new gmp_task_args_nm_5<M, A0, A1, A2, A3, A4>
-    (m, a0, a1, a2, a3, a4);
-}
-
-// 5 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename R>
-gmp_task_args_nm_5_ret<M, A0, A1, A2, A3, A4, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, R* r) {
-  return new gmp_task_args_nm_5_ret<M, A0, A1, A2, A3, A4, R>
-    (m, a0, a1, a2, a3, a4, r);
-}
-
-// 5 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4>
-gmp_task_args_m_5<C, M, A0, A1, A2, A3, A4>* WrapTask(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {
-  return new gmp_task_args_m_5<C, M, A0, A1, A2, A3, A4>
-    (o, m, a0, a1, a2, a3, a4);
-}
-
-// 5 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename R>
-gmp_task_args_m_5_ret<C, M, A0, A1, A2, A3, A4, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, R* r) {
-  return new gmp_task_args_m_5_ret<C, M, A0, A1, A2, A3, A4, R>
-    (o, m, a0, a1, a2, a3, a4, r);
-}
-
-// 6 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
-gmp_task_args_nm_6<M, A0, A1, A2, A3, A4, A5>* WrapTaskNM(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {
-  return new gmp_task_args_nm_6<M, A0, A1, A2, A3, A4, A5>
-    (m, a0, a1, a2, a3, a4, a5);
-}
-
-// 6 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename R>
-gmp_task_args_nm_6_ret<M, A0, A1, A2, A3, A4, A5, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, R* r) {
-  return new gmp_task_args_nm_6_ret<M, A0, A1, A2, A3, A4, A5, R>
-    (m, a0, a1, a2, a3, a4, a5, r);
-}
-
-// 6 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
-gmp_task_args_m_6<C, M, A0, A1, A2, A3, A4, A5>* WrapTask(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {
-  return new gmp_task_args_m_6<C, M, A0, A1, A2, A3, A4, A5>
-    (o, m, a0, a1, a2, a3, a4, a5);
-}
-
-// 6 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename R>
-gmp_task_args_m_6_ret<C, M, A0, A1, A2, A3, A4, A5, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, R* r) {
-  return new gmp_task_args_m_6_ret<C, M, A0, A1, A2, A3, A4, A5, R>
-    (o, m, a0, a1, a2, a3, a4, a5, r);
-}
-
-// 7 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
-gmp_task_args_nm_7<M, A0, A1, A2, A3, A4, A5, A6>* WrapTaskNM(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {
-  return new gmp_task_args_nm_7<M, A0, A1, A2, A3, A4, A5, A6>
-    (m, a0, a1, a2, a3, a4, a5, a6);
-}
-
-// 7 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename R>
-gmp_task_args_nm_7_ret<M, A0, A1, A2, A3, A4, A5, A6, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, R* r) {
-  return new gmp_task_args_nm_7_ret<M, A0, A1, A2, A3, A4, A5, A6, R>
-    (m, a0, a1, a2, a3, a4, a5, a6, r);
-}
-
-// 7 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
-gmp_task_args_m_7<C, M, A0, A1, A2, A3, A4, A5, A6>* WrapTask(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {
-  return new gmp_task_args_m_7<C, M, A0, A1, A2, A3, A4, A5, A6>
-    (o, m, a0, a1, a2, a3, a4, a5, a6);
-}
-
-// 7 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename R>
-gmp_task_args_m_7_ret<C, M, A0, A1, A2, A3, A4, A5, A6, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, R* r) {
-  return new gmp_task_args_m_7_ret<C, M, A0, A1, A2, A3, A4, A5, A6, R>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, r);
-}
-
-// 8 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
-gmp_task_args_nm_8<M, A0, A1, A2, A3, A4, A5, A6, A7>* WrapTaskNM(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {
-  return new gmp_task_args_nm_8<M, A0, A1, A2, A3, A4, A5, A6, A7>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7);
-}
-
-// 8 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename R>
-gmp_task_args_nm_8_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, R* r) {
-  return new gmp_task_args_nm_8_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, R>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, r);
-}
-
-// 8 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
-gmp_task_args_m_8<C, M, A0, A1, A2, A3, A4, A5, A6, A7>* WrapTask(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {
-  return new gmp_task_args_m_8<C, M, A0, A1, A2, A3, A4, A5, A6, A7>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7);
-}
-
-// 8 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename R>
-gmp_task_args_m_8_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, R* r) {
-  return new gmp_task_args_m_8_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, R>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, r);
-}
-
-// 9 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
-gmp_task_args_nm_9<M, A0, A1, A2, A3, A4, A5, A6, A7, A8>* WrapTaskNM(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
-  return new gmp_task_args_nm_9<M, A0, A1, A2, A3, A4, A5, A6, A7, A8>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, a8);
-}
-
-// 9 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename R>
-gmp_task_args_nm_9_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, R* r) {
-  return new gmp_task_args_nm_9_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, R>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, a8, r);
-}
-
-// 9 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
-gmp_task_args_m_9<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8>* WrapTask(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
-  return new gmp_task_args_m_9<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, a8);
-}
-
-// 9 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename R>
-gmp_task_args_m_9_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, R* r) {
-  return new gmp_task_args_m_9_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, R>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, a8, r);
-}
-
-// 10 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
-gmp_task_args_nm_10<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>* WrapTaskNM(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) {
-  return new gmp_task_args_nm_10<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
-}
-
-// 10 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename R>
-gmp_task_args_nm_10_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, R* r) {
-  return new gmp_task_args_nm_10_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, R>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, r);
-}
-
-// 10 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
-gmp_task_args_m_10<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>* WrapTask(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) {
-  return new gmp_task_args_m_10<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
-}
-
-// 10 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename R>
-gmp_task_args_m_10_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, R* r) {
-  return new gmp_task_args_m_10_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, R>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, r);
-}
-
-// 11 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
-gmp_task_args_nm_11<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>* WrapTaskNM(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) {
-  return new gmp_task_args_nm_11<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
-}
-
-// 11 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename R>
-gmp_task_args_nm_11_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, R* r) {
-  return new gmp_task_args_nm_11_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, R>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, r);
-}
-
-// 11 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
-gmp_task_args_m_11<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>* WrapTask(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) {
-  return new gmp_task_args_m_11<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
-}
-
-// 11 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename R>
-gmp_task_args_m_11_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, R* r) {
-  return new gmp_task_args_m_11_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, R>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, r);
-}
-
-// 12 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
-gmp_task_args_nm_12<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>* WrapTaskNM(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) {
-  return new gmp_task_args_nm_12<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
-}
-
-// 12 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename R>
-gmp_task_args_nm_12_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, R* r) {
-  return new gmp_task_args_nm_12_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, R>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, r);
-}
-
-// 12 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
-gmp_task_args_m_12<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>* WrapTask(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) {
-  return new gmp_task_args_m_12<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
-}
-
-// 12 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename R>
-gmp_task_args_m_12_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, R* r) {
-  return new gmp_task_args_m_12_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, R>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, r);
-}
-
-// 13 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
-gmp_task_args_nm_13<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>* WrapTaskNM(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) {
-  return new gmp_task_args_nm_13<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
-}
-
-// 13 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename R>
-gmp_task_args_nm_13_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, R* r) {
-  return new gmp_task_args_nm_13_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, R>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, r);
-}
-
-// 13 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
-gmp_task_args_m_13<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>* WrapTask(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) {
-  return new gmp_task_args_m_13<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
-}
-
-// 13 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename R>
-gmp_task_args_m_13_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, R* r) {
-  return new gmp_task_args_m_13_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, R>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, r);
-}
-
-// 14 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
-gmp_task_args_nm_14<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>* WrapTaskNM(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) {
-  return new gmp_task_args_nm_14<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
-}
-
-// 14 arguments --
-template<typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename R>
-gmp_task_args_nm_14_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, R>* WrapTaskNMRet(M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, R* r) {
-  return new gmp_task_args_nm_14_ret<M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, R>
-    (m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, r);
-}
-
-// 14 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
-gmp_task_args_m_14<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>* WrapTask(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) {
-  return new gmp_task_args_m_14<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
-}
-
-// 14 arguments --
-template<typename C, typename M, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename R>
-gmp_task_args_m_14_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, R>* WrapTaskRet(C o, M m, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, R* r) {
-  return new gmp_task_args_m_14_ret<C, M, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, R>
-    (o, m, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, r);
-}
-
diff --git a/media/gmp-clearkey/0.1/gmp-task-utils.h b/media/gmp-clearkey/0.1/gmp-task-utils.h
deleted file mode 100644
index 78a1393..0000000
--- a/media/gmp-clearkey/0.1/gmp-task-utils.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-// Original author: ekr@rtfm.com
-
-#ifndef gmp_task_utils_h_
-#define gmp_task_utils_h_
-
-#include "gmp-platform.h"
-
-class gmp_task_args_base : public GMPTask {
-public:
-  virtual void Destroy() { delete this; }
-  virtual void Run() = 0;
-};
-
-// The generated file contains four major function templates
-// (in variants for arbitrary numbers of arguments up to 10,
-// which is why it is machine generated). The four templates
-// are:
-//
-// WrapTask(o, m, ...) -- wraps a member function m of an object ptr o
-// WrapTaskRet(o, m, ..., r) -- wraps a member function m of an object ptr o
-//                                  the function returns something that can
-//                                  be assigned to *r
-// WrapTaskNM(f, ...) -- wraps a function f
-// WrapTaskNMRet(f, ..., r) -- wraps a function f that returns something
-//                                 that can be assigned to *r
-//
-// All of these template functions return a GMPTask* which can be passed
-// to DispatchXX().
-#include "gmp-task-utils-generated.h"
-
-#endif // gmp_task_utils_h_
diff --git a/media/gmp-clearkey/0.1/gtest/TestClearKeyUtils.cpp b/media/gmp-clearkey/0.1/gtest/TestClearKeyUtils.cpp
deleted file mode 100644
index 865a225..0000000
--- a/media/gmp-clearkey/0.1/gtest/TestClearKeyUtils.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
-* License, v. 2.0. If a copy of the MPL was not distributed with this
-* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "gtest/gtest.h"
-#include <algorithm>
-#include <stdint.h>
-#include <vector>
-
-#include "../ClearKeyBase64.cpp"
-
-
-using namespace std;
-using namespace mozilla;
-
-struct B64Test {
-  const char* b64;
-  uint8_t raw[16];
-  bool shouldPass;
-};
-
-B64Test tests[] = {
-  {
-    "AAAAADk4AU4AAAAAAAAAAA",
-    { 0x0, 0x0, 0x0, 0x0, 0x39, 0x38, 0x1, 0x4e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
-    true
-  },
-  {
-    "h2mqp1zAJjDIC34YXEXBxA==",
-    { 0x87, 0x69, 0xaa, 0xa7, 0x5c, 0xc0, 0x26, 0x30, 0xc8, 0xb, 0x7e, 0x18, 0x5c, 0x45, 0xc1, 0xc4 },
-    true
-  },
-  {
-    "flcdA35XHQN-Vx0DflcdAw",
-    { 0x7e, 0x57, 0x1d, 0x3, 0x7e, 0x57, 0x1d, 0x3, 0x7e, 0x57, 0x1d, 0x3, 0x7e, 0x57, 0x1d, 0x3 },
-    true
-  },
-  {
-    "flczM35XMzN-VzMzflczMw",
-    { 0x7e, 0x57, 0x33, 0x33, 0x7e, 0x57, 0x33, 0x33, 0x7e, 0x57, 0x33, 0x33, 0x7e, 0x57, 0x33, 0x33 },
-    true
-  },
-  {
-    "flcdBH5XHQR-Vx0EflcdBA",
-    { 0x7e, 0x57, 0x1d, 0x4, 0x7e, 0x57, 0x1d, 0x4, 0x7e, 0x57, 0x1d, 0x4, 0x7e, 0x57, 0x1d, 0x4 },
-    true
-  },
-  {
-    "fldERH5XRER-V0REfldERA",
-    { 0x7e, 0x57, 0x44, 0x44, 0x7e, 0x57, 0x44, 0x44, 0x7e, 0x57, 0x44, 0x44, 0x7e, 0x57, 0x44, 0x44 },
-    true
-  },
-  // Failure tests
-  { "", { 0 }, false }, // empty
-  { "fuzzbiz", { 0 }, false }, // Too short
-  { "fuzzbizfuzzbizfuzzbizfuzzbizfuzzbizfuzzbizfuzzbizfuzzbiz", { 0 }, false }, // too long
-
-};
-
-TEST(ClearKey, DecodeBase64KeyOrId) {
-  for (size_t i = 0; i < MOZ_ARRAY_LENGTH(tests); i++) {
-    vector<uint8_t> v;
-    const B64Test& test = tests[i];
-    bool rv = DecodeBase64KeyOrId(string(test.b64), v);
-    EXPECT_EQ(rv, test.shouldPass);
-    if (test.shouldPass) {
-      EXPECT_EQ(v.size(), 16u);
-      for (size_t k = 0; k < 16; k++) {
-        EXPECT_EQ(v[k], test.raw[k]);
-      }
-    }
-  }
-}
diff --git a/media/gmp-clearkey/0.1/gtest/moz.build b/media/gmp-clearkey/0.1/gtest/moz.build
deleted file mode 100644
index c46b68d..0000000
--- a/media/gmp-clearkey/0.1/gtest/moz.build
+++ /dev/null
@@ -1,17 +0,0 @@
-# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-UNIFIED_SOURCES += [
-    'TestClearKeyUtils.cpp',
-]
-
-FINAL_LIBRARY = 'xul-gtest'
-
-FAIL_ON_WARNINGS = True
-
-LOCAL_INCLUDES += [
-    '..',
-]
diff --git a/media/gmp-clearkey/0.1/moz.build b/media/gmp-clearkey/0.1/moz.build
deleted file mode 100644
index 03724b9..0000000
--- a/media/gmp-clearkey/0.1/moz.build
+++ /dev/null
@@ -1,74 +0,0 @@
-# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-SharedLibrary('clearkey')
-
-FINAL_TARGET = 'dist/bin/gmp-clearkey/0.1'
-
-UNIFIED_SOURCES += [
-    'ClearKeyBase64.cpp',
-    'ClearKeyDecryptionManager.cpp',
-    'ClearKeyPersistence.cpp',
-    'ClearKeySession.cpp',
-    'ClearKeySessionManager.cpp',
-    'ClearKeyStorage.cpp',
-    'ClearKeyUtils.cpp',
-    'gmp-clearkey.cpp',
-]
-
-SOURCES += [
-    'openaes/oaes_lib.c',
-]
-
-if CONFIG['OS_ARCH'] == 'WINNT':
-    UNIFIED_SOURCES += [
-        'AnnexB.cpp',
-        'AudioDecoder.cpp',
-        'VideoDecoder.cpp',
-        'WMFAACDecoder.cpp',
-        'WMFH264Decoder.cpp',
-    ]
-
-    SOURCES += [
-        'WMFUtils.cpp',
-    ]
-
-    OS_LIBS += [
-        'mfuuid',
-    ]
-
-    DEFINES['ENABLE_WMF'] = True
-
-TEST_DIRS += [
-    'gtest',
-]
-
-
-LOCAL_INCLUDES += [
-    '/dom/media/gmp',
-]
-
-USE_STATIC_LIBS = True
-
-DISABLE_STL_WRAPPING = True
-DEFINES['MOZ_NO_MOZALLOC'] = True
-
-# Suppress warnings in third-party code.
-if CONFIG['GNU_CXX']:
-    CFLAGS += [
-        '-Wno-missing-braces',
-        '-Wno-pointer-to-int-cast',
-        '-Wno-sign-compare',
-        '-include stdio.h',         # for sprintf() prototype
-        '-include unistd.h',        # for getpid() prototype
-    ]
-elif CONFIG['_MSC_VER']:
-    CFLAGS += [
-        '-FI stdio.h',              # for sprintf() prototype
-        '-wd4090',                  # '=' : different 'const' qualifiers
-    ]
-
-FAIL_ON_WARNINGS = True
diff --git a/media/gmp-clearkey/0.1/openaes/LICENSE b/media/gmp-clearkey/0.1/openaes/LICENSE
deleted file mode 100644
index d824e13..0000000
--- a/media/gmp-clearkey/0.1/openaes/LICENSE
+++ /dev/null
@@ -1,27 +0,0 @@
----------------------------------------------------------------------------
-OpenAES Licence
----------------------------------------------------------------------------
-Copyright (c) 2012, Nabil S. Al Ramli, www.nalramli.com
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-  - Redistributions of source code must retain the above copyright notice,
-    this list of conditions and the following disclaimer.
-  - Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
----------------------------------------------------------------------------
diff --git a/media/gmp-clearkey/0.1/openaes/oaes_common.h b/media/gmp-clearkey/0.1/openaes/oaes_common.h
deleted file mode 100644
index 7e2bf51..0000000
--- a/media/gmp-clearkey/0.1/openaes/oaes_common.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/* 
- * ---------------------------------------------------------------------------
- * OpenAES License
- * ---------------------------------------------------------------------------
- * Copyright (c) 2013, Nabil S. Al Ramli, www.nalramli.com
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- * 
- *   - Redistributions of source code must retain the above copyright notice,
- *     this list of conditions and the following disclaimer.
- *   - Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- * ---------------------------------------------------------------------------
- */
-
-#ifndef _OAES_COMMON_H
-#define _OAES_COMMON_H
-
-#include <stdint.h>
-
-#ifdef __cplusplus 
-extern "C" {
-#endif
-
-#ifdef _WIN32
-#	ifdef OAES_SHARED
-#		ifdef oaes_lib_EXPORTS
-#			define OAES_API __declspec(dllexport)
-#		else
-#			define OAES_API __declspec(dllimport)
-#		endif
-#	else
-#		define OAES_API
-#	endif
-#else
-#	define OAES_API
-#endif // WIN32
-
-#define OAES_VERSION "0.9.0"
-
-typedef enum
-{
-	OAES_RET_FIRST = 0,
-	OAES_RET_SUCCESS = 0,
-	OAES_RET_ERROR,
-	OAES_RET_ARG1,
-	OAES_RET_ARG2,
-	OAES_RET_ARG3,
-	OAES_RET_ARG4,
-	OAES_RET_ARG5,
-	OAES_RET_NOKEY,
-	OAES_RET_MEM,
-	OAES_RET_BUF,
-	OAES_RET_HEADER,
-	OAES_RET_COUNT
-} OAES_RET;
-
-#ifdef __cplusplus 
-}
-#endif
-
-#endif // _OAES_COMMON_H
diff --git a/media/gmp-clearkey/0.1/openaes/oaes_config.h b/media/gmp-clearkey/0.1/openaes/oaes_config.h
deleted file mode 100644
index cb9f4e7..0000000
--- a/media/gmp-clearkey/0.1/openaes/oaes_config.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/* 
- * ---------------------------------------------------------------------------
- * OpenAES License
- * ---------------------------------------------------------------------------
- * Copyright (c) 2012, Nabil S. Al Ramli, www.nalramli.com
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- * 
- *   - Redistributions of source code must retain the above copyright notice,
- *     this list of conditions and the following disclaimer.
- *   - Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- * ---------------------------------------------------------------------------
- */
-
-#ifndef _OAES_CONFIG_H
-#define _OAES_CONFIG_H
-
-#ifdef __cplusplus 
-extern "C" {
-#endif
-
-#ifndef OAES_DEBUG
-#define OAES_DEBUG 0
-#endif // OAES_DEBUG
-
-#ifdef __cplusplus 
-}
-#endif
-
-#endif // _OAES_CONFIG_H
diff --git a/media/gmp-clearkey/0.1/openaes/oaes_lib.c b/media/gmp-clearkey/0.1/openaes/oaes_lib.c
deleted file mode 100644
index 6234b1d..0000000
--- a/media/gmp-clearkey/0.1/openaes/oaes_lib.c
+++ /dev/null
@@ -1,1391 +0,0 @@
-/* 
- * ---------------------------------------------------------------------------
- * OpenAES License
- * ---------------------------------------------------------------------------
- * Copyright (c) 2012, Nabil S. Al Ramli, www.nalramli.com
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- * 
- *   - Redistributions of source code must retain the above copyright notice,
- *     this list of conditions and the following disclaimer.
- *   - Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- * ---------------------------------------------------------------------------
- */
-
-#include <stdlib.h>
-#include <stddef.h>
-#include <time.h> 
-#include <string.h>
-
-#ifdef WIN32
-#include <process.h>
-#endif
-
-#include "oaes_config.h"
-#include "oaes_lib.h"
-
-#ifdef OAES_HAVE_ISAAC
-#include "rand.h"
-#define OAES_RAND(x) rand(x)
-#else
-#define OAES_RAND(x) rand()
-#endif // OAES_HAVE_ISAAC
-
-#define OAES_RKEY_LEN 4
-#define OAES_COL_LEN 4
-#define OAES_ROUND_BASE 7
-
-// the block is padded
-#define OAES_FLAG_PAD 0x01
-
-#ifndef min
-# define min(a,b) (((a)<(b)) ? (a) : (b))
-#endif /* min */
-
-typedef struct _oaes_key
-{
-	size_t data_len;
-	uint8_t *data;
-	size_t exp_data_len;
-	uint8_t *exp_data;
-	size_t num_keys;
-	size_t key_base;
-} oaes_key;
-
-typedef struct _oaes_ctx
-{
-#ifdef OAES_HAVE_ISAAC
-  randctx * rctx;
-#endif // OAES_HAVE_ISAAC
-
-#ifdef OAES_DEBUG
-	oaes_step_cb step_cb;
-#endif // OAES_DEBUG
-
-	oaes_key * key;
-	OAES_OPTION options;
-	uint8_t iv[OAES_BLOCK_SIZE];
-} oaes_ctx;
-
-// "OAES<8-bit header version><8-bit type><16-bit options><8-bit flags><56-bit reserved>"
-static uint8_t oaes_header[OAES_BLOCK_SIZE] = {
-	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
-	/*0*/	0x4f, 0x41, 0x45, 0x53, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-};
-static uint8_t oaes_gf_8[] = {
-	0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 };
-
-static uint8_t oaes_sub_byte_value[16][16] = {
-	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
-	/*0*/	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
-	/*1*/	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
-	/*2*/	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
-	/*3*/	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
-	/*4*/	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
-	/*5*/	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
-	/*6*/	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
-	/*7*/	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
-	/*8*/	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
-	/*9*/	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
-	/*a*/	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
-	/*b*/	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
-	/*c*/	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
-	/*d*/	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
-	/*e*/	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
-	/*f*/	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
-};
-
-static uint8_t oaes_inv_sub_byte_value[16][16] = {
-	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
-	/*0*/	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
-	/*1*/	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
-	/*2*/	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
-	/*3*/	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
-	/*4*/	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
-	/*5*/	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
-	/*6*/	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
-	/*7*/	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
-	/*8*/	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
-	/*9*/	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
-	/*a*/	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
-	/*b*/	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
-	/*c*/	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
-	/*d*/	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
-	/*e*/	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
-	/*f*/	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
-};
-
-static uint8_t oaes_gf_mul_2[16][16] = {
-	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
-	/*0*/	0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
-	/*1*/	0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
-	/*2*/	0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
-	/*3*/	0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
-	/*4*/	0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
-	/*5*/	0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
-	/*6*/	0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
-	/*7*/	0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
-	/*8*/	0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
-	/*9*/	0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
-	/*a*/	0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
-	/*b*/	0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
-	/*c*/	0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
-	/*d*/	0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
-	/*e*/	0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
-	/*f*/	0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5,
-};
-
-static uint8_t oaes_gf_mul_3[16][16] = {
-	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
-	/*0*/	0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
-	/*1*/	0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
-	/*2*/	0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
-	/*3*/	0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
-	/*4*/	0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
-	/*5*/	0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
-	/*6*/	0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
-	/*7*/	0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
-	/*8*/	0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
-	/*9*/	0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
-	/*a*/	0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
-	/*b*/	0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
-	/*c*/	0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
-	/*d*/	0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
-	/*e*/	0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
-	/*f*/	0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a,
-};
-
-static uint8_t oaes_gf_mul_9[16][16] = {
-	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
-	/*0*/	0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
-	/*1*/	0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
-	/*2*/	0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
-	/*3*/	0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
-	/*4*/	0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
-	/*5*/	0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
-	/*6*/	0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
-	/*7*/	0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
-	/*8*/	0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
-	/*9*/	0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
-	/*a*/	0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
-	/*b*/	0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
-	/*c*/	0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
-	/*d*/	0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
-	/*e*/	0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
-	/*f*/	0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46,
-};
-
-static uint8_t oaes_gf_mul_b[16][16] = {
-	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
-	/*0*/	0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
-	/*1*/	0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
-	/*2*/	0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
-	/*3*/	0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
-	/*4*/	0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
-	/*5*/	0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
-	/*6*/	0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
-	/*7*/	0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
-	/*8*/	0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
-	/*9*/	0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
-	/*a*/	0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
-	/*b*/	0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
-	/*c*/	0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
-	/*d*/	0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
-	/*e*/	0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
-	/*f*/	0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3,
-};
-
-static uint8_t oaes_gf_mul_d[16][16] = {
-	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
-	/*0*/	0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
-	/*1*/	0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
-	/*2*/	0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
-	/*3*/	0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
-	/*4*/	0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
-	/*5*/	0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
-	/*6*/	0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
-	/*7*/	0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
-	/*8*/	0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
-	/*9*/	0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
-	/*a*/	0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
-	/*b*/	0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
-	/*c*/	0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
-	/*d*/	0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
-	/*e*/	0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
-	/*f*/	0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97,
-};
-
-static uint8_t oaes_gf_mul_e[16][16] = {
-	// 		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,
-	/*0*/	0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
-	/*1*/	0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
-	/*2*/	0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
-	/*3*/	0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
-	/*4*/	0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
-	/*5*/	0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
-	/*6*/	0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
-	/*7*/	0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
-	/*8*/	0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
-	/*9*/	0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
-	/*a*/	0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
-	/*b*/	0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
-	/*c*/	0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
-	/*d*/	0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
-	/*e*/	0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
-	/*f*/	0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d,
-};
-
-static OAES_RET oaes_sub_byte( uint8_t * byte )
-{
-	size_t _x, _y;
-	
-	if( NULL == byte )
-		return OAES_RET_ARG1;
-
-	_x = _y = *byte;
-	_x &= 0x0f;
-	_y &= 0xf0;
-	_y >>= 4;
-	*byte = oaes_sub_byte_value[_y][_x];
-	
-	return OAES_RET_SUCCESS;
-}
-
-static OAES_RET oaes_inv_sub_byte( uint8_t * byte )
-{
-	size_t _x, _y;
-	
-	if( NULL == byte )
-		return OAES_RET_ARG1;
-
-	_x = _y = *byte;
-	_x &= 0x0f;
-	_y &= 0xf0;
-	_y >>= 4;
-	*byte = oaes_inv_sub_byte_value[_y][_x];
-	
-	return OAES_RET_SUCCESS;
-}
-
-static OAES_RET oaes_word_rot_left( uint8_t word[OAES_COL_LEN] )
-{
-	uint8_t _temp[OAES_COL_LEN];
-	
-	if( NULL == word )
-		return OAES_RET_ARG1;
-
-	memcpy( _temp, word + 1, OAES_COL_LEN - 1 );
-	_temp[OAES_COL_LEN - 1] = word[0];
-	memcpy( word, _temp, OAES_COL_LEN );
-	
-	return OAES_RET_SUCCESS;
-}
-
-static OAES_RET oaes_shift_rows( uint8_t block[OAES_BLOCK_SIZE] )
-{
-	uint8_t _temp[OAES_BLOCK_SIZE];
-
-	if( NULL == block )
-		return OAES_RET_ARG1;
-
-	_temp[0x00] = block[0x00];
-	_temp[0x01] = block[0x05];
-	_temp[0x02] = block[0x0a];
-	_temp[0x03] = block[0x0f];
-	_temp[0x04] = block[0x04];
-	_temp[0x05] = block[0x09];
-	_temp[0x06] = block[0x0e];
-	_temp[0x07] = block[0x03];
-	_temp[0x08] = block[0x08];
-	_temp[0x09] = block[0x0d];
-	_temp[0x0a] = block[0x02];
-	_temp[0x0b] = block[0x07];
-	_temp[0x0c] = block[0x0c];
-	_temp[0x0d] = block[0x01];
-	_temp[0x0e] = block[0x06];
-	_temp[0x0f] = block[0x0b];
-	memcpy( block, _temp, OAES_BLOCK_SIZE );
-	
-	return OAES_RET_SUCCESS;
-}
-
-static OAES_RET oaes_inv_shift_rows( uint8_t block[OAES_BLOCK_SIZE] )
-{
-	uint8_t _temp[OAES_BLOCK_SIZE];
-
-	if( NULL == block )
-		return OAES_RET_ARG1;
-
-	_temp[0x00] = block[0x00];
-	_temp[0x01] = block[0x0d];
-	_temp[0x02] = block[0x0a];
-	_temp[0x03] = block[0x07];
-	_temp[0x04] = block[0x04];
-	_temp[0x05] = block[0x01];
-	_temp[0x06] = block[0x0e];
-	_temp[0x07] = block[0x0b];
-	_temp[0x08] = block[0x08];
-	_temp[0x09] = block[0x05];
-	_temp[0x0a] = block[0x02];
-	_temp[0x0b] = block[0x0f];
-	_temp[0x0c] = block[0x0c];
-	_temp[0x0d] = block[0x09];
-	_temp[0x0e] = block[0x06];
-	_temp[0x0f] = block[0x03];
-	memcpy( block, _temp, OAES_BLOCK_SIZE );
-	
-	return OAES_RET_SUCCESS;
-}
-
-static uint8_t oaes_gf_mul(uint8_t left, uint8_t right)
-{
-	size_t _x, _y;
-	
-	_x = _y = left;
-	_x &= 0x0f;
-	_y &= 0xf0;
-	_y >>= 4;
-	
-	switch( right )
-	{
-		case 0x02:
-			return oaes_gf_mul_2[_y][_x];
-			break;
-		case 0x03:
-			return oaes_gf_mul_3[_y][_x];
-			break;
-		case 0x09:
-			return oaes_gf_mul_9[_y][_x];
-			break;
-		case 0x0b:
-			return oaes_gf_mul_b[_y][_x];
-			break;
-		case 0x0d:
-			return oaes_gf_mul_d[_y][_x];
-			break;
-		case 0x0e:
-			return oaes_gf_mul_e[_y][_x];
-			break;
-		default:
-			return left;
-			break;
-	}
-}
-
-static OAES_RET oaes_mix_cols( uint8_t word[OAES_COL_LEN] )
-{
-	uint8_t _temp[OAES_COL_LEN];
-
-	if( NULL == word )
-		return OAES_RET_ARG1;
-	
-	_temp[0] = oaes_gf_mul(word[0], 0x02) ^ oaes_gf_mul( word[1], 0x03 ) ^
-			word[2] ^ word[3];
-	_temp[1] = word[0] ^ oaes_gf_mul( word[1], 0x02 ) ^
-			oaes_gf_mul( word[2], 0x03 ) ^ word[3];
-	_temp[2] = word[0] ^ word[1] ^
-			oaes_gf_mul( word[2], 0x02 ) ^ oaes_gf_mul( word[3], 0x03 );
-	_temp[3] = oaes_gf_mul( word[0], 0x03 ) ^ word[1] ^
-			word[2] ^ oaes_gf_mul( word[3], 0x02 );
-	memcpy( word, _temp, OAES_COL_LEN );
-	
-	return OAES_RET_SUCCESS;
-}
-
-static OAES_RET oaes_inv_mix_cols( uint8_t word[OAES_COL_LEN] )
-{
-	uint8_t _temp[OAES_COL_LEN];
-
-	if( NULL == word )
-		return OAES_RET_ARG1;
-	
-	_temp[0] = oaes_gf_mul( word[0], 0x0e ) ^ oaes_gf_mul( word[1], 0x0b ) ^
-			oaes_gf_mul( word[2], 0x0d ) ^ oaes_gf_mul( word[3], 0x09 );
-	_temp[1] = oaes_gf_mul( word[0], 0x09 ) ^ oaes_gf_mul( word[1], 0x0e ) ^
-			oaes_gf_mul( word[2], 0x0b ) ^ oaes_gf_mul( word[3], 0x0d );
-	_temp[2] = oaes_gf_mul( word[0], 0x0d ) ^ oaes_gf_mul( word[1], 0x09 ) ^
-			oaes_gf_mul( word[2], 0x0e ) ^ oaes_gf_mul( word[3], 0x0b );
-	_temp[3] = oaes_gf_mul( word[0], 0x0b ) ^ oaes_gf_mul( word[1], 0x0d ) ^
-			oaes_gf_mul( word[2], 0x09 ) ^ oaes_gf_mul( word[3], 0x0e );
-	memcpy( word, _temp, OAES_COL_LEN );
-	
-	return OAES_RET_SUCCESS;
-}
-
-OAES_RET oaes_sprintf(
-		char * buf, size_t * buf_len, const uint8_t * data, size_t data_len )
-{
-	size_t _i, _buf_len_in;
-	char _temp[4];
-	
-	if( NULL == buf_len )
-		return OAES_RET_ARG2;
-
-	_buf_len_in = *buf_len;
-	*buf_len = data_len * 3 + data_len / OAES_BLOCK_SIZE + 1;
-	
-	if( NULL == buf )
-		return OAES_RET_SUCCESS;
-
-	if( *buf_len > _buf_len_in )
-		return OAES_RET_BUF;
-
-	if( NULL == data )
-		return OAES_RET_ARG3;
-
-	strcpy( buf, "" );
-	
-	for( _i = 0; _i < data_len; _i++ )
-	{
-		sprintf( _temp, "%02x ", data[_i] );
-		strcat( buf, _temp );
-		if( _i && 0 == ( _i + 1 ) % OAES_BLOCK_SIZE )
-			strcat( buf, "\n" );
-	}
-	
-	return OAES_RET_SUCCESS;
-}
-
-/*
-#ifdef OAES_HAVE_ISAAC
-static void oaes_get_seed( char buf[RANDSIZ + 1] )
-{
-	struct timeb timer;
-	struct tm *gmTimer;
-	char * _test = NULL;
-	
-	ftime (&timer);
-	gmTimer = gmtime( &timer.time );
-	_test = (char *) calloc( sizeof( char ), timer.millitm );
-	sprintf( buf, "%04d%02d%02d%02d%02d%02d%03d%p%d",
-		gmTimer->tm_year + 1900, gmTimer->tm_mon + 1, gmTimer->tm_mday,
-		gmTimer->tm_hour, gmTimer->tm_min, gmTimer->tm_sec, timer.millitm,
-		_test + timer.millitm, getpid() );
-	
-	if( _test )
-		free( _test );
-}
-#else
-static uint32_t oaes_get_seed()
-{
-	struct timeb timer;
-	struct tm *gmTimer;
-	char * _test = NULL;
-	uint32_t _ret = 0;
-	
-	ftime (&timer);
-	gmTimer = gmtime( &timer.time );
-	_test = (char *) calloc( sizeof( char ), timer.millitm );
-	_ret = gmTimer->tm_year + 1900 + gmTimer->tm_mon + 1 + gmTimer->tm_mday +
-			gmTimer->tm_hour + gmTimer->tm_min + gmTimer->tm_sec + timer.millitm +
-			(uint32_t) ( _test + timer.millitm ) + getpid();
-
-	if( _test )
-		free( _test );
-	
-	return _ret;
-}
-#endif // OAES_HAVE_ISAAC
-*/
-
-static OAES_RET oaes_key_destroy( oaes_key ** key )
-{
-	if( NULL == *key )
-		return OAES_RET_SUCCESS;
-	
-	if( (*key)->data )
-	{
-		free( (*key)->data );
-		(*key)->data = NULL;
-	}
-	
-	if( (*key)->exp_data )
-	{
-		free( (*key)->exp_data );
-		(*key)->exp_data = NULL;
-	}
-	
-	(*key)->data_len = 0;
-	(*key)->exp_data_len = 0;
-	(*key)->num_keys = 0;
-	(*key)->key_base = 0;
-	free( *key );
-	*key = NULL;
-	
-	return OAES_RET_SUCCESS;
-}
-
-static OAES_RET oaes_key_expand( OAES_CTX * ctx )
-{
-	size_t _i, _j;
-	oaes_ctx * _ctx = (oaes_ctx *) ctx;
-	
-	if( NULL == _ctx )
-		return OAES_RET_ARG1;
-	
-	if( NULL == _ctx->key )
-		return OAES_RET_NOKEY;
-	
-	_ctx->key->key_base = _ctx->key->data_len / OAES_RKEY_LEN;
-	_ctx->key->num_keys =  _ctx->key->key_base + OAES_ROUND_BASE;
-					
-	_ctx->key->exp_data_len = _ctx->key->num_keys * OAES_RKEY_LEN * OAES_COL_LEN;
-	_ctx->key->exp_data = (uint8_t *)
-			calloc( _ctx->key->exp_data_len, sizeof( uint8_t ));
-	
-	if( NULL == _ctx->key->exp_data )
-		return OAES_RET_MEM;
-	
-	// the first _ctx->key->data_len are a direct copy
-	memcpy( _ctx->key->exp_data, _ctx->key->data, _ctx->key->data_len );
-
-	// apply ExpandKey algorithm for remainder
-	for( _i = _ctx->key->key_base; _i < _ctx->key->num_keys * OAES_RKEY_LEN; _i++ )
-	{
-		uint8_t _temp[OAES_COL_LEN];
-		
-		memcpy( _temp,
-				_ctx->key->exp_data + ( _i - 1 ) * OAES_RKEY_LEN, OAES_COL_LEN );
-		
-		// transform key column
-		if( 0 == _i % _ctx->key->key_base )
-		{
-			oaes_word_rot_left( _temp );
-
-			for( _j = 0; _j < OAES_COL_LEN; _j++ )
-				oaes_sub_byte( _temp + _j );
-
-			_temp[0] = _temp[0] ^ oaes_gf_8[ _i / _ctx->key->key_base - 1 ];
-		}
-		else if( _ctx->key->key_base > 6 && 4 == _i % _ctx->key->key_base )
-		{
-			for( _j = 0; _j < OAES_COL_LEN; _j++ )
-				oaes_sub_byte( _temp + _j );
-		}
-		
-		for( _j = 0; _j < OAES_COL_LEN; _j++ )
-		{
-			_ctx->key->exp_data[ _i * OAES_RKEY_LEN + _j ] =
-					_ctx->key->exp_data[ ( _i - _ctx->key->key_base ) *
-					OAES_RKEY_LEN + _j ] ^ _temp[_j];
-		}
-	}
-	
-	return OAES_RET_SUCCESS;
-}
-
-static OAES_RET oaes_key_gen( OAES_CTX * ctx, size_t key_size )
-{
-	size_t _i;
-	oaes_key * _key = NULL;
-	oaes_ctx * _ctx = (oaes_ctx *) ctx;
-	OAES_RET _rc = OAES_RET_SUCCESS;
-	
-	if( NULL == _ctx )
-		return OAES_RET_ARG1;
-	
-	_key = (oaes_key *) calloc( sizeof( oaes_key ), 1 );
-	
-	if( NULL == _key )
-		return OAES_RET_MEM;
-	
-	if( _ctx->key )
-		oaes_key_destroy( &(_ctx->key) );
-	
-	_key->data_len = key_size;
-	_key->data = (uint8_t *) calloc( key_size, sizeof( uint8_t ));
-	
-	if( NULL == _key->data )
-	{
-		oaes_key_destroy( &_key );
-		return OAES_RET_MEM;
-	}
-	
-	for( _i = 0; _i < key_size; _i++ )
-		_key->data[_i] = (uint8_t) OAES_RAND(_ctx->rctx);
-	
-	_ctx->key = _key;
-	_rc = _rc || oaes_key_expand( ctx );
-	
-	if( _rc != OAES_RET_SUCCESS )
-	{
-		oaes_key_destroy( &(_ctx->key) );
-		return _rc;
-	}
-	
-	return OAES_RET_SUCCESS;
-}
-
-OAES_RET oaes_key_gen_128( OAES_CTX * ctx )
-{
-	return oaes_key_gen( ctx, 16 );
-}
-
-OAES_RET oaes_key_gen_192( OAES_CTX * ctx )
-{
-	return oaes_key_gen( ctx, 24 );
-}
-
-OAES_RET oaes_key_gen_256( OAES_CTX * ctx )
-{
-	return oaes_key_gen( ctx, 32 );
-}
-
-OAES_RET oaes_key_export( OAES_CTX * ctx,
-		uint8_t * data, size_t * data_len )
-{
-	size_t _data_len_in;
-	oaes_ctx * _ctx = (oaes_ctx *) ctx;
-	
-	if( NULL == _ctx )
-		return OAES_RET_ARG1;
-	
-	if( NULL == _ctx->key )
-		return OAES_RET_NOKEY;
-	
-	if( NULL == data_len )
-		return OAES_RET_ARG3;
-
-	_data_len_in = *data_len;
-	// data + header
-	*data_len = _ctx->key->data_len + OAES_BLOCK_SIZE;
-
-	if( NULL == data )
-		return OAES_RET_SUCCESS;
-	
-	if( _data_len_in < *data_len )
-		return OAES_RET_BUF;
-	
-	// header
-	memcpy( data, oaes_header, OAES_BLOCK_SIZE );
-	data[5] = 0x01;
-	data[7] = _ctx->key->data_len;
-	memcpy( data + OAES_BLOCK_SIZE, _ctx->key->data, _ctx->key->data_len );
-	
-	return OAES_RET_SUCCESS;
-}
-
-OAES_RET oaes_key_export_data( OAES_CTX * ctx,
-		uint8_t * data, size_t * data_len )
-{
-	size_t _data_len_in;
-	oaes_ctx * _ctx = (oaes_ctx *) ctx;
-	
-	if( NULL == _ctx )
-		return OAES_RET_ARG1;
-	
-	if( NULL == _ctx->key )
-		return OAES_RET_NOKEY;
-	
-	if( NULL == data_len )
-		return OAES_RET_ARG3;
-
-	_data_len_in = *data_len;
-	*data_len = _ctx->key->data_len;
-
-	if( NULL == data )
-		return OAES_RET_SUCCESS;
-	
-	if( _data_len_in < *data_len )
-		return OAES_RET_BUF;
-	
-	memcpy( data, _ctx->key->data, *data_len );
-	
-	return OAES_RET_SUCCESS;
-}
-
-OAES_RET oaes_key_import( OAES_CTX * ctx,
-		const uint8_t * data, size_t data_len )
-{
-	oaes_ctx * _ctx = (oaes_ctx *) ctx;
-	OAES_RET _rc = OAES_RET_SUCCESS;
-	int _key_length;
-	
-	if( NULL == _ctx )
-		return OAES_RET_ARG1;
-	
-	if( NULL == data )
-		return OAES_RET_ARG2;
-	
-	switch( data_len )
-	{
-		case 16 + OAES_BLOCK_SIZE:
-		case 24 + OAES_BLOCK_SIZE:
-		case 32 + OAES_BLOCK_SIZE:
-			break;
-		default:
-			return OAES_RET_ARG3;
-	}
-	
-	// header
-	if( 0 != memcmp( data, oaes_header, 4 ) )
-		return OAES_RET_HEADER;
-
-	// header version
-	switch( data[4] )
-	{
-		case 0x01:
-			break;
-		default:
-			return OAES_RET_HEADER;
-	}
-	
-	// header type
-	switch( data[5] )
-	{
-		case 0x01:
-			break;
-		default:
-			return OAES_RET_HEADER;
-	}
-	
-	// options
-	_key_length = data[7];
-	switch( _key_length )
-	{
-		case 16:
-		case 24:
-		case 32:
-			break;
-		default:
-			return OAES_RET_HEADER;
-	}
-	
-	if( data_len != _key_length + OAES_BLOCK_SIZE )
-			return OAES_RET_ARG3;
-	
-	if( _ctx->key )
-		oaes_key_destroy( &(_ctx->key) );
-	
-	_ctx->key = (oaes_key *) calloc( sizeof( oaes_key ), 1 );
-	
-	if( NULL == _ctx->key )
-		return OAES_RET_MEM;
-	
-	_ctx->key->data_len = _key_length;
-	_ctx->key->data = (uint8_t *)
-			calloc( _key_length, sizeof( uint8_t ));
-	
-	if( NULL == _ctx->key->data )
-	{
-		oaes_key_destroy( &(_ctx->key) );
-		return OAES_RET_MEM;
-	}
-
-	memcpy( _ctx->key->data, data + OAES_BLOCK_SIZE, _key_length );
-	_rc = _rc || oaes_key_expand( ctx );
-	
-	if( _rc != OAES_RET_SUCCESS )
-	{
-		oaes_key_destroy( &(_ctx->key) );
-		return _rc;
-	}
-	
-	return OAES_RET_SUCCESS;
-}
-
-OAES_RET oaes_key_import_data( OAES_CTX * ctx,
-		const uint8_t * data, size_t data_len )
-{
-	oaes_ctx * _ctx = (oaes_ctx *) ctx;
-	OAES_RET _rc = OAES_RET_SUCCESS;
-	
-	if( NULL == _ctx )
-		return OAES_RET_ARG1;
-	
-	if( NULL == data )
-		return OAES_RET_ARG2;
-	
-	switch( data_len )
-	{
-		case 16:
-		case 24:
-		case 32:
-			break;
-		default:
-			return OAES_RET_ARG3;
-	}
-	
-	if( _ctx->key )
-		oaes_key_destroy( &(_ctx->key) );
-	
-	_ctx->key = (oaes_key *) calloc( sizeof( oaes_key ), 1 );
-	
-	if( NULL == _ctx->key )
-		return OAES_RET_MEM;
-	
-	_ctx->key->data_len = data_len;
-	_ctx->key->data = (uint8_t *)
-			calloc( data_len, sizeof( uint8_t ));
-	
-	if( NULL == _ctx->key->data )
-	{
-		oaes_key_destroy( &(_ctx->key) );
-		return OAES_RET_MEM;
-	}
-
-	memcpy( _ctx->key->data, data, data_len );
-	_rc = _rc || oaes_key_expand( ctx );
-	
-	if( _rc != OAES_RET_SUCCESS )
-	{
-		oaes_key_destroy( &(_ctx->key) );
-		return _rc;
-	}
-	
-	return OAES_RET_SUCCESS;
-}
-
-OAES_CTX * oaes_alloc()
-{
-	oaes_ctx * _ctx = (oaes_ctx *) calloc( sizeof( oaes_ctx ), 1 );
-	
-	if( NULL == _ctx )
-		return NULL;
-
-#ifdef OAES_HAVE_ISAAC
-	{
-	  ub4 _i = 0;
-		char _seed[RANDSIZ + 1];
-		
-		_ctx->rctx = (randctx *) calloc( sizeof( randctx ), 1 );
-
-		if( NULL == _ctx->rctx )
-		{
-			free( _ctx );
-			return NULL;
-		}
-
-		oaes_get_seed( _seed );
-		memset( _ctx->rctx->randrsl, 0, RANDSIZ );
-		memcpy( _ctx->rctx->randrsl, _seed, RANDSIZ );
-		randinit( _ctx->rctx, TRUE);
-	}
-#else
-  //srand( oaes_get_seed() );
-#endif // OAES_HAVE_ISAAC
-
-	_ctx->key = NULL;
-	oaes_set_option( _ctx, OAES_OPTION_CBC, NULL );
-
-#ifdef OAES_DEBUG
-	_ctx->step_cb = NULL;
-	oaes_set_option( _ctx, OAES_OPTION_STEP_OFF, NULL );
-#endif // OAES_DEBUG
-
-	return (OAES_CTX *) _ctx;
-}
-
-OAES_RET oaes_free( OAES_CTX ** ctx )
-{
-	oaes_ctx ** _ctx = (oaes_ctx **) ctx;
-
-	if( NULL == _ctx )
-		return OAES_RET_ARG1;
-	
-	if( NULL == *_ctx )
-		return OAES_RET_SUCCESS;
-	
-	if( (*_ctx)->key )
-		oaes_key_destroy( &((*_ctx)->key) );
-
-#ifdef OAES_HAVE_ISAAC
-	if( (*_ctx)->rctx )
-	{
-		free( (*_ctx)->rctx );
-		(*_ctx)->rctx = NULL;
-	}
-#endif // OAES_HAVE_ISAAC
-	
-	free( *_ctx );
-	*_ctx = NULL;
-
-	return OAES_RET_SUCCESS;
-}
-
-OAES_RET oaes_set_option( OAES_CTX * ctx,
-		OAES_OPTION option, const void * value )
-{
-	size_t _i;
-	oaes_ctx * _ctx = (oaes_ctx *) ctx;
-	
-	if( NULL == _ctx )
-		return OAES_RET_ARG1;
-
-	switch( option )
-	{
-		case OAES_OPTION_ECB:
-			_ctx->options &= ~OAES_OPTION_CBC;
-			memset( _ctx->iv, 0, OAES_BLOCK_SIZE );
-			break;
-
-		case OAES_OPTION_CBC:
-			_ctx->options &= ~OAES_OPTION_ECB;
-			if( value )
-				memcpy( _ctx->iv, value, OAES_BLOCK_SIZE );
-			else
-			{
-				for( _i = 0; _i < OAES_BLOCK_SIZE; _i++ )
-					_ctx->iv[_i] = (uint8_t) OAES_RAND(_ctx->rctx);
-			}
-			break;
-
-#ifdef OAES_DEBUG
-
-		case OAES_OPTION_STEP_ON:
-			if( value )
-			{
-				_ctx->options &= ~OAES_OPTION_STEP_OFF;
-				_ctx->step_cb = value;
-			}
-			else
-			{
-				_ctx->options &= ~OAES_OPTION_STEP_ON;
-				_ctx->options |= OAES_OPTION_STEP_OFF;
-				_ctx->step_cb = NULL;
-				return OAES_RET_ARG3;
-			}
-			break;
-
-		case OAES_OPTION_STEP_OFF:
-			_ctx->options &= ~OAES_OPTION_STEP_ON;
-			_ctx->step_cb = NULL;
-			break;
-
-#endif // OAES_DEBUG
-
-		default:
-			return OAES_RET_ARG2;
-	}
-
-	_ctx->options |= option;
-
-	return OAES_RET_SUCCESS;
-}
-
-static OAES_RET oaes_encrypt_block(
-		OAES_CTX * ctx, uint8_t * c, size_t c_len )
-{
-	size_t _i, _j;
-	oaes_ctx * _ctx = (oaes_ctx *) ctx;
-	
-	if( NULL == _ctx )
-		return OAES_RET_ARG1;
-	
-	if( NULL == c )
-		return OAES_RET_ARG2;
-	
-	if( c_len != OAES_BLOCK_SIZE )
-		return OAES_RET_ARG3;
-	
-	if( NULL == _ctx->key )
-		return OAES_RET_NOKEY;
-	
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-		_ctx->step_cb( c, "input", 1, NULL );
-#endif // OAES_DEBUG
-
-	// AddRoundKey(State, K0)
-	for( _i = 0; _i < c_len; _i++ )
-		c[_i] = c[_i] ^ _ctx->key->exp_data[_i];
-	
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-	{
-		_ctx->step_cb( _ctx->key->exp_data, "k_sch", 1, NULL );
-		_ctx->step_cb( c, "k_add", 1, NULL );
-	}
-#endif // OAES_DEBUG
-
-	// for round = 1 step 1 to Nr1
-	for( _i = 1; _i < _ctx->key->num_keys - 1; _i++ )
-	{
-		// SubBytes(state)
-		for( _j = 0; _j < c_len; _j++ )
-			oaes_sub_byte( c + _j );
-
-#ifdef OAES_DEBUG
-		if( _ctx->step_cb )
-			_ctx->step_cb( c, "s_box", _i, NULL );
-#endif // OAES_DEBUG
-
-		// ShiftRows(state)
-		oaes_shift_rows( c );
-		
-#ifdef OAES_DEBUG
-		if( _ctx->step_cb )
-			_ctx->step_cb( c, "s_row", _i, NULL );
-#endif // OAES_DEBUG
-
-		// MixColumns(state)
-		oaes_mix_cols( c );
-		oaes_mix_cols( c + 4 );
-		oaes_mix_cols( c + 8 );
-		oaes_mix_cols( c + 12 );
-		
-#ifdef OAES_DEBUG
-		if( _ctx->step_cb )
-			_ctx->step_cb( c, "m_col", _i, NULL );
-#endif // OAES_DEBUG
-
-		// AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
-		for( _j = 0; _j < c_len; _j++ )
-			c[_j] = c[_j] ^
-					_ctx->key->exp_data[_i * OAES_RKEY_LEN * OAES_COL_LEN + _j];
-
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-	{
-		_ctx->step_cb( _ctx->key->exp_data + _i * OAES_RKEY_LEN * OAES_COL_LEN,
-				"k_sch", _i, NULL );
-		_ctx->step_cb( c, "k_add", _i, NULL );
-	}
-#endif // OAES_DEBUG
-
-	}
-	
-	// SubBytes(state)
-	for( _i = 0; _i < c_len; _i++ )
-		oaes_sub_byte( c + _i );
-	
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-		_ctx->step_cb( c, "s_box", _ctx->key->num_keys - 1, NULL );
-#endif // OAES_DEBUG
-
-	// ShiftRows(state)
-	oaes_shift_rows( c );
-
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-		_ctx->step_cb( c, "s_row", _ctx->key->num_keys - 1, NULL );
-#endif // OAES_DEBUG
-
-	// AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
-	for( _i = 0; _i < c_len; _i++ )
-		c[_i] = c[_i] ^ _ctx->key->exp_data[
-				( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN + _i ];
-
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-	{
-		_ctx->step_cb( _ctx->key->exp_data +
-				( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN,
-				"k_sch", _ctx->key->num_keys - 1, NULL );
-		_ctx->step_cb( c, "output", _ctx->key->num_keys - 1, NULL );
-	}
-#endif // OAES_DEBUG
-
-	return OAES_RET_SUCCESS;
-}
-
-static OAES_RET oaes_decrypt_block(
-		OAES_CTX * ctx, uint8_t * c, size_t c_len )
-{
-	size_t _i, _j;
-	oaes_ctx * _ctx = (oaes_ctx *) ctx;
-	
-	if( NULL == _ctx )
-		return OAES_RET_ARG1;
-	
-	if( NULL == c )
-		return OAES_RET_ARG2;
-	
-	if( c_len != OAES_BLOCK_SIZE )
-		return OAES_RET_ARG3;
-	
-	if( NULL == _ctx->key )
-		return OAES_RET_NOKEY;
-	
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-		_ctx->step_cb( c, "iinput", _ctx->key->num_keys - 1, NULL );
-#endif // OAES_DEBUG
-
-	// AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
-	for( _i = 0; _i < c_len; _i++ )
-		c[_i] = c[_i] ^ _ctx->key->exp_data[
-				( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN + _i ];
-
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-	{
-		_ctx->step_cb( _ctx->key->exp_data +
-				( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN,
-				"ik_sch", _ctx->key->num_keys - 1, NULL );
-		_ctx->step_cb( c, "ik_add", _ctx->key->num_keys - 1, NULL );
-	}
-#endif // OAES_DEBUG
-
-	for( _i = _ctx->key->num_keys - 2; _i > 0; _i-- )
-	{
-		// InvShiftRows(state)
-		oaes_inv_shift_rows( c );
-
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-		_ctx->step_cb( c, "is_row", _i, NULL );
-#endif // OAES_DEBUG
-
-		// InvSubBytes(state)
-		for( _j = 0; _j < c_len; _j++ )
-			oaes_inv_sub_byte( c + _j );
-	
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-		_ctx->step_cb( c, "is_box", _i, NULL );
-#endif // OAES_DEBUG
-
-		// AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
-		for( _j = 0; _j < c_len; _j++ )
-			c[_j] = c[_j] ^
-					_ctx->key->exp_data[_i * OAES_RKEY_LEN * OAES_COL_LEN + _j];
-		
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-	{
-		_ctx->step_cb( _ctx->key->exp_data + _i * OAES_RKEY_LEN * OAES_COL_LEN,
-				"ik_sch", _i, NULL );
-		_ctx->step_cb( c, "ik_add", _i, NULL );
-	}
-#endif // OAES_DEBUG
-
-		// InvMixColums(state)
-		oaes_inv_mix_cols( c );
-		oaes_inv_mix_cols( c + 4 );
-		oaes_inv_mix_cols( c + 8 );
-		oaes_inv_mix_cols( c + 12 );
-
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-		_ctx->step_cb( c, "im_col", _i, NULL );
-#endif // OAES_DEBUG
-
-	}
-
-	// InvShiftRows(state)
-	oaes_inv_shift_rows( c );
-
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-		_ctx->step_cb( c, "is_row", 1, NULL );
-#endif // OAES_DEBUG
-
-	// InvSubBytes(state)
-	for( _i = 0; _i < c_len; _i++ )
-		oaes_inv_sub_byte( c + _i );
-
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-		_ctx->step_cb( c, "is_box", 1, NULL );
-#endif // OAES_DEBUG
-
-	// AddRoundKey(state, w[0, Nb-1])
-	for( _i = 0; _i < c_len; _i++ )
-		c[_i] = c[_i] ^ _ctx->key->exp_data[_i];
-	
-#ifdef OAES_DEBUG
-	if( _ctx->step_cb )
-	{
-		_ctx->step_cb( _ctx->key->exp_data, "ik_sch", 1, NULL );
-		_ctx->step_cb( c, "ioutput", 1, NULL );
-	}
-#endif // OAES_DEBUG
-
-	return OAES_RET_SUCCESS;
-}
-
-OAES_RET oaes_encrypt( OAES_CTX * ctx,
-		const uint8_t * m, size_t m_len, uint8_t * c, size_t * c_len )
-{
-	size_t _i, _j, _c_len_in, _c_data_len;
-	size_t _pad_len = m_len % OAES_BLOCK_SIZE == 0 ?
-			0 : OAES_BLOCK_SIZE - m_len % OAES_BLOCK_SIZE;
-	oaes_ctx * _ctx = (oaes_ctx *) ctx;
-	OAES_RET _rc = OAES_RET_SUCCESS;
-	uint8_t _flags = _pad_len ? OAES_FLAG_PAD : 0;
-	
-	if( NULL == _ctx )
-		return OAES_RET_ARG1;
-	
-	if( NULL == m )
-		return OAES_RET_ARG2;
-	
-	if( NULL == c_len )
-		return OAES_RET_ARG5;
-	
-	_c_len_in = *c_len;
-	// data + pad
-	_c_data_len = m_len + _pad_len;
-	// header + iv + data + pad
-	*c_len = 2 * OAES_BLOCK_SIZE + m_len + _pad_len;
-
-	if( NULL == c )
-		return OAES_RET_SUCCESS;
-	
-	if( _c_len_in < *c_len )
-		return OAES_RET_BUF;
-	
-	if( NULL == _ctx->key )
-		return OAES_RET_NOKEY;
-	
-	// fill with random data first
-	for( _i = 0; _i < OAES_BLOCK_SIZE; _i++ )
-		c[_i] = (uint8_t) OAES_RAND(_ctx->rctx);
-	// header
-	memcpy(c + 6, &_ctx->options, sizeof(_ctx->options));
-	memcpy(c + 8, &_flags, sizeof(_flags));
-	// iv
-	memcpy(c + OAES_BLOCK_SIZE, _ctx->iv, OAES_BLOCK_SIZE );
-	// data
-	memcpy(c + 2 * OAES_BLOCK_SIZE, m, m_len );
-	
-	for( _i = 0; _i < _c_data_len; _i += OAES_BLOCK_SIZE )
-	{
-		uint8_t _block[OAES_BLOCK_SIZE];
-		size_t _block_size = min( m_len - _i, OAES_BLOCK_SIZE );
-
-		memcpy( _block, c + 2 * OAES_BLOCK_SIZE + _i, _block_size );
-		
-		// insert pad
-		for( _j = 0; _j < OAES_BLOCK_SIZE - _block_size; _j++ )
-			_block[ _block_size + _j ] = _j + 1;
-	
-		// CBC
-		if( _ctx->options & OAES_OPTION_CBC )
-		{
-			for( _j = 0; _j < OAES_BLOCK_SIZE; _j++ )
-				_block[_j] = _block[_j] ^ _ctx->iv[_j];
-		}
-
-		_rc = _rc ||
-				oaes_encrypt_block( ctx, _block, OAES_BLOCK_SIZE );
-		memcpy( c + 2 * OAES_BLOCK_SIZE + _i, _block, OAES_BLOCK_SIZE );
-		
-		if( _ctx->options & OAES_OPTION_CBC )
-			memcpy( _ctx->iv, _block, OAES_BLOCK_SIZE );
-	}
-	
-	return _rc;
-}
-
-OAES_RET oaes_decrypt( OAES_CTX * ctx,
-		const uint8_t * c, size_t c_len, uint8_t * m, size_t * m_len )
-{
-	size_t _i, _j, _m_len_in;
-	oaes_ctx * _ctx = (oaes_ctx *) ctx;
-	OAES_RET _rc = OAES_RET_SUCCESS;
-	uint8_t _iv[OAES_BLOCK_SIZE];
-	uint8_t _flags;
-	OAES_OPTION _options;
-	
-	if( NULL == ctx )
-		return OAES_RET_ARG1;
-	
-	if( NULL == c )
-		return OAES_RET_ARG2;
-	
-	if( c_len % OAES_BLOCK_SIZE )
-		return OAES_RET_ARG3;
-	
-	if( NULL == m_len )
-		return OAES_RET_ARG5;
-	
-	_m_len_in = *m_len;
-	*m_len = c_len - 2 * OAES_BLOCK_SIZE;
-	
-	if( NULL == m )
-		return OAES_RET_SUCCESS;
-	
-	if( _m_len_in < *m_len )
-		return OAES_RET_BUF;
-	
-	if( NULL == _ctx->key )
-		return OAES_RET_NOKEY;
-	
-	// options
-	memcpy(&_options, c + 6, sizeof(_options));
-	// validate that all options are valid
-	if( _options & ~(
-			  OAES_OPTION_ECB
-			| OAES_OPTION_CBC
-#ifdef OAES_DEBUG
-			| OAES_OPTION_STEP_ON
-			| OAES_OPTION_STEP_OFF
-#endif // OAES_DEBUG
-			) )
-		return OAES_RET_HEADER;
-	if( ( _options & OAES_OPTION_ECB ) &&
-			( _options & OAES_OPTION_CBC ) )
-		return OAES_RET_HEADER;
-	if( _options == OAES_OPTION_NONE )
-		return OAES_RET_HEADER;
-	
-	// flags
-	memcpy(&_flags, c + 8, sizeof(_flags));
-	// validate that all flags are valid
-	if( _flags & ~(
-			  OAES_FLAG_PAD
-			) )
-		return OAES_RET_HEADER;
-
-	// iv
-	memcpy( _iv, c + OAES_BLOCK_SIZE, OAES_BLOCK_SIZE);
-	// data + pad
-	memcpy( m, c + 2 * OAES_BLOCK_SIZE, *m_len );
-	
-	for( _i = 0; _i < *m_len; _i += OAES_BLOCK_SIZE )
-	{
-		if( ( _options & OAES_OPTION_CBC ) && _i > 0 )
-			memcpy( _iv, c + OAES_BLOCK_SIZE + _i, OAES_BLOCK_SIZE );
-		
-		_rc = _rc ||
-				oaes_decrypt_block( ctx, m + _i, min( *m_len - _i, OAES_BLOCK_SIZE ) );
-		
-		// CBC
-		if( _options & OAES_OPTION_CBC )
-		{
-			for( _j = 0; _j < OAES_BLOCK_SIZE; _j++ )
-				m[ _i + _j ] = m[ _i + _j ] ^ _iv[_j];
-		}
-	}
-	
-	// remove pad
-	if( _flags & OAES_FLAG_PAD )
-	{
-		int _is_pad = 1;
-		size_t _temp = (size_t) m[*m_len - 1];
-
-		if( _temp  <= 0x00 || _temp > 0x0f )
-			return OAES_RET_HEADER;
-		for( _i = 0; _i < _temp; _i++ )
-			if( m[*m_len - 1 - _i] != _temp - _i )
-				_is_pad = 0;
-		if( _is_pad )
-		{
-			memset( m + *m_len - _temp, 0, _temp );
-			*m_len -= _temp;
-		}
-		else
-			return OAES_RET_HEADER;
-	}
-	
-	return OAES_RET_SUCCESS;
-}
diff --git a/media/gmp-clearkey/0.1/openaes/oaes_lib.h b/media/gmp-clearkey/0.1/openaes/oaes_lib.h
deleted file mode 100644
index 2344480..0000000
--- a/media/gmp-clearkey/0.1/openaes/oaes_lib.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/* 
- * ---------------------------------------------------------------------------
- * OpenAES License
- * ---------------------------------------------------------------------------
- * Copyright (c) 2013, Nabil S. Al Ramli, www.nalramli.com
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- * 
- *   - Redistributions of source code must retain the above copyright notice,
- *     this list of conditions and the following disclaimer.
- *   - Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- * ---------------------------------------------------------------------------
- */
-
-#ifndef _OAES_LIB_H
-#define _OAES_LIB_H
-
-#include "oaes_common.h"
-
-#ifdef __cplusplus 
-extern "C" {
-#endif
-
-#ifdef _WIN32
-#	ifdef OAES_SHARED
-#		ifdef oaes_lib_EXPORTS
-#			define OAES_API __declspec(dllexport)
-#		else
-#			define OAES_API __declspec(dllimport)
-#		endif
-#	else
-#		define OAES_API
-#	endif
-#else
-#	define OAES_API
-#endif // WIN32
-
-#define OAES_BLOCK_SIZE 16
-
-typedef void OAES_CTX;
-
-/*
- * oaes_set_option() takes one of these values for its [option] parameter
- * some options accept either an optional or a required [value] parameter
- */
-// no option
-#define OAES_OPTION_NONE 0
-// enable ECB mode, disable CBC mode
-#define OAES_OPTION_ECB 1
-// enable CBC mode, disable ECB mode
-// value is optional, may pass uint8_t iv[OAES_BLOCK_SIZE] to specify
-// the value of the initialization vector, iv
-#define OAES_OPTION_CBC 2
-
-#ifdef OAES_DEBUG
-typedef int ( * oaes_step_cb ) (
-		const uint8_t state[OAES_BLOCK_SIZE],
-		const char * step_name,
-		int step_count,
-		void * user_data );
-// enable state stepping mode
-// value is required, must pass oaes_step_cb to receive the state at each step
-#define OAES_OPTION_STEP_ON 4
-// disable state stepping mode
-#define OAES_OPTION_STEP_OFF 8
-#endif // OAES_DEBUG
-
-typedef uint16_t OAES_OPTION;
-
-/*
- * // usage:
- * 
- * OAES_CTX * ctx = oaes_alloc();
- * .
- * .
- * .
- * {
- *   oaes_gen_key_xxx( ctx );
- *   {
- *     oaes_key_export( ctx, _buf, &_buf_len );
- *     // or
- *     oaes_key_export_data( ctx, _buf, &_buf_len );\
- *   }
- * }
- * // or
- * {
- *   oaes_key_import( ctx, _buf, _buf_len );
- *   // or
- *   oaes_key_import_data( ctx, _buf, _buf_len );
- * }
- * .
- * .
- * .
- * oaes_encrypt( ctx, m, m_len, c, &c_len );
- * .
- * .
- * .
- * oaes_decrypt( ctx, c, c_len, m, &m_len );
- * .
- * .
- * .
- * oaes_free( &ctx );
- */
-
-OAES_API OAES_CTX * oaes_alloc();
-
-OAES_API OAES_RET oaes_free( OAES_CTX ** ctx );
-
-OAES_API OAES_RET oaes_set_option( OAES_CTX * ctx,
-		OAES_OPTION option, const void * value );
-
-OAES_API OAES_RET oaes_key_gen_128( OAES_CTX * ctx );
-
-OAES_API OAES_RET oaes_key_gen_192( OAES_CTX * ctx );
-
-OAES_API OAES_RET oaes_key_gen_256( OAES_CTX * ctx );
-
-// export key with header information
-// set data == NULL to get the required data_len
-OAES_API OAES_RET oaes_key_export( OAES_CTX * ctx,
-		uint8_t * data, size_t * data_len );
-
-// directly export the data from key
-// set data == NULL to get the required data_len
-OAES_API OAES_RET oaes_key_export_data( OAES_CTX * ctx,
-		uint8_t * data, size_t * data_len );
-
-// import key with header information
-OAES_API OAES_RET oaes_key_import( OAES_CTX * ctx,
-		const uint8_t * data, size_t data_len );
-
-// directly import data into key
-OAES_API OAES_RET oaes_key_import_data( OAES_CTX * ctx,
-		const uint8_t * data, size_t data_len );
-
-// set c == NULL to get the required c_len
-OAES_API OAES_RET oaes_encrypt( OAES_CTX * ctx,
-		const uint8_t * m, size_t m_len, uint8_t * c, size_t * c_len );
-
-// set m == NULL to get the required m_len
-OAES_API OAES_RET oaes_decrypt( OAES_CTX * ctx,
-		const uint8_t * c, size_t c_len, uint8_t * m, size_t * m_len );
-
-// set buf == NULL to get the required buf_len
-OAES_API OAES_RET oaes_sprintf(
-		char * buf, size_t * buf_len, const uint8_t * data, size_t data_len );
-
-#ifdef __cplusplus 
-}
-#endif
-
-#endif // _OAES_LIB_H
diff --git a/media/gmp-clearkey/0.1/openaes/standard.h b/media/gmp-clearkey/0.1/openaes/standard.h
deleted file mode 100644
index fbe6ef5..0000000
--- a/media/gmp-clearkey/0.1/openaes/standard.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
-------------------------------------------------------------------------------
-Standard definitions and types, Bob Jenkins
-------------------------------------------------------------------------------
-*/
-#ifndef STANDARD
-# define STANDARD
-# ifndef STDIO
-#  include <stdio.h>
-#  define STDIO
-# endif
-# ifndef STDDEF
-#  include <stddef.h>
-#  define STDDEF
-# endif
-typedef  unsigned long long  ub8;
-#define UB8MAXVAL 0xffffffffffffffffLL
-#define UB8BITS 64
-typedef    signed long long  sb8;
-#define SB8MAXVAL 0x7fffffffffffffffLL
-typedef  unsigned long  int  ub4;   /* unsigned 4-byte quantities */
-#define UB4MAXVAL 0xffffffff
-typedef    signed long  int  sb4;
-#define UB4BITS 32
-#define SB4MAXVAL 0x7fffffff
-typedef  unsigned short int  ub2;
-#define UB2MAXVAL 0xffff
-#define UB2BITS 16
-typedef    signed short int  sb2;
-#define SB2MAXVAL 0x7fff
-typedef  unsigned       char ub1;
-#define UB1MAXVAL 0xff
-#define UB1BITS 8
-typedef    signed       char sb1;   /* signed 1-byte quantities */
-#define SB1MAXVAL 0x7f
-typedef                 int  word;  /* fastest type available */
-
-#define bis(target,mask)  ((target) |=  (mask))
-#define bic(target,mask)  ((target) &= ~(mask))
-#define bit(target,mask)  ((target) &   (mask))
-// #ifndef min
-// # define min(a,b) (((a)<(b)) ? (a) : (b))
-// #endif /* min */
-// #ifndef max
-// # define max(a,b) (((a)<(b)) ? (b) : (a))
-// #endif /* max */
-#ifndef align
-# define align(a) (((ub4)a+(sizeof(void *)-1))&(~(sizeof(void *)-1)))
-#endif /* align */
-// #ifndef abs
-// # define abs(a)   (((a)>0) ? (a) : -(a))
-// #endif
-#define TRUE  1
-#define FALSE 0
-#define SUCCESS 0  /* 1 on VAX */
-
-#endif /* STANDARD */
diff --git a/media/webrtc/signaling/src/peerconnection/MediaPipelineFactory.cpp b/media/webrtc/signaling/src/peerconnection/MediaPipelineFactory.cpp
index 2f9cc36..75da6a8 100644
--- a/media/webrtc/signaling/src/peerconnection/MediaPipelineFactory.cpp
+++ b/media/webrtc/signaling/src/peerconnection/MediaPipelineFactory.cpp
@@ -22,7 +22,6 @@
 #include "mozilla/Preferences.h"
 #endif
 
-#include "GmpVideoCodec.h"
 #ifdef MOZ_WEBRTC_OMX
 #include "OMXVideoCodec.h"
 #include "OMXCodecWrapper.h"
@@ -794,8 +793,6 @@ MediaPipelineFactory::EnsureExternalCodec(VideoSessionConduit& aConduit,
 #ifdef MOZ_WEBRTC_OMX
       encoder =
           OMXVideoCodec::CreateEncoder(OMXVideoCodec::CodecType::CODEC_H264);
-#else
-      encoder = GmpVideoCodec::CreateEncoder();
 #endif
       if (encoder) {
         return aConduit.SetExternalSendCodec(aConfig, encoder);
@@ -807,8 +804,6 @@ MediaPipelineFactory::EnsureExternalCodec(VideoSessionConduit& aConduit,
 #ifdef MOZ_WEBRTC_OMX
       decoder =
           OMXVideoCodec::CreateDecoder(OMXVideoCodec::CodecType::CODEC_H264);
-#else
-      decoder = GmpVideoCodec::CreateDecoder();
 #endif
       if (decoder) {
         return aConduit.SetExternalRecvCodec(aConfig, decoder);
diff --git a/media/webrtc/signaling/src/peerconnection/PeerConnectionCtx.cpp b/media/webrtc/signaling/src/peerconnection/PeerConnectionCtx.cpp
index ea11847..cdd182a 100644
--- a/media/webrtc/signaling/src/peerconnection/PeerConnectionCtx.cpp
+++ b/media/webrtc/signaling/src/peerconnection/PeerConnectionCtx.cpp
@@ -26,9 +26,6 @@
 #include "mozilla/Services.h"
 #include "StaticPtr.h"
 
-#include "gmp-video-decode.h" // GMP_API_VIDEO_DECODER
-#include "gmp-video-encode.h" // GMP_API_VIDEO_ENCODER
-
 static const char* logTag = "PeerConnectionCtx";
 
 namespace mozilla {
@@ -311,7 +308,6 @@ PeerConnectionCtx::EverySecondTelemetryCallback_m(nsITimer* timer, void *closure
 #endif
 
 nsresult PeerConnectionCtx::Initialize() {
-  initGMP();
 
 #ifdef MOZILLA_INTERNAL_API
   mConnectionCounter = 0;
@@ -328,48 +324,10 @@ nsresult PeerConnectionCtx::Initialize() {
   return NS_OK;
 }
 
-static void GMPReady_m() {
-  if (PeerConnectionCtx::isActive()) {
-    PeerConnectionCtx::GetInstance()->onGMPReady();
-  }
-};
-
-static void GMPReady() {
-  PeerConnectionCtx::gMainThread->Dispatch(WrapRunnableNM(&GMPReady_m),
-                                           NS_DISPATCH_NORMAL);
-};
-
-void PeerConnectionCtx::initGMP()
-{
-  mGMPService = do_GetService("@mozilla.org/goanna-media-plugin-service;1");
-
-  if (!mGMPService) {
-    CSFLogError(logTag, "%s failed to get the goanna-media-plugin-service",
-                __FUNCTION__);
-    return;
-  }
-
-  nsCOMPtr<nsIThread> thread;
-  nsresult rv = mGMPService->GetThread(getter_AddRefs(thread));
-
-  if (NS_FAILED(rv)) {
-    mGMPService = nullptr;
-    CSFLogError(logTag,
-                "%s failed to get the goanna-media-plugin thread, err=%u",
-                __FUNCTION__,
-                static_cast<unsigned>(rv));
-    return;
-  }
-
-  // presumes that all GMP dir scans have been queued for the GMPThread
-  thread->Dispatch(WrapRunnableNM(&GMPReady), NS_DISPATCH_NORMAL);
-}
-
 nsresult PeerConnectionCtx::Cleanup() {
   CSFLogDebug(logTag, "%s", __FUNCTION__);
 
   mQueuedJSEPOperations.Clear();
-  mGMPService = nullptr;
   return NS_OK;
 }
 
@@ -387,39 +345,12 @@ void PeerConnectionCtx::queueJSEPOperation(nsRefPtr<nsIRunnable> aOperation) {
   mQueuedJSEPOperations.AppendElement(aOperation);
 }
 
-void PeerConnectionCtx::onGMPReady() {
-  mGMPReady = true;
-  for (size_t i = 0; i < mQueuedJSEPOperations.Length(); ++i) {
-    mQueuedJSEPOperations[i]->Run();
-  }
-  mQueuedJSEPOperations.Clear();
-}
-
-bool PeerConnectionCtx::gmpHasH264() {
-  if (!mGMPService) {
-    return false;
-  }
-
   // XXX I'd prefer if this was all known ahead of time...
 
   nsTArray<nsCString> tags;
   tags.AppendElement(NS_LITERAL_CSTRING("h264"));
 
-  bool has_gmp;
   nsresult rv;
-  rv = mGMPService->HasPluginForAPI(NS_LITERAL_CSTRING(GMP_API_VIDEO_ENCODER),
-                                    &tags,
-                                    &has_gmp);
-  if (NS_FAILED(rv) || !has_gmp) {
-    return false;
-  }
-
-  rv = mGMPService->HasPluginForAPI(NS_LITERAL_CSTRING(GMP_API_VIDEO_DECODER),
-                                    &tags,
-                                    &has_gmp);
-  if (NS_FAILED(rv) || !has_gmp) {
-    return false;
-  }
 
   return true;
 }
diff --git a/media/webrtc/signaling/src/peerconnection/PeerConnectionCtx.h b/media/webrtc/signaling/src/peerconnection/PeerConnectionCtx.h
index a7ae629..a4198a2 100644
--- a/media/webrtc/signaling/src/peerconnection/PeerConnectionCtx.h
+++ b/media/webrtc/signaling/src/peerconnection/PeerConnectionCtx.h
@@ -23,7 +23,6 @@ class WebrtcGlobalInformation;
 // A class to hold some of the singleton objects we need:
 // * The global PeerConnectionImpl table and its associated lock.
 // * Stats report objects for PCs that are gone
-// * GMP related state
 class PeerConnectionCtx {
  public:
   static nsresult InitializeGlobal(nsIThread *mainThread, nsIEventTarget *stsThread);
@@ -32,17 +31,10 @@ class PeerConnectionCtx {
   static void Destroy();
 
   bool isReady() {
-    // If mGMPService is not set, we aren't using GMP.
-    if (mGMPService) {
-      return mGMPReady;
-    }
     return true;
   }
 
   void queueJSEPOperation(nsRefPtr<nsIRunnable> aJSEPOperation);
-  void onGMPReady();
-
-  bool gmpHasH264();
 
   // Make these classes friend so that they can access mPeerconnections.
   friend class PeerConnectionImpl;
@@ -60,7 +52,6 @@ class PeerConnectionCtx {
   // We could make these available only via accessors but it's too much trouble.
   std::map<const std::string, PeerConnectionImpl *> mPeerConnections;
 
-  PeerConnectionCtx() :  mGMPReady(false) {}
   // This is a singleton, so don't copy construct it, etc.
   PeerConnectionCtx(const PeerConnectionCtx& other) = delete;
   void operator=(const PeerConnectionCtx& other) = delete;
@@ -69,8 +60,6 @@ class PeerConnectionCtx {
   nsresult Initialize();
   nsresult Cleanup();
 
-  void initGMP();
-
   static void
   EverySecondTelemetryCallback_m(nsITimer* timer, void *);
 
@@ -87,13 +76,6 @@ public:
 private:
 #endif
 
-  // We cannot form offers/answers properly until the Goanna Media Plugin stuff
-  // has been initted, which is a complicated mess of thread dispatches,
-  // including sync dispatches to main. So, we need to be able to queue up
-  // offer creation (or SetRemote, when we're the answerer) until all of this is
-  // ready to go, since blocking on this init is just begging for deadlock.
-  nsCOMPtr<mozIGoannaMediaPluginService> mGMPService;
-  bool mGMPReady;
   nsTArray<nsRefPtr<nsIRunnable>> mQueuedJSEPOperations;
 
   static PeerConnectionCtx *gInstance;
diff --git a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
index 1e1b9e7..0adbb11 100644
--- a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
+++ b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
@@ -895,9 +895,6 @@ PeerConnectionImpl::ConfigureJsepSessionCodecs() {
 
 #endif // MOZ_WEBRTC_OMX
 
-#ifdef MOZILLA_INTERNAL_API
-  bool softwareH264Enabled = PeerConnectionCtx::GetInstance()->gmpHasH264();
-#else
   // For unit-tests
   bool softwareH264Enabled = true;
 #endif
@@ -2315,7 +2312,6 @@ PeerConnectionImpl::PluginCrash(uint64_t aPluginID,
   init.mPluginDumpID = aPluginDumpID;
   init.mPluginName = aPluginName;
   init.mSubmittedCrashReport = false;
-  init.mGmpPlugin = true;
   init.mBubbles = true;
   init.mCancelable = true;
 
diff --git a/mobile/android/app/mobile.js b/mobile/android/app/mobile.js
index 87ffc96..2ad52dc 100644
--- a/mobile/android/app/mobile.js
+++ b/mobile/android/app/mobile.js
@@ -801,9 +801,6 @@ pref("device.storage.enabled", true);
 // Enable meta-viewport support for font inflation code
 pref("dom.meta-viewport.enabled", true);
 
-// Enable GMP support in the addon manager.
-pref("media.gmp-provider.enabled", true);
-
 // The default color scheme in reader mode (light, dark, auto)
 // auto = color automatically adjusts according to ambient light level
 // (auto only works on platforms where the 'devicelight' event is enabled)
diff --git a/mobile/android/chrome/content/browser.js b/mobile/android/chrome/content/browser.js
index 2d2ffc3..e100611 100644
--- a/mobile/android/chrome/content/browser.js
+++ b/mobile/android/chrome/content/browser.js
@@ -100,9 +100,6 @@ XPCOMUtils.defineLazyModuleGetter(this, "SharedPreferences",
 XPCOMUtils.defineLazyModuleGetter(this, "Notifications",
                                   "resource://gre/modules/Notifications.jsm");
 
-XPCOMUtils.defineLazyModuleGetter(this, "GMPInstallManager",
-                                  "resource://gre/modules/GMPInstallManager.jsm");
-
 XPCOMUtils.defineLazyModuleGetter(this, "ReaderMode", "resource://gre/modules/ReaderMode.jsm");
 
 let lazilyLoadedBrowserScripts = [
@@ -373,8 +370,8 @@ var BrowserApp = {
 
           // Delay this a minute because there's no rush
           setTimeout(() => {
-            BrowserApp.gmpInstallManager = new GMPInstallManager();
-            BrowserApp.gmpInstallManager.simpleCheckAndInstall().then(null, () => {});
+          //  BrowserApp.gmpInstallManager = new GMPInstallManager();
+          //  BrowserApp.gmpInstallManager.simpleCheckAndInstall().then(null, () => {});
           }, 1000 * 60);
         }, Ci.nsIThread.DISPATCH_NORMAL);
 
@@ -1228,9 +1225,9 @@ var BrowserApp = {
   },
 
   quit: function quit(aClear = { sanitize: {}, dontSaveSession: false }) {
-    if (this.gmpInstallManager) {
-      this.gmpInstallManager.uninit();
-    }
+//    if (this.gmpInstallManager) {
+//      this.gmpInstallManager.uninit();
+//    }
 
     // Figure out if there's at least one other browser window around.
     let lastBrowser = true;
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
index 0d97f0e..1bd76ff 100644
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -335,7 +335,6 @@ pref("media.windows-media-foundation.use-dxva", true);
 pref("media.ffmpeg.enabled", true);
 pref("media.libavcodec.allow-obsolete", false);
 #endif
-pref("media.gmp.decoder.enabled", false);
 #ifdef MOZ_RAW
 pref("media.raw.enabled", true);
 #endif
@@ -4653,44 +4652,6 @@ pref("browser.search.geoip.timeout", 2000);
 pref("browser.search.official", true);
 #endif
 
-#ifndef MOZ_WIDGET_GONK
-// GMPInstallManager prefs
-
-// User-settable override to media.gmp-manager.url for testing purposes.
-//pref("media.gmp-manager.url.override", "");
-
-// Update service URL for GMP install/updates:
-pref("media.gmp-manager.url", "https://aus4.mozilla.org/update/3/GMP/%VERSION%/%BUILD_ID%/%BUILD_TARGET%/%LOCALE%/%CHANNEL%/%OS_VERSION%/%DISTRIBUTION%/%DISTRIBUTION_VERSION%/update.xml");
-
-// When |media.gmp-manager.cert.requireBuiltIn| is true or not specified the
-// final certificate and all certificates the connection is redirected to before
-// the final certificate for the url specified in the |media.gmp-manager.url|
-// preference must be built-in.
-pref("media.gmp-manager.cert.requireBuiltIn", true);
-
-// The |media.gmp-manager.certs.| preference branch contains branches that are
-// sequentially numbered starting at 1 that contain attribute name / value
-// pairs for the certificate used by the server that hosts the update xml file
-// as specified in the |media.gmp-manager.url| preference. When these preferences are
-// present the following conditions apply for a successful update check:
-// 1. the uri scheme must be https
-// 2. the preference name must exist as an attribute name on the certificate and
-//    the value for the name must be the same as the value for the attribute name
-//    on the certificate.
-// If these conditions aren't met it will be treated the same as when there is
-// no update available. This validation will not be performed when the
-// |media.gmp-manager.url.override| user preference has been set for testing updates or
-// when the |media.gmp-manager.cert.checkAttributes| preference is set to false. Also,
-// the |media.gmp-manager.url.override| preference should ONLY be used for testing.
-// IMPORTANT! app.update.certs.* prefs should also be updated if these
-// are updated.
-pref("media.gmp-manager.cert.checkAttributes", true);
-pref("media.gmp-manager.certs.1.issuerName", "CN=DigiCert Secure Server CA,O=DigiCert Inc,C=US");
-pref("media.gmp-manager.certs.1.commonName", "aus4.mozilla.org");
-pref("media.gmp-manager.certs.2.issuerName", "CN=Thawte SSL CA,O=\"Thawte, Inc.\",C=US");
-pref("media.gmp-manager.certs.2.commonName", "aus4.mozilla.org");
-#endif
-
 // Whether or not to perform reader mode article parsing on page load.
 // If this pref is disabled, we will never show a reader mode icon in the toolbar.
 pref("reader.parse-on-load.enabled", true);
@@ -4724,12 +4685,6 @@ pref("reader.has_used_toolbar", false);
 // Whether to use a vertical or horizontal toolbar.
 pref("reader.toolbar.vertical", true);
 
-#if defined(XP_LINUX) && defined(MOZ_GMP_SANDBOX)
-// Whether to allow, on a Linux system that doesn't support the necessary sandboxing
-// features, loading Goanna Media Plugins unsandboxed.
-pref("media.gmp.insecure.allow", false);
-#endif
-
 // Use vsync aligned rendering.
 // Only supported on windows, os x, and b2g
 #if defined(XP_WIN) || defined(XP_MACOSX)
diff --git a/python/mozbuild/mozbuild/mach_commands.py b/python/mozbuild/mozbuild/mach_commands.py
index 7ee9677..9e63840 100644
--- a/python/mozbuild/mozbuild/mach_commands.py
+++ b/python/mozbuild/mozbuild/mach_commands.py
@@ -710,10 +710,6 @@ class GTestCommands(MachCommandBase):
 
         xre_path = os.path.join(self.topobjdir, "dist", "bin")
         gtest_env["MOZ_XRE_DIR"] = xre_path
-        gtest_env["MOZ_GMP_PATH"] = os.pathsep.join(
-            os.path.join(xre_path, p, "1.0")
-            for p in ('gmp-fake', 'gmp-fakeopenh264')
-        )
 
         gtest_env[b"MOZ_RUN_GTEST"] = b"True"
 
diff --git a/security/sandbox/linux/Sandbox.cpp b/security/sandbox/linux/Sandbox.cpp
index ee1a138..583b0f3 100644
--- a/security/sandbox/linux/Sandbox.cpp
+++ b/security/sandbox/linux/Sandbox.cpp
@@ -58,14 +58,6 @@ namespace mozilla {
 SandboxCrashFunc gSandboxCrashFunc;
 #endif
 
-#ifdef MOZ_GMP_SANDBOX
-// For media plugins, we can start the sandbox before we dlopen the
-// module, so we have to pre-open the file and simulate the sandboxed
-// open().
-static int gMediaPluginFileDesc = -1;
-static const char *gMediaPluginFilePath;
-#endif
-
 /**
  * This is the SIGSYS handler function. It is used to report to the user
  * which system call has been denied by Seccomp.
@@ -113,27 +105,6 @@ Reporter(int nr, siginfo_t *info, void *void_context)
   }
 #endif
 
-#ifdef MOZ_GMP_SANDBOX
-  if (syscall_nr == __NR_open && gMediaPluginFilePath) {
-    const char *path = reinterpret_cast<const char*>(args[0]);
-    int flags = int(args[1]);
-
-    if ((flags & O_ACCMODE) != O_RDONLY) {
-      SANDBOX_LOG_ERROR("non-read-only open of file %s attempted (flags=0%o)",
-                        path, flags);
-    } else if (strcmp(path, gMediaPluginFilePath) != 0) {
-      SANDBOX_LOG_ERROR("attempt to open file %s which is not the media plugin"
-                        " %s", path, gMediaPluginFilePath);
-    } else if (gMediaPluginFileDesc == -1) {
-      SANDBOX_LOG_ERROR("multiple opens of media plugin file unimplemented");
-    } else {
-      SECCOMP_RESULT(ctx) = gMediaPluginFileDesc;
-      gMediaPluginFileDesc = -1;
-      return;
-    }
-  }
-#endif
-
   SANDBOX_LOG_ERROR("seccomp sandbox violation: pid %d, syscall %lu,"
                     " args %lu %lu %lu %lu %lu %lu.  Killing process.",
                     pid, syscall_nr,
@@ -439,37 +410,4 @@ SetContentProcessSandbox()
 }
 #endif // MOZ_CONTENT_SANDBOX
 
-#ifdef MOZ_GMP_SANDBOX
-/**
- * Starts the seccomp sandbox for a media plugin process.  Should be
- * called only once, and before any potentially harmful content is
- * loaded -- including the plugin itself, if it's considered untrusted.
- *
- * The file indicated by aFilePath, if non-null, can be open()ed once
- * read-only after the sandbox starts; it should be the .so file
- * implementing the not-yet-loaded plugin.
- *
- * Will normally make the process exit on failure.
-*/
-void
-SetMediaPluginSandbox(const char *aFilePath)
-{
-  if (!SandboxInfo::Get().Test(SandboxInfo::kEnabledForMedia)) {
-    return;
-  }
-
-  if (aFilePath) {
-    gMediaPluginFilePath = strdup(aFilePath);
-    gMediaPluginFileDesc = open(aFilePath, O_RDONLY | O_CLOEXEC);
-    if (gMediaPluginFileDesc == -1) {
-      SANDBOX_LOG_ERROR("failed to open plugin file %s: %s",
-                        aFilePath, strerror(errno));
-      MOZ_CRASH();
-    }
-  }
-  // Finally, start the sandbox.
-  SetCurrentProcessSandbox(kSandboxMediaPlugin);
-}
-#endif // MOZ_GMP_SANDBOX
-
 } // namespace mozilla
diff --git a/security/sandbox/linux/Sandbox.h b/security/sandbox/linux/Sandbox.h
index 7e6314b..b5acf91 100644
--- a/security/sandbox/linux/Sandbox.h
+++ b/security/sandbox/linux/Sandbox.h
@@ -29,12 +29,6 @@ namespace mozilla {
 MOZ_SANDBOX_EXPORT void SetContentProcessSandbox();
 #endif
 
-#ifdef MOZ_GMP_SANDBOX
-// Call only if SandboxInfo::CanSandboxMedia() returns true.
-// (No-op if MOZ_DISABLE_GMP_SANDBOX is set.)
-MOZ_SANDBOX_EXPORT void SetMediaPluginSandbox(const char *aFilePath);
-#endif
-
 } // namespace mozilla
 
 #endif // mozilla_Sandbox_h
diff --git a/security/sandbox/linux/SandboxFilter.cpp b/security/sandbox/linux/SandboxFilter.cpp
index af00aeb..79d887a 100644
--- a/security/sandbox/linux/SandboxFilter.cpp
+++ b/security/sandbox/linux/SandboxFilter.cpp
@@ -348,108 +348,6 @@ SandboxFilterImplContent::Build() {
 }
 #endif // MOZ_CONTENT_SANDBOX
 
-#ifdef MOZ_GMP_SANDBOX
-class SandboxFilterImplGMP : public SandboxFilterImpl {
-protected:
-  virtual void Build() override;
-};
-
-void SandboxFilterImplGMP::Build() {
-  // As for content processes, check the most common syscalls first.
-
-  Allow(SYSCALL_WITH_ARG(clock_gettime, 0, CLOCK_MONOTONIC, CLOCK_REALTIME));
-  Allow(SYSCALL(futex));
-  Allow(SYSCALL(gettimeofday));
-  Allow(SYSCALL(poll));
-  Allow(SYSCALL(write));
-  Allow(SYSCALL(read));
-  Allow(SYSCALL(epoll_wait));
-  Allow(SYSCALL(epoll_pwait));
-  Allow(SOCKETCALL(recvmsg, RECVMSG));
-  Allow(SOCKETCALL(sendmsg, SENDMSG));
-  Allow(SYSCALL(time));
-  Allow(SYSCALL(sched_yield));
-
-  // Nothing after this line is performance-critical.
-
-#if SYSCALL_EXISTS(mmap2)
-  Allow(SYSCALL(mmap2));
-#else
-  Allow(SYSCALL(mmap));
-#endif
-  Allow(SYSCALL_LARGEFILE(fstat, fstat64));
-  Allow(SYSCALL(munmap));
-
-  Allow(SYSCALL(getpid));
-  Allow(SYSCALL(gettid));
-
-  AllowThreadClone();
-
-  Allow(SYSCALL_WITH_ARG(prctl, 0, PR_GET_SECCOMP, PR_SET_NAME));
-
-#if SYSCALL_EXISTS(set_robust_list)
-  Allow(SYSCALL(set_robust_list));
-#endif
-
-  // NSPR can call this when creating a thread, but it will accept a
-  // polite "no".
-  Deny(EACCES, SYSCALL(getpriority));
-  // But if thread creation races with sandbox startup, that call
-  // could succeed, and then we get one of these:
-  Deny(EACCES, SYSCALL(setpriority));
-
-  // Stack bounds are obtained via pthread_getattr_np, which calls
-  // this but doesn't actually need it:
-  Deny(ENOSYS, SYSCALL(sched_getaffinity));
-
-#ifdef MOZ_ASAN
-  Allow(SYSCALL(sigaltstack));
-  // ASAN's error reporter wants to know if stderr is a tty.
-  Deny(ENOTTY, SYSCALL_WITH_ARG(ioctl, 0, STDERR_FILENO));
-  // ...and before compiler-rt r209773, it will call readlink and use
-  // the cached value only if that fails:
-  Deny(ENOENT, SYSCALL(readlink));
-  // ...and if it found an external symbolizer, it will try to run it:
-  // (See also bug 1081242 comment #7.)
-  Deny(ENOENT, SYSCALL_LARGEFILE(stat, stat64));
-#endif
-
-  Allow(SYSCALL(mprotect));
-  Allow(SYSCALL_WITH_ARG(madvise, 2, MADV_DONTNEED));
-
-#if SYSCALL_EXISTS(sigreturn)
-  Allow(SYSCALL(sigreturn));
-#endif
-  Allow(SYSCALL(rt_sigreturn));
-
-  Allow(SYSCALL(restart_syscall));
-  Allow(SYSCALL(close));
-
-  // "Sleeping for 300 seconds" in debug crashes; possibly other uses.
-  Allow(SYSCALL(nanosleep));
-
-  // For the crash reporter:
-#if SYSCALL_EXISTS(sigprocmask)
-  Allow(SYSCALL(sigprocmask));
-#endif
-  Allow(SYSCALL(rt_sigprocmask));
-#if SYSCALL_EXISTS(sigaction)
-  Allow(SYSCALL(sigaction));
-#endif
-  Allow(SYSCALL(rt_sigaction));
-  Allow(SYSCALL(pipe));
-  Allow(SYSCALL_WITH_ARG(tgkill, 0, uint32_t(getpid())));
-  Allow(SYSCALL_WITH_ARG(prctl, 0, PR_SET_DUMPABLE));
-
-  // Note for when GMP is supported on an ARM platform: Add whichever
-  // of the ARM-specific syscalls are needed for this type of process.
-
-  Allow(SYSCALL(epoll_ctl));
-  Allow(SYSCALL(exit));
-  Allow(SYSCALL(exit_group));
-}
-#endif // MOZ_GMP_SANDBOX
-
 SandboxFilter::SandboxFilter(const sock_fprog** aStored, SandboxType aType,
                              bool aVerbose)
   : mStored(aStored)
@@ -466,14 +364,6 @@ SandboxFilter::SandboxFilter(const sock_fprog** aStored, SandboxType aType,
     MOZ_CRASH("Content process sandboxing not supported in this build!");
 #endif
     break;
-  case kSandboxMediaPlugin:
-#ifdef MOZ_GMP_SANDBOX
-    impl = new SandboxFilterImplGMP();
-#else
-    MOZ_CRASH("Goanna Media Plugin process sandboxing not supported in this"
-              " build!");
-#endif
-    break;
   default:
     MOZ_CRASH("Nonexistent sandbox type!");
   }
diff --git a/security/sandbox/linux/common/SandboxInfo.cpp b/security/sandbox/linux/common/SandboxInfo.cpp
index 6cf8998..310e027 100644
--- a/security/sandbox/linux/common/SandboxInfo.cpp
+++ b/security/sandbox/linux/common/SandboxInfo.cpp
@@ -42,11 +42,6 @@ SandboxInfo::SandboxInfo() {
     flags |= kEnabledForContent;
   }
 #endif
-#ifdef MOZ_GMP_SANDBOX
-  if (!getenv("MOZ_DISABLE_GMP_SANDBOX")) {
-    flags |= kEnabledForMedia;
-  }
-#endif
   if (getenv("MOZ_SANDBOX_VERBOSE")) {
     flags |= kVerbose;
   }
diff --git a/security/sandbox/linux/common/SandboxInfo.h b/security/sandbox/linux/common/SandboxInfo.h
index 524ee7c..fe27a9c 100644
--- a/security/sandbox/linux/common/SandboxInfo.h
+++ b/security/sandbox/linux/common/SandboxInfo.h
@@ -27,10 +27,8 @@ public:
     kHasSeccompBPF     = 1 << 0,
     // Config flag MOZ_CONTENT_SANDBOX; env var MOZ_DISABLE_CONTENT_SANDBOX.
     kEnabledForContent = 1 << 1,
-    // Config flag MOZ_GMP_SANDBOX; env var MOZ_DISABLE_GMP_SANDBOX.
-    kEnabledForMedia   = 1 << 2,
     // Env var MOZ_SANDBOX_VERBOSE.
-    kVerbose           = 1 << 3,
+    kVerbose           = 1 << 2,
   };
 
   bool Test(Flags aFlag) const { return (mFlags & aFlag) == aFlag; }
diff --git a/security/sandbox/mac/Sandbox.h b/security/sandbox/mac/Sandbox.h
index 8ab1d04..403d6b2 100644
--- a/security/sandbox/mac/Sandbox.h
+++ b/security/sandbox/mac/Sandbox.h
@@ -17,9 +17,6 @@ enum MacSandboxType {
 
 enum MacSandboxPluginType {
   MacSandboxPluginType_Default = 0,
-  MacSandboxPluginType_GMPlugin_Default,  // Any Goanna Media Plugin
-  MacSandboxPluginType_GMPlugin_OpenH264, // Goanna Media Plugin, OpenH264
-  MacSandboxPluginType_GMPlugin_EME,      // Goanna Media Plugin, EME
   MacSandboxPluginType_Invalid
 };
 
diff --git a/security/sandbox/win/src/sandboxbroker/sandboxBroker.cpp b/security/sandbox/win/src/sandboxbroker/sandboxBroker.cpp
index 70e9ba5..02177f0 100644
--- a/security/sandbox/win/src/sandboxbroker/sandboxBroker.cpp
+++ b/security/sandbox/win/src/sandboxbroker/sandboxBroker.cpp
@@ -204,125 +204,6 @@ SandboxBroker::SetSecurityLevelForIPDLUnitTestProcess()
 }
 
 bool
-SandboxBroker::SetSecurityLevelForGMPlugin()
-{
-  if (!mPolicy) {
-    return false;
-  }
-
-  auto result = mPolicy->SetJobLevel(sandbox::JOB_LOCKDOWN, 0);
-  bool ret = (sandbox::SBOX_ALL_OK == result);
-  result =
-    mPolicy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,
-                           sandbox::USER_LOCKDOWN);
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  result = mPolicy->SetAlternateDesktop(true);
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  result = mPolicy->SetIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  result =
-    mPolicy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_UNTRUSTED);
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  sandbox::MitigationFlags mitigations =
-    sandbox::MITIGATION_BOTTOM_UP_ASLR |
-    sandbox::MITIGATION_HEAP_TERMINATE |
-    sandbox::MITIGATION_SEHOP |
-    sandbox::MITIGATION_DEP_NO_ATL_THUNK |
-    sandbox::MITIGATION_DEP;
-
-  result = mPolicy->SetProcessMitigations(mitigations);
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  mitigations =
-    sandbox::MITIGATION_STRICT_HANDLE_CHECKS |
-    sandbox::MITIGATION_DLL_SEARCH_ORDER;
-
-  result = mPolicy->SetDelayedProcessMitigations(mitigations);
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  // Add the policy for the client side of a pipe. It is just a file
-  // in the \pipe\ namespace. We restrict it to pipes that start with
-  // "chrome." so the sandboxed process cannot connect to system services.
-  result = mPolicy->AddRule(sandbox::TargetPolicy::SUBSYS_FILES,
-                            sandbox::TargetPolicy::FILES_ALLOW_ANY,
-                            L"\\??\\pipe\\chrome.*");
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  // Add the policy for the client side of the crash server pipe.
-  result = mPolicy->AddRule(sandbox::TargetPolicy::SUBSYS_FILES,
-                            sandbox::TargetPolicy::FILES_ALLOW_ANY,
-                            L"\\??\\pipe\\goanna-crash-server-pipe.*");
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-#ifdef DEBUG
-  // The plugin process can't create named events, but we'll
-  // make an exception for the events used in logging. Removing
-  // this will break EME in debug builds.
-  result = mPolicy->AddRule(sandbox::TargetPolicy::SUBSYS_SYNC,
-                            sandbox::TargetPolicy::EVENTS_ALLOW_ANY,
-                            L"ChromeIPCLog.*");
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-#endif
-
-  // The following rules were added because, during analysis of an EME
-  // plugin during development, these registry keys were accessed when
-  // loading the plugin. Commenting out these policy exceptions caused
-  // plugin loading to fail, so they are necessary for proper functioning
-  // of at least one EME plugin.
-  result = mPolicy->AddRule(sandbox::TargetPolicy::SUBSYS_REGISTRY,
-                            sandbox::TargetPolicy::REG_ALLOW_READONLY,
-                            L"HKEY_CURRENT_USER");
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  result = mPolicy->AddRule(sandbox::TargetPolicy::SUBSYS_REGISTRY,
-                            sandbox::TargetPolicy::REG_ALLOW_READONLY,
-                            L"HKEY_CURRENT_USER\\Control Panel\\Desktop");
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  result = mPolicy->AddRule(sandbox::TargetPolicy::SUBSYS_REGISTRY,
-                            sandbox::TargetPolicy::REG_ALLOW_READONLY,
-                            L"HKEY_CURRENT_USER\\Control Panel\\Desktop\\LanguageConfiguration");
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  result = mPolicy->AddRule(sandbox::TargetPolicy::SUBSYS_REGISTRY,
-                            sandbox::TargetPolicy::REG_ALLOW_READONLY,
-                            L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SideBySide");
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-
-  // The following rules were added because, during analysis of an EME
-  // plugin during development, these registry keys were accessed when
-  // loading the plugin. Commenting out these policy exceptions did not
-  // cause anything to break during initial testing, but might cause
-  // unforeseen issues down the road.
-  result = mPolicy->AddRule(sandbox::TargetPolicy::SUBSYS_REGISTRY,
-                            sandbox::TargetPolicy::REG_ALLOW_READONLY,
-                            L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\MUI\\Settings");
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  result = mPolicy->AddRule(sandbox::TargetPolicy::SUBSYS_REGISTRY,
-                            sandbox::TargetPolicy::REG_ALLOW_READONLY,
-                            L"HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\Control Panel\\Desktop");
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  result = mPolicy->AddRule(sandbox::TargetPolicy::SUBSYS_REGISTRY,
-                            sandbox::TargetPolicy::REG_ALLOW_READONLY,
-                            L"HKEY_CURRENT_USER\\Control Panel\\Desktop\\PreferredUILanguages");
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  result = mPolicy->AddRule(sandbox::TargetPolicy::SUBSYS_REGISTRY,
-                            sandbox::TargetPolicy::REG_ALLOW_READONLY,
-                            L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SideBySide\\PreferExternalManifest");
-  ret = ret && (sandbox::SBOX_ALL_OK == result);
-
-  return ret;
-}
-
-bool
 SandboxBroker::AllowReadFile(wchar_t const *file)
 {
   auto result =
diff --git a/security/sandbox/win/src/sandboxbroker/sandboxBroker.h b/security/sandbox/win/src/sandboxbroker/sandboxBroker.h
index 12cf1d3..3f080b5 100644
--- a/security/sandbox/win/src/sandboxbroker/sandboxBroker.h
+++ b/security/sandbox/win/src/sandboxbroker/sandboxBroker.h
@@ -38,7 +38,6 @@ public:
 #endif
   bool SetSecurityLevelForPluginProcess(int32_t aSandboxLevel);
   bool SetSecurityLevelForIPDLUnitTestProcess();
-  bool SetSecurityLevelForGMPlugin();
 
   // File system permissions
   bool AllowReadFile(wchar_t const *file);
diff --git a/services/healthreport/tests/xpcshell/test_provider_addons.js b/services/healthreport/tests/xpcshell/test_provider_addons.js
index e5775b5..47fe4ca 100644
--- a/services/healthreport/tests/xpcshell/test_provider_addons.js
+++ b/services/healthreport/tests/xpcshell/test_provider_addons.js
@@ -123,14 +123,6 @@ add_task(function test_collect() {
       userDisabled: false,
       appDisabled: false,
     },
-    {
-      // Should be in gm-plugins
-      id: "gmp-testgmp",
-      type: "plugin",
-      userDisabled: false,
-      version: "7.2",
-      isGMPlugin: true,
-    },
   ];
 
   monkeypatchAddons(provider, testAddons);
@@ -202,7 +194,6 @@ add_task(function test_collect() {
   do_check_true(!("addon2" in value));
   do_check_true("addon3" in value);
   do_check_true(!("pluginfake" in value));
-  do_check_true(!("gmp-testgmp" in value));
 
   let serializer = addons.serializer(addons.SERIALIZE_JSON);
   let serialized = serializer.singular(data.singular);
@@ -254,30 +245,6 @@ add_task(function test_collect() {
   }
   do_check_eq(serialized._v, 1);
 
-  // Test GMP plugins measurement.
-
-  let gmPlugins = provider.getMeasurement("gm-plugins", 1);
-  data = yield gmPlugins.getValues();
-
-  do_check_eq(data.days.size, 0);
-  do_check_eq(data.singular.size, 1);
-  do_check_true(data.singular.has("gm-plugins"));
-
-  json = data.singular.get("gm-plugins")[1];
-  value = JSON.parse(json);
-  do_print("value: " + json);
-  do_check_eq(typeof(value), "object");
-  do_check_eq(Object.keys(value).length, 1);
-
-  do_check_eq(value["gmp-testgmp"].version, "7.2");
-  do_check_eq(value["gmp-testgmp"].userDisabled, false);
-
-  serializer = gmPlugins.serializer(plugins.SERIALIZE_JSON);
-  serialized = serializer.singular(data.singular);
-  do_check_eq(typeof(serialized), "object");
-  do_check_eq(serialized["gmp-testgmp"].version, "7.2");
-  do_check_eq(serialized._v, 1);
-
   // Test counts measurement.
 
   let counts = provider.getMeasurement("counts", 2);
diff --git a/testing/gtest/rungtests.py b/testing/gtest/rungtests.py
index 1329d7a..49f6204 100755
--- a/testing/gtest/rungtests.py
+++ b/testing/gtest/rungtests.py
@@ -67,10 +67,6 @@ class GTests(object):
         """
         env["MOZILLA_FIVE_HOME"] = self.xre_path
         env["MOZ_XRE_DIR"] = self.xre_path
-        env["MOZ_GMP_PATH"] = os.pathsep.join(
-            os.path.join(self.xre_path, p, "1.0")
-            for p in ('gmp-fake', 'gmp-fakeopenh264')
-        )
         env["XPCOM_DEBUG_BREAK"] = "stack-and-abort"
         env["MOZ_CRASHREPORTER_NO_REPORT"] = "1"
         env["MOZ_CRASHREPORTER"] = "1"
@@ -83,7 +79,6 @@ class GTests(object):
           # which is too old to support sandboxing. Disable sandbox for gtests
           # on machines which don't support sandboxing until they can be
           # upgraded, or gtests are run on test machines instead.
-          env["MOZ_DISABLE_GMP_SANDBOX"] = "1"
 
         return env
 
diff --git a/testing/mochitest/Makefile.in b/testing/mochitest/Makefile.in
index 18291f2..19314ce 100644
--- a/testing/mochitest/Makefile.in
+++ b/testing/mochitest/Makefile.in
@@ -89,12 +89,6 @@ endif
 PKG_STAGE = $(DIST)/test-stage
 DIST_BIN = $(DIST)/bin
 
-GMP_TEST_PLUGIN_DIRS := \
-  $(DIST_BIN)/gmp-fake \
-  $(DIST_BIN)/gmp-fakeopenh264 \
-  $(DIST_BIN)/gmp-clearkey \
-  $(NULL)
-
 $(_DEST_DIR):
 	$(NSINSTALL) -D $@
 
@@ -121,4 +115,4 @@ stage-package:
 	@(cd $(DIST_BIN)/components && tar $(TAR_CREATE_FLAGS) - $(TEST_HARNESS_COMPONENTS)) | (cd $(PKG_STAGE)/bin/components && tar -xf -)
 	(cd $(topsrcdir)/build/pgo && tar $(TAR_CREATE_FLAGS) - certs) | (cd $(PKG_STAGE) && tar -xf -)
 	@(cd $(DIST)/plugins && tar $(TAR_CREATE_FLAGS) - $(TEST_HARNESS_PLUGINS)) | (cd $(PKG_STAGE)/bin/plugins && tar -xf -)
-	$(foreach x,$(GMP_TEST_PLUGIN_DIRS),cp -RL $(x) $(PKG_STAGE)/bin/plugins;)
+	$(foreach x,$(
diff --git a/testing/mochitest/mach_commands.py b/testing/mochitest/mach_commands.py
index b0b897c..f4b7c12 100644
--- a/testing/mochitest/mach_commands.py
+++ b/testing/mochitest/mach_commands.py
@@ -444,18 +444,6 @@ class MochitestRunner(MozbuildObject):
                 options.app = self.get_binary_path(where='staged-package')
             elif app_override:
                 options.app = app_override
-            if options.gmp_path is None:
-                # Need to fix the location of gmp_fake which might not be
-                # shipped in the binary
-                bin_path = self.get_binary_path()
-                gmp_modules = (
-                    ('gmp-fake', '1.0'),
-                    ('gmp-clearkey', '0.1'),
-                    ('gmp-fakeopenh264', '1.0')
-                )
-                options.gmp_path = os.pathsep.join(
-                    os.path.join(os.path.dirname(bin_path), *p)
-                    for p in gmp_modules)
 
         logger_options = {
             key: value for key,
diff --git a/testing/mochitest/mochitest_options.py b/testing/mochitest/mochitest_options.py
index 19aa412..d1713bc 100644
--- a/testing/mochitest/mochitest_options.py
+++ b/testing/mochitest/mochitest_options.py
@@ -449,12 +449,6 @@ class MochitestOptions(optparse.OptionParser):
           "dest": "useTestMediaDevices",
           "help": "Use test media device drivers for media testing.",
           }],
-        [["--gmp-path"],
-         {"action": "store",
-          "default": None,
-          "dest": "gmp_path",
-          "help": "Path to fake GMP plugin. Will be deduced from the binary if not passed.",
-          }],
         [["--xre-path"],
          {"action": "store",
           "type": "string",
@@ -699,8 +693,6 @@ class MochitestOptions(optparse.OptionParser):
         options.leakThresholds = {
             "default": options.defaultLeakThreshold,
             "tab": 25000,  # See dependencies of bug 1051230.
-            # GMP rarely gets a log, but when it does, it leaks a little.
-            "goannamediaplugin": 20000,
         }
 
         # Bug 1065098 - The goannamediaplugin process fails to produce a leak
diff --git a/testing/mochitest/runtests.py b/testing/mochitest/runtests.py
index f958c40..fee447b 100644
--- a/testing/mochitest/runtests.py
+++ b/testing/mochitest/runtests.py
@@ -1433,35 +1433,6 @@ class Mochitest(MochitestUtilsMixin):
 
         return manifest
 
-    def getGMPPluginPath(self, options):
-        if options.gmp_path:
-            return options.gmp_path
-
-        gmp_parentdirs = [
-            # For local builds, GMP plugins will be under dist/bin.
-            options.xrePath,
-            # For packaged builds, GMP plugins will get copied under
-            # $profile/plugins.
-            os.path.join(self.profile.profile, 'plugins'),
-        ]
-
-        gmp_subdirs = [
-            os.path.join('gmp-fake', '1.0'),
-            os.path.join('gmp-fakeopenh264', '1.0'),
-            os.path.join('gmp-clearkey', '0.1'),
-        ]
-
-        gmp_paths = [os.path.join(parent, sub)
-                     for parent in gmp_parentdirs
-                     for sub in gmp_subdirs
-                     if os.path.isdir(os.path.join(parent, sub))]
-
-        if not gmp_paths:
-            # This is fatal for desktop environments.
-            raise EnvironmentError('Could not find test gmp plugins')
-
-        return os.pathsep.join(gmp_paths)
-
     def buildBrowserEnv(self, options, debugger=False, env=None):
         """build the environment variables for the specific test and operating system"""
         if mozinfo.info["asan"]:
@@ -1501,17 +1472,6 @@ class Mochitest(MochitestUtilsMixin):
 
         browserEnv["XPCOM_MEM_BLOAT_LOG"] = self.leak_report_file
 
-        try:
-            gmp_path = self.getGMPPluginPath(options)
-            if gmp_path is not None:
-                browserEnv["MOZ_GMP_PATH"] = gmp_path
-        except EnvironmentError:
-            self.log.error('Could not find path to gmp-fake plugin!')
-            return None
-
-        if options.fatalAssertions:
-            browserEnv["XPCOM_DEBUG_BREAK"] = "stack-and-abort"
-
         # Produce an NSPR log, is setup (see NSPR_LOG_MODULES global at the top of
         # this script).
         self.nsprLogs = NSPR_LOG_MODULES and "MOZ_UPLOAD_DIR" in os.environ
diff --git a/testing/mochitest/runtestsremote.py b/testing/mochitest/runtestsremote.py
index 433b8be..1ff130f 100644
--- a/testing/mochitest/runtestsremote.py
+++ b/testing/mochitest/runtestsremote.py
@@ -669,10 +669,6 @@ class MochiRemote(Mochitest):
                 "robotium.config"))
         os.unlink(fHandle.name)
 
-    def getGMPPluginPath(self, options):
-        # TODO: bug 1043403
-        return None
-
     def buildBrowserEnv(self, options, debugger=False):
         browserEnv = Mochitest.buildBrowserEnv(
             self,
diff --git a/testing/mozharness/scripts/openh264_build.py b/testing/mozharness/scripts/openh264_build.py
deleted file mode 100644
index 072d102..0000000
--- a/testing/mozharness/scripts/openh264_build.py
+++ /dev/null
@@ -1,250 +0,0 @@
-#!/usr/bin/env python
-# ***** BEGIN LICENSE BLOCK *****
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this file,
-# You can obtain one at http://mozilla.org/MPL/2.0/.
-# ***** END LICENSE BLOCK *****
-import sys
-import os
-import glob
-
-# load modules from parent dir
-sys.path.insert(1, os.path.dirname(sys.path[0]))
-
-# import the guts
-from mozharness.base.vcs.vcsbase import VCSScript
-from mozharness.base.log import ERROR
-from mozharness.base.transfer import TransferMixin
-from mozharness.mozilla.mock import MockMixin
-
-
-class OpenH264Build(MockMixin, TransferMixin, VCSScript):
-    all_actions = [
-        'clobber',
-        'checkout-sources',
-        'build',
-        'test',
-        'package',
-        'upload',
-    ]
-
-    default_actions = [
-        'checkout-sources',
-        'build',
-        'test',
-        'package',
-    ]
-
-    config_options = [
-        [["--repo"], {
-            "dest": "repo",
-            "help": "OpenH264 repository to use",
-            "default": "https://github.com/cisco/openh264.git"
-        }],
-        [["--rev"], {
-            "dest": "revision",
-            "help": "revision to checkout",
-            "default": "master"
-        }],
-        [["--debug"], {
-            "dest": "debug_build",
-            "action": "store_true",
-            "help": "Do a debug build",
-        }],
-        [["--64"], {
-            "dest": "64bit",
-            "action": "store_true",
-            "help": "Do a 64-bit build",
-            "default": True,
-        }],
-        [["--32"], {
-            "dest": "64bit",
-            "action": "store_false",
-            "help": "Do a 32-bit build",
-        }],
-        [["--os"], {
-            "dest": "operating_system",
-            "help": "Specify the operating system to build for",
-        }],
-        [["--use-mock"], {
-            "dest": "use_mock",
-            "help": "use mock to set up build environment",
-            "action": "store_true",
-            "default": False,
-        }],
-        [["--use-yasm"], {
-            "dest": "use_yasm",
-            "help": "use yasm instead of nasm",
-            "action": "store_true",
-            "default": False,
-        }],
-    ]
-
-    def __init__(self, require_config_file=False, config={},
-                 all_actions=all_actions,
-                 default_actions=default_actions):
-
-        # Default configuration
-        default_config = {
-            'debug_build': False,
-            'mock_target': 'mozilla-centos6-x86_64',
-            'mock_packages': ['make', 'git', 'nasm', 'glibc-devel.i686', 'libstdc++-devel.i686', 'zip', 'yasm'],
-            'mock_files': [],
-            'upload_ssh_key': os.path.expanduser("~/.ssh/ffxbld_rsa"),
-            'upload_ssh_user': 'ffxbld',
-            'upload_ssh_host': 'stage.mozilla.org',
-            'upload_path_base': '/home/ffxbld/openh264',
-            'use_yasm': False,
-        }
-        default_config.update(config)
-
-        VCSScript.__init__(
-            self,
-            config_options=self.config_options,
-            require_config_file=require_config_file,
-            config=default_config,
-            all_actions=all_actions,
-            default_actions=default_actions,
-        )
-
-        if self.config['use_mock']:
-            self.setup_mock()
-            self.enable_mock()
-
-    def query_package_name(self):
-        if self.config['64bit']:
-            bits = '64'
-        else:
-            bits = '32'
-
-        version = self.config['revision']
-
-        if sys.platform == 'linux2':
-            if self.config.get('operating_system') == 'android':
-                return 'openh264-android-{version}.zip'.format(version=version, bits=bits)
-            else:
-                return 'openh264-linux{bits}-{version}.zip'.format(version=version, bits=bits)
-        elif sys.platform == 'darwin':
-            return 'openh264-macosx{bits}-{version}.zip'.format(version=version, bits=bits)
-        elif sys.platform == 'win32':
-            return 'openh264-win{bits}-{version}.zip'.format(version=version, bits=bits)
-        self.fatal("can't determine platform")
-
-    def query_make_params(self):
-        retval = []
-        if self.config['debug_build']:
-            retval.append('BUILDTYPE=Debug')
-
-        if self.config['64bit']:
-            retval.append('ENABLE64BIT=Yes')
-        else:
-            retval.append('ENABLE64BIT=No')
-
-        if "operating_system" in self.config:
-            retval.append("OS=%s" % self.config['operating_system'])
-
-        if self.config['use_yasm']:
-            retval.append('ASM=yasm')
-
-        return retval
-
-    def query_upload_ssh_key(self):
-        return self.config['upload_ssh_key']
-
-    def query_upload_ssh_host(self):
-        return self.config['upload_ssh_host']
-
-    def query_upload_ssh_user(self):
-        return self.config['upload_ssh_user']
-
-    def query_upload_ssh_path(self):
-        return "%s/%s" % (self.config['upload_path_base'], self.config['revision'])
-
-    def run_make(self, target):
-        cmd = ['make', target] + self.query_make_params()
-        dirs = self.query_abs_dirs()
-        repo_dir = os.path.join(dirs['abs_work_dir'], 'src')
-        return self.run_command(cmd, cwd=repo_dir)
-
-    def checkout_sources(self):
-        repo = self.config['repo']
-        rev = self.config['revision']
-
-        dirs = self.query_abs_dirs()
-        repo_dir = os.path.join(dirs['abs_work_dir'], 'src')
-
-        repos = [
-            {'vcs': 'gittool', 'repo': repo, 'dest': repo_dir, 'revision': rev},
-        ]
-
-        # self.vcs_checkout already retries, so no need to wrap it in
-        # self.retry. We set the error_level to ERROR to prevent it going fatal
-        # so we can do our own handling here.
-        retval = self.vcs_checkout_repos(repos, error_level=ERROR)
-        if not retval:
-            self.rmtree(repo_dir)
-            self.fatal("Automation Error: couldn't clone repo", exit_code=4)
-
-        # Checkout gmp-api
-        # TODO: Nothing here updates it yet, or enforces versions!
-        if not os.path.exists(os.path.join(repo_dir, 'gmp-api')):
-            retval = self.run_make('gmp-bootstrap')
-            if retval != 0:
-                self.fatal("couldn't bootstrap gmp")
-        else:
-            self.info("skipping gmp bootstrap - we have it locally")
-
-        # Checkout gtest
-        # TODO: Requires svn!
-        if not os.path.exists(os.path.join(repo_dir, 'gtest')):
-            retval = self.run_make('gtest-bootstrap')
-            if retval != 0:
-                self.fatal("couldn't bootstrap gtest")
-        else:
-            self.info("skipping gtest bootstrap - we have it locally")
-
-        return retval
-
-    def build(self):
-        retval = self.run_make('plugin')
-        if retval != 0:
-            self.fatal("couldn't build plugin")
-
-    def package(self):
-        dirs = self.query_abs_dirs()
-        srcdir = os.path.join(dirs['abs_work_dir'], 'src')
-        package_name = self.query_package_name()
-        package_file = os.path.join(dirs['abs_work_dir'], package_name)
-        if os.path.exists(package_file):
-            os.unlink(package_file)
-        to_package = [os.path.basename(f) for f in glob.glob(os.path.join(srcdir, "*gmpopenh264*"))]
-        cmd = ['zip', package_file] + to_package
-        retval = self.run_command(cmd, cwd=srcdir)
-        if retval != 0:
-            self.fatal("couldn't make package")
-        self.copy_to_upload_dir(package_file)
-
-    def upload(self):
-        if self.config['use_mock']:
-            self.disable_mock()
-        dirs = self.query_abs_dirs()
-        self.rsync_upload_directory(
-            dirs['abs_upload_dir'],
-            self.query_upload_ssh_key(),
-            self.query_upload_ssh_user(),
-            self.query_upload_ssh_host(),
-            self.query_upload_ssh_path(),
-        )
-        if self.config['use_mock']:
-            self.enable_mock()
-
-    def test(self):
-        retval = self.run_make('test')
-        if retval != 0:
-            self.fatal("test failures")
-
-
-# main {{{1
-if __name__ == '__main__':
-    myScript = OpenH264Build()
-    myScript.run_and_exit()
diff --git a/testing/profiles/prefs_general.js b/testing/profiles/prefs_general.js
index 834c5df..6b841c9 100644
--- a/testing/profiles/prefs_general.js
+++ b/testing/profiles/prefs_general.js
@@ -44,8 +44,6 @@ user_pref("security.warn_viewing_mixed", false);
 user_pref("app.update.enabled", false);
 user_pref("app.update.staging.enabled", false);
 user_pref("app.update.url.android", "");
-// Make sure GMPInstallManager won't hit the network.
-user_pref("media.gmp-manager.url.override", "http://%(server)s/dummy-gmp-manager.xml");
 user_pref("browser.panorama.experienced_first_run", true); // Assume experienced
 user_pref("dom.w3c_touch_events.enabled", 1);
 user_pref("dom.undo_manager.enabled", true);
diff --git a/testing/xpcshell/head.js b/testing/xpcshell/head.js
index aca6c51..1c53e89 100644
--- a/testing/xpcshell/head.js
+++ b/testing/xpcshell/head.js
@@ -1399,7 +1399,6 @@ try {
     let prefs = Components.classes["@mozilla.org/preferences-service;1"]
       .getService(Components.interfaces.nsIPrefBranch);
 
-    prefs.setCharPref("media.gmp-manager.url.override", "http://%(server)s/dummy-gmp-manager.xml");
     prefs.setCharPref("browser.selfsupport.url", "https://%(server)s/selfsupport-dummy/");
   }
 } catch (e) { }
diff --git a/toolkit/components/crashes/CrashManager.jsm b/toolkit/components/crashes/CrashManager.jsm
index 83899cc..54ae2ce 100644
--- a/toolkit/components/crashes/CrashManager.jsm
+++ b/toolkit/components/crashes/CrashManager.jsm
@@ -134,9 +134,6 @@ this.CrashManager.prototype = Object.freeze({
   // A crash in a plugin process.
   PROCESS_TYPE_PLUGIN: "plugin",
 
-  // A crash in a Goanna media plugin process.
-  PROCESS_TYPE_GMPLUGIN: "gmplugin",
-
   // A real crash.
   CRASH_TYPE_CRASH: "crash",
 
diff --git a/toolkit/components/crashes/CrashService.js b/toolkit/components/crashes/CrashService.js
index e1b75d6..14ee796 100644
--- a/toolkit/components/crashes/CrashService.js
+++ b/toolkit/components/crashes/CrashService.js
@@ -34,9 +34,6 @@ CrashService.prototype = Object.freeze({
     case Ci.nsICrashService.PROCESS_TYPE_PLUGIN:
       processType = Services.crashmanager.PROCESS_TYPE_PLUGIN;
       break;
-    case Ci.nsICrashService.PROCESS_TYPE_GMPLUGIN:
-      processType = Services.crashmanager.PROCESS_TYPE_GMPLUGIN;
-      break;
     default:
       throw new Error("Unrecognized PROCESS_TYPE: " + processType);
     }
diff --git a/toolkit/components/crashes/nsICrashService.idl b/toolkit/components/crashes/nsICrashService.idl
index 4057c96..3b94390 100644
--- a/toolkit/components/crashes/nsICrashService.idl
+++ b/toolkit/components/crashes/nsICrashService.idl
@@ -22,7 +22,6 @@ interface nsICrashService : nsISupports
   const long PROCESS_TYPE_MAIN = 0;
   const long PROCESS_TYPE_CONTENT = 1;
   const long PROCESS_TYPE_PLUGIN = 2;
-  const long PROCESS_TYPE_GMPLUGIN = 3;
 
   const long CRASH_TYPE_CRASH = 0;
   const long CRASH_TYPE_HANG = 1;
diff --git a/toolkit/components/crashes/tests/xpcshell/test_crash_manager.js b/toolkit/components/crashes/tests/xpcshell/test_crash_manager.js
index ee6db05..84cade7 100644
--- a/toolkit/components/crashes/tests/xpcshell/test_crash_manager.js
+++ b/toolkit/components/crashes/tests/xpcshell/test_crash_manager.js
@@ -309,8 +309,6 @@ add_task(function* test_addCrash() {
                    "plugin-crash", DUMMY_DATE);
   yield m.addCrash(m.PROCESS_TYPE_PLUGIN, m.CRASH_TYPE_HANG,
                    "plugin-hang", DUMMY_DATE);
-  yield m.addCrash(m.PROCESS_TYPE_GMPLUGIN, m.CRASH_TYPE_CRASH,
-                   "gmplugin-crash", DUMMY_DATE);
 
   yield m.addCrash(m.PROCESS_TYPE_MAIN, m.CRASH_TYPE_CRASH,
                    "changing-item", DUMMY_DATE);
@@ -358,12 +356,6 @@ add_task(function* test_addCrash() {
   Assert.equal(crash.type, m.PROCESS_TYPE_PLUGIN + "-" + m.CRASH_TYPE_HANG);
   Assert.ok(crash.isOfType(m.PROCESS_TYPE_PLUGIN, m.CRASH_TYPE_HANG));
 
-  crash = map.get("gmplugin-crash");
-  Assert.ok(!!crash);
-  Assert.equal(crash.crashDate, DUMMY_DATE);
-  Assert.equal(crash.type, m.PROCESS_TYPE_GMPLUGIN + "-" + m.CRASH_TYPE_CRASH);
-  Assert.ok(crash.isOfType(m.PROCESS_TYPE_GMPLUGIN, m.CRASH_TYPE_CRASH));
-
   crash = map.get("changing-item");
   Assert.ok(!!crash);
   Assert.equal(crash.crashDate, DUMMY_DATE_2);
diff --git a/toolkit/components/crashes/tests/xpcshell/test_crash_store.js b/toolkit/components/crashes/tests/xpcshell/test_crash_store.js
index c9babe7..ee53097 100644
--- a/toolkit/components/crashes/tests/xpcshell/test_crash_store.js
+++ b/toolkit/components/crashes/tests/xpcshell/test_crash_store.js
@@ -23,7 +23,6 @@ const {
   PROCESS_TYPE_MAIN,
   PROCESS_TYPE_CONTENT,
   PROCESS_TYPE_PLUGIN,
-  PROCESS_TYPE_GMPLUGIN,
   CRASH_TYPE_CRASH,
   CRASH_TYPE_HANG,
   SUBMISSION_RESULT_OK,
@@ -300,33 +299,6 @@ add_task(function* test_add_plugin_hang() {
   Assert.equal(crashes.length, 2);
 });
 
-add_task(function* test_add_gmplugin_crash() {
-  let s = yield getStore();
-
-  Assert.ok(
-    s.addCrash(PROCESS_TYPE_GMPLUGIN, CRASH_TYPE_CRASH, "id1", new Date())
-  );
-  Assert.equal(s.crashesCount, 1);
-
-  let c = s.crashes[0];
-  Assert.ok(c.crashDate);
-  Assert.equal(c.type, PROCESS_TYPE_GMPLUGIN + "-" + CRASH_TYPE_CRASH);
-  Assert.ok(c.isOfType(PROCESS_TYPE_GMPLUGIN, CRASH_TYPE_CRASH));
-
-  Assert.ok(
-    s.addCrash(PROCESS_TYPE_GMPLUGIN, CRASH_TYPE_CRASH, "id2", new Date())
-  );
-  Assert.equal(s.crashesCount, 2);
-
-  Assert.ok(
-    s.addCrash(PROCESS_TYPE_GMPLUGIN, CRASH_TYPE_CRASH, "id1", new Date())
-  );
-  Assert.equal(s.crashesCount, 2);
-
-  let crashes = s.getCrashesOfType(PROCESS_TYPE_GMPLUGIN, CRASH_TYPE_CRASH);
-  Assert.equal(crashes.length, 2);
-});
-
 add_task(function* test_add_mixed_types() {
   let s = yield getStore();
 
@@ -337,7 +309,6 @@ add_task(function* test_add_mixed_types() {
     s.addCrash(PROCESS_TYPE_CONTENT, CRASH_TYPE_HANG, "chang", new Date()) &&
     s.addCrash(PROCESS_TYPE_PLUGIN, CRASH_TYPE_CRASH, "pcrash", new Date()) &&
     s.addCrash(PROCESS_TYPE_PLUGIN, CRASH_TYPE_HANG, "phang", new Date()) &&
-    s.addCrash(PROCESS_TYPE_GMPLUGIN, CRASH_TYPE_CRASH, "gmpcrash", new Date())
   );
 
   Assert.equal(s.crashesCount, 7);
@@ -363,8 +334,6 @@ add_task(function* test_add_mixed_types() {
   Assert.equal(crashes.length, 1);
   crashes = s.getCrashesOfType(PROCESS_TYPE_PLUGIN, CRASH_TYPE_HANG);
   Assert.equal(crashes.length, 1);
-  crashes = s.getCrashesOfType(PROCESS_TYPE_GMPLUGIN, CRASH_TYPE_CRASH);
-  Assert.equal(crashes.length, 1);
 });
 
 // Crashes added beyond the high water mark behave properly.
diff --git a/toolkit/content/license.html b/toolkit/content/license.html
index 8c7e9f1..b4f0da0 100644
--- a/toolkit/content/license.html
+++ b/toolkit/content/license.html
@@ -3361,41 +3361,6 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
     <hr>
 
-    <h1><a id="openaes"></a>OpenAES License</h1>
-
-    <p>This license applies to certain files in the directory
-    <span class="path">media/gmp-clearkey/0.1/openaes</span>.
-    </p>
-
-<pre>
-Copyright (c) 2012, Nabil S. Al Ramli, www.nalramli.com
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-  - Redistributions of source code must retain the above copyright notice,
-    this list of conditions and the following disclaimer.
-  - Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-</pre>
-
-
-    <hr>
-
     <h1><a id="opentok"></a>OpenTok License</h1>
 
     <p>This license applies to the file
diff --git a/toolkit/locales/en-US/chrome/mozapps/extensions/extensions.properties b/toolkit/locales/en-US/chrome/mozapps/extensions/extensions.properties
index c4e2660..c512329 100644
--- a/toolkit/locales/en-US/chrome/mozapps/extensions/extensions.properties
+++ b/toolkit/locales/en-US/chrome/mozapps/extensions/extensions.properties
@@ -57,8 +57,6 @@ notification.downloadError.retry.tooltip=Try downloading this add-on again
 notification.installError=There was an error installing %1$S.
 notification.installError.retry=Try again
 notification.installError.retry.tooltip=Try downloading and installing this add-on again
-#LOCALIZATION NOTE (notification.gmpPending) %1$S is the add-on name.
-notification.gmpPending=%1$S will be installed shortly.
 
 #LOCALIZATION NOTE (contributionAmount2) %S is the currency amount recommended for contributions
 contributionAmount2=Suggested Contribution: %S
@@ -100,8 +98,6 @@ details.notification.install=%1$S will be installed after you restart %2$S.
 details.notification.uninstall=%1$S will be uninstalled after you restart %2$S.
 #LOCALIZATION NOTE (details.notification.upgrade) %1$S is the add-on name, %2$S is brand name
 details.notification.upgrade=%1$S will be updated after you restart %2$S.
-#LOCALIZATION NOTE (details.notification.gmpPending) %1$S is the add-on name
-details.notification.gmpPending=%1$S will be installed shortly.
 
 # LOCALIZATION NOTE (details.experiment.time.daysRemaining):
 # Semicolon-separated list of plural forms.
diff --git a/toolkit/modules/GMPInstallManager.jsm b/toolkit/modules/GMPInstallManager.jsm
deleted file mode 100644
index eac5e9c..0000000
--- a/toolkit/modules/GMPInstallManager.jsm
+++ /dev/null
@@ -1,961 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-this.EXPORTED_SYMBOLS = [];
-
-const {classes: Cc, interfaces: Ci, results: Cr, utils: Cu, manager: Cm} =
-  Components;
-// Chunk size for the incremental downloader
-const DOWNLOAD_CHUNK_BYTES_SIZE = 300000;
-// Incremental downloader interval
-const DOWNLOAD_INTERVAL  = 0;
-// 1 day default
-const DEFAULT_SECONDS_BETWEEN_CHECKS = 60 * 60 * 24;
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/FileUtils.jsm");
-Cu.import("resource://gre/modules/Promise.jsm");
-Cu.import("resource://gre/modules/Preferences.jsm");
-Cu.import("resource://gre/modules/Log.jsm");
-Cu.import("resource://gre/modules/osfile.jsm");
-Cu.import("resource://gre/modules/Task.jsm");
-Cu.import("resource://gre/modules/ctypes.jsm");
-Cu.import("resource://gre/modules/GMPUtils.jsm");
-
-this.EXPORTED_SYMBOLS = ["GMPInstallManager", "GMPExtractor", "GMPDownloader",
-                         "GMPAddon"];
-
-var gLocale = null;
-
-// Shared code for suppressing bad cert dialogs
-XPCOMUtils.defineLazyGetter(this, "gCertUtils", function() {
-  let temp = { };
-  Cu.import("resource://gre/modules/CertUtils.jsm", temp);
-  return temp;
-});
-
-XPCOMUtils.defineLazyModuleGetter(this, "UpdateChannel",
-                                  "resource://gre/modules/UpdateChannel.jsm");
-
-/**
- * Number of milliseconds after which we need to cancel `checkForAddons`.
- *
- * Bug 1087674 suggests that the XHR we use in `checkForAddons` may
- * never terminate in presence of network nuisances (e.g. strange
- * antivirus behavior). This timeout is a defensive measure to ensure
- * that we fail cleanly in such case.
- */
-const CHECK_FOR_ADDONS_TIMEOUT_DELAY_MS = 20000;
-
-function getScopedLogger(prefix) {
-  // `PARENT_LOGGER_ID.` being passed here effectively links this logger
-  // to the parentLogger.
-  return Log.repository.getLoggerWithMessagePrefix("Toolkit.GMP", prefix + " ");
-}
-
-// This is copied directly from nsUpdateService.js
-// It is used for calculating the URL string w/ var replacement.
-// TODO: refactor this out somewhere else
-XPCOMUtils.defineLazyGetter(this, "gOSVersion", function aus_gOSVersion() {
-  let osVersion;
-  let sysInfo = Cc["@mozilla.org/system-info;1"].
-                getService(Ci.nsIPropertyBag2);
-  try {
-    osVersion = sysInfo.getProperty("name") + " " + sysInfo.getProperty("version");
-  }
-  catch (e) {
-    LOG("gOSVersion - OS Version unknown: updates are not possible.");
-  }
-
-  if (osVersion) {
-#ifdef XP_WIN
-    const BYTE = ctypes.uint8_t;
-    const WORD = ctypes.uint16_t;
-    const DWORD = ctypes.uint32_t;
-    const WCHAR = ctypes.char16_t;
-    const BOOL = ctypes.int;
-
-    // This structure is described at:
-    // http://msdn.microsoft.com/en-us/library/ms724833%28v=vs.85%29.aspx
-    const SZCSDVERSIONLENGTH = 128;
-    const OSVERSIONINFOEXW = new ctypes.StructType('OSVERSIONINFOEXW',
-        [
-        {dwOSVersionInfoSize: DWORD},
-        {dwMajorVersion: DWORD},
-        {dwMinorVersion: DWORD},
-        {dwBuildNumber: DWORD},
-        {dwPlatformId: DWORD},
-        {szCSDVersion: ctypes.ArrayType(WCHAR, SZCSDVERSIONLENGTH)},
-        {wServicePackMajor: WORD},
-        {wServicePackMinor: WORD},
-        {wSuiteMask: WORD},
-        {wProductType: BYTE},
-        {wReserved: BYTE}
-        ]);
-
-    // This structure is described at:
-    // http://msdn.microsoft.com/en-us/library/ms724958%28v=vs.85%29.aspx
-    const SYSTEM_INFO = new ctypes.StructType('SYSTEM_INFO',
-        [
-        {wProcessorArchitecture: WORD},
-        {wReserved: WORD},
-        {dwPageSize: DWORD},
-        {lpMinimumApplicationAddress: ctypes.voidptr_t},
-        {lpMaximumApplicationAddress: ctypes.voidptr_t},
-        {dwActiveProcessorMask: DWORD.ptr},
-        {dwNumberOfProcessors: DWORD},
-        {dwProcessorType: DWORD},
-        {dwAllocationGranularity: DWORD},
-        {wProcessorLevel: WORD},
-        {wProcessorRevision: WORD}
-        ]);
-
-    let kernel32 = false;
-    try {
-      kernel32 = ctypes.open("Kernel32");
-    } catch (e) {
-      LOG("gOSVersion - Unable to open kernel32! " + e);
-      osVersion += ".unknown (unknown)";
-    }
-
-    if(kernel32) {
-      try {
-        // Get Service pack info
-        try {
-          let GetVersionEx = kernel32.declare("GetVersionExW",
-                                              ctypes.default_abi,
-                                              BOOL,
-                                              OSVERSIONINFOEXW.ptr);
-          let winVer = OSVERSIONINFOEXW();
-          winVer.dwOSVersionInfoSize = OSVERSIONINFOEXW.size;
-
-          if(0 !== GetVersionEx(winVer.address())) {
-            osVersion += "." + winVer.wServicePackMajor
-                      +  "." + winVer.wServicePackMinor;
-          } else {
-            LOG("gOSVersion - Unknown failure in GetVersionEX (returned 0)");
-            osVersion += ".unknown";
-          }
-        } catch (e) {
-          LOG("gOSVersion - error getting service pack information. Exception: " + e);
-          osVersion += ".unknown";
-        }
-
-        // Get processor architecture
-        let arch = "unknown";
-        try {
-          let GetNativeSystemInfo = kernel32.declare("GetNativeSystemInfo",
-                                                     ctypes.default_abi,
-                                                     ctypes.void_t,
-                                                     SYSTEM_INFO.ptr);
-          let sysInfo = SYSTEM_INFO();
-          // Default to unknown
-          sysInfo.wProcessorArchitecture = 0xffff;
-
-          GetNativeSystemInfo(sysInfo.address());
-          switch(sysInfo.wProcessorArchitecture) {
-            case 9:
-              arch = "x64";
-              break;
-            case 6:
-              arch = "IA64";
-              break;
-            case 0:
-              arch = "x86";
-              break;
-          }
-        } catch (e) {
-          LOG("gOSVersion - error getting processor architecture.  Exception: " + e);
-        } finally {
-          osVersion += " (" + arch + ")";
-        }
-      } finally {
-        kernel32.close();
-      }
-    }
-#endif
-
-    try {
-      osVersion += " (" + sysInfo.getProperty("secondaryLibrary") + ")";
-    }
-    catch (e) {
-      // Not all platforms have a secondary widget library, so an error is nothing to worry about.
-    }
-    osVersion = encodeURIComponent(osVersion);
-  }
-  return osVersion;
-});
-
-// This is copied directly from nsUpdateService.js
-// It is used for calculating the URL string w/ var replacement.
-// TODO: refactor this out somewhere else
-XPCOMUtils.defineLazyGetter(this, "gABI", function aus_gABI() {
-  let abi = null;
-  try {
-    abi = Services.appinfo.XPCOMABI;
-  }
-  catch (e) {
-    LOG("gABI - XPCOM ABI unknown: updates are not possible.");
-  }
-#ifdef XP_MACOSX
-  // Mac universal build should report a different ABI than either macppc
-  // or mactel.
-  let macutils = Cc["@mozilla.org/xpcom/mac-utils;1"].
-                 getService(Ci.nsIMacUtils);
-
-  if (macutils.isUniversalBinary)
-    abi += "-u-" + macutils.architecturesInBinary;
-#ifdef MOZ_SHARK
-  // Disambiguate optimised and shark nightlies
-  abi += "-shark"
-#endif
-#endif
-  return abi;
-});
-
-/**
- * Provides an easy API for downloading and installing GMP Addons
- */
-function GMPInstallManager() {
-}
-/**
- * Temp file name used for downloading
- */
-GMPInstallManager.prototype = {
-  /**
-   * Obtains a URL with replacement of vars
-   */
-  _getURL: function() {
-    let log = getScopedLogger("GMPInstallManager._getURL");
-    // Use the override URL if it is specified.  The override URL is just like
-    // the normal URL but it does not check the cert.
-    let url = GMPPrefs.get(GMPPrefs.KEY_URL_OVERRIDE);
-    if (url) {
-      log.info("Using override url: " + url);
-    } else {
-      url = GMPPrefs.get(GMPPrefs.KEY_URL);
-      log.info("Using url: " + url);
-    }
-
-    url =
-      url.replace(/%PRODUCT%/g, Services.appinfo.name)
-         .replace(/%VERSION%/g, Services.appinfo.version)
-         .replace(/%BUILD_ID%/g, Services.appinfo.appBuildID)
-         .replace(/%BUILD_TARGET%/g, Services.appinfo.OS + "_" + gABI)
-         .replace(/%OS_VERSION%/g, gOSVersion);
-    if (/%LOCALE%/.test(url)) {
-      // TODO: Get the real local, does it actually matter for GMP plugins?
-      url = url.replace(/%LOCALE%/g, "en-US");
-    }
-    url =
-      url.replace(/%CHANNEL%/g, UpdateChannel.get())
-         .replace(/%PLATFORM_VERSION%/g, Services.appinfo.platformVersion)
-         .replace(/%DISTRIBUTION%/g,
-                  GMPPrefs.get(GMPPrefs.KEY_APP_DISTRIBUTION))
-         .replace(/%DISTRIBUTION_VERSION%/g,
-                  GMPPrefs.get(GMPPrefs.KEY_APP_DISTRIBUTION_VERSION))
-         .replace(/\+/g, "%2B");
-    log.info("Using url (with replacement): " + url);
-    return url;
-  },
-  /**
-   * Performs an addon check.
-   * @return a promise which will be resolved or rejected.
-   *         The promise is resolved with an array of GMPAddons
-   *         The promise is rejected with an object with properties:
-   *           target: The XHR request object
-   *           status: The HTTP status code
-   *           type: Sometimes specifies type of rejection
-   */
-  checkForAddons: function() {
-    let log = getScopedLogger("GMPInstallManager.checkForAddons");
-    if (this._deferred) {
-        log.error("checkForAddons already called");
-        return Promise.reject({type: "alreadycalled"});
-    }
-    this._deferred = Promise.defer();
-    let url = this._getURL();
-
-    this._request = Cc["@mozilla.org/xmlextras/xmlhttprequest;1"].
-                    createInstance(Ci.nsISupports);
-    // This is here to let unit test code override XHR
-    if (this._request.wrappedJSObject) {
-      this._request = this._request.wrappedJSObject;
-    }
-    this._request.open("GET", url, true);
-    let allowNonBuiltIn = !GMPPrefs.get(GMPPrefs.KEY_CERT_CHECKATTRS, true);
-    this._request.channel.notificationCallbacks =
-      new gCertUtils.BadCertHandler(allowNonBuiltIn);
-    // Prevent the request from reading from the cache.
-    this._request.channel.loadFlags |= Ci.nsIRequest.LOAD_BYPASS_CACHE;
-    // Prevent the request from writing to the cache.
-    this._request.channel.loadFlags |= Ci.nsIRequest.INHIBIT_CACHING;
-
-    this._request.overrideMimeType("text/xml");
-    // The Cache-Control header is only interpreted by proxies and the
-    // final destination. It does not help if a resource is already
-    // cached locally.
-    this._request.setRequestHeader("Cache-Control", "no-cache");
-    // HTTP/1.0 servers might not implement Cache-Control and
-    // might only implement Pragma: no-cache
-    this._request.setRequestHeader("Pragma", "no-cache");
-
-    this._request.timeout = CHECK_FOR_ADDONS_TIMEOUT_DELAY_MS;
-    this._request.addEventListener("error", event => this.onFailXML("onErrorXML", event), false);
-    this._request.addEventListener("abort", event => this.onFailXML("onAbortXML", event), false);
-    this._request.addEventListener("timeout", event => this.onFailXML("onTimeoutXML", event), false);
-    this._request.addEventListener("load", event => this.onLoadXML(event), false);
-
-    log.info("sending request to: " + url);
-    this._request.send(null);
-
-    return this._deferred.promise;
-  },
-  /**
-   * Installs the specified addon and calls a callback when done.
-   * @param gmpAddon The GMPAddon object to install
-   * @return a promise which will be resolved or rejected
-   *         The promise will resolve with an array of paths that were extracted
-   *         The promise will reject with an error object:
-   *           target: The XHR request object
-   *           status: The HTTP status code
-   *           type: A string to represent the type of error
-   *                 downloaderr, verifyerr or previouserrorencountered
-   */
-  installAddon: function(gmpAddon) {
-    if (this._deferred) {
-        log.error("previous error encountered");
-        return Promise.reject({type: "previouserrorencountered"});
-    }
-    this.gmpDownloader = new GMPDownloader(gmpAddon);
-    return this.gmpDownloader.start();
-  },
-  _getTimeSinceLastCheck: function() {
-    let now = Math.round(Date.now() / 1000);
-    // Default to 0 here because `now - 0` will be returned later if that case
-    // is hit. We want a large value so a check will occur.
-    let lastCheck = GMPPrefs.get(GMPPrefs.KEY_UPDATE_LAST_CHECK, 0);
-    // Handle clock jumps, return now since we want it to represent
-    // a lot of time has passed since the last check.
-    if (now < lastCheck) {
-      return now;
-    }
-    return now - lastCheck;
-  },
-  get _isEMEEnabled() {
-    return GMPPrefs.get(GMPPrefs.KEY_EME_ENABLED, true);
-  },
-  _isAddonUpdateEnabled: function(aAddon) {
-    return GMPPrefs.get(GMPPrefs.KEY_PLUGIN_ENABLED, true, aAddon) &&
-           GMPPrefs.get(GMPPrefs.KEY_PLUGIN_AUTOUPDATE, true, aAddon);
-  },
-  _updateLastCheck: function() {
-    let now = Math.round(Date.now() / 1000);
-    GMPPrefs.set(GMPPrefs.KEY_UPDATE_LAST_CHECK, now);
-  },
-  _versionchangeOccurred: function() {
-    let savedBuildID = GMPPrefs.get(GMPPrefs.KEY_BUILDID, null);
-    let buildID = Services.appinfo.platformBuildID;
-    if (savedBuildID == buildID) {
-      return false;
-    }
-    GMPPrefs.set(GMPPrefs.KEY_BUILDID, buildID);
-    return true;
-  },
-  /**
-   * Wrapper for checkForAddons and installAddon.
-   * Will only install if not already installed and will log the results.
-   * This will only install/update the OpenH264 and EME plugins
-   * @return a promise which will be resolved if all addons could be installed
-   *         successfully, rejected otherwise.
-   */
-  simpleCheckAndInstall: Task.async(function*() {
-    let log = getScopedLogger("GMPInstallManager.simpleCheckAndInstall");
-
-    if (this._versionchangeOccurred()) {
-      log.info("A version change occurred. Ignoring " +
-               "media.gmp-manager.lastCheck to check immediately for " +
-               "new or updated GMPs.");
-    } else {
-      let secondsBetweenChecks =
-        GMPPrefs.get(GMPPrefs.KEY_SECONDS_BETWEEN_CHECKS,
-                     DEFAULT_SECONDS_BETWEEN_CHECKS)
-      let secondsSinceLast = this._getTimeSinceLastCheck();
-      log.info("Last check was: " + secondsSinceLast +
-               " seconds ago, minimum seconds: " + secondsBetweenChecks);
-      if (secondsBetweenChecks > secondsSinceLast) {
-        log.info("Will not check for updates.");
-        return {status: "too-frequent-no-check"};
-      }
-    }
-
-    try {
-      let gmpAddons = yield this.checkForAddons();
-      this._updateLastCheck();
-      log.info("Found " + gmpAddons.length + " addons advertised.");
-      let addonsToInstall = gmpAddons.filter(function(gmpAddon) {
-        log.info("Found addon: " + gmpAddon.toString());
-
-        if (!gmpAddon.isValid || GMPUtils.isPluginHidden(gmpAddon) ||
-            gmpAddon.isInstalled) {
-          log.info("Addon invalid, hidden or already installed.");
-          return false;
-        }
-
-        let addonUpdateEnabled = false;
-        if (GMP_PLUGIN_IDS.indexOf(gmpAddon.id) >= 0) {
-          addonUpdateEnabled = this._isAddonUpdateEnabled(gmpAddon.id);
-          if (!addonUpdateEnabled) {
-            log.info("Auto-update is off for " + gmpAddon.id +
-                     ", skipping check.");
-          }
-        } else {
-          // Currently, we only support installs of OpenH264 and EME plugins.
-          log.info("Auto-update is off for unknown plugin '" + gmpAddon.id +
-                   "', skipping check.");
-        }
-
-        return addonUpdateEnabled;
-      }, this);
-
-      if (!addonsToInstall.length) {
-        log.info("No new addons to install, returning");
-        return {status: "nothing-new-to-install"};
-      }
-
-      let installResults = [];
-      let failureEncountered = false;
-      for (let addon of addonsToInstall) {
-        try {
-          yield this.installAddon(addon);
-          installResults.push({
-            id:     addon.id,
-            result: "succeeded",
-          });
-        } catch (e) {
-          failureEncountered = true;
-          installResults.push({
-            id:     addon.id,
-            result: "failed",
-          });
-        }
-      }
-      if (failureEncountered) {
-        throw {status:  "failed",
-               results: installResults};
-      }
-      return {status:  "succeeded",
-              results: installResults};
-    } catch(e) {
-      log.error("Could not check for addons", e);
-      throw e;
-    }
-  }),
-
-  /**
-   * Makes sure everything is cleaned up
-   */
-  uninit: function() {
-    let log = getScopedLogger("GMPInstallManager.uninit");
-    if (this._request) {
-      log.info("Aborting request");
-      this._request.abort();
-    }
-    if (this._deferred) {
-        log.info("Rejecting deferred");
-        this._deferred.reject({type: "uninitialized"});
-    }
-    log.info("Done cleanup");
-  },
-
-  /**
-   * If set to true, specifies to leave the temporary downloaded zip file.
-   * This is useful for tests.
-   */
-  overrideLeaveDownloadedZip: false,
-
-  /**
-   * The XMLHttpRequest succeeded and the document was loaded.
-   * @param event The nsIDOMEvent for the load
-  */
-  onLoadXML: function(event) {
-    let log = getScopedLogger("GMPInstallManager.onLoadXML");
-    try {
-      log.info("request completed downloading document");
-      let certs = null;
-      if (!Services.prefs.prefHasUserValue(GMPPrefs.KEY_URL_OVERRIDE) &&
-          GMPPrefs.get(GMPPrefs.KEY_CERT_CHECKATTRS, true)) {
-        certs = gCertUtils.readCertPrefs(GMPPrefs.KEY_CERTS_BRANCH);
-      }
-
-      let allowNonBuiltIn = !GMPPrefs.get(GMPPrefs.KEY_CERT_REQUIREBUILTIN,
-                                          true);
-      log.info("allowNonBuiltIn: " + allowNonBuiltIn);
-
-      gCertUtils.checkCert(this._request.channel, allowNonBuiltIn, certs);
-
-      this.parseResponseXML();
-    } catch (ex) {
-      log.error("could not load xml: " + ex);
-      this._deferred.reject({
-        target: event.target,
-        status: this._getChannelStatus(event.target),
-        message: "" + ex,
-      });
-      delete this._deferred;
-    }
-  },
-
-  /**
-   * Returns the status code for the XMLHttpRequest
-   */
-  _getChannelStatus: function(request) {
-    let log = getScopedLogger("GMPInstallManager._getChannelStatus");
-    let status = null;
-    try {
-      status = request.status;
-      log.info("request.status is: " + request.status);
-    }
-    catch (e) {
-    }
-
-    if (status == null) {
-      status = request.channel.QueryInterface(Ci.nsIRequest).status;
-    }
-    return status;
-  },
-
-  /**
-   * There was an error of some kind during the XMLHttpRequest.  This
-   * error may have been caused by external factors (e.g. network
-   * issues) or internally (by a timeout).
-   *
-   * @param event The nsIDOMEvent for the error
-   */
-  onFailXML: function(failure, event) {
-    let log = getScopedLogger("GMPInstallManager.onFailXML " + failure);
-    let request = event.target;
-    let status = this._getChannelStatus(request);
-    let message = "request.status: " + status +  " (" + event.type + ")";
-    log.warn(message);
-    this._deferred.reject({
-      target: request,
-      status: status,
-      message: message
-    });
-    delete this._deferred;
-  },
-
-  /**
-   * Returns an array of GMPAddon objects discovered by the update check.
-   * Or returns an empty array if there were any problems with parsing.
-   * If there's an error, it will be logged if logging is enabled.
-   */
-  parseResponseXML: function() {
-    try {
-      let log = getScopedLogger("GMPInstallManager.parseResponseXML");
-      let updatesElement = this._request.responseXML.documentElement;
-      if (!updatesElement) {
-        let message = "empty updates document";
-        log.warn(message);
-        this._deferred.reject({
-          target: this._request,
-          message: message
-        });
-        delete this._deferred;
-        return;
-      }
-
-      if (updatesElement.nodeName != "updates") {
-        let message = "got node name: " + updatesElement.nodeName +
-          ", expected: updates";
-        log.warn(message);
-        this._deferred.reject({
-          target: this._request,
-          message: message
-        });
-        delete this._deferred;
-        return;
-      }
-
-      const ELEMENT_NODE = Ci.nsIDOMNode.ELEMENT_NODE;
-      let gmpResults = [];
-      for (let i = 0; i < updatesElement.childNodes.length; ++i) {
-        let updatesChildElement = updatesElement.childNodes.item(i);
-        if (updatesChildElement.nodeType != ELEMENT_NODE) {
-          continue;
-        }
-        if (updatesChildElement.localName == "addons") {
-          gmpResults = GMPAddon.parseGMPAddonsNode(updatesChildElement);
-        }
-      }
-      this._deferred.resolve(gmpResults);
-      delete this._deferred;
-    } catch (e) {
-      this._deferred.reject({
-        target: this._request,
-        message: e
-      });
-      delete this._deferred;
-    }
-  },
-};
-
-/**
- * Used to construct a single GMP addon
- * GMPAddon objects are returns from GMPInstallManager.checkForAddons
- * GMPAddon objects can also be used in calls to GMPInstallManager.installAddon
- *
- * @param gmpAddon The AUS response XML's DOM element `addon`
- */
-function GMPAddon(gmpAddon) {
-  let log = getScopedLogger("GMPAddon.constructor");
-  gmpAddon.QueryInterface(Ci.nsIDOMElement);
-  ["id", "URL", "hashFunction",
-   "hashValue", "version", "size"].forEach(name => {
-    if (gmpAddon.hasAttribute(name)) {
-      this[name] = gmpAddon.getAttribute(name);
-    }
-  });
-  this.size = Number(this.size) || undefined;
-  log.info ("Created new addon: " + this.toString());
-}
-/**
- * Parses an XML GMP addons node from AUS into an array
- * @param addonsElement An nsIDOMElement compatible node with XML from AUS
- * @return An array of GMPAddon results
- */
-GMPAddon.parseGMPAddonsNode = function(addonsElement) {
-  let log = getScopedLogger("GMPAddon.parseGMPAddonsNode");
-  let gmpResults = [];
-  if (addonsElement.localName !== "addons") {
-    return;
-  }
-
-  addonsElement.QueryInterface(Ci.nsIDOMElement);
-  let addonCount = addonsElement.childNodes.length;
-  for (let i = 0; i < addonCount; ++i) {
-    let addonElement = addonsElement.childNodes.item(i);
-    if (addonElement.localName !== "addon") {
-      continue;
-    }
-    addonElement.QueryInterface(Ci.nsIDOMElement);
-    try {
-      gmpResults.push(new GMPAddon(addonElement));
-    } catch (e) {
-      log.warn("invalid addon: " + e);
-      continue;
-    }
-  }
-  return gmpResults;
-};
-GMPAddon.prototype = {
-  /**
-   * Returns a string representation of the addon
-   */
-  toString: function() {
-    return this.id + " (" +
-           "isValid: " + this.isValid +
-           ", isInstalled: " + this.isInstalled +
-           ", hashFunction: " + this.hashFunction+
-           ", hashValue: " + this.hashValue +
-           (this.size !== undefined ? ", size: " + this.size : "" ) +
-           ")";
-  },
-  /**
-   * If all the fields aren't specified don't consider this addon valid
-   * @return true if the addon is parsed and valid
-   */
-  get isValid() {
-    return this.id && this.URL && this.version &&
-      this.hashFunction && !!this.hashValue;
-  },
-  get isInstalled() {
-    return this.version &&
-      GMPPrefs.get(GMPPrefs.KEY_PLUGIN_VERSION, "", this.id) === this.version;
-  },
-  get isEME() {
-    return this.id.indexOf("gmp-eme-") == 0;
-  },
-};
-/**
- * Constructs a GMPExtractor object which is used to extract a GMP zip
- * into the specified location. (Which typically leties per platform)
- * @param zipPath The path on disk of the zip file to extract
- */
-function GMPExtractor(zipPath, installToDirPath) {
-    this.zipPath = zipPath;
-    this.installToDirPath = installToDirPath;
-}
-GMPExtractor.prototype = {
-  /**
-   * Obtains a list of all the entries in a zipfile in the format of *.*.
-   * This also includes files inside directories.
-   *
-   * @param zipReader the nsIZipReader to check
-   * @return An array of string name entries which can be used
-   *         in nsIZipReader.extract
-   */
-  _getZipEntries: function(zipReader) {
-    let entries = [];
-    let enumerator = zipReader.findEntries("*.*");
-    while (enumerator.hasMore()) {
-      entries.push(enumerator.getNext());
-    }
-    return entries;
-  },
-  /**
-   * Installs the this.zipPath contents into the directory used to store GMP
-   * addons for the current platform.
-   *
-   * @return a promise which will be resolved or rejected
-   *         See GMPInstallManager.installAddon for resolve/rejected info
-   */
-  install: function() {
-    try {
-      let log = getScopedLogger("GMPExtractor.install");
-      this._deferred = Promise.defer();
-      log.info("Installing " + this.zipPath + "...");
-      // Get the input zip file
-      let zipFile = Cc["@mozilla.org/file/local;1"].
-                    createInstance(Ci.nsIFile);
-      zipFile.initWithPath(this.zipPath);
-
-      // Initialize a zipReader and obtain the entries
-      var zipReader = Cc["@mozilla.org/libjar/zip-reader;1"].
-                      createInstance(Ci.nsIZipReader);
-      zipReader.open(zipFile)
-      let entries = this._getZipEntries(zipReader);
-      let extractedPaths = [];
-
-      // Extract each of the entries
-      entries.forEach(entry => {
-        // We don't need these types of files
-        if (entry.includes("__MACOSX")) {
-          return;
-        }
-        let outFile = Cc["@mozilla.org/file/local;1"].
-                      createInstance(Ci.nsILocalFile);
-        outFile.initWithPath(this.installToDirPath);
-        outFile.appendRelativePath(entry);
-
-        // Make sure the directory hierarchy exists
-        if(!outFile.parent.exists()) {
-          outFile.parent.create(Ci.nsIFile.DIRECTORY_TYPE, parseInt("0755", 8));
-        }
-        zipReader.extract(entry, outFile);
-        extractedPaths.push(outFile.path);
-        log.info(entry + " was successfully extracted to: " +
-            outFile.path);
-      });
-      zipReader.close();
-      if (!GMPInstallManager.overrideLeaveDownloadedZip) {
-        zipFile.remove(false);
-      }
-
-      log.info(this.zipPath + " was installed successfully");
-      this._deferred.resolve(extractedPaths);
-    } catch (e) {
-      if (zipReader) {
-        zipReader.close();
-      }
-      this._deferred.reject({
-        target: this,
-        status: e,
-        type: "exception"
-      });
-    }
-    return this._deferred.promise;
-  }
-};
-
-
-/**
- * Constructs an object which downloads and initiates an install of
- * the specified GMPAddon object.
- * @param gmpAddon The addon to install.
- */
-function GMPDownloader(gmpAddon)
-{
-  this._gmpAddon = gmpAddon;
-}
-/**
- * Computes the file hash of fileToHash with the specified hash function
- * @param hashFunctionName A hash function name such as sha512
- * @param fileToHash An nsIFile to hash
- * @return a promise which resolve to a digest in binary hex format
- */
-GMPDownloader.computeHash = function(hashFunctionName, fileToHash) {
-  let log = getScopedLogger("GMPDownloader.computeHash");
-  let digest;
-  let fileStream = Cc["@mozilla.org/network/file-input-stream;1"].
-                   createInstance(Ci.nsIFileInputStream);
-  fileStream.init(fileToHash, FileUtils.MODE_RDONLY,
-                  FileUtils.PERMS_FILE, 0);
-  try {
-    let hash = Cc["@mozilla.org/security/hash;1"].
-               createInstance(Ci.nsICryptoHash);
-    let hashFunction =
-      Ci.nsICryptoHash[hashFunctionName.toUpperCase()];
-    if (!hashFunction) {
-      log.error("could not get hash function");
-      return Promise.reject();
-    }
-    hash.init(hashFunction);
-    hash.updateFromStream(fileStream, -1);
-    digest = binaryToHex(hash.finish(false));
-  } catch (e) {
-    log.warn("failed to compute hash: " + e);
-    digest = "";
-  }
-  fileStream.close();
-  return Promise.resolve(digest);
-},
-GMPDownloader.prototype = {
-  /**
-   * Starts the download process for an addon.
-   * @return a promise which will be resolved or rejected
-   *         See GMPInstallManager.installAddon for resolve/rejected info
-   */
-  start: function() {
-    let log = getScopedLogger("GMPDownloader.start");
-    this._deferred = Promise.defer();
-    if (!this._gmpAddon.isValid) {
-      log.info("gmpAddon is not valid, will not continue");
-      return Promise.reject({
-        target: this,
-        status: status,
-        type: "downloaderr"
-      });
-    }
-
-    let uri = Services.io.newURI(this._gmpAddon.URL, null, null);
-    this._request = Cc["@mozilla.org/network/incremental-download;1"].
-                    createInstance(Ci.nsIIncrementalDownload);
-    let gmpFile = FileUtils.getFile("TmpD", [this._gmpAddon.id + ".zip"]);
-    if (gmpFile.exists()) {
-      gmpFile.remove(false);
-    }
-
-    log.info("downloading from " + uri.spec + " to " + gmpFile.path);
-    this._request.init(uri, gmpFile, DOWNLOAD_CHUNK_BYTES_SIZE,
-                       DOWNLOAD_INTERVAL);
-    this._request.start(this, null);
-    return this._deferred.promise;
-  },
-  // For nsIRequestObserver
-  onStartRequest: function(request, context) {
-  },
-  // For nsIRequestObserver
-  // Called when the GMP addon zip file is downloaded
-  onStopRequest: function(request, context, status) {
-    let log = getScopedLogger("GMPDownloader.onStopRequest");
-    log.info("onStopRequest called");
-    if (!Components.isSuccessCode(status)) {
-      log.info("status failed: " + status);
-      this._deferred.reject({
-        target: this,
-        status: status,
-        type: "downloaderr"
-      });
-      return;
-    }
-
-    let promise = this._verifyDownload();
-    promise.then(() => {
-      log.info("GMP file is ready to unzip");
-      let destination = this._request.destination;
-
-      let zipPath = destination.path;
-      let gmpAddon = this._gmpAddon;
-      let installToDirPath = Cc["@mozilla.org/file/local;1"].
-                          createInstance(Ci.nsIFile);
-      let path = OS.Path.join(OS.Constants.Path.profileDir,
-                              gmpAddon.id,
-                              gmpAddon.version);
-      installToDirPath.initWithPath(path);
-      log.info("install to directory path: " + installToDirPath.path);
-      let gmpInstaller = new GMPExtractor(zipPath, installToDirPath.path);
-      let installPromise = gmpInstaller.install();
-      installPromise.then(extractedPaths => {
-        // Success, set the prefs
-        let now = Math.round(Date.now() / 1000);
-        GMPPrefs.set(GMPPrefs.KEY_PLUGIN_LAST_UPDATE, now, gmpAddon.id);
-        // Setting the version pref signals installation completion to consumers,
-        // if you need to set other prefs etc. do it before this.
-        GMPPrefs.set(GMPPrefs.KEY_PLUGIN_VERSION, gmpAddon.version,
-                     gmpAddon.id);
-        this._deferred.resolve(extractedPaths);
-      }, err => {
-        this._deferred.reject(err);
-      });
-    }, err => {
-      log.warn("verifyDownload check failed");
-      this._deferred.reject({
-        target: this,
-        status: 200,
-        type: "verifyerr"
-      });
-    });
-  },
-  /**
-   * Verifies that the downloaded zip file's hash matches the GMPAddon hash.
-   * @return a promise which resolves if the download verifies
-   */
-  _verifyDownload: function() {
-    let verifyDownloadDeferred = Promise.defer();
-    let log = getScopedLogger("GMPDownloader._verifyDownload");
-    log.info("_verifyDownload called");
-    if (!this._request) {
-      return Promise.reject();
-    }
-
-    let destination = this._request.destination;
-    log.info("for path: " + destination.path);
-
-    // Ensure that the file size matches the expected file size.
-    if (this._gmpAddon.size !== undefined &&
-        destination.fileSize != this._gmpAddon.size) {
-      log.warn("Downloader:_verifyDownload downloaded size " +
-               destination.fileSize + " != expected size " +
-               this._gmpAddon.size + ".");
-      return Promise.reject();
-    }
-
-    let promise = GMPDownloader.computeHash(this._gmpAddon.hashFunction, destination);
-    promise.then(digest => {
-        let expectedDigest = this._gmpAddon.hashValue.toLowerCase();
-        if (digest !== expectedDigest) {
-          log.warn("hashes do not match! Got: `" +
-                   digest + "`, expected: `" + expectedDigest +  "`");
-          this._deferred.reject();
-          return;
-        }
-
-        log.info("hashes match!");
-        verifyDownloadDeferred.resolve();
-    }, err => {
-        verifyDownloadDeferred.reject();
-    });
-    return verifyDownloadDeferred.promise;
-  },
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIRequestObserver])
-};
-
-/**
- * Convert a string containing binary values to hex.
- */
-function binaryToHex(input) {
-  let result = "";
-  for (let i = 0; i < input.length; ++i) {
-    let hex = input.charCodeAt(i).toString(16);
-    if (hex.length == 1)
-      hex = "0" + hex;
-    result += hex;
-  }
-  return result;
-}
diff --git a/toolkit/modules/GMPUtils.jsm b/toolkit/modules/GMPUtils.jsm
deleted file mode 100644
index 86206ca..0000000
--- a/toolkit/modules/GMPUtils.jsm
+++ /dev/null
@@ -1,156 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-const {classes: Cc, interfaces: Ci, results: Cr, utils: Cu, manager: Cm} =
-  Components;
-
-this.EXPORTED_SYMBOLS = [ "EME_ADOBE_ID",
-                          "GMP_PLUGIN_IDS",
-                          "GMPPrefs",
-                          "GMPUtils",
-                          "OPEN_H264_ID" ];
-
-Cu.import("resource://gre/modules/Preferences.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-
-// GMP IDs
-const OPEN_H264_ID  = "gmp-gmpopenh264";
-const EME_ADOBE_ID  = "gmp-eme-adobe";
-const GMP_PLUGIN_IDS = [ OPEN_H264_ID, EME_ADOBE_ID ];
-
-this.GMPUtils = {
-  /**
-   * Checks whether or not a given plugin is hidden. Hidden plugins are neither
-   * downloaded nor displayed in the addons manager.
-   * @param   aPlugin
-   *          The plugin to check.
-   */
-  isPluginHidden: function(aPlugin) {
-    if (aPlugin.isEME) {
-      if (this._isPluginSupported(aPlugin) ||
-          this._isPluginForcedVisible(aPlugin)) {
-        return !GMPPrefs.get(GMPPrefs.KEY_EME_ENABLED, true);
-      } else {
-        return true;
-      }
-    }
-    return false;
-  },
-
-  /**
-   * Checks whether or not a given plugin is supported by the current OS.
-   * @param   aPlugin
-   *          The plugin to check.
-   */
-  _isPluginSupported: function(aPlugin) {
-    if (aPlugin.id == EME_ADOBE_ID) {
-      if (Services.appinfo.OS == "WINNT") {
-        return Services.sysinfo.getPropertyAsInt32("version") >= 6;
-      } else {
-        return false;
-      }
-    }
-    return true;
-  },
-
-  /**
-   * Checks whether or not a given plugin is forced visible. This can be used
-   * to test plugins that aren't yet supported by default on a particular OS.
-   * @param   aPlugin
-   *          The plugin to check.
-   */
-  _isPluginForcedVisible: function(aPlugin) {
-    return GMPPrefs.get(GMPPrefs.KEY_PLUGIN_FORCEVISIBLE, false, aPlugin.id);
-  },
-};
-
-/**
- * Manages preferences for GMP addons
- */
-this.GMPPrefs = {
-  KEY_EME_ENABLED:              "media.eme.enabled",
-  KEY_PLUGIN_ENABLED:           "media.{0}.enabled",
-  KEY_PLUGIN_LAST_UPDATE:       "media.{0}.lastUpdate",
-  KEY_PLUGIN_VERSION:           "media.{0}.version",
-  KEY_PLUGIN_AUTOUPDATE:        "media.{0}.autoupdate",
-  KEY_PLUGIN_FORCEVISIBLE:      "media.{0}.forcevisible",
-  KEY_URL:                      "media.gmp-manager.url",
-  KEY_URL_OVERRIDE:             "media.gmp-manager.url.override",
-  KEY_CERT_CHECKATTRS:          "media.gmp-manager.cert.checkAttributes",
-  KEY_CERT_REQUIREBUILTIN:      "media.gmp-manager.cert.requireBuiltIn",
-  KEY_UPDATE_LAST_CHECK:        "media.gmp-manager.lastCheck",
-  KEY_SECONDS_BETWEEN_CHECKS:   "media.gmp-manager.secondsBetweenChecks",
-  KEY_APP_DISTRIBUTION:         "distribution.id",
-  KEY_APP_DISTRIBUTION_VERSION: "distribution.version",
-  KEY_BUILDID:                  "media.gmp-manager.buildID",
-  KEY_CERTS_BRANCH:             "media.gmp-manager.certs.",
-  KEY_PROVIDER_ENABLED:         "media.gmp-provider.enabled",
-  KEY_LOG_BASE:                 "media.gmp.log.",
-  KEY_LOGGING_LEVEL:            "media.gmp.log.level",
-  KEY_LOGGING_DUMP:             "media.gmp.log.dump",
-
-  /**
-   * Obtains the specified preference in relation to the specified plugin.
-   * @param aKey The preference key value to use.
-   * @param aDefaultValue The default value if no preference exists.
-   * @param aPlugin The plugin to scope the preference to.
-   * @return The obtained preference value, or the defaultValue if none exists.
-   */
-  get: function(aKey, aDefaultValue, aPlugin) {
-    if (aKey === this.KEY_APP_DISTRIBUTION ||
-        aKey === this.KEY_APP_DISTRIBUTION_VERSION) {
-      let prefValue = "default";
-      try {
-        prefValue = Services.prefs.getDefaultBranch(null).getCharPref(aKey);
-      } catch (e) {
-        // use default when pref not found
-      }
-      return prefValue;
-    }
-    return Preferences.get(this.getPrefKey(aKey, aPlugin), aDefaultValue);
-  },
-
-  /**
-   * Sets the specified preference in relation to the specified plugin.
-   * @param aKey The preference key value to use.
-   * @param aVal The value to set.
-   * @param aPlugin The plugin to scope the preference to.
-   */
-  set: function(aKey, aVal, aPlugin) {
-    Preferences.set(this.getPrefKey(aKey, aPlugin), aVal);
-  },
-
-  /**
-   * Checks whether or not the specified preference is set in relation to the
-   * specified plugin.
-   * @param aKey The preference key value to use.
-   * @param aPlugin The plugin to scope the preference to.
-   * @return true if the preference is set, false otherwise.
-   */
-  isSet: function(aKey, aPlugin) {
-    return Preferences.isSet(this.getPrefKey(aKey, aPlugin));
-  },
-
-  /**
-   * Resets the specified preference in relation to the specified plugin to its
-   * default.
-   * @param aKey The preference key value to use.
-   * @param aPlugin The plugin to scope the preference to.
-   */
-  reset: function(aKey, aPlugin) {
-    Preferences.reset(this.getPrefKey(aKey, aPlugin));
-  },
-
-  /**
-   * Scopes the specified preference key to the specified plugin.
-   * @param aKey The preference key value to use.
-   * @param aPlugin The plugin to scope the preference to.
-   * @return A preference key scoped to the specified plugin.
-   */
-  getPrefKey: function(aKey, aPlugin) {
-    return aKey.replace("{0}", aPlugin || "");
-  },
-};
\ No newline at end of file
diff --git a/toolkit/modules/moz.build b/toolkit/modules/moz.build
index d7ef002..f11bd57 100644
--- a/toolkit/modules/moz.build
+++ b/toolkit/modules/moz.build
@@ -23,7 +23,6 @@ EXTRA_JS_MODULES += [
     'FileUtils.jsm',
     'Finder.jsm',
     'Geometry.jsm',
-    'GMPUtils.jsm',
     'Http.jsm',
     'InlineSpellChecker.jsm',
     'InlineSpellCheckerContent.jsm',
@@ -64,7 +63,6 @@ EXTRA_JS_MODULES += [
 
 EXTRA_PP_JS_MODULES += [
     'CertUtils.jsm',
-    'GMPInstallManager.jsm',
     'ResetProfile.jsm',
     'secondscreen/RokuApp.jsm',
     'Services.jsm',
diff --git a/toolkit/modules/tests/xpcshell/test_GMPInstallManager.js b/toolkit/modules/tests/xpcshell/test_GMPInstallManager.js
deleted file mode 100644
index 7509014..0000000
--- a/toolkit/modules/tests/xpcshell/test_GMPInstallManager.js
+++ /dev/null
@@ -1,865 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
- * http://creativecommons.org/publicdomain/zero/1.0/ */
-
-const {classes: Cc, interfaces: Ci, results: Cr, utils: Cu, manager: Cm} = Components;
-const URL_HOST = "http://localhost";
-
-let GMPScope = Cu.import("resource://gre/modules/GMPInstallManager.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/FileUtils.jsm");
-Cu.import("resource://testing-common/httpd.js");
-Cu.import("resource://gre/modules/Promise.jsm");
-Cu.import("resource://gre/modules/Preferences.jsm")
-
-do_get_profile();
-
-function run_test() {Cu.import("resource://gre/modules/Preferences.jsm")
-  Preferences.set("media.gmp.log.dump", true);
-  Preferences.set("media.gmp.log.level", 0);
-  run_next_test();
-}
-
-/**
- * Tests that the helper used for preferences works correctly
- */
-add_task(function* test_prefs() {
-  let addon1 = "addon1", addon2 = "addon2";
-
-  GMPScope.GMPPrefs.set(GMPScope.GMPPrefs.KEY_URL, "http://not-really-used");
-  GMPScope.GMPPrefs.set(GMPScope.GMPPrefs.KEY_URL_OVERRIDE, "http://not-really-used-2");
-  GMPScope.GMPPrefs.set(GMPScope.GMPPrefs.KEY_PLUGIN_LAST_UPDATE, "1", addon1);
-  GMPScope.GMPPrefs.set(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, "2", addon1);
-  GMPScope.GMPPrefs.set(GMPScope.GMPPrefs.KEY_PLUGIN_LAST_UPDATE, "3", addon2);
-  GMPScope.GMPPrefs.set(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, "4", addon2);
-  GMPScope.GMPPrefs.set(GMPScope.GMPPrefs.KEY_PLUGIN_AUTOUPDATE, false, addon2);
-  GMPScope.GMPPrefs.set(GMPScope.GMPPrefs.KEY_CERT_CHECKATTRS, true);
-
-  do_check_eq(GMPScope.GMPPrefs.get(GMPScope.GMPPrefs.KEY_URL), "http://not-really-used");
-  do_check_eq(GMPScope.GMPPrefs.get(GMPScope.GMPPrefs.KEY_URL_OVERRIDE),
-              "http://not-really-used-2");
-  do_check_eq(GMPScope.GMPPrefs.get(GMPScope.GMPPrefs.KEY_PLUGIN_LAST_UPDATE, "", addon1), "1");
-  do_check_eq(GMPScope.GMPPrefs.get(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, "", addon1), "2");
-  do_check_eq(GMPScope.GMPPrefs.get(GMPScope.GMPPrefs.KEY_PLUGIN_LAST_UPDATE, "", addon2), "3");
-  do_check_eq(GMPScope.GMPPrefs.get(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, "", addon2), "4");
-  do_check_eq(GMPScope.GMPPrefs.get(GMPScope.GMPPrefs.KEY_PLUGIN_AUTOUPDATE, undefined, addon2),
-              false);
-  do_check_true(GMPScope.GMPPrefs.get(GMPScope.GMPPrefs.KEY_CERT_CHECKATTRS));
-  GMPScope.GMPPrefs.set(GMPScope.GMPPrefs.KEY_PLUGIN_AUTOUPDATE, true, addon2);
-});
-
-/**
- * Tests that an uninit without a check works fine
- */
-add_task(function* test_checkForAddons_uninitWithoutCheck() {
-  let installManager = new GMPInstallManager();
-  installManager.uninit();
-});
-
-/**
- * Tests that an uninit without an install works fine
- */
-add_test(function test_checkForAddons_uninitWithoutInstall() {
-  overrideXHR(200, "");
-  let installManager = new GMPInstallManager();
-  let promise = installManager.checkForAddons();
-  promise.then(() => {
-    do_throw("no response should reject");
-  }, err => {
-    do_check_true(!!err);
-    installManager.uninit();
-    run_next_test();
-  });
-});
-
-/**
- * Tests that no response returned rejects
- */
-add_test(function test_checkForAddons_noResponse() {
-  overrideXHR(200, "");
-  let installManager = new GMPInstallManager();
-  let promise = installManager.checkForAddons();
-  promise.then(() => {
-    do_throw("no response should reject");
-  }, err => {
-    do_check_true(!!err);
-    installManager.uninit();
-    run_next_test();
-  });
-});
-
-/**
- * Tests that no addons element returned resolves with no addons
- */
-add_task(function* test_checkForAddons_noAddonsElement() {
-  overrideXHR(200, "<updates></updates>");
-  let installManager = new GMPInstallManager();
-  let gmpAddons = yield installManager.checkForAddons();
-  do_check_eq(gmpAddons.length, 0);
-  installManager.uninit();
-});
-
-/**
- * Tests that empty addons element returned resolves with no addons
- */
-add_task(function* test_checkForAddons_emptyAddonsElement() {
-  overrideXHR(200, "<updates><addons/></updates>");
-  let installManager = new GMPInstallManager();
-  let gmpAddons = yield installManager.checkForAddons();
-  do_check_eq(gmpAddons.length, 0);
-  installManager.uninit();
-});
-
-/**
- * Tests that a response with the wrong root element rejects
- */
-add_test(function test_checkForAddons_wrongResponseXML() {
-  overrideXHR(200, "<digits_of_pi>3.141592653589793....</digits_of_pi>");
-  let installManager = new GMPInstallManager();
-  let promise = installManager.checkForAddons();
-  promise.then(() => {
-    do_throw("response with the wrong root element should reject");
-  }, err => {
-    do_check_true(!!err);
-    installManager.uninit();
-    run_next_test();
-  });
-});
-
-/**
- * Tests that a 404 error works as expected
- */
-add_test(function test_checkForAddons_404Error() {
-  overrideXHR(404, "");
-  let installManager = new GMPInstallManager();
-  let promise = installManager.checkForAddons();
-  promise.then(() => {
-    do_throw("404 response should reject");
-  }, err => {
-    do_check_true(!!err);
-    do_check_eq(err.status, 404);
-    installManager.uninit();
-    run_next_test();
-  });
-});
-
-/**
- * Tests that a xhr abort() works as expected
- */
-add_test(function test_checkForAddons_abort() {
-  let xhr = overrideXHR(200, "", { dropRequest: true} );
-  let installManager = new GMPInstallManager();
-  let promise = installManager.checkForAddons();
-  xhr.abort();
-  promise.then(() => {
-    do_throw("abort() should reject");
-  }, err => {
-    do_check_eq(err.status, 0);
-    installManager.uninit();
-    run_next_test();
-  });
-});
-
-/**
- * Tests that a defensive timeout works as expected
- */
-add_test(function test_checkForAddons_timeout() {
-  overrideXHR(200, "", { dropRequest: true, timeout: true });
-  let installManager = new GMPInstallManager();
-  let promise = installManager.checkForAddons();
-  promise.then(() => {
-    do_throw("Defensive timeout should reject");
-  }, err => {
-    do_check_eq(err.status, 0);
-    installManager.uninit();
-    run_next_test();
-  });
-});
-
-/**
- * Tests that we throw correctly in case of ssl certification error.
- */
-add_test(function test_checkForAddons_bad_ssl() {
-  //
-  // Add random stuff that cause CertUtil to require https.
-  //
-  let PREF_KEY_URL_OVERRIDE_BACKUP =
-    Preferences.get(GMPScope.GMPPrefs.KEY_URL_OVERRIDE, undefined);
-  Preferences.reset(GMPScope.GMPPrefs.KEY_URL_OVERRIDE);
-
-  let CERTS_BRANCH_DOT_ONE = GMPScope.GMPPrefs.KEY_CERTS_BRANCH + ".1";
-  let PREF_CERTS_BRANCH_DOT_ONE_BACKUP =
-    Preferences.get(CERTS_BRANCH_DOT_ONE, undefined);
-  Services.prefs.setCharPref(CERTS_BRANCH_DOT_ONE, "funky value");
-
-
-  overrideXHR(200, "");
-  let installManager = new GMPInstallManager();
-  let promise = installManager.checkForAddons();
-  promise.then(() => {
-    do_throw("Defensive timeout should reject");
-  }, err => {
-    do_check_true(err.message.includes("SSL is required and URI scheme is " +
-                                       "not https."));
-    installManager.uninit();
-    if (PREF_KEY_URL_OVERRIDE_BACKUP) {
-      Preferences.set(GMPScope.GMPPrefs.KEY_URL_OVERRIDE,
-        PREF_KEY_URL_OVERRIDE_BACKUP);
-    }
-    if (PREF_CERTS_BRANCH_DOT_ONE_BACKUP) {
-      Preferences.set(CERTS_BRANCH_DOT_ONE,
-        PREF_CERTS_BRANCH_DOT_ONE_BACKUP);
-    }
-    run_next_test();
-  });
-});
-
-/**
- * Tests that gettinga a funky non XML response works as expected
- */
-add_test(function test_checkForAddons_notXML() {
-  overrideXHR(200, "3.141592653589793....");
-  let installManager = new GMPInstallManager();
-  let promise = installManager.checkForAddons();
-  promise.then(() => {
-    do_throw("non XML response should reject");
-  }, err => {
-    do_check_true(!!err);
-    installManager.uninit();
-    run_next_test();
-  });
-});
-
-/**
- * Tests that getting a response with a single addon works as expected
- */
-add_task(function* test_checkForAddons_singleAddon() {
-  let responseXML =
-    "<?xml version=\"1.0\"?>" +
-    "<updates>" +
-    "    <addons>" +
-    "        <addon id=\"gmp-gmpopenh264\"" +
-    "               URL=\"http://127.0.0.1:8011/gmp-gmpopenh264-1.1.zip\"" +
-    "               hashFunction=\"sha256\"" +
-    "               hashValue=\"1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee\"" +
-    "               version=\"1.1\"/>" +
-    "  </addons>" +
-    "</updates>"
-  overrideXHR(200, responseXML);
-  let installManager = new GMPInstallManager();
-  let gmpAddons = yield installManager.checkForAddons();
-  do_check_eq(gmpAddons.length, 1);
-  let gmpAddon= gmpAddons[0];
-  do_check_eq(gmpAddon.id, "gmp-gmpopenh264");
-  do_check_eq(gmpAddon.URL, "http://127.0.0.1:8011/gmp-gmpopenh264-1.1.zip");
-  do_check_eq(gmpAddon.hashFunction, "sha256");
-  do_check_eq(gmpAddon.hashValue, "1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee");
-  do_check_eq(gmpAddon.version, "1.1");
-  do_check_eq(gmpAddon.size, undefined);
-  do_check_true(gmpAddon.isValid);
-  do_check_false(gmpAddon.isInstalled);
-  installManager.uninit();
-});
-
-/**
- * Tests that getting a response with a single addon with the optional size
- * attribute parses as expected.
- */
-add_task(function* test_checkForAddons_singleAddonWithSize() {
-  let responseXML =
-    "<?xml version=\"1.0\"?>" +
-    "<updates>" +
-    "    <addons>" +
-    "        <addon id=\"openh264-plugin-no-at-symbol\"" +
-    "               URL=\"http://127.0.0.1:8011/gmp-gmpopenh264-1.1.zip\"" +
-    "               hashFunction=\"sha256\"" +
-    "               size=\"42\"" +
-    "               hashValue=\"1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee\"" +
-    "               version=\"1.1\"/>" +
-    "  </addons>" +
-    "</updates>"
-  overrideXHR(200, responseXML);
-  let installManager = new GMPInstallManager();
-  let gmpAddons = yield installManager.checkForAddons();
-  do_check_eq(gmpAddons.length, 1);
-  let gmpAddon = gmpAddons[0];
-  do_check_eq(gmpAddon.id, "openh264-plugin-no-at-symbol");
-  do_check_eq(gmpAddon.URL, "http://127.0.0.1:8011/gmp-gmpopenh264-1.1.zip");
-  do_check_eq(gmpAddon.hashFunction, "sha256");
-  do_check_eq(gmpAddon.hashValue, "1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee");
-  do_check_eq(gmpAddon.size, 42);
-  do_check_eq(gmpAddon.version, "1.1");
-  do_check_true(gmpAddon.isValid);
-  do_check_false(gmpAddon.isInstalled);
-  installManager.uninit();
-});
-
-/**
- * Tests that checking for multiple addons work correctly.
- * Also tests that invalid addons work correctly.
- */
-add_task(function* test_checkForAddons_multipleAddonNoUpdatesSomeInvalid() {
-  let responseXML =
-    "<?xml version=\"1.0\"?>" +
-    "<updates>" +
-    "    <addons>" +
-    // valid openh264
-    "        <addon id=\"gmp-gmpopenh264\"" +
-    "               URL=\"http://127.0.0.1:8011/gmp-gmpopenh264-1.1.zip\"" +
-    "               hashFunction=\"sha256\"" +
-    "               hashValue=\"1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee\"" +
-    "               version=\"1.1\"/>" +
-    // valid not openh264
-    "        <addon id=\"NOT-gmp-gmpopenh264\"" +
-    "               URL=\"http://127.0.0.1:8011/NOT-gmp-gmpopenh264-1.1.zip\"" +
-    "               hashFunction=\"sha512\"" +
-    "               hashValue=\"141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee\"" +
-    "               version=\"9.1\"/>" +
-    // noid
-    "        <addon notid=\"NOT-gmp-gmpopenh264\"" +
-    "               URL=\"http://127.0.0.1:8011/NOT-gmp-gmpopenh264-1.1.zip\"" +
-    "               hashFunction=\"sha512\"" +
-    "               hashValue=\"141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee\"" +
-    "               version=\"9.1\"/>" +
-    // no URL
-    "        <addon id=\"NOT-gmp-gmpopenh264\"" +
-    "               notURL=\"http://127.0.0.1:8011/NOT-gmp-gmpopenh264-1.1.zip\"" +
-    "               hashFunction=\"sha512\"" +
-    "               hashValue=\"141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee\"" +
-    "               version=\"9.1\"/>" +
-    // no hash function
-    "        <addon id=\"NOT-gmp-gmpopenh264\"" +
-    "               URL=\"http://127.0.0.1:8011/NOT-gmp-gmpopenh264-1.1.zip\"" +
-    "               nothashFunction=\"sha512\"" +
-    "               hashValue=\"141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee\"" +
-    "               version=\"9.1\"/>" +
-    // no hash function
-    "        <addon id=\"NOT-gmp-gmpopenh264\"" +
-    "               URL=\"http://127.0.0.1:8011/NOT-gmp-gmpopenh264-1.1.zip\"" +
-    "               hashFunction=\"sha512\"" +
-    "               nothashValue=\"141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee\"" +
-    "               version=\"9.1\"/>" +
-    // not version
-    "        <addon id=\"NOT-gmp-gmpopenh264\"" +
-    "               URL=\"http://127.0.0.1:8011/NOT-gmp-gmpopenh264-1.1.zip\"" +
-    "               hashFunction=\"sha512\"" +
-    "               hashValue=\"141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee\"" +
-    "               notversion=\"9.1\"/>" +
-    "  </addons>" +
-    "</updates>"
-  overrideXHR(200, responseXML);
-  let installManager = new GMPInstallManager();
-  let gmpAddons = yield installManager.checkForAddons();
-  do_check_eq(gmpAddons.length, 7);
-  let gmpAddon= gmpAddons[0];
-  do_check_eq(gmpAddon.id, "gmp-gmpopenh264");
-  do_check_eq(gmpAddon.URL, "http://127.0.0.1:8011/gmp-gmpopenh264-1.1.zip");
-  do_check_eq(gmpAddon.hashFunction, "sha256");
-  do_check_eq(gmpAddon.hashValue, "1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee");
-  do_check_eq(gmpAddon.version, "1.1");
-  do_check_true(gmpAddon.isValid);
-  do_check_false(gmpAddon.isInstalled);
-
-  gmpAddon= gmpAddons[1];
-  do_check_eq(gmpAddon.id, "NOT-gmp-gmpopenh264");
-  do_check_eq(gmpAddon.URL, "http://127.0.0.1:8011/NOT-gmp-gmpopenh264-1.1.zip");
-  do_check_eq(gmpAddon.hashFunction, "sha512");
-  do_check_eq(gmpAddon.hashValue, "141592656f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee");
-  do_check_eq(gmpAddon.version, "9.1");
-  do_check_true(gmpAddon.isValid);
-  do_check_false(gmpAddon.isInstalled);
-
-  for (let i = 2; i < gmpAddons.length; i++) {
-    do_check_false(gmpAddons[i].isValid);
-    do_check_false(gmpAddons[i].isInstalled);
-  }
-  installManager.uninit();
-});
-
-/**
- * Tests that checking for addons when there are also updates available
- * works as expected.
- */
-add_task(function* test_checkForAddons_updatesWithAddons() {
-  let responseXML =
-    "<?xml version=\"1.0\"?>" +
-    "    <updates>" +
-    "        <update type=\"minor\" displayVersion=\"33.0a1\" appVersion=\"33.0a1\" platformVersion=\"33.0a1\" buildID=\"20140628030201\">" +
-    "        <patch type=\"complete\" URL=\"http://ftp.mozilla.org/pub/mozilla.org/firefox/nightly/2014/06/2014-06-28-03-02-01-mozilla-central/firefox-33.0a1.en-US.mac.complete.mar\" hashFunction=\"sha512\" hashValue=\"f3f90d71dff03ae81def80e64bba3e4569da99c9e15269f731c2b167c4fc30b3aed9f5fee81c19614120230ca333e73a5e7def1b8e45d03135b2069c26736219\" size=\"85249896\"/>" +
-    "    </update>" +
-    "    <addons>" +
-    "        <addon id=\"gmp-gmpopenh264\"" +
-    "               URL=\"http://127.0.0.1:8011/gmp-gmpopenh264-1.1.zip\"" +
-    "               hashFunction=\"sha256\"" +
-    "               hashValue=\"1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee\"" +
-    "               version=\"1.1\"/>" +
-    "  </addons>" +
-    "</updates>"
-  overrideXHR(200, responseXML);
-  let installManager = new GMPInstallManager();
-  let gmpAddons = yield installManager.checkForAddons();
-  do_check_eq(gmpAddons.length, 1);
-  let gmpAddon= gmpAddons[0];
-  do_check_eq(gmpAddon.id, "gmp-gmpopenh264");
-  do_check_eq(gmpAddon.URL, "http://127.0.0.1:8011/gmp-gmpopenh264-1.1.zip");
-  do_check_eq(gmpAddon.hashFunction, "sha256");
-  do_check_eq(gmpAddon.hashValue, "1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee");
-  do_check_eq(gmpAddon.version, "1.1");
-  do_check_true(gmpAddon.isValid);
-  do_check_false(gmpAddon.isInstalled);
-  installManager.uninit();
-});
-
-/**
- * Tests that installing found addons works as expected
- */
-function* test_checkForAddons_installAddon(id, includeSize, wantInstallReject) {
-  do_print("Running installAddon for id: " + id +
-           ", includeSize: " + includeSize +
-           " and wantInstallReject: " + wantInstallReject);
-  let httpServer = new HttpServer();
-  let dir = FileUtils.getDir("TmpD", [], true);
-  httpServer.registerDirectory("/", dir);
-  httpServer.start(-1);
-  let testserverPort = httpServer.identity.primaryPort;
-  let zipFileName = "test_" + id + "_GMP.zip";
-
-  let zipURL = URL_HOST + ":" + testserverPort + "/" + zipFileName;
-  do_print("zipURL: " + zipURL);
-
-  let data = "e~=0.5772156649";
-  let zipFile = createNewZipFile(zipFileName, data);
-  let hashFunc = "sha256";
-  let expectedDigest = yield GMPDownloader.computeHash(hashFunc, zipFile);
-  let fileSize = zipFile.fileSize;
-  if (wantInstallReject) {
-    fileSize = 1;
-  }
-
-  let responseXML =
-    "<?xml version=\"1.0\"?>" +
-    "<updates>" +
-    "    <addons>" +
-    "        <addon id=\"" + id + "-gmp-gmpopenh264\"" +
-    "               URL=\"" + zipURL + "\"" +
-    "               hashFunction=\"" + hashFunc + "\"" +
-    "               hashValue=\"" + expectedDigest + "\"" +
-    (includeSize ? " size=\"" + fileSize + "\"" : "") +
-    "               version=\"1.1\"/>" +
-    "  </addons>" +
-    "</updates>"
-
-  overrideXHR(200, responseXML);
-  let installManager = new GMPInstallManager();
-  let gmpAddons = yield installManager.checkForAddons();
-  do_check_eq(gmpAddons.length, 1);
-  let gmpAddon = gmpAddons[0];
-  do_check_false(gmpAddon.isInstalled);
-
-  GMPInstallManager.overrideLeaveDownloadedZip = true;
-  try {
-    let extractedPaths = yield installManager.installAddon(gmpAddon);
-    if (wantInstallReject) {
-      do_check_true(false); // installAddon() should have thrown.
-    }
-    do_check_eq(extractedPaths.length, 1);
-    let extractedPath = extractedPaths[0];
-
-    do_print("Extracted path: " + extractedPath);
-
-    let extractedFile = Cc["@mozilla.org/file/local;1"].
-                        createInstance(Ci.nsIFile);
-    extractedFile.initWithPath(extractedPath);
-    do_check_true(extractedFile.exists());
-    let readData = readStringFromFile(extractedFile);
-    do_check_eq(readData, data);
-
-    // Check that the downloaded zip matches the offered zip exactly
-    let downloadedGMPFile = FileUtils.getFile("TmpD",
-      [gmpAddon.id + ".zip"]);
-    do_check_true(downloadedGMPFile.exists());
-    let downloadedBytes = getBinaryFileData(downloadedGMPFile);
-    let sourceBytes = getBinaryFileData(zipFile);
-    do_check_true(compareBinaryData(downloadedBytes, sourceBytes));
-
-    // Make sure the prefs are set correctly
-    do_check_true(!!GMPScope.GMPPrefs.get(
-      GMPScope.GMPPrefs.KEY_PLUGIN_LAST_UPDATE, "", gmpAddon.id));
-    do_check_eq(GMPScope.GMPPrefs.get(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, "",
-                                      gmpAddon.id),
-                "1.1");
-    // Make sure it reports as being installed
-    do_check_true(gmpAddon.isInstalled);
-
-    // Cleanup
-    extractedFile.parent.remove(true);
-    zipFile.remove(false);
-    httpServer.stop(function() {});
-    do_print("Removing downloaded GMP file: " + downloadedGMPFile.path);
-    downloadedGMPFile.remove(false);
-    installManager.uninit();
-  } catch(ex) {
-    zipFile.remove(false);
-    let downloadedGMPFile = FileUtils.getFile("TmpD",
-      [gmpAddon.id + ".zip"]);
-    do_print("Removing downloaded GMP file from exception handler: " +
-             downloadedGMPFile.path);
-    downloadedGMPFile.remove(false);
-    if (!wantInstallReject) {
-      do_throw("install update should not reject");
-    }
-  }
-}
-
-add_task(test_checkForAddons_installAddon.bind(null, "1", true, false));
-add_task(test_checkForAddons_installAddon.bind(null, "2", false, false));
-add_task(test_checkForAddons_installAddon.bind(null, "3", true, true));
-
-/**
- * Tests simpleCheckAndInstall when autoupdate is disabled for a GMP
- */
-add_task(function* test_simpleCheckAndInstall_autoUpdateDisabled() {
-  GMPScope.GMPPrefs.set(GMPScope.GMPPrefs.KEY_PLUGIN_AUTOUPDATE, false, GMPScope.OPEN_H264_ID);
-  let responseXML =
-    "<?xml version=\"1.0\"?>" +
-    "<updates>" +
-    "    <addons>" +
-    // valid openh264
-    "        <addon id=\"gmp-gmpopenh264\"" +
-    "               URL=\"http://127.0.0.1:8011/gmp-gmpopenh264-1.1.zip\"" +
-    "               hashFunction=\"sha256\"" +
-    "               hashValue=\"1118b90d6f645eefc2b99af17bae396636ace1e33d079c88de715177584e2aee\"" +
-    "               version=\"1.1\"/>" +
-    "  </addons>" +
-    "</updates>"
-
-  overrideXHR(200, responseXML);
-  let installManager = new GMPInstallManager();
-  let result = yield installManager.simpleCheckAndInstall();
-  do_check_eq(result.status, "nothing-new-to-install");
-  Preferences.reset(GMPScope.GMPPrefs.KEY_UPDATE_LAST_CHECK);
-  GMPScope.GMPPrefs.set(GMPScope.GMPPrefs.KEY_PLUGIN_AUTOUPDATE, true, GMPScope.OPEN_H264_ID);
-});
-
-/**
- * Tests simpleCheckAndInstall nothing to install
- */
-add_task(function* test_simpleCheckAndInstall_nothingToInstall() {
-  let responseXML =
-    "<?xml version=\"1.0\"?>" +
-    "<updates>" +
-    "</updates>"
-
-  overrideXHR(200, responseXML);
-  let installManager = new GMPInstallManager();
-  let result = yield installManager.simpleCheckAndInstall();
-  do_check_eq(result.status, "nothing-new-to-install");
-});
-
-/**
- * Tests simpleCheckAndInstall too frequent
- */
-add_task(function* test_simpleCheckAndInstall_tooFrequent() {
-  let responseXML =
-    "<?xml version=\"1.0\"?>" +
-    "<updates>" +
-    "</updates>"
-
-  overrideXHR(200, responseXML);
-  let installManager = new GMPInstallManager();
-  let result = yield installManager.simpleCheckAndInstall();
-  do_check_eq(result.status, "too-frequent-no-check");
-});
-
-/**
- * Tests that installing addons when there is no server works as expected
- */
-add_test(function test_installAddon_noServer() {
-  let dir = FileUtils.getDir("TmpD", [], true);
-  let zipFileName = "test_GMP.zip";
-  let zipURL = URL_HOST + ":0/" + zipFileName;
-
-  let data = "e~=0.5772156649";
-  let zipFile = createNewZipFile(zipFileName, data);
-
-  let responseXML =
-    "<?xml version=\"1.0\"?>" +
-    "<updates>" +
-    "    <addons>" +
-    "        <addon id=\"gmp-gmpopenh264\"" +
-    "               URL=\"" + zipURL + "\"" +
-    "               hashFunction=\"sha256\"" +
-    "               hashValue=\"11221cbda000347b054028b527a60e578f919cb10f322ef8077d3491c6fcb474\"" +
-    "               version=\"1.1\"/>" +
-    "  </addons>" +
-    "</updates>"
-
-  overrideXHR(200, responseXML);
-  let installManager = new GMPInstallManager();
-  let checkPromise = installManager.checkForAddons();
-  checkPromise.then(gmpAddons => {
-    do_check_eq(gmpAddons.length, 1);
-    let gmpAddon= gmpAddons[0];
-
-    GMPInstallManager.overrideLeaveDownloadedZip = true;
-    let installPromise = installManager.installAddon(gmpAddon);
-    installPromise.then(extractedPaths => {
-      do_throw("No server for install should reject");
-    }, err => {
-      do_check_true(!!err);
-      installManager.uninit();
-      run_next_test();
-    });
-  }, () => {
-    do_throw("check should not reject for install no server");
-  });
-});
-
-/**
- * Returns the read stream into a string
- */
-function readStringFromInputStream(inputStream) {
-  let sis = Cc["@mozilla.org/scriptableinputstream;1"].
-            createInstance(Ci.nsIScriptableInputStream);
-  sis.init(inputStream);
-  let text = sis.read(sis.available());
-  sis.close();
-  return text;
-}
-
-/**
- * Reads a string of text from a file.
- * This function only works with ASCII text.
- */
-function readStringFromFile(file) {
-  if (!file.exists()) {
-    do_print("readStringFromFile - file doesn't exist: " + file.path);
-    return null;
-  }
-  let fis = Cc["@mozilla.org/network/file-input-stream;1"].
-            createInstance(Ci.nsIFileInputStream);
-  fis.init(file, FileUtils.MODE_RDONLY, FileUtils.PERMS_FILE, 0);
-  return readStringFromInputStream(fis);
-}
-
-/**
- * Bare bones XMLHttpRequest implementation for testing onprogress, onerror,
- * and onload nsIDomEventListener handleEvent.
- */
-function makeHandler(aVal) {
-  if (typeof aVal == "function")
-    return { handleEvent: aVal };
-  return aVal;
-}
-/**
- * Constructs a mock xhr which is used for testing different aspects
- * of responses.
- */
-function xhr(inputStatus, inputResponse, options) {
-  this.inputStatus = inputStatus;
-  this.inputResponse = inputResponse;
-  this.status = 0;
-  this.responseXML = null;
-  this._aborted = false;
-  this._onabort = null;
-  this._onprogress = null;
-  this._onerror = null;
-  this._onload = null;
-  this._onloadend = null;
-  this._ontimeout = null;
-  this._url = null;
-  this._method = null;
-  this._timeout = 0;
-  this._notified = false;
-  this._options = options || {};
-}
-xhr.prototype = {
-  overrideMimeType: function(aMimetype) { },
-  setRequestHeader: function(aHeader, aValue) { },
-  status: null,
-  channel: { set notificationCallbacks(aVal) { } },
-  open: function(aMethod, aUrl) {
-    this.channel.originalURI = Services.io.newURI(aUrl, null, null);
-    this._method = aMethod; this._url = aUrl;
-  },
-  abort: function() {
-    this._dropRequest = true;
-    this._notify(["abort", "loadend"]);
-  },
-  responseXML: null,
-  responseText: null,
-  send: function(aBody) {
-    do_execute_soon(function() {
-      try {
-        if (this._options.dropRequest) {
-          if (this._timeout > 0 && this._options.timeout) {
-            this._notify(["timeout", "loadend"]);
-          }
-          return;
-        }
-        this.status = this.inputStatus;
-        this.responseText = this.inputResponse;
-        try {
-          let parser = Cc["@mozilla.org/xmlextras/domparser;1"].
-                createInstance(Ci.nsIDOMParser);
-          this.responseXML = parser.parseFromString(this.inputResponse,
-            "application/xml");
-        } catch (e) {
-          this.responseXML = null;
-        }
-        if (this.inputStatus === 200) {
-          this._notify(["load", "loadend"]);
-        } else {
-          this._notify(["error", "loadend"]);
-        }
-      } catch (ex) {
-        do_throw(ex);
-      }
-    }.bind(this));
-  },
-  set onabort(aValue) { this._onabort = makeHandler(aValue); },
-  get onabort() { return this._onabort; },
-  set onprogress(aValue) { this._onprogress = makeHandler(aValue); },
-  get onprogress() { return this._onprogress; },
-  set onerror(aValue) { this._onerror = makeHandler(aValue); },
-  get onerror() { return this._onerror; },
-  set onload(aValue) { this._onload = makeHandler(aValue); },
-  get onload() { return this._onload; },
-  set onloadend(aValue) { this._onloadend = makeHandler(aValue); },
-  get onloadend() { return this._onloadend; },
-  set ontimeout(aValue) { this._ontimeout = makeHandler(aValue); },
-  get ontimeout() { return this._ontimeout; },
-  set timeout(aValue) { this._timeout = aValue; },
-  _notify: function(events) {
-    if (this._notified) {
-      return;
-    }
-    this._notified = true;
-    for (let item of events) {
-      let k = "on" + item;
-      if (this[k]) {
-        do_print("Notifying " + item);
-        let e = {
-          target: this,
-          type: item,
-        };
-        this[k](e);
-      } else {
-        do_print("Notifying " + item + ", but there are no listeners");
-      }
-    }
-  },
-  addEventListener: function(aEvent, aValue, aCapturing) {
-    eval("this._on" + aEvent + " = aValue");
-  },
-  flags: Ci.nsIClassInfo.SINGLETON,
-  implementationLanguage: Ci.nsIProgrammingLanguage.JAVASCRIPT,
-  getHelperForLanguage: function(aLanguage) null,
-  getInterfaces: function(aCount) {
-    let interfaces = [Ci.nsISupports];
-    aCount.value = interfaces.length;
-    return interfaces;
-  },
-  classDescription: "XMLHttpRequest",
-  contractID: "@mozilla.org/xmlextras/xmlhttprequest;1",
-  classID: Components.ID("{c9b37f43-4278-4304-a5e0-600991ab08cb}"),
-  createInstance: function(aOuter, aIID) {
-    if (aOuter == null)
-      return this.QueryInterface(aIID);
-    throw Cr.NS_ERROR_NO_AGGREGATION;
-  },
-  QueryInterface: function(aIID) {
-    if (aIID.equals(Ci.nsIClassInfo) ||
-        aIID.equals(Ci.nsISupports))
-      return this;
-    throw Cr.NS_ERROR_NO_INTERFACE;
-  },
-  get wrappedJSObject() { return this; }
-};
-
-/**
- * Helper used to overrideXHR requests (no matter to what URL) with the
- * specified status and response.
- * @param status The status you want to get back when an XHR request is made
- * @param response The response you want to get back when an XHR request is made
- */
-function overrideXHR(status, response, options) {
-  let registrar = Components.manager.QueryInterface(Ci.nsIComponentRegistrar);
-  if (overrideXHR.myxhr) {
-    registrar.unregisterFactory(overrideXHR.myxhr.classID, overrideXHR.myxhr);
-  }
-  overrideXHR.myxhr = new xhr(status, response, options);
-  registrar.registerFactory(overrideXHR.myxhr.classID,
-                            overrideXHR.myxhr.classDescription,
-                            overrideXHR.myxhr.contractID,
-                            overrideXHR.myxhr);
-  return overrideXHR.myxhr;
-}
-
-/**
- * Compares binary data of 2 arrays and returns true if they are the same
- *
- * @param arr1 The first array to compare
- * @param arr2 The second array to compare
-*/
-function compareBinaryData(arr1, arr2) {
-  do_check_eq(arr1.length, arr2.length);
-  for (let i = 0; i < arr1.length; i++) {
-    if (arr1[i] != arr2[i]) {
-      do_print("Data differs at index " + i +
-               ", arr1: " + arr1[i] + ", arr2: " + arr2[i]);
-      return false;
-    }
-  }
-  return true;
-}
-
-/**
- * Reads a file's data and returns it
- *
- * @param file The file to read the data from
- * @return array of bytes for the data in the file.
-*/
-function getBinaryFileData(file) {
-  let fileStream = Cc["@mozilla.org/network/file-input-stream;1"].
-                   createInstance(Ci.nsIFileInputStream);
-  // Open as RD_ONLY with default permissions.
-  fileStream.init(file, FileUtils.MODE_RDONLY, FileUtils.PERMS_FILE, 0);
-
-  // Check the returned size versus the expected size.
-  let stream = Cc["@mozilla.org/binaryinputstream;1"].
-               createInstance(Ci.nsIBinaryInputStream);
-  stream.setInputStream(fileStream);
-  let bytes = stream.readByteArray(stream.available());
-  fileStream.close();
-  return bytes;
-}
-
-/**
- * Creates a new zip file containing a file with the specified data
- * @param zipName The name of the zip file
- * @param data The data to go inside the zip for the filename entry1.info
- */
-function createNewZipFile(zipName, data) {
-   // Create a zip file which will be used for extracting
-    let stream = Cc["@mozilla.org/io/string-input-stream;1"].
-                 createInstance(Ci.nsIStringInputStream);
-    stream.setData(data, data.length);
-    let zipWriter = Cc["@mozilla.org/zipwriter;1"].
-                    createInstance(Components.interfaces.nsIZipWriter);
-    let zipFile = FileUtils.getFile("TmpD", [zipName]);
-    if (zipFile.exists()) {
-      zipFile.remove(false);
-    }
-    // From prio.h
-    const PR_RDWR = 0x04;
-    const PR_CREATE_FILE = 0x08;
-    const PR_TRUNCATE    = 0x20;
-    zipWriter.open(zipFile, PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE);
-    zipWriter.addEntryStream("entry1.info", Date.now(),
-                             Ci.nsIZipWriter.COMPRESSION_BEST, stream, false);
-    zipWriter.close();
-    stream.close();
-    do_print("zip file created on disk at: " + zipFile.path);
-    return zipFile;
-}
diff --git a/toolkit/modules/tests/xpcshell/xpcshell.ini b/toolkit/modules/tests/xpcshell/xpcshell.ini
index f2fa7e6..b919989 100644
--- a/toolkit/modules/tests/xpcshell/xpcshell.ini
+++ b/toolkit/modules/tests/xpcshell/xpcshell.ini
@@ -12,7 +12,6 @@ support-files =
 [test_DeferredTask.js]
 [test_dict.js]
 [test_FileUtils.js]
-[test_GMPInstallManager.js]
 [test_Http.js]
 [test_Log.js]
 [test_NewTabUtils.js]
diff --git a/toolkit/mozapps/extensions/content/extensions.js b/toolkit/mozapps/extensions/content/extensions.js
index a799eee..dbfe952 100644
--- a/toolkit/mozapps/extensions/content/extensions.js
+++ b/toolkit/mozapps/extensions/content/extensions.js
@@ -1038,7 +1038,7 @@ var gViewController = {
     cmd_showItemPreferences: {
       isEnabled: function cmd_showItemPreferences_isEnabled(aAddon) {
         if (!aAddon ||
-            (!aAddon.isActive && !aAddon.isGMPlugin) ||
+            (!aAddon.isActive) ||
             !aAddon.optionsURL) {
           return false;
         }
@@ -1927,11 +1927,7 @@ var gHeader = {
 
     // XXXunf Temporary until bug 371900 is fixed.
     let key = document.getElementById("focusSearch").getAttribute("key");
-#ifdef XP_MACOSX
-    let keyModifier = aEvent.metaKey;
-#else
     let keyModifier = aEvent.ctrlKey;
-#endif
     if (String.fromCharCode(aEvent.charCode) == key && keyModifier) {
       this.focusSearchBox();
       return;
@@ -2813,15 +2809,7 @@ var gDetailView = {
 
     var fullDesc = document.getElementById("detail-fulldesc");
     if (aAddon.fullDescription) {
-      // The following is part of an awful hack to include the licenses for GMP
-      // plugins without having bug 624602 fixed yet, and intentionally ignores
-      // localisation.
-      if (aAddon.isGMPlugin) {
-        fullDesc.innerHTML = aAddon.fullDescription;
-      } else {
-        fullDesc.textContent = aAddon.fullDescription;
-      }
-
+      fullDesc.textContent = aAddon.fullDescription;
       fullDesc.hidden = false;
     } else {
       fullDesc.hidden = true;
@@ -3127,13 +3115,6 @@ var gDetailView = {
         errorLink.value = gStrings.ext.GetStringFromName("details.notification.vulnerableNoUpdate.link");
         errorLink.href = this._addon.blocklistURL;
         errorLink.hidden = false;
-      } else if (this._addon.isGMPlugin && !this._addon.isInstalled &&
-                 this._addon.isActive) {
-        this.node.setAttribute("notification", "warning");
-        let warning = document.getElementById("detail-warning");
-        warning.textContent =
-          gStrings.ext.formatStringFromName("details.notification.gmpPending",
-                                            [this._addon.name], 1);
       } else {
         this.node.removeAttribute("notification");
       }
diff --git a/toolkit/mozapps/extensions/content/extensions.xml b/toolkit/mozapps/extensions/content/extensions.xml
index 9c15902..ddf4e6c 100644
--- a/toolkit/mozapps/extensions/content/extensions.xml
+++ b/toolkit/mozapps/extensions/content/extensions.xml
@@ -1362,12 +1362,6 @@
               this._errorLink.value = gStrings.ext.GetStringFromName("notification.vulnerableNoUpdate.link");
               this._errorLink.href = this.mAddon.blocklistURL;
               this._errorLink.hidden = false;
-            } else if (this.mAddon.isGMPlugin && !this.mAddon.isInstalled &&
-                       this.mAddon.isActive) {
-              this.setAttribute("notification", "warning");
-              this._warning.textContent =
-                gStrings.ext.formatStringFromName("notification.gmpPending",
-                                                  [this.mAddon.name], 1);
             } else {
               this.removeAttribute("notification");
               if (this.mAddon.type == "extension")
diff --git a/toolkit/mozapps/extensions/content/gmpPrefs.xul b/toolkit/mozapps/extensions/content/gmpPrefs.xul
deleted file mode 100644
index ea7ee92..0000000
--- a/toolkit/mozapps/extensions/content/gmpPrefs.xul
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0"?>
-
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this file,
-- You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-<!-- This is intentionally empty and a dummy to let the GMPProvider
-     have a preferences button in the list view. -->
diff --git a/toolkit/mozapps/extensions/extensions.manifest b/toolkit/mozapps/extensions/extensions.manifest
index f0f0054..1015a7a 100644
--- a/toolkit/mozapps/extensions/extensions.manifest
+++ b/toolkit/mozapps/extensions/extensions.manifest
@@ -16,5 +16,4 @@ category JavaScript-global-property InstallTrigger @mozilla.org/addons/installtr
 #ifndef MOZ_WIDGET_ANDROID
 category addon-provider-module PluginProvider resource://gre/modules/addons/PluginProvider.jsm
 #endif
-category addon-provider-module GMPProvider resource://gre/modules/addons/GMPProvider.jsm
 #endif
diff --git a/toolkit/mozapps/extensions/internal/GMPProvider.jsm b/toolkit/mozapps/extensions/internal/GMPProvider.jsm
deleted file mode 100644
index 1c94689..0000000
--- a/toolkit/mozapps/extensions/internal/GMPProvider.jsm
+++ /dev/null
@@ -1,606 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cu = Components.utils;
-
-this.EXPORTED_SYMBOLS = [];
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/AddonManager.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/Preferences.jsm");
-Cu.import("resource://gre/modules/osfile.jsm");
-Cu.import("resource://gre/modules/Log.jsm");
-Cu.import("resource://gre/modules/Task.jsm");
-Cu.import("resource://gre/modules/GMPUtils.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(
-  this, "GMPInstallManager", "resource://gre/modules/GMPInstallManager.jsm");
-XPCOMUtils.defineLazyModuleGetter(
-  this, "setTimeout", "resource://gre/modules/Timer.jsm");
-
-const URI_EXTENSION_STRINGS  = "chrome://mozapps/locale/extensions/extensions.properties";
-const STRING_TYPE_NAME       = "type.%ID%.name";
-
-const SEC_IN_A_DAY           = 24 * 60 * 60;
-// How long to wait after a user enabled EME before attempting to download CDMs.
-const GMP_CHECK_DELAY        = 10 * 1000; // milliseconds
-
-const NS_GRE_DIR             = "GreD";
-const CLEARKEY_PLUGIN_ID     = "gmp-clearkey";
-const CLEARKEY_VERSION       = "0.1";
-
-const GMP_LICENSE_INFO       = "gmp_license_info";
-
-const GMP_PLUGINS = [
-  {
-    id:              OPEN_H264_ID,
-    name:            "openH264_name",
-    description:     "openH264_description",
-    // The following licenseURL is part of an awful hack to include the OpenH264
-    // license without having bug 624602 fixed yet, and intentionally ignores
-    // localisation.
-    licenseURL:      "chrome://mozapps/content/extensions/OpenH264-license.txt",
-    homepageURL:     "http://www.openh264.org/",
-    optionsURL:      "chrome://mozapps/content/extensions/gmpPrefs.xul"
-  },
-  {
-    id:              EME_ADOBE_ID,
-    name:            "eme-adobe_name",
-    description:     "eme-adobe_description",
-    licenseURL:      "http://help.adobe.com/en_US/primetime/drm/HTML5_CDM_EULA/index.html",
-    homepageURL:     "http://help.adobe.com/en_US/primetime/drm/HTML5_CDM",
-    optionsURL:      "chrome://mozapps/content/extensions/gmpPrefs.xul",
-    isEME:           true
-  }];
-
-XPCOMUtils.defineLazyGetter(this, "pluginsBundle",
-  () => Services.strings.createBundle("chrome://global/locale/plugins.properties"));
-XPCOMUtils.defineLazyGetter(this, "gmpService",
-  () => Cc["@mozilla.org/goanna-media-plugin-service;1"].getService(Ci.mozIGoannaMediaPluginService));
-
-let messageManager = Cc["@mozilla.org/globalmessagemanager;1"]
-                       .getService(Ci.nsIMessageListenerManager);
-
-let gLogger;
-let gLogAppenderDump = null;
-
-function configureLogging() {
-  if (!gLogger) {
-    gLogger = Log.repository.getLogger("Toolkit.GMP");
-    gLogger.addAppender(new Log.ConsoleAppender(new Log.BasicFormatter()));
-  }
-  gLogger.level = GMPPrefs.get(GMPPrefs.KEY_LOGGING_LEVEL, Log.Level.Warn);
-
-  let logDumping = GMPPrefs.get(GMPPrefs.KEY_LOGGING_DUMP, false);
-  if (logDumping != !!gLogAppenderDump) {
-    if (logDumping) {
-      gLogAppenderDump = new Log.DumpAppender(new Log.BasicFormatter());
-      gLogger.addAppender(gLogAppenderDump);
-    } else {
-      gLogger.removeAppender(gLogAppenderDump);
-      gLogAppenderDump = null;
-    }
-  }
-}
-
-
-
-/**
- * The GMPWrapper provides the info for the various GMP plugins to public
- * callers through the API.
- */
-function GMPWrapper(aPluginInfo) {
-  this._plugin = aPluginInfo;
-  this._log =
-    Log.repository.getLoggerWithMessagePrefix("Toolkit.GMP",
-                                              "GMPWrapper(" +
-                                              this._plugin.id + ") ");
-  Preferences.observe(GMPPrefs.getPrefKey(GMPPrefs.KEY_PLUGIN_ENABLED,
-                                          this._plugin.id),
-                      this.onPrefEnabledChanged, this);
-  Preferences.observe(GMPPrefs.getPrefKey(GMPPrefs.KEY_PLUGIN_VERSION,
-                                          this._plugin.id),
-                      this.onPrefVersionChanged, this);
-  if (this._plugin.isEME) {
-    Preferences.observe(GMPPrefs.KEY_EME_ENABLED,
-                        this.onPrefEMEGlobalEnabledChanged, this);
-    messageManager.addMessageListener("EMEVideo:ContentMediaKeysRequest", this);
-  }
-}
-
-GMPWrapper.prototype = {
-  // An active task that checks for plugin updates and installs them.
-  _updateTask: null,
-  _gmpPath: null,
-  _isUpdateCheckPending: false,
-
-  optionsType: AddonManager.OPTIONS_TYPE_INLINE,
-  get optionsURL() { return this._plugin.optionsURL; },
-
-  set gmpPath(aPath) { this._gmpPath = aPath; },
-  get gmpPath() {
-    if (!this._gmpPath && this.isInstalled) {
-      this._gmpPath = OS.Path.join(OS.Constants.Path.profileDir,
-                                   this._plugin.id,
-                                   GMPPrefs.get(GMPPrefs.KEY_PLUGIN_VERSION,
-                                                null, this._plugin.id));
-    }
-    return this._gmpPath;
-  },
-
-  get id() { return this._plugin.id; },
-  get type() { return "plugin"; },
-  get isGMPlugin() { return true; },
-  get name() { return this._plugin.name; },
-  get creator() { return null; },
-  get homepageURL() { return this._plugin.homepageURL; },
-
-  get description() { return this._plugin.description; },
-  get fullDescription() { return this._plugin.fullDescription; },
-
-  get version() { return GMPPrefs.get(GMPPrefs.KEY_PLUGIN_VERSION, null,
-                                      this._plugin.id); },
-
-  get isActive() { return !this.appDisabled && !this.userDisabled; },
-  get appDisabled() {
-    if (this._plugin.isEME && !GMPPrefs.get(GMPPrefs.KEY_EME_ENABLED, true)) {
-      // If "media.eme.enabled" is false, all EME plugins are disabled.
-      return true;
-    }
-   return false;
-  },
-
-  get userDisabled() {
-    return !GMPPrefs.get(GMPPrefs.KEY_PLUGIN_ENABLED, true, this._plugin.id);
-  },
-  set userDisabled(aVal) { GMPPrefs.set(GMPPrefs.KEY_PLUGIN_ENABLED,
-                                        aVal === false,
-                                        this._plugin.id); },
-
-  get blocklistState() { return Ci.nsIBlocklistService.STATE_NOT_BLOCKED; },
-  get size() { return 0; },
-  get scope() { return AddonManager.SCOPE_APPLICATION; },
-  get pendingOperations() { return AddonManager.PENDING_NONE; },
-
-  get operationsRequiringRestart() { return AddonManager.OP_NEEDS_RESTART_NONE },
-
-  get permissions() {
-    let permissions = 0;
-    if (!this.appDisabled) {
-      permissions |= AddonManager.PERM_CAN_UPGRADE;
-      permissions |= this.userDisabled ? AddonManager.PERM_CAN_ENABLE :
-                                         AddonManager.PERM_CAN_DISABLE;
-    }
-    return permissions;
-  },
-
-  get updateDate() {
-    let time = Number(GMPPrefs.get(GMPPrefs.KEY_PLUGIN_LAST_UPDATE, null,
-                                   this._plugin.id));
-    if (time !== NaN && this.isInstalled) {
-      return new Date(time * 1000)
-    }
-    return null;
-  },
-
-  get isCompatible() {
-    return true;
-  },
-
-  get isPlatformCompatible() {
-    return true;
-  },
-
-  get providesUpdatesSecurely() {
-    return true;
-  },
-
-  get foreignInstall() {
-    return false;
-  },
-
-  isCompatibleWith: function(aAppVersion, aPlatformVersion) {
-    return true;
-  },
-
-  get applyBackgroundUpdates() {
-    if (!GMPPrefs.isSet(GMPPrefs.KEY_PLUGIN_AUTOUPDATE, this._plugin.id)) {
-      return AddonManager.AUTOUPDATE_DEFAULT;
-    }
-
-    return GMPPrefs.get(GMPPrefs.KEY_PLUGIN_AUTOUPDATE, true, this._plugin.id) ?
-      AddonManager.AUTOUPDATE_ENABLE : AddonManager.AUTOUPDATE_DISABLE;
-  },
-
-  set applyBackgroundUpdates(aVal) {
-    if (aVal == AddonManager.AUTOUPDATE_DEFAULT) {
-      GMPPrefs.reset(GMPPrefs.KEY_PLUGIN_AUTOUPDATE, this._plugin.id);
-    } else if (aVal == AddonManager.AUTOUPDATE_ENABLE) {
-      GMPPrefs.set(GMPPrefs.KEY_PLUGIN_AUTOUPDATE, true, this._plugin.id);
-    } else if (aVal == AddonManager.AUTOUPDATE_DISABLE) {
-      GMPPrefs.set(GMPPrefs.KEY_PLUGIN_AUTOUPDATE, false, this._plugin.id);
-    }
-  },
-
-  findUpdates: function(aListener, aReason, aAppVersion, aPlatformVersion) {
-    this._log.trace("findUpdates() - " + this._plugin.id + " - reason=" +
-                    aReason);
-
-    AddonManagerPrivate.callNoUpdateListeners(this, aListener);
-
-    if (aReason === AddonManager.UPDATE_WHEN_PERIODIC_UPDATE) {
-      if (!AddonManager.shouldAutoUpdate(this)) {
-        this._log.trace("findUpdates() - " + this._plugin.id +
-                        " - no autoupdate");
-        return Promise.resolve(false);
-      }
-
-      let secSinceLastCheck =
-        Date.now() / 1000 - Preferences.get(GMPPrefs.KEY_UPDATE_LAST_CHECK, 0);
-      if (secSinceLastCheck <= SEC_IN_A_DAY) {
-        this._log.trace("findUpdates() - " + this._plugin.id +
-                        " - last check was less then a day ago");
-        return Promise.resolve(false);
-      }
-    } else if (aReason !== AddonManager.UPDATE_WHEN_USER_REQUESTED) {
-      this._log.trace("findUpdates() - " + this._plugin.id +
-                      " - the given reason to update is not supported");
-      return Promise.resolve(false);
-    }
-
-    if (this._updateTask !== null) {
-      this._log.trace("findUpdates() - " + this._plugin.id +
-                      " - update task already running");
-      return this._updateTask;
-    }
-
-    this._updateTask = Task.spawn(function* GMPProvider_updateTask() {
-      this._log.trace("findUpdates() - updateTask");
-      try {
-        let installManager = new GMPInstallManager();
-        let gmpAddons = yield installManager.checkForAddons();
-        let update = gmpAddons.find(function(aAddon) {
-          return aAddon.id === this._plugin.id;
-        }, this);
-        if (update && update.isValid && !update.isInstalled) {
-          this._log.trace("findUpdates() - found update for " +
-                          this._plugin.id + ", installing");
-          yield installManager.installAddon(update);
-        } else {
-          this._log.trace("findUpdates() - no updates for " + this._plugin.id);
-        }
-        this._log.info("findUpdates() - updateTask succeeded for " +
-                       this._plugin.id);
-      } catch (e) {
-        this._log.error("findUpdates() - updateTask for " + this._plugin.id +
-                        " threw", e);
-        throw e;
-      } finally {
-        this._updateTask = null;
-        return true;
-      }
-    }.bind(this));
-
-    return this._updateTask;
-  },
-
-  get pluginMimeTypes() { return []; },
-  get pluginLibraries() {
-    if (this.isInstalled) {
-      let path = this.version;
-      return [path];
-    }
-    return [];
-  },
-  get pluginFullpath() {
-    if (this.isInstalled) {
-      let path = OS.Path.join(OS.Constants.Path.profileDir,
-                              this._plugin.id,
-                              this.version);
-      return [path];
-    }
-    return [];
-  },
-
-  get isInstalled() {
-    return this.version && this.version.length > 0;
-  },
-
-  _handleEnabledChanged: function() {
-    AddonManagerPrivate.callAddonListeners(this.isActive ?
-                                           "onEnabling" : "onDisabling",
-                                           this, false);
-    if (this._gmpPath) {
-      if (this.isActive) {
-        this._log.info("onPrefEnabledChanged() - adding gmp directory " +
-                       this._gmpPath);
-        gmpService.addPluginDirectory(this._gmpPath);
-      } else {
-        this._log.info("onPrefEnabledChanged() - removing gmp directory " +
-                       this._gmpPath);
-        gmpService.removePluginDirectory(this._gmpPath);
-      }
-    }
-    AddonManagerPrivate.callAddonListeners(this.isActive ?
-                                           "onEnabled" : "onDisabled",
-                                           this);
-  },
-
-  onPrefEMEGlobalEnabledChanged: function() {
-    AddonManagerPrivate.callAddonListeners("onPropertyChanged", this,
-                                           ["appDisabled"]);
-    if (this.appDisabled) {
-      this.uninstallPlugin();
-    } else {
-      AddonManagerPrivate.callInstallListeners("onExternalInstall", null, this,
-                                               null, false);
-      AddonManagerPrivate.callAddonListeners("onInstalling", this, false);
-      AddonManagerPrivate.callAddonListeners("onInstalled", this);
-      this.checkForUpdates(GMP_CHECK_DELAY);
-    }
-    if (!this.userDisabled) {
-      this._handleEnabledChanged();
-    }
-  },
-
-  checkForUpdates: function(delay) {
-    if (this._isUpdateCheckPending) {
-      return;
-    }
-    this._isUpdateCheckPending = true;
-    GMPPrefs.reset(GMPPrefs.KEY_UPDATE_LAST_CHECK, null);
-    // Delay this in case the user changes his mind and doesn't want to
-    // enable EME after all.
-    setTimeout(() => {
-      if (!this.appDisabled) {
-        let gmpInstallManager = new GMPInstallManager();
-        // We don't really care about the results, if someone is interested
-        // they can check the log.
-        gmpInstallManager.simpleCheckAndInstall().then(null, () => {});
-      }
-      this._isUpdateCheckPending = false;
-    }, delay);
-  },
-
-  receiveMessage: function({target: browser, data: data}) {
-    this._log.trace("receiveMessage() data=" + data);
-    let parsedData;
-    try {
-      parsedData = JSON.parse(data);
-    } catch(ex) {
-      this._log.error("Malformed EME video message with data: " + data);
-      return;
-    }
-    let {status: status, keySystem: keySystem} = parsedData;
-    if (status == "cdm-not-installed" || status == "cdm-insufficient-version") {
-      this.checkForUpdates(0);
-    }
-  },
-
-  onPrefEnabledChanged: function() {
-    if (!this._plugin.isEME || !this.appDisabled) {
-      this._handleEnabledChanged();
-    }
-  },
-
-  onPrefVersionChanged: function() {
-    AddonManagerPrivate.callAddonListeners("onUninstalling", this, false);
-    if (this._gmpPath) {
-      this._log.info("onPrefVersionChanged() - unregistering gmp directory " +
-                     this._gmpPath);
-      gmpService.removeAndDeletePluginDirectory(this._gmpPath, true /* can defer */);
-    }
-    AddonManagerPrivate.callAddonListeners("onUninstalled", this);
-
-    AddonManagerPrivate.callInstallListeners("onExternalInstall", null, this,
-                                             null, false);
-    AddonManagerPrivate.callAddonListeners("onInstalling", this, false);
-    this._gmpPath = null;
-    if (this.isInstalled) {
-      this._gmpPath = OS.Path.join(OS.Constants.Path.profileDir,
-                                   this._plugin.id,
-                                   GMPPrefs.get(GMPPrefs.KEY_PLUGIN_VERSION,
-                                                null, this._plugin.id));
-    }
-    if (this._gmpPath && this.isActive) {
-      this._log.info("onPrefVersionChanged() - registering gmp directory " +
-                     this._gmpPath);
-      gmpService.addPluginDirectory(this._gmpPath);
-    }
-    AddonManagerPrivate.callAddonListeners("onInstalled", this);
-  },
-
-  uninstallPlugin: function() {
-    AddonManagerPrivate.callAddonListeners("onUninstalling", this, false);
-    if (this.gmpPath) {
-      this._log.info("uninstallPlugin() - unregistering gmp directory " +
-                     this.gmpPath);
-      gmpService.removeAndDeletePluginDirectory(this.gmpPath);
-    }
-    GMPPrefs.reset(GMPPrefs.KEY_PLUGIN_VERSION, this.id);
-    AddonManagerPrivate.callAddonListeners("onUninstalled", this);
-  },
-
-  shutdown: function() {
-    Preferences.ignore(GMPPrefs.getPrefKey(GMPPrefs.KEY_PLUGIN_ENABLED,
-                                           this._plugin.id),
-                       this.onPrefEnabledChanged, this);
-    Preferences.ignore(GMPPrefs.getPrefKey(GMPPrefs.KEY_PLUGIN_VERSION,
-                                           this._plugin.id),
-                       this.onPrefVersionChanged, this);
-    if (this._plugin.isEME) {
-      Preferences.ignore(GMPPrefs.KEY_EME_ENABLED,
-                         this.onPrefEMEGlobalEnabledChanged, this);
-      messageManager.removeMessageListener("EMEVideo:ContentMediaKeysRequest", this);
-    }
-    return this._updateTask;
-  },
-};
-
-let GMPProvider = {
-  get name() { return "GMPProvider"; },
-
-  _plugins: null,
-
-  startup: function() {
-    configureLogging();
-    this._log = Log.repository.getLoggerWithMessagePrefix("Toolkit.GMP",
-                                                          "GMPProvider.");
-    let telemetry = {};
-    this.buildPluginList();
-    this.ensureProperCDMInstallState();
-
-    Preferences.observe(GMPPrefs.KEY_LOG_BASE, configureLogging);
-
-    for (let [id, plugin] of this._plugins) {
-      let wrapper = plugin.wrapper;
-      let gmpPath = wrapper.gmpPath;
-      let isEnabled = wrapper.isActive;
-      this._log.trace("startup - enabled=" + isEnabled + ", gmpPath=" +
-                      gmpPath);
-
-      if (gmpPath && isEnabled) {
-        this._log.info("startup - adding gmp directory " + gmpPath);
-        try {
-          gmpService.addPluginDirectory(gmpPath);
-        } catch (e if e.name == 'NS_ERROR_NOT_AVAILABLE') {
-          this._log.warn("startup - adding gmp directory failed with " +
-                         e.name + " - sandboxing not available?", e);
-        }
-      }
-
-      if (this.isEnabled) {
-        telemetry[id] = {
-          userDisabled: wrapper.userDisabled,
-          version: wrapper.version,
-          applyBackgroundUpdates: wrapper.applyBackgroundUpdates,
-        };
-      }
-    }
-
-    if (Preferences.get(GMPPrefs.KEY_EME_ENABLED, false)) {
-      try {
-        let greDir = Services.dirsvc.get(NS_GRE_DIR,
-                                         Ci.nsILocalFile);
-        let clearkeyPath = OS.Path.join(greDir.path,
-                                        CLEARKEY_PLUGIN_ID,
-                                        CLEARKEY_VERSION);
-        this._log.info("startup - adding clearkey CDM directory " +
-                       clearkeyPath);
-        gmpService.addPluginDirectory(clearkeyPath);
-      } catch (e) {
-        this._log.warn("startup - adding clearkey CDM failed", e);
-      }
-    }
-
-    AddonManagerPrivate.setTelemetryDetails("GMP", telemetry);
-  },
-
-  shutdown: function() {
-    this._log.trace("shutdown");
-    Preferences.ignore(GMPPrefs.KEY_LOG_BASE, configureLogging);
-
-    let shutdownTask = Task.spawn(function* GMPProvider_shutdownTask() {
-      this._log.trace("shutdown - shutdownTask");
-      let shutdownSucceeded = true;
-
-      for (let plugin of this._plugins.values()) {
-        try {
-          yield plugin.wrapper.shutdown();
-        } catch (e) {
-          shutdownSucceeded = false;
-        }
-      }
-
-      this._plugins = null;
-
-      if (!shutdownSucceeded) {
-        throw new Error("Shutdown failed");
-      }
-    }.bind(this));
-
-    return shutdownTask;
-  },
-
-  getAddonByID: function(aId, aCallback) {
-    if (!this.isEnabled) {
-      aCallback(null);
-      return;
-    }
-
-    let plugin = this._plugins.get(aId);
-    if (plugin && !GMPUtils.isPluginHidden(plugin)) {
-      aCallback(plugin.wrapper);
-    } else {
-      aCallback(null);
-    }
-  },
-
-  getAddonsByTypes: function(aTypes, aCallback) {
-    if (!this.isEnabled ||
-        (aTypes && aTypes.indexOf("plugin") < 0)) {
-      aCallback([]);
-      return;
-    }
-
-    let results = [p.wrapper for ([id, p] of this._plugins)
-                    if (!GMPUtils.isPluginHidden(p))];
-    aCallback(results);
-  },
-
-  get isEnabled() {
-    return GMPPrefs.get(GMPPrefs.KEY_PROVIDER_ENABLED, false);
-  },
-
-  generateFullDescription: function(aLicenseURL, aLicenseInfo) {
-    return "<xhtml:a href=\"" + aLicenseURL + "\" target=\"_blank\">" +
-           aLicenseInfo + "</xhtml:a>."
-  },
-
-  buildPluginList: function() {
-    let licenseInfo = pluginsBundle.GetStringFromName(GMP_LICENSE_INFO);
-
-    this._plugins = new Map();
-    for (let aPlugin of GMP_PLUGINS) {
-      let plugin = {
-        id: aPlugin.id,
-        name: pluginsBundle.GetStringFromName(aPlugin.name),
-        description: pluginsBundle.GetStringFromName(aPlugin.description),
-        homepageURL: aPlugin.homepageURL,
-        optionsURL: aPlugin.optionsURL,
-        wrapper: null,
-        isEME: aPlugin.isEME,
-      };
-      if (aPlugin.licenseURL) {
-        plugin.fullDescription =
-          this.generateFullDescription(aPlugin.licenseURL, licenseInfo);
-      }
-      plugin.wrapper = new GMPWrapper(plugin);
-      this._plugins.set(plugin.id, plugin);
-    }
-  },
-
-  ensureProperCDMInstallState: function() {
-    if (!GMPPrefs.get(GMPPrefs.KEY_EME_ENABLED, true)) {
-      for (let [id, plugin] of this._plugins) {
-        if (plugin.isEME && plugin.wrapper.isInstalled) {
-          gmpService.addPluginDirectory(plugin.wrapper.gmpPath);
-          plugin.wrapper.uninstallPlugin();
-        }
-      }
-    }
-  },
-};
-
-AddonManagerPrivate.registerProvider(GMPProvider, [
-  new AddonManagerPrivate.AddonType("plugin", URI_EXTENSION_STRINGS,
-                                    STRING_TYPE_NAME,
-                                    AddonManager.VIEW_TYPE_LIST, 6000,
-                                    AddonManager.TYPE_SUPPORTS_ASK_TO_ACTIVATE)
-]);
diff --git a/toolkit/mozapps/extensions/internal/moz.build b/toolkit/mozapps/extensions/internal/moz.build
index 96ee985..8e197dc 100644
--- a/toolkit/mozapps/extensions/internal/moz.build
+++ b/toolkit/mozapps/extensions/internal/moz.build
@@ -8,7 +8,6 @@ EXTRA_JS_MODULES.addons += [
     'AddonLogging.jsm',
     'AddonRepository_SQLiteMigrator.jsm',
     'Content.js',
-    'GMPProvider.jsm',
     'LightweightThemeImageOptimizer.jsm',
     'SpellCheckDictionaryBootstrap.js',
 ]
diff --git a/toolkit/mozapps/extensions/jar.mn b/toolkit/mozapps/extensions/jar.mn
index e95d93c..70aa15c 100644
--- a/toolkit/mozapps/extensions/jar.mn
+++ b/toolkit/mozapps/extensions/jar.mn
@@ -29,8 +29,6 @@ toolkit.jar:
   content/mozapps/extensions/newaddon.js                        (content/newaddon.js)
   content/mozapps/extensions/setting.xml                        (content/setting.xml)
   content/mozapps/extensions/pluginPrefs.xul                    (content/pluginPrefs.xul)
-  content/mozapps/extensions/gmpPrefs.xul                       (content/gmpPrefs.xul)
-  content/mozapps/extensions/OpenH264-license.txt               (content/OpenH264-license.txt)
   content/mozapps/xpinstall/xpinstallConfirm.xul                (content/xpinstallConfirm.xul)
   content/mozapps/xpinstall/xpinstallConfirm.js                 (content/xpinstallConfirm.js)
   content/mozapps/xpinstall/xpinstallConfirm.css                (content/xpinstallConfirm.css)
diff --git a/toolkit/mozapps/extensions/test/browser/browser.ini b/toolkit/mozapps/extensions/test/browser/browser.ini
index dc6f86b..82c834b 100644
--- a/toolkit/mozapps/extensions/test/browser/browser.ini
+++ b/toolkit/mozapps/extensions/test/browser/browser.ini
@@ -38,7 +38,6 @@ skip-if = e10s
 [browser_bug616841.js]
 [browser_cancelCompatCheck.js]
 [browser_checkAddonCompatibility.js]
-[browser_gmpProvider.js]
 [browser_installssl.js]
 [browser_newaddon.js]
 skip-if = e10s
diff --git a/toolkit/mozapps/extensions/test/browser/browser_gmpProvider.js b/toolkit/mozapps/extensions/test/browser/browser_gmpProvider.js
deleted file mode 100644
index 1813df7..0000000
--- a/toolkit/mozapps/extensions/test/browser/browser_gmpProvider.js
+++ /dev/null
@@ -1,401 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
- * http://creativecommons.org/publicdomain/zero/1.0/
- */
-
-"use strict";
-
-Cu.import("resource://gre/modules/Promise.jsm");
-let {AddonTestUtils} = Cu.import("resource://testing-common/AddonManagerTesting.jsm", {});
-let GMPScope = Cu.import("resource://gre/modules/addons/GMPProvider.jsm");
-
-const TEST_DATE = new Date(2013, 0, 1, 12);
-
-let gManagerWindow;
-let gCategoryUtilities;
-let gIsEnUsLocale;
-
-let gMockAddons = [];
-
-for (let plugin of GMPScope.GMP_PLUGINS) {
-  let mockAddon = Object.freeze({
-      id: plugin.id,
-      isValid: true,
-      isInstalled: false,
-      isEME: plugin.id.indexOf("gmp-eme-") == 0 ? true : false,
-  });
-  gMockAddons.push(mockAddon);
-}
-
-let gInstalledAddonId = "";
-let gInstallDeferred = null;
-let gPrefs = Services.prefs;
-let getKey = GMPScope.GMPPrefs.getPrefKey;
-
-function MockGMPInstallManager() {
-}
-
-MockGMPInstallManager.prototype = {
-  checkForAddons: () => Promise.resolve(gMockAddons),
-
-  installAddon: addon => {
-    gInstalledAddonId = addon.id;
-    gInstallDeferred.resolve();
-    return Promise.resolve();
-  },
-};
-
-let gOptionsObserver = {
-  lastDisplayed: null,
-  observe: function(aSubject, aTopic, aData) {
-    if (aTopic == AddonManager.OPTIONS_NOTIFICATION_DISPLAYED) {
-      this.lastDisplayed = aData;
-    }
-  }
-};
-
-function getInstallItem() {
-  let doc = gManagerWindow.document;
-  let list = doc.getElementById("addon-list");
-
-  let node = list.firstChild;
-  while (node) {
-    if (node.getAttribute("status") == "installing") {
-      return node;
-    }
-    node = node.nextSibling;
-  }
-
-  return null;
-}
-
-function openDetailsView(aId) {
-  let item = get_addon_element(gManagerWindow, aId);
-  Assert.ok(item, "Should have got add-on element.");
-  is_element_visible(item, "Add-on element should be visible.");
-
-  EventUtils.synthesizeMouseAtCenter(item, { clickCount: 1 }, gManagerWindow);
-  EventUtils.synthesizeMouseAtCenter(item, { clickCount: 2 }, gManagerWindow);
-
-  let deferred = Promise.defer();
-  wait_for_view_load(gManagerWindow, deferred.resolve);
-  return deferred.promise;
-}
-
-add_task(function* initializeState() {
-  gPrefs.setBoolPref(GMPScope.GMPPrefs.KEY_LOGGING_DUMP, true);
-  gPrefs.setIntPref(GMPScope.GMPPrefs.KEY_LOGGING_LEVEL, 0);
-
-  gManagerWindow = yield open_manager();
-  gCategoryUtilities = new CategoryUtilities(gManagerWindow);
-
-  registerCleanupFunction(Task.async(function*() {
-    Services.obs.removeObserver(gOptionsObserver, AddonManager.OPTIONS_NOTIFICATION_DISPLAYED);
-
-    for (let addon of gMockAddons) {
-      gPrefs.clearUserPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_ENABLED, addon.id));
-      gPrefs.clearUserPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_LAST_UPDATE, addon.id));
-      gPrefs.clearUserPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_AUTOUPDATE, addon.id));
-      gPrefs.clearUserPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, addon.id));
-      gPrefs.clearUserPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_FORCEVISIBLE, addon.id));
-    }
-    gPrefs.clearUserPref(GMPScope.GMPPrefs.KEY_LOGGING_DUMP);
-    gPrefs.clearUserPref(GMPScope.GMPPrefs.KEY_LOGGING_LEVEL);
-    gPrefs.clearUserPref(GMPScope.GMPPrefs.KEY_UPDATE_LAST_CHECK);
-    gPrefs.clearUserPref(GMPScope.GMPPrefs.KEY_EME_ENABLED);
-    yield GMPScope.GMPProvider.shutdown();
-    GMPScope.GMPProvider.startup();
-  }));
-
-  let chrome = Cc["@mozilla.org/chrome/chrome-registry;1"].getService(Ci.nsIXULChromeRegistry);
-  gIsEnUsLocale = chrome.getSelectedLocale("global") == "en-US";
-
-  Services.obs.addObserver(gOptionsObserver, AddonManager.OPTIONS_NOTIFICATION_DISPLAYED, false);
-
-  // Start out with plugins not being installed, disabled and automatic updates
-  // disabled.
-  gPrefs.setBoolPref(GMPScope.GMPPrefs.KEY_EME_ENABLED, true);
-  for (let addon of gMockAddons) {
-    gPrefs.setBoolPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_ENABLED, addon.id), false);
-    gPrefs.setIntPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_LAST_UPDATE, addon.id), 0);
-    gPrefs.setBoolPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_AUTOUPDATE, addon.id), false);
-    gPrefs.setCharPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, addon.id), "");
-    gPrefs.setBoolPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_FORCEVISIBLE, addon.id),
-                       true);
-  }
-  yield GMPScope.GMPProvider.shutdown();
-  GMPScope.GMPProvider.startup();
-});
-
-add_task(function* testNotInstalledDisabled() {
-  Assert.ok(gCategoryUtilities.isTypeVisible("plugin"), "Plugin tab visible.");
-  yield gCategoryUtilities.openType("plugin");
-
-  for (let addon of gMockAddons) {
-    let item = get_addon_element(gManagerWindow, addon.id);
-    Assert.ok(item, "Got add-on element:" + addon.id);
-    item.parentNode.ensureElementIsVisible(item);
-    is(item.getAttribute("active"), "false");
-
-    let el = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "warning");
-    is_element_hidden(el, "Warning notification is hidden.");
-    el = item.ownerDocument.getAnonymousElementByAttribute(item, "class", "disabled-postfix");
-    is_element_visible(el, "disabled-postfix is visible.");
-    el = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "disable-btn");
-    is_element_hidden(el, "Disable button not visible.");
-    el = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "enable-btn");
-    is_element_hidden(el, "Enable button not visible.");
-
-    let menu = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "state-menulist");
-    is_element_visible(menu, "State menu should be visible.");
-
-    let neverActivate = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "never-activate-menuitem");
-    is(menu.selectedItem, neverActivate, "Plugin state should be never-activate.");
-  }
-});
-
-add_task(function* testNotInstalledDisabledDetails() {
-  for (let addon of gMockAddons) {
-    yield openDetailsView(addon.id);
-    let doc = gManagerWindow.document;
-
-    let el = doc.getElementsByClassName("disabled-postfix")[0];
-    is_element_visible(el, "disabled-postfix is visible.");
-    el = doc.getElementById("detail-findUpdates-btn");
-    is_element_visible(el, "Find updates link is visible.");
-    el = doc.getElementById("detail-warning");
-    is_element_hidden(el, "Warning notification is hidden.");
-    el = doc.getElementsByTagName("setting")[0];
-  }
-});
-
-add_task(function* testNotInstalled() {
-  Assert.ok(gCategoryUtilities.isTypeVisible("plugin"), "Plugin tab visible.");
-  yield gCategoryUtilities.openType("plugin");
-
-  for (let addon of gMockAddons) {
-    gPrefs.setBoolPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_ENABLED, addon.id), true);
-    let item = get_addon_element(gManagerWindow, addon.id);
-    Assert.ok(item, "Got add-on element:" + addon.id);
-    item.parentNode.ensureElementIsVisible(item);
-    is(item.getAttribute("active"), "true");
-
-    let el = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "warning");
-    is_element_visible(el, "Warning notification is visible.");
-    el = item.ownerDocument.getAnonymousElementByAttribute(item, "class", "disabled-postfix");
-    is_element_hidden(el, "disabled-postfix is hidden.");
-    el = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "disable-btn");
-    is_element_hidden(el, "Disable button not visible.");
-    el = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "enable-btn");
-    is_element_hidden(el, "Enable button not visible.");
-
-    let menu = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "state-menulist");
-    is_element_visible(menu, "State menu should be visible.");
-
-    let alwaysActivate = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "always-activate-menuitem");
-    is(menu.selectedItem, alwaysActivate, "Plugin state should be always-activate.");
-  }
-});
-
-add_task(function* testNotInstalledDetails() {
-  for (let addon of gMockAddons) {
-    yield openDetailsView(addon.id);
-    let doc = gManagerWindow.document;
-
-    let el = doc.getElementsByClassName("disabled-postfix")[0];
-    is_element_hidden(el, "disabled-postfix is hidden.");
-    el = doc.getElementById("detail-findUpdates-btn");
-    is_element_visible(el, "Find updates link is visible.");
-    el = doc.getElementById("detail-warning");
-    is_element_visible(el, "Warning notification is visible.");
-    el = doc.getElementsByTagName("setting")[0];
-  }
-});
-
-add_task(function* testInstalled() {
-  for (let addon of gMockAddons) {
-    gPrefs.setIntPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_LAST_UPDATE, addon.id),
-                      TEST_DATE.getTime());
-    gPrefs.setBoolPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_AUTOUPDATE, addon.id), false);
-    gPrefs.setCharPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, addon.id), "1.2.3.4");
-
-    yield gCategoryUtilities.openType("plugin");
-
-    let item = get_addon_element(gManagerWindow, addon.id);
-    Assert.ok(item, "Got add-on element.");
-    item.parentNode.ensureElementIsVisible(item);
-    is(item.getAttribute("active"), "true");
-
-    let el = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "warning");
-    is_element_hidden(el, "Warning notification is hidden.");
-    el = item.ownerDocument.getAnonymousElementByAttribute(item, "class", "disabled-postfix");
-    is_element_hidden(el, "disabled-postfix is hidden.");
-    el = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "disable-btn");
-    is_element_hidden(el, "Disable button not visible.");
-    el = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "enable-btn");
-    is_element_hidden(el, "Enable button not visible.");
-
-    let menu = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "state-menulist");
-    is_element_visible(menu, "State menu should be visible.");
-
-    let alwaysActivate = item.ownerDocument.getAnonymousElementByAttribute(item, "anonid", "always-activate-menuitem");
-    is(menu.selectedItem, alwaysActivate, "Plugin state should be always-activate.");
-  }
-});
-
-add_task(function* testInstalledDetails() {
-  for (let addon of gMockAddons) {
-    yield openDetailsView(addon.id);
-    let doc = gManagerWindow.document;
-
-    let el = doc.getElementsByClassName("disabled-postfix")[0];
-    is_element_hidden(el, "disabled-postfix is hidden.");
-    el = doc.getElementById("detail-findUpdates-btn");
-    is_element_visible(el, "Find updates link is visible.");
-    el = doc.getElementById("detail-warning");
-    is_element_hidden(el, "Warning notification is hidden.");
-    el = doc.getElementsByTagName("setting")[0];
-
-    let contextMenu = doc.getElementById("addonitem-popup");
-    let deferred = Promise.defer();
-    let listener = () => {
-      contextMenu.removeEventListener("popupshown", listener, false);
-      deferred.resolve();
-    };
-    contextMenu.addEventListener("popupshown", listener, false);
-    el = doc.getElementsByClassName("detail-view-container")[0];
-    EventUtils.synthesizeMouse(el, 4, 4, { }, gManagerWindow);
-    EventUtils.synthesizeMouse(el, 4, 4, { type: "contextmenu", button: 2 }, gManagerWindow);
-    yield deferred.promise;
-    let menuSep = doc.getElementById("addonitem-menuseparator");
-    is_element_hidden(menuSep, "Menu separator is hidden.");
-    contextMenu.hidePopup();
-  }
-});
-
-add_task(function* testInstalledGlobalEmeDisabled() {
-  gPrefs.setBoolPref(GMPScope.GMPPrefs.KEY_EME_ENABLED, false);
-  for (let addon of gMockAddons) {
-    yield gCategoryUtilities.openType("plugin");
-
-    let item = get_addon_element(gManagerWindow, addon.id);
-    if (addon.isEME) {
-      Assert.ok(!item, "Couldn't get add-on element.");
-    } else {
-      Assert.ok(item, "Got add-on element.");
-    }
-  }
-  gPrefs.setBoolPref(GMPScope.GMPPrefs.KEY_EME_ENABLED, true);
-});
-
-add_task(function* testPreferencesButton() {
-
-  let prefValues = [
-    { enabled: false, version: "" },
-    { enabled: false, version: "1.2.3.4" },
-    { enabled: true, version: "" },
-    { enabled: true, version: "1.2.3.4" },
-  ];
-
-  for (let preferences of prefValues) {
-    dump("Testing preferences button with pref settings: " +
-         JSON.stringify(preferences) + "\n");
-    for (let addon of gMockAddons) {
-      yield close_manager(gManagerWindow);
-      gManagerWindow = yield open_manager();
-      gCategoryUtilities = new CategoryUtilities(gManagerWindow);
-      gPrefs.setCharPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, addon.id),
-                         preferences.version);
-      gPrefs.setBoolPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_ENABLED, addon.id),
-                         preferences.enabled);
-
-      yield gCategoryUtilities.openType("plugin");
-      let doc = gManagerWindow.document;
-      let item = get_addon_element(gManagerWindow, addon.id);
-
-      let button = doc.getAnonymousElementByAttribute(item, "anonid", "preferences-btn");
-      EventUtils.synthesizeMouseAtCenter(button, { clickCount: 1 }, gManagerWindow);
-      let deferred = Promise.defer();
-      wait_for_view_load(gManagerWindow, deferred.resolve);
-      yield deferred.promise;
-
-      is(gOptionsObserver.lastDisplayed, addon.id);
-    }
-  }
-});
-
-add_task(function* testUpdateButton() {
-  gPrefs.clearUserPref(GMPScope.GMPPrefs.KEY_UPDATE_LAST_CHECK);
-
-  let originalInstallManager = GMPScope.GMPInstallManager;
-  Object.defineProperty(GMPScope, "GMPInstallManager", {
-    value: MockGMPInstallManager,
-    writable: true,
-    enumerable: true,
-    configurable: true
-  });
-
-  for (let addon of gMockAddons) {
-    yield gCategoryUtilities.openType("plugin");
-    let doc = gManagerWindow.document;
-    let item = get_addon_element(gManagerWindow, addon.id);
-
-    gInstalledAddonId = "";
-    gInstallDeferred = Promise.defer();
-
-    let button = doc.getAnonymousElementByAttribute(item, "anonid", "preferences-btn");
-    EventUtils.synthesizeMouseAtCenter(button, { clickCount: 1 }, gManagerWindow);
-    let deferred = Promise.defer();
-    wait_for_view_load(gManagerWindow, deferred.resolve);
-    yield deferred.promise;
-
-    button = doc.getElementById("detail-findUpdates-btn");
-    Assert.ok(button != null, "Got detail-findUpdates-btn");
-    EventUtils.synthesizeMouseAtCenter(button, { clickCount: 1 }, gManagerWindow);
-    yield gInstallDeferred.promise;
-
-    Assert.equal(gInstalledAddonId, addon.id);
-  }
-  Object.defineProperty(GMPScope, "GMPInstallManager", {
-    value: originalInstallManager,
-    writable: true,
-    enumerable: true,
-    configurable: true
-  });
-});
-
-add_task(function* testEmeSupport() {
-  for (let addon of gMockAddons) {
-    gPrefs.clearUserPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_FORCEVISIBLE, addon.id));
-  }
-  yield GMPScope.GMPProvider.shutdown();
-  GMPScope.GMPProvider.startup();
-
-  for (let addon of gMockAddons) {
-    yield gCategoryUtilities.openType("plugin");
-    let doc = gManagerWindow.document;
-    let item = get_addon_element(gManagerWindow, addon.id);
-    if (addon.id == GMPScope.EME_ADOBE_ID) {
-      if (Services.appinfo.OS == "WINNT" &&
-          Services.sysinfo.getPropertyAsInt32("version") >= 6) {
-        Assert.ok(item, "Adobe EME supported, found add-on element.");
-      } else {
-        Assert.ok(!item,
-                  "Adobe EME not supported, couldn't find add-on element.");
-      }
-    } else {
-      Assert.ok(item, "Found add-on element.");
-    }
-  }
-
-  for (let addon of gMockAddons) {
-    gPrefs.setBoolPref(getKey(GMPScope.GMPPrefs.KEY_PLUGIN_FORCEVISIBLE, addon.id),
-                       true);
-  }
-  yield GMPScope.GMPProvider.shutdown();
-  GMPScope.GMPProvider.startup();
-
-});
-
-add_task(function* test_cleanup() {
-  yield close_manager(gManagerWindow);
-});
diff --git a/toolkit/mozapps/extensions/test/xpcshell/test_duplicateplugins.js b/toolkit/mozapps/extensions/test/xpcshell/test_duplicateplugins.js
index bad5603..40b532c 100644
--- a/toolkit/mozapps/extensions/test/xpcshell/test_duplicateplugins.js
+++ b/toolkit/mozapps/extensions/test/xpcshell/test_duplicateplugins.js
@@ -102,7 +102,6 @@ var gPluginIDs = [null, null, null, null, null];
 function run_test() {
   do_test_pending();
   createAppInfo("xpcshell@tests.mozilla.org", "XPCShell", "1", "1.9.2");
-  Services.prefs.setBoolPref("media.gmp-provider.enabled", false);
 
   startupManager();
 
diff --git a/toolkit/mozapps/extensions/test/xpcshell/test_gmpProvider.js b/toolkit/mozapps/extensions/test/xpcshell/test_gmpProvider.js
deleted file mode 100644
index 8de3ab4..0000000
--- a/toolkit/mozapps/extensions/test/xpcshell/test_gmpProvider.js
+++ /dev/null
@@ -1,332 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
- * http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
-let GMPScope = Cu.import("resource://gre/modules/addons/GMPProvider.jsm");
-
-XPCOMUtils.defineLazyGetter(this, "pluginsBundle",
-  () => Services.strings.createBundle("chrome://global/locale/plugins.properties"));
-
-let gMockAddons = new Map();
-let gMockEmeAddons = new Map();
-
-for (let plugin of GMPScope.GMP_PLUGINS) {
-  let mockAddon = Object.freeze({
-      id: plugin.id,
-      isValid: true,
-      isInstalled: false,
-      nameId: plugin.name,
-      descriptionId: plugin.description,
-  });
-  gMockAddons.set(mockAddon.id, mockAddon);
-  if (mockAddon.id.indexOf("gmp-eme-") == 0) {
-    gMockEmeAddons.set(mockAddon.id, mockAddon);
-  }
-}
-
-let gInstalledAddonId = "";
-let gPrefs = Services.prefs;
-let gGetKey = GMPScope.GMPPrefs.getPrefKey;
-
-function MockGMPInstallManager() {
-}
-
-MockGMPInstallManager.prototype = {
-  checkForAddons: () => Promise.resolve([...gMockAddons.values()]),
-
-  installAddon: addon => {
-    gInstalledAddonId = addon.id;
-    return Promise.resolve();
-  },
-};
-
-
-function run_test() {
-  createAppInfo("xpcshell@tests.mozilla.org", "XPCShell", "1", "1.9.2");
-  startupManager();
-
-  gPrefs.setBoolPref(GMPScope.GMPPrefs.KEY_LOGGING_DUMP, true);
-  gPrefs.setIntPref(GMPScope.GMPPrefs.KEY_LOGGING_LEVEL, 0);
-  gPrefs.setBoolPref(GMPScope.GMPPrefs.KEY_EME_ENABLED, true);
-  for (let addon of gMockAddons.values()) {
-    gPrefs.setBoolPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_FORCEVISIBLE, addon.id),
-                       true);
-  }
-  GMPScope.GMPProvider.shutdown();
-  GMPScope.GMPProvider.startup();
-
-  run_next_test();
-}
-
-add_task(function* test_notInstalled() {
-  for (let addon of gMockAddons.values()) {
-    gPrefs.setCharPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, addon.id), "");
-    gPrefs.setBoolPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_ENABLED, addon.id), false);
-  }
-
-  let addons = yield promiseAddonsByIDs([...gMockAddons.keys()]);
-  Assert.equal(addons.length, gMockAddons.size);
-
-  for (let addon of addons) {
-    Assert.ok(!addon.isInstalled);
-    Assert.equal(addon.type, "plugin");
-    Assert.equal(addon.version, "");
-
-    let mockAddon = gMockAddons.get(addon.id);
-
-    Assert.notEqual(mockAddon, null);
-    let name = pluginsBundle.GetStringFromName(mockAddon.nameId);
-    Assert.equal(addon.name, name);
-    let description = pluginsBundle.GetStringFromName(mockAddon.descriptionId);
-    Assert.equal(addon.description, description);
-
-    Assert.ok(!addon.isActive);
-    Assert.ok(!addon.appDisabled);
-    Assert.ok(addon.userDisabled);
-
-    Assert.equal(addon.blocklistState, Ci.nsIBlocklistService.STATE_NOT_BLOCKED);
-    Assert.equal(addon.size, 0);
-    Assert.equal(addon.scope, AddonManager.SCOPE_APPLICATION);
-    Assert.equal(addon.pendingOperations, AddonManager.PENDING_NONE);
-    Assert.equal(addon.operationsRequiringRestart, AddonManager.PENDING_NONE);
-
-    Assert.equal(addon.permissions, AddonManager.PERM_CAN_UPGRADE |
-                                    AddonManager.PERM_CAN_ENABLE);
-
-    Assert.equal(addon.updateDate, null);
-
-    Assert.ok(addon.isCompatible);
-    Assert.ok(addon.isPlatformCompatible);
-    Assert.ok(addon.providesUpdatesSecurely);
-    Assert.ok(!addon.foreignInstall);
-
-    let mimetypes = addon.pluginMimeTypes;
-    Assert.ok(mimetypes);
-    Assert.equal(mimetypes.length, 0);
-    let libraries = addon.pluginLibraries;
-    Assert.ok(libraries);
-    Assert.equal(libraries.length, 0);
-    Assert.equal(addon.pluginFullpath, "");
-  }
-});
-
-add_task(function* test_installed() {
-  const TEST_DATE = new Date(2013, 0, 1, 12);
-  const TEST_VERSION = "1.2.3.4";
-  const TEST_TIME_SEC = Math.round(TEST_DATE.getTime() / 1000);
-
-  let addons = yield promiseAddonsByIDs([...gMockAddons.keys()]);
-  Assert.equal(addons.length, gMockAddons.size);
-
-  for (let addon of addons) {
-    let mockAddon = gMockAddons.get(addon.id);
-    Assert.notEqual(mockAddon, null);
-
-    let file = Services.dirsvc.get("ProfD", Ci.nsIFile);
-    file.append(addon.id);
-    file.append(TEST_VERSION);
-    gPrefs.setBoolPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_ENABLED, mockAddon.id), false);
-    gPrefs.setCharPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_LAST_UPDATE, mockAddon.id),
-                      "" + TEST_TIME_SEC);
-    gPrefs.setCharPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, mockAddon.id),
-                      TEST_VERSION);
-
-    Assert.ok(addon.isInstalled);
-    Assert.equal(addon.type, "plugin");
-    Assert.ok(!addon.isActive);
-    Assert.ok(!addon.appDisabled);
-    Assert.ok(addon.userDisabled);
-
-    let name = pluginsBundle.GetStringFromName(mockAddon.nameId);
-    Assert.equal(addon.name, name);
-    Assert.equal(addon.version, TEST_VERSION);
-
-    Assert.equal(addon.permissions, AddonManager.PERM_CAN_UPGRADE |
-                                    AddonManager.PERM_CAN_ENABLE);
-
-    Assert.equal(addon.updateDate.getTime(), TEST_TIME_SEC * 1000);
-
-    let mimetypes = addon.pluginMimeTypes;
-    Assert.ok(mimetypes);
-    Assert.equal(mimetypes.length, 0);
-    let libraries = addon.pluginLibraries;
-    Assert.ok(libraries);
-    Assert.equal(libraries.length, 1);
-    Assert.equal(libraries[0], TEST_VERSION);
-    let fullpath = addon.pluginFullpath;
-    Assert.equal(fullpath.length, 1);
-    Assert.equal(fullpath[0], file.path);
-  }
-});
-
-add_task(function* test_enable() {
-  let addons = yield promiseAddonsByIDs([...gMockAddons.keys()]);
-  Assert.equal(addons.length, gMockAddons.size);
-
-  for (let addon of addons) {
-    gPrefs.setBoolPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_ENABLED, addon.id), true);
-
-    Assert.ok(addon.isActive);
-    Assert.ok(!addon.appDisabled);
-    Assert.ok(!addon.userDisabled);
-
-    Assert.equal(addon.permissions, AddonManager.PERM_CAN_UPGRADE |
-                                    AddonManager.PERM_CAN_DISABLE);
-  }
-});
-
-add_task(function* test_globalEmeDisabled() {
-  let addons = yield promiseAddonsByIDs([...gMockEmeAddons.keys()]);
-  Assert.equal(addons.length, gMockEmeAddons.size);
-
-  gPrefs.setBoolPref(GMPScope.GMPPrefs.KEY_EME_ENABLED, false);
-  GMPScope.GMPProvider.shutdown();
-  GMPScope.GMPProvider.startup();
-  for (let addon of addons) {
-    Assert.ok(!addon.isActive);
-    Assert.ok(addon.appDisabled);
-    Assert.ok(!addon.userDisabled);
-
-    Assert.equal(addon.permissions, 0);
-  }
-  gPrefs.setBoolPref(GMPScope.GMPPrefs.KEY_EME_ENABLED, true);
-  GMPScope.GMPProvider.shutdown();
-  GMPScope.GMPProvider.startup();
-});
-
-add_task(function* test_autoUpdatePrefPersistance() {
-  let addons = yield promiseAddonsByIDs([...gMockAddons.keys()]);
-  Assert.equal(addons.length, gMockAddons.size);
-
-  for (let addon of addons) {
-    let autoupdateKey = gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_AUTOUPDATE, addon.id);
-    gPrefs.clearUserPref(autoupdateKey);
-
-    addon.applyBackgroundUpdates = AddonManager.AUTOUPDATE_DISABLE;
-    Assert.ok(!gPrefs.getBoolPref(autoupdateKey));
-
-    addon.applyBackgroundUpdates = AddonManager.AUTOUPDATE_ENABLE;
-    Assert.equal(addon.applyBackgroundUpdates, AddonManager.AUTOUPDATE_ENABLE);
-    Assert.ok(gPrefs.getBoolPref(autoupdateKey));
-
-    addon.applyBackgroundUpdates = AddonManager.AUTOUPDATE_DEFAULT;
-    Assert.ok(!gPrefs.prefHasUserValue(autoupdateKey));
-  }
-});
-
-add_task(function* test_pluginRegistration() {
-  const TEST_VERSION = "1.2.3.4";
-
-  for (let addon of gMockAddons.values()) {
-    let file = Services.dirsvc.get("ProfD", Ci.nsIFile);
-    file.append(addon.id);
-    file.append(TEST_VERSION);
-
-    let addedPaths = [];
-    let removedPaths = [];
-    let clearPaths = () => { addedPaths = []; removedPaths = []; }
-
-    let MockGMPService = {
-      addPluginDirectory: path => addedPaths.push(path),
-      removePluginDirectory: path => removedPaths.push(path),
-      removeAndDeletePluginDirectory: path => removedPaths.push(path),
-    };
-
-    GMPScope.gmpService = MockGMPService;
-    gPrefs.setBoolPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_ENABLED, addon.id), true);
-
-    // Check that the plugin gets registered after startup.
-    gPrefs.setCharPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, addon.id),
-                      TEST_VERSION);
-    clearPaths();
-    yield promiseRestartManager();
-    Assert.notEqual(addedPaths.indexOf(file.path), -1);
-    Assert.deepEqual(removedPaths, []);
-
-    // Check that clearing the version doesn't trigger registration.
-    clearPaths();
-    gPrefs.clearUserPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, addon.id));
-    Assert.deepEqual(addedPaths, []);
-    Assert.deepEqual(removedPaths, [file.path]);
-
-    // Restarting with no version set should not trigger registration.
-    clearPaths();
-    yield promiseRestartManager();
-    Assert.equal(addedPaths.indexOf(file.path), -1);
-    Assert.equal(removedPaths.indexOf(file.path), -1);
-
-    // Changing the pref mid-session should cause unregistration and registration.
-    gPrefs.setCharPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, addon.id),
-                      TEST_VERSION);
-    clearPaths();
-    const TEST_VERSION_2 = "5.6.7.8";
-    let file2 = Services.dirsvc.get("ProfD", Ci.nsIFile);
-    file2.append(addon.id);
-    file2.append(TEST_VERSION_2);
-    gPrefs.setCharPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, addon.id),
-                      TEST_VERSION_2);
-    Assert.deepEqual(addedPaths, [file2.path]);
-    Assert.deepEqual(removedPaths, [file.path]);
-
-    // Disabling the plugin should cause unregistration.
-    gPrefs.setCharPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_VERSION, addon.id),
-                      TEST_VERSION);
-    clearPaths();
-    gPrefs.setBoolPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_ENABLED, addon.id), false);
-    Assert.deepEqual(addedPaths, []);
-    Assert.deepEqual(removedPaths, [file.path]);
-
-    // Restarting with the plugin disabled should not cause registration.
-    clearPaths();
-    yield promiseRestartManager();
-    Assert.equal(addedPaths.indexOf(file.path), -1);
-    Assert.equal(removedPaths.indexOf(file.path), -1);
-
-    // Re-enabling the plugin should cause registration.
-    clearPaths();
-    gPrefs.setBoolPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_ENABLED, addon.id), true);
-    Assert.deepEqual(addedPaths, [file.path]);
-    Assert.deepEqual(removedPaths, []);
-    GMPScope = Cu.import("resource://gre/modules/addons/GMPProvider.jsm");
-  }
-});
-
-add_task(function* test_periodicUpdate() {
-  Object.defineProperty(GMPScope, "GMPInstallManager", {
-    value: MockGMPInstallManager,
-    writable: true,
-    enumerable: true,
-    configurable: true
-  });
-
-  let addons = yield promiseAddonsByIDs([...gMockAddons.keys()]);
-  Assert.equal(addons.length, gMockAddons.size);
-
-  for (let addon of addons) {
-    gPrefs.clearUserPref(gGetKey(GMPScope.GMPPrefs.KEY_PLUGIN_AUTOUPDATE, addon.id));
-
-    addon.applyBackgroundUpdates = AddonManager.AUTOUPDATE_DISABLE;
-    gPrefs.setIntPref(GMPScope.GMPPrefs.KEY_UPDATE_LAST_CHECK, 0);
-    let result =
-      yield addon.findUpdates({}, AddonManager.UPDATE_WHEN_PERIODIC_UPDATE);
-    Assert.strictEqual(result, false);
-
-    addon.applyBackgroundUpdates = AddonManager.AUTOUPDATE_ENABLE;
-    gPrefs.setIntPref(GMPScope.GMPPrefs.KEY_UPDATE_LAST_CHECK, Date.now() / 1000 - 60);
-    result =
-      yield addon.findUpdates({}, AddonManager.UPDATE_WHEN_PERIODIC_UPDATE);
-    Assert.strictEqual(result, false);
-
-    gPrefs.setIntPref(GMPScope.GMPPrefs.KEY_UPDATE_LAST_CHECK,
-                     Date.now() / 1000 - 2 * GMPScope.SEC_IN_A_DAY);
-    gInstalledAddonId = "";
-    result =
-      yield addon.findUpdates({}, AddonManager.UPDATE_WHEN_PERIODIC_UPDATE);
-    Assert.strictEqual(result, true);
-    Assert.equal(gInstalledAddonId, addon.id);
-  }
-
-  GMPScope = Cu.import("resource://gre/modules/addons/GMPProvider.jsm");
-});
diff --git a/toolkit/mozapps/extensions/test/xpcshell/test_pluginchange.js b/toolkit/mozapps/extensions/test/xpcshell/test_pluginchange.js
index d3e33da..b489b49 100644
--- a/toolkit/mozapps/extensions/test/xpcshell/test_pluginchange.js
+++ b/toolkit/mozapps/extensions/test/xpcshell/test_pluginchange.js
@@ -67,8 +67,6 @@ function run_test() {
   do_test_pending();
   createAppInfo("xpcshell@tests.mozilla.org", "XPCShell", "1", "1.9.2");
 
-  Services.prefs.setBoolPref("media.gmp-provider.enabled", false);
-
   startupManager();
   AddonManager.addAddonListener(AddonListener);
   AddonManager.addInstallListener(InstallListener);
diff --git a/toolkit/mozapps/extensions/test/xpcshell/xpcshell.ini b/toolkit/mozapps/extensions/test/xpcshell/xpcshell.ini
index 83ab77c..5a08bee 100644
--- a/toolkit/mozapps/extensions/test/xpcshell/xpcshell.ini
+++ b/toolkit/mozapps/extensions/test/xpcshell/xpcshell.ini
@@ -12,7 +12,6 @@ support-files =
 [test_asyncBlocklistLoad.js]
 [test_cacheflush.js]
 [test_DeferredSave.js]
-[test_gmpProvider.js]
 run-if = appname == "firefox"
 [test_isReady.js]
 [test_metadata_update.js]
diff --git a/toolkit/toolkit.mozbuild b/toolkit/toolkit.mozbuild
index ae60185..c535091 100644
--- a/toolkit/toolkit.mozbuild
+++ b/toolkit/toolkit.mozbuild
@@ -172,7 +172,6 @@ if CONFIG['ENABLE_MARIONETTE'] or CONFIG['MOZ_WIDGET_TOOLKIT'] not in ('gonk', '
 
 DIRS += [
     '/tools/quitter',
-    '/media/gmp-clearkey/0.1',
 ]
 
 if CONFIG['ENABLE_TESTS']:
diff --git a/toolkit/xre/nsAppRunner.cpp b/toolkit/xre/nsAppRunner.cpp
index 0650f34..cef8be0 100644
--- a/toolkit/xre/nsAppRunner.cpp
+++ b/toolkit/xre/nsAppRunner.cpp
@@ -795,7 +795,7 @@ SYNC_ENUMS(CONTENT, Content)
 SYNC_ENUMS(IPDLUNITTEST, IPDLUnitTest)
 
 // .. and ensure that that is all of them:
-static_assert(GoannaProcessType_GMPlugin + 1 == GoannaProcessType_End,
+static_assert(GoannaProcessType_IPDLUnitTest + 1 == GoannaProcessType_End,
               "Did not find the final GoannaProcessType");
 
 NS_IMETHODIMP
diff --git a/toolkit/xre/nsEmbedFunctions.cpp b/toolkit/xre/nsEmbedFunctions.cpp
index 596bd0b..17e8aa2 100644
--- a/toolkit/xre/nsEmbedFunctions.cpp
+++ b/toolkit/xre/nsEmbedFunctions.cpp
@@ -70,9 +70,6 @@
 #include "mozilla/ipc/XPCShellEnvironment.h"
 #include "mozilla/WindowsDllBlocklist.h"
 
-#include "GMPProcessChild.h"
-#include "GMPLoader.h"
-
 #include "GoannaProfiler.h"
 
 #if defined(MOZ_SANDBOX) && defined(XP_WIN)
@@ -100,10 +97,6 @@ using mozilla::dom::ContentProcess;
 using mozilla::dom::ContentParent;
 using mozilla::dom::ContentChild;
 
-using mozilla::gmp::GMPLoader;
-using mozilla::gmp::CreateGMPLoader;
-using mozilla::gmp::GMPProcessChild;
-
 using mozilla::ipc::TestShellParent;
 using mozilla::ipc::TestShellCommandParent;
 using mozilla::ipc::XPCShellEnvironment;
@@ -265,7 +258,7 @@ SetTaskbarGroupId(const nsString& aId)
 nsresult
 XRE_InitChildProcess(int aArgc,
                      char* aArgv[],
-                     GMPLoader* aGMPLoader)
+                     GoannaProcessType aProcess)
 {
   NS_ENSURE_ARG_MIN(aArgc, 2);
   NS_ENSURE_ARG_POINTER(aArgv);
@@ -275,18 +268,6 @@ XRE_InitChildProcess(int aArgc,
   DllBlocklist_Initialize();
 #endif
 
-#if !defined(MOZ_WIDGET_ANDROID) && !defined(MOZ_WIDGET_GONK)
-  // On non-Fennec Goanna, the GMPLoader code resides in plugin-container,
-  // and we must forward it through to the GMP code here.
-  GMPProcessChild::SetGMPLoader(aGMPLoader);
-#else
-  // On Fennec, the GMPLoader's code resides inside XUL (because for the time
-  // being GMPLoader relies upon NSPR, which we can't use in plugin-container
-  // on Android), so we create it here inside XUL and pass it to the GMP code.
-  nsAutoPtr<GMPLoader> loader(CreateGMPLoader(nullptr));
-  GMPProcessChild::SetGMPLoader(loader);
-#endif
-
 #if defined(XP_WIN)
   // From the --attach-console support in nsNativeAppSupportWin.cpp, but
   // here we are a content child process, so we always attempt to attach
@@ -404,10 +385,8 @@ XRE_InitChildProcess(int aArgc,
   // Retrieve the parent process handle. We need this for shared memory use and
   // for creating new transports in the child.
   base::ProcessHandle parentHandle = 0;
-  if (XRE_GetProcessType() != GoannaProcessType_GMPlugin) {
-    mozilla::DebugOnly<bool> ok = base::OpenProcessHandle(parentPID, &parentHandle);
-    MOZ_ASSERT(ok, "can't open handle to parent");
-  }
+  mozilla::DebugOnly<bool> ok = base::OpenProcessHandle(parentPID, &parentHandle);
+  MOZ_ASSERT(ok, "can't open handle to parent");
 
 #if defined(XP_WIN)
   // On Win7+, register the application user model id passed in by
@@ -445,9 +424,6 @@ XRE_InitChildProcess(int aArgc,
       // Content processes need the XPCOM/chromium frankenventloop
       uiLoopType = MessageLoop::TYPE_MOZILLA_CHILD;
       break;
-  case GoannaProcessType_GMPlugin:
-      uiLoopType = MessageLoop::TYPE_DEFAULT;
-      break;
   default:
       uiLoopType = MessageLoop::TYPE_UI;
       break;
@@ -499,10 +475,6 @@ XRE_InitChildProcess(int aArgc,
 #endif
         break;
 
-      case GoannaProcessType_GMPlugin:
-        process = new gmp::GMPProcessChild(parentHandle);
-        break;
-
       default:
         NS_RUNTIMEABORT("Unknown main thread class");
       }
diff --git a/xpcom/build/nsXULAppAPI.h b/xpcom/build/nsXULAppAPI.h
index 27ee375..f8b2120 100644
--- a/xpcom/build/nsXULAppAPI.h
+++ b/xpcom/build/nsXULAppAPI.h
@@ -350,8 +350,6 @@ enum GoannaProcessType
 
   GoannaProcessType_IPDLUnitTest,
 
-  GoannaProcessType_GMPlugin, // Goanna Media Plugin
-
   GoannaProcessType_End,
   GoannaProcessType_Invalid = GoannaProcessType_End
 };
@@ -360,8 +358,7 @@ static const char* const kGoannaProcessTypeString[] = {
   "default",
   "plugin",
   "tab",
-  "ipdlunittest",
-  "goannamediaplugin"
+  "ipdlunittest"
 };
 
 static_assert(MOZ_ARRAY_LENGTH(kGoannaProcessTypeString) ==
@@ -374,16 +371,10 @@ XRE_API(const char*,
 XRE_API(void,
         XRE_SetProcessType, (const char* aProcessTypeString))
 
-namespace mozilla {
-namespace gmp {
-class GMPLoader;
-} // namespace gmp
-} // namepsace mozilla
-
 XRE_API(nsresult,
         XRE_InitChildProcess, (int aArgc,
                                char* aArgv[],
-                               mozilla::gmp::GMPLoader* aGMPLoader))
+                               GoannaProcessType aProcess))
 
 XRE_API(GoannaProcessType,
         XRE_GetProcessType, ())
diff --git a/xpcom/system/nsIXULRuntime.idl b/xpcom/system/nsIXULRuntime.idl
index 657a1e1..bd09aa7 100644
--- a/xpcom/system/nsIXULRuntime.idl
+++ b/xpcom/system/nsIXULRuntime.idl
@@ -73,7 +73,6 @@ interface nsIXULRuntime : nsISupports
   const unsigned long PROCESS_TYPE_PLUGIN = 1;
   const unsigned long PROCESS_TYPE_CONTENT = 2;
   const unsigned long PROCESS_TYPE_IPDLUNITTEST = 3;
-  const unsigned long PROCESS_TYPE_GMPLUGIN = 4;
 
   /**
    * The type of the caller's process.  Returns one of the values above.
-- 
2.8.2.windows.1

